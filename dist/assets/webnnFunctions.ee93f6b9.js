var sE=Object.defineProperty,rE=Object.defineProperties;var aE=Object.getOwnPropertyDescriptors;var Wv=Object.getOwnPropertySymbols;var oE=Object.prototype.hasOwnProperty,iE=Object.prototype.propertyIsEnumerable;var Vv=(s,e,t)=>e in s?sE(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,B1=(s,e)=>{for(var t in e||(e={}))oE.call(e,t)&&Vv(s,t,e[t]);if(Wv)for(var t of Wv(e))iE.call(e,t)&&Vv(s,t,e[t]);return s},Uv=(s,e)=>rE(s,aE(e));import{c as Id}from"./autoprefixer.3278b1e3.js";function uE(s,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(n){if(n!=="default"&&!(n in s)){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(s,n,r.get?r:{enumerable:!0,get:function(){return t[n]}})}})}),Object.freeze(Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}))}(function(s){var e={};function t(n){if(e[n])return e[n].exports;var r=e[n]={i:n,l:!1,exports:{}};return s[n].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=s,t.c=e,t.d=function(n,r,a){t.o(n,r)||Object.defineProperty(n,r,{enumerable:!0,get:a})},t.r=function(n){typeof Symbol!="undefined"&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,r){if(1&r&&(n=t(n)),8&r||4&r&&typeof n=="object"&&n&&n.__esModule)return n;var a=Object.create(null);if(t.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:n}),2&r&&typeof n!="string")for(var o in n)t.d(a,o,function(i){return n[i]}.bind(null,o));return a},t.n=function(n){var r=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(r,"a",r),r},t.o=function(n,r){return Object.prototype.hasOwnProperty.call(n,r)},t.p="",t(t.s=103)})([function(s,e,t){t.r(e),t.d(e,"AdadeltaOptimizer",function(){return Ni}),t.d(e,"AdagradOptimizer",function(){return ci}),t.d(e,"AdamOptimizer",function(){return Ei}),t.d(e,"AdamaxOptimizer",function(){return Ri}),t.d(e,"MomentumOptimizer",function(){return ru}),t.d(e,"Optimizer",function(){return xo}),t.d(e,"OptimizerConstructors",function(){return Eo}),t.d(e,"RMSPropOptimizer",function(){return Oi}),t.d(e,"SGDOptimizer",function(){return Ai}),t.d(e,"Tensor",function(){return xn.a}),t.d(e,"TensorBuffer",function(){return xn.b}),t.d(e,"Variable",function(){return xn.c}),t.d(e,"Rank",function(){return Fi.a}),t.d(e,"sumOutType",function(){return Fi.b}),t.d(e,"upcastType",function(){return Fi.c}),t.d(e,"abs",function(){return Ia}),t.d(e,"acos",function(){return Cc}),t.d(e,"acosh",function(){return Di}),t.d(e,"add",function(){return bs}),t.d(e,"addN",function(){return Ro}),t.d(e,"all",function(){return au}),t.d(e,"any",function(){return Mi}),t.d(e,"argMax",function(){return _c}),t.d(e,"argMin",function(){return di}),t.d(e,"asin",function(){return Pi}),t.d(e,"asinh",function(){return ou}),t.d(e,"atan",function(){return Xu}),t.d(e,"atan2",function(){return Sc}),t.d(e,"atanh",function(){return $c}),t.d(e,"avgPool",function(){return Lt}),t.d(e,"avgPool3d",function(){return Jt}),t.d(e,"basicLSTMCell",function(){return Jn}),t.d(e,"batchToSpaceND",function(){return Ss}),t.d(e,"batchNorm",function(){return Ms}),t.d(e,"batchNorm2d",function(){return Ps}),t.d(e,"batchNorm3d",function(){return Fs}),t.d(e,"batchNorm4d",function(){return pr}),t.d(e,"bincount",function(){return er}),t.d(e,"broadcastArgs",function(){return fr}),t.d(e,"broadcastTo",function(){return cr}),t.d(e,"buffer",function(){return Dn}),t.d(e,"cast",function(){return Un}),t.d(e,"ceil",function(){return jr}),t.d(e,"clipByValue",function(){return Ca}),t.d(e,"clone",function(){return Ws}),t.d(e,"complex",function(){return Ta.a}),t.d(e,"concat",function(){return un}),t.d(e,"concat1d",function(){return yo}),t.d(e,"concat2d",function(){return Ao}),t.d(e,"concat3d",function(){return Li}),t.d(e,"concat4d",function(){return hi}),t.d(e,"conv1d",function(){return Ho}),t.d(e,"conv2d",function(){return wo}),t.d(e,"conv2dTranspose",function(){return Bi}),t.d(e,"conv3d",function(){return ca}),t.d(e,"conv3dTranspose",function(){return Zu}),t.d(e,"cos",function(){return Wi}),t.d(e,"cosh",function(){return Qu}),t.d(e,"cumprod",function(){return Ol}),t.d(e,"cumsum",function(){return Kc}),t.d(e,"denseBincount",function(){return Fl}),t.d(e,"depthToSpace",function(){return Xc}),t.d(e,"depthwiseConv2d",function(){return Tc}),t.d(e,"diag",function(){return Ju}),t.d(e,"dilation2d",function(){return Yc}),t.d(e,"div",function(){return hr}),t.d(e,"divNoNan",function(){return Dl}),t.d(e,"dot",function(){return Ml}),t.d(e,"einsum",function(){return Pl}),t.d(e,"elu",function(){return Zc}),t.d(e,"equal",function(){return Nc}),t.d(e,"erf",function(){return ec}),t.d(e,"euclideanNorm",function(){return el}),t.d(e,"exp",function(){return Ko}),t.d(e,"expandDims",function(){return Se}),t.d(e,"expm1",function(){return Oe}),t.d(e,"eye",function(){return fe}),t.d(e,"fill",function(){return nu}),t.d(e,"floor",function(){return H}),t.d(e,"floorDiv",function(){return jn}),t.d(e,"gather",function(){return ce}),t.d(e,"greater",function(){return Ce}),t.d(e,"greaterEqual",function(){return De}),t.d(e,"imag",function(){return mo}),t.d(e,"isFinite",function(){return Fe}),t.d(e,"isInf",function(){return Ie}),t.d(e,"isNaN",function(){return Te}),t.d(e,"leakyRelu",function(){return Ye}),t.d(e,"less",function(){return Le}),t.d(e,"lessEqual",function(){return Je}),t.d(e,"linspace",function(){return gt}),t.d(e,"localResponseNormalization",function(){return lt}),t.d(e,"log",function(){return ft}),t.d(e,"log1p",function(){return yt}),t.d(e,"logSigmoid",function(){return Bt}),t.d(e,"logSoftmax",function(){return G}),t.d(e,"logSumExp",function(){return A}),t.d(e,"logicalAnd",function(){return R}),t.d(e,"logicalNot",function(){return q}),t.d(e,"logicalOr",function(){return j}),t.d(e,"logicalXor",function(){return te}),t.d(e,"lowerBound",function(){return xe}),t.d(e,"matMul",function(){return wn}),t.d(e,"max",function(){return uu}),t.d(e,"maxPool",function(){return _e}),t.d(e,"maxPool3d",function(){return Ue}),t.d(e,"maxPoolWithArgmax",function(){return nt}),t.d(e,"maximum",function(){return su}),t.d(e,"mean",function(){return it}),t.d(e,"meshgrid",function(){return ut}),t.d(e,"min",function(){return tc}),t.d(e,"minimum",function(){return Et}),t.d(e,"mirrorPad",function(){return Tt}),t.d(e,"mod",function(){return Dt}),t.d(e,"moments",function(){return Wt}),t.d(e,"mul",function(){return Gn}),t.d(e,"multiRNNCell",function(){return qt}),t.d(e,"multinomial",function(){return cn}),t.d(e,"neg",function(){return Ar}),t.d(e,"notEqual",function(){return rn}),t.d(e,"oneHot",function(){return gs}),t.d(e,"ones",function(){return dt}),t.d(e,"onesLike",function(){return yn}),t.d(e,"outerProduct",function(){return Fn}),t.d(e,"pad",function(){return _n}),t.d(e,"pad1d",function(){return ss}),t.d(e,"pad2d",function(){return zn}),t.d(e,"pad3d",function(){return Kn}),t.d(e,"pad4d",function(){return us}),t.d(e,"pool",function(){return es}),t.d(e,"pow",function(){return li}),t.d(e,"prelu",function(){return ks}),t.d(e,"print",function(){return Gs}),t.d(e,"prod",function(){return Ks}),t.d(e,"raggedTensorToTensor",function(){return sa}),t.d(e,"rand",function(){return or}),t.d(e,"randomGamma",function(){return Ha}),t.d(e,"randomNormal",function(){return vo}),t.d(e,"randomStandardNormal",function(){return pi}),t.d(e,"randomUniform",function(){return fi}),t.d(e,"range",function(){return Ac}),t.d(e,"real",function(){return Na}),t.d(e,"reciprocal",function(){return tl}),t.d(e,"relu",function(){return nl}),t.d(e,"relu6",function(){return Pd}),t.d(e,"reshape",function(){return Ze}),t.d(e,"reverse",function(){return mi}),t.d(e,"reverse1d",function(){return Bb}),t.d(e,"reverse2d",function(){return zb}),t.d(e,"reverse3d",function(){return Wb}),t.d(e,"reverse4d",function(){return Vb}),t.d(e,"round",function(){return Pf}),t.d(e,"rsqrt",function(){return Ub}),t.d(e,"scalar",function(){return ar}),t.d(e,"selu",function(){return jb}),t.d(e,"separableConv2d",function(){return Gb}),t.d(e,"setdiff1dAsync",function(){return Hb}),t.d(e,"sigmoid",function(){return In}),t.d(e,"sign",function(){return qb}),t.d(e,"sin",function(){return Kb}),t.d(e,"sinh",function(){return Xb}),t.d(e,"slice",function(){return Xt}),t.d(e,"slice1d",function(){return Yb}),t.d(e,"slice2d",function(){return Zb}),t.d(e,"slice3d",function(){return Qb}),t.d(e,"slice4d",function(){return Jb}),t.d(e,"softmax",function(){return ex}),t.d(e,"softplus",function(){return $t}),t.d(e,"spaceToBatchND",function(){return ps}),t.d(e,"fft",function(){return Oh}),t.d(e,"ifft",function(){return Wl}),t.d(e,"irfft",function(){return Lf}),t.d(e,"rfft",function(){return Fh}),t.d(e,"split",function(){return Vl}),t.d(e,"sqrt",function(){return Aa}),t.d(e,"square",function(){return Vr}),t.d(e,"squaredDifference",function(){return Bf}),t.d(e,"squeeze",function(){return Dh}),t.d(e,"stack",function(){return Ul}),t.d(e,"step",function(){return zf}),t.d(e,"stridedSlice",function(){return tx}),t.d(e,"sub",function(){return Os}),t.d(e,"sum",function(){return gr}),t.d(e,"tan",function(){return nx}),t.d(e,"tanh",function(){return $n}),t.d(e,"tensor",function(){return Mh.a}),t.d(e,"tensor1d",function(){return Vi}),t.d(e,"tensor2d",function(){return jl}),t.d(e,"tensor3d",function(){return fa}),t.d(e,"tensor4d",function(){return sx}),t.d(e,"tensor5d",function(){return rx}),t.d(e,"tensor6d",function(){return ax}),t.d(e,"tile",function(){return Z}),t.d(e,"topk",function(){return ox}),t.d(e,"truncatedNormal",function(){return ix}),t.d(e,"unique",function(){return ux}),t.d(e,"unsortedSegmentSum",function(){return cx}),t.d(e,"unstack",function(){return Ph}),t.d(e,"upperBound",function(){return Wf}),t.d(e,"variable",function(){return lx}),t.d(e,"where",function(){return iu}),t.d(e,"whereAsync",function(){return Bh}),t.d(e,"zeros",function(){return et}),t.d(e,"zerosLike",function(){return ua}),t.d(e,"booleanMaskAsync",function(){return dx}),t.d(e,"transpose",function(){return Ea}),t.d(e,"norm",function(){return Au}),t.d(e,"movingAverage",function(){return Vf}),t.d(e,"scatterND",function(){return hx}),t.d(e,"searchSorted",function(){return he}),t.d(e,"sparseToDense",function(){return px}),t.d(e,"gatherND",function(){return fx}),t.d(e,"dropout",function(){return mx}),t.d(e,"enclosingPowerOfTwo",function(){return Uf}),t.d(e,"cosineWindow",function(){return zh}),t.d(e,"inTopKAsync",function(){return gx}),t.d(e,"op",function(){return Qe.b}),t.d(e,"OP_SCOPE_SUFFIX",function(){return Qe.a}),t.d(e,"image",function(){return i1}),t.d(e,"linalg",function(){return u1}),t.d(e,"losses",function(){return c1}),t.d(e,"spectral",function(){return a1}),t.d(e,"fused",function(){return l}),t.d(e,"signal",function(){return o1}),t.d(e,"sparse",function(){return l1}),t.d(e,"string",function(){return d1}),t.d(e,"Reduction",function(){return io}),t.d(e,"train",function(){return h1}),t.d(e,"enableProdMode",function(){return Hs}),t.d(e,"enableDebugMode",function(){return xr}),t.d(e,"disableDeprecationWarnings",function(){return Ir}),t.d(e,"deprecationWarn",function(){return qs}),t.d(e,"disposeVariables",function(){return ta}),t.d(e,"engine",function(){return pa}),t.d(e,"memory",function(){return rr}),t.d(e,"profile",function(){return eo}),t.d(e,"tidy",function(){return Qs}),t.d(e,"dispose",function(){return mr}),t.d(e,"keep",function(){return $r}),t.d(e,"time",function(){return ia}),t.d(e,"setBackend",function(){return Pr}),t.d(e,"ready",function(){return Cr}),t.d(e,"getBackend",function(){return Ba}),t.d(e,"removeBackend",function(){return za}),t.d(e,"findBackend",function(){return to}),t.d(e,"findBackendFactory",function(){return Wo}),t.d(e,"registerBackend",function(){return si}),t.d(e,"backend",function(){return fo}),t.d(e,"setPlatform",function(){return no}),t.d(e,"getKernel",function(){return Kr.c}),t.d(e,"getGradient",function(){return Kr.b}),t.d(e,"getKernelsForBackend",function(){return Kr.d}),t.d(e,"registerKernel",function(){return Kr.f}),t.d(e,"registerGradient",function(){return Kr.e}),t.d(e,"unregisterKernel",function(){return Kr.h}),t.d(e,"unregisterGradient",function(){return Kr.g}),t.d(e,"copyRegisteredKernels",function(){return Kr.a}),t.d(e,"customGrad",function(){return oo}),t.d(e,"grad",function(){return tu}),t.d(e,"grads",function(){return ui}),t.d(e,"valueAndGrad",function(){return jo}),t.d(e,"valueAndGrads",function(){return Ku}),t.d(e,"variableGrads",function(){return Ur}),t.d(e,"Environment",function(){return m.b}),t.d(e,"env",function(){return m.c}),t.d(e,"ENV",function(){return m.a}),t.d(e,"version_core",function(){return ii}),t.d(e,"nextFrame",function(){return Jf.a}),t.d(e,"browser",function(){return o}),t.d(e,"io",function(){return n}),t.d(e,"math",function(){return r}),t.d(e,"serialization",function(){return d}),t.d(e,"test_util",function(){return h}),t.d(e,"util",function(){return To}),t.d(e,"backend_util",function(){return f}),t.d(e,"broadcast_util",function(){return a}),t.d(e,"tensor_util",function(){return Mn}),t.d(e,"slice_util",function(){return c}),t.d(e,"gather_util",function(){return i}),t.d(e,"scatter_util",function(){return u}),t.d(e,"device_util",function(){return vs}),t.d(e,"kernel_impls",function(){return x}),t.d(e,"KernelBackend",function(){return fs.b}),t.d(e,"DataStorage",function(){return fs.a}),t.d(e,"Abs",function(){return pe.a}),t.d(e,"Acos",function(){return pe.b}),t.d(e,"Acosh",function(){return pe.c}),t.d(e,"Add",function(){return pe.d}),t.d(e,"AddN",function(){return pe.e}),t.d(e,"All",function(){return pe.f}),t.d(e,"Any",function(){return pe.g}),t.d(e,"ArgMax",function(){return pe.h}),t.d(e,"ArgMin",function(){return pe.i}),t.d(e,"Asin",function(){return pe.j}),t.d(e,"Asinh",function(){return pe.k}),t.d(e,"Atan",function(){return pe.l}),t.d(e,"Atanh",function(){return pe.n}),t.d(e,"Atan2",function(){return pe.m}),t.d(e,"AvgPool",function(){return pe.o}),t.d(e,"AvgPoolGrad",function(){return pe.r}),t.d(e,"AvgPool3D",function(){return pe.p}),t.d(e,"AvgPool3DGrad",function(){return pe.q}),t.d(e,"BatchMatMul",function(){return pe.s}),t.d(e,"BatchToSpaceND",function(){return pe.t}),t.d(e,"Bincount",function(){return pe.u}),t.d(e,"BroadcastTo",function(){return pe.w}),t.d(e,"BroadcastArgs",function(){return pe.v}),t.d(e,"Cast",function(){return pe.x}),t.d(e,"Ceil",function(){return pe.y}),t.d(e,"ClipByValue",function(){return pe.z}),t.d(e,"Complex",function(){return pe.A}),t.d(e,"ComplexAbs",function(){return pe.B}),t.d(e,"Concat",function(){return pe.C}),t.d(e,"Conv2D",function(){return pe.D}),t.d(e,"Conv2DBackpropFilter",function(){return pe.E}),t.d(e,"Conv2DBackpropInput",function(){return pe.F}),t.d(e,"Conv3D",function(){return pe.G}),t.d(e,"Conv3DBackpropFilterV2",function(){return pe.H}),t.d(e,"Conv3DBackpropInputV2",function(){return pe.I}),t.d(e,"Cos",function(){return pe.J}),t.d(e,"Cosh",function(){return pe.K}),t.d(e,"Cumprod",function(){return pe.M}),t.d(e,"Cumsum",function(){return pe.N}),t.d(e,"CropAndResize",function(){return pe.L}),t.d(e,"DenseBincount",function(){return pe.O}),t.d(e,"DepthToSpace",function(){return pe.P}),t.d(e,"DepthwiseConv2dNative",function(){return pe.Q}),t.d(e,"DepthwiseConv2dNativeBackpropFilter",function(){return pe.R}),t.d(e,"DepthwiseConv2dNativeBackpropInput",function(){return pe.S}),t.d(e,"Diag",function(){return pe.T}),t.d(e,"Dilation2D",function(){return pe.U}),t.d(e,"Dilation2DBackpropInput",function(){return pe.W}),t.d(e,"Dilation2DBackpropFilter",function(){return pe.V}),t.d(e,"RealDiv",function(){return pe.qc}),t.d(e,"Einsum",function(){return pe.X}),t.d(e,"Elu",function(){return pe.Y}),t.d(e,"EluGrad",function(){return pe.Z}),t.d(e,"Erf",function(){return pe.bb}),t.d(e,"Equal",function(){return pe.ab}),t.d(e,"Exp",function(){return pe.cb}),t.d(e,"ExpandDims",function(){return pe.db}),t.d(e,"Expm1",function(){return pe.eb}),t.d(e,"FFT",function(){return pe.fb}),t.d(e,"Fill",function(){return pe.gb}),t.d(e,"FlipLeftRight",function(){return pe.hb}),t.d(e,"Floor",function(){return pe.ib}),t.d(e,"FloorDiv",function(){return pe.jb}),t.d(e,"FusedBatchNorm",function(){return pe.lb}),t.d(e,"GatherV2",function(){return pe.pb}),t.d(e,"GatherNd",function(){return pe.ob}),t.d(e,"Greater",function(){return pe.qb}),t.d(e,"GreaterEqual",function(){return pe.rb}),t.d(e,"Identity",function(){return pe.tb}),t.d(e,"IFFT",function(){return pe.sb}),t.d(e,"Imag",function(){return pe.ub}),t.d(e,"IsFinite",function(){return pe.vb}),t.d(e,"IsInf",function(){return pe.wb}),t.d(e,"IsNan",function(){return pe.xb}),t.d(e,"LeakyRelu",function(){return pe.Ab}),t.d(e,"Less",function(){return pe.Bb}),t.d(e,"LessEqual",function(){return pe.Cb}),t.d(e,"LinSpace",function(){return pe.Db}),t.d(e,"Log",function(){return pe.Eb}),t.d(e,"Log1p",function(){return pe.Fb}),t.d(e,"LogicalAnd",function(){return pe.Hb}),t.d(e,"LogicalNot",function(){return pe.Ib}),t.d(e,"LogicalOr",function(){return pe.Jb}),t.d(e,"LogicalXor",function(){return pe.Kb}),t.d(e,"LogSoftmax",function(){return pe.Gb}),t.d(e,"LowerBound",function(){return pe.Lb}),t.d(e,"LRN",function(){return pe.yb}),t.d(e,"LRNGrad",function(){return pe.zb}),t.d(e,"Max",function(){return pe.Mb}),t.d(e,"Maximum",function(){return pe.Sb}),t.d(e,"MaxPool",function(){return pe.Nb}),t.d(e,"MaxPoolGrad",function(){return pe.Qb}),t.d(e,"MaxPool3D",function(){return pe.Ob}),t.d(e,"MaxPool3DGrad",function(){return pe.Pb}),t.d(e,"MaxPoolWithArgmax",function(){return pe.Rb}),t.d(e,"Mean",function(){return pe.Tb}),t.d(e,"Min",function(){return pe.Ub}),t.d(e,"Minimum",function(){return pe.Vb}),t.d(e,"MirrorPad",function(){return pe.Wb}),t.d(e,"Mod",function(){return pe.Xb}),t.d(e,"Multinomial",function(){return pe.Yb}),t.d(e,"Multiply",function(){return pe.Zb}),t.d(e,"Neg",function(){return pe.ac}),t.d(e,"NotEqual",function(){return pe.ec}),t.d(e,"NonMaxSuppressionV3",function(){return pe.bc}),t.d(e,"NonMaxSuppressionV4",function(){return pe.cc}),t.d(e,"NonMaxSuppressionV5",function(){return pe.dc}),t.d(e,"OnesLike",function(){return pe.gc}),t.d(e,"OneHot",function(){return pe.fc}),t.d(e,"Pack",function(){return pe.hc}),t.d(e,"PadV2",function(){return pe.ic}),t.d(e,"Pool",function(){return pe.jc}),t.d(e,"Pow",function(){return pe.kc}),t.d(e,"Prelu",function(){return pe.lc}),t.d(e,"Prod",function(){return pe.mc}),t.d(e,"RaggedTensorToTensor",function(){return pe.nc}),t.d(e,"Range",function(){return pe.oc}),t.d(e,"Real",function(){return pe.pc}),t.d(e,"Reciprocal",function(){return pe.rc}),t.d(e,"Relu",function(){return pe.sc}),t.d(e,"Reshape",function(){return pe.uc}),t.d(e,"ResizeNearestNeighbor",function(){return pe.xc}),t.d(e,"ResizeNearestNeighborGrad",function(){return pe.yc}),t.d(e,"ResizeBilinear",function(){return pe.vc}),t.d(e,"ResizeBilinearGrad",function(){return pe.wc}),t.d(e,"Relu6",function(){return pe.tc}),t.d(e,"Reverse",function(){return pe.zc}),t.d(e,"Round",function(){return pe.Bc}),t.d(e,"Rsqrt",function(){return pe.Cc}),t.d(e,"ScatterNd",function(){return pe.Dc}),t.d(e,"SearchSorted",function(){return pe.Ec}),t.d(e,"Select",function(){return pe.Fc}),t.d(e,"Selu",function(){return pe.Gc}),t.d(e,"Slice",function(){return pe.Lc}),t.d(e,"Sin",function(){return pe.Jc}),t.d(e,"Sinh",function(){return pe.Kc}),t.d(e,"Sign",function(){return pe.Ic}),t.d(e,"Sigmoid",function(){return pe.Hc}),t.d(e,"Softplus",function(){return pe.Nc}),t.d(e,"Sqrt",function(){return pe.Vc}),t.d(e,"Sum",function(){return pe.ed}),t.d(e,"SpaceToBatchND",function(){return pe.Oc}),t.d(e,"SplitV",function(){return pe.Uc}),t.d(e,"Softmax",function(){return pe.Mc}),t.d(e,"SparseFillEmptyRows",function(){return pe.Pc}),t.d(e,"SparseReshape",function(){return pe.Qc}),t.d(e,"SparseSegmentMean",function(){return pe.Rc}),t.d(e,"SparseSegmentSum",function(){return pe.Sc}),t.d(e,"SparseToDense",function(){return pe.Tc}),t.d(e,"SquaredDifference",function(){return pe.Xc}),t.d(e,"Square",function(){return pe.Wc}),t.d(e,"StridedSlice",function(){return pe.Zc}),t.d(e,"StringNGrams",function(){return pe.ad}),t.d(e,"StringSplit",function(){return pe.bd}),t.d(e,"StringToHashBucketFast",function(){return pe.cd}),t.d(e,"Sub",function(){return pe.dd}),t.d(e,"Tan",function(){return pe.fd}),t.d(e,"Tanh",function(){return pe.gd}),t.d(e,"Tile",function(){return pe.hd}),t.d(e,"TopK",function(){return pe.id}),t.d(e,"Transform",function(){return pe.jd}),t.d(e,"Transpose",function(){return pe.kd}),t.d(e,"Unique",function(){return pe.ld}),t.d(e,"Unpack",function(){return pe.md}),t.d(e,"UnsortedSegmentSum",function(){return pe.nd}),t.d(e,"UpperBound",function(){return pe.od}),t.d(e,"ZerosLike",function(){return pe.pd}),t.d(e,"Step",function(){return pe.Yc}),t.d(e,"FromPixels",function(){return pe.kb}),t.d(e,"RotateWithOffset",function(){return pe.Ac}),t.d(e,"_FusedMatMul",function(){return pe.qd}),t.d(e,"FusedConv2D",function(){return pe.mb}),t.d(e,"FusedDepthwiseConv2D",function(){return pe.nb});var n={};t.r(n),t.d(n,"copyModel",function(){return ht}),t.d(n,"listModels",function(){return At}),t.d(n,"moveModel",function(){return Pt}),t.d(n,"removeModel",function(){return $e}),t.d(n,"browserFiles",function(){return pn}),t.d(n,"browserHTTPRequest",function(){return de}),t.d(n,"concatenateArrayBuffers",function(){return I.d}),t.d(n,"decodeWeights",function(){return I.e}),t.d(n,"encodeWeights",function(){return I.f}),t.d(n,"fromMemory",function(){return on}),t.d(n,"fromMemorySync",function(){return tn}),t.d(n,"getLoadHandlers",function(){return L}),t.d(n,"getModelArtifactsForJSON",function(){return I.g}),t.d(n,"getModelArtifactsInfoForJSON",function(){return I.h}),t.d(n,"getSaveHandlers",function(){return U}),t.d(n,"http",function(){return re}),t.d(n,"isHTTPScheme",function(){return Us}),t.d(n,"loadWeights",function(){return Ns}),t.d(n,"registerLoadRouter",function(){return D}),t.d(n,"registerSaveRouter",function(){return E}),t.d(n,"weightsLoaderFactory",function(){return ys}),t.d(n,"withSaveHandler",function(){return bn}),t.d(n,"withSaveHandlerSync",function(){return On});var r={};t.r(r),t.d(r,"confusionMatrix",function(){return Vo});var a={};t.r(a),t.d(a,"getBroadcastDims",function(){return So}),t.d(a,"getReductionAxes",function(){return so}),t.d(a,"assertAndGetBroadcastShape",function(){return Zs});var o={};t.r(o),t.d(o,"fromPixelsAsync",function(){return It}),t.d(o,"toPixels",function(){return Ut}),t.d(o,"fromPixels",function(){return sn});var i={};t.r(i),t.d(i,"prepareAndValidate",function(){return vn});var u={};t.r(u),t.d(u,"validateUpdateShape",function(){return fn}),t.d(u,"validateInput",function(){return Vn}),t.d(u,"calculateShapes",function(){return hs});var c={};t.r(c),t.d(c,"assertParamsValid",function(){return Es}),t.d(c,"maskToAxes",function(){return dr}),t.d(c,"computeOutShape",function(){return Js}),t.d(c,"stridesWithElidedDims",function(){return ga}),t.d(c,"getNormalizedAxes",function(){return ro}),t.d(c,"startIndicesWithElidedDims",function(){return Wa}),t.d(c,"stopIndicesWithElidedDims",function(){return Va}),t.d(c,"stridesForAxis",function(){return Qi}),t.d(c,"startForAxis",function(){return _i}),t.d(c,"stopForAxis",function(){return ri}),t.d(c,"isSliceContinous",function(){return $u}),t.d(c,"computeFlatOffset",function(){return go}),t.d(c,"parseSliceParams",function(){return bo}),t.d(c,"sliceInfo",function(){return Ua});var d={};t.r(d),t.d(d,"Serializable",function(){return Ji}),t.d(d,"SerializationMap",function(){return Xr}),t.d(d,"registerClass",function(){return ja});var h={};t.r(h),t.d(h,"TEST_EPSILON_FLOAT16",function(){return ai}),t.d(h,"expectArraysClose",function(){return Tu}),t.d(h,"testEpsilon",function(){return oi}),t.d(h,"expectPromiseToFail",function(){return Nu}),t.d(h,"expectArraysEqual",function(){return Ls}),t.d(h,"expectNumbersClose",function(){return Lr}),t.d(h,"expectValuesInRange",function(){return Si}),t.d(h,"expectArrayBuffersEqual",function(){return eu}),t.d(h,"encodeStrings",function(){return No}),t.d(h,"createVideoElement",function(){return $i}),t.d(h,"play",function(){return Ti});var l={};t.r(l),t.d(l,"conv2d",function(){return xx}),t.d(l,"depthwiseConv2d",function(){return vx}),t.d(l,"matMul",function(){return kx});var p={};t.r(p),t.d(p,"segOpComputeOptimalWindowSize",function(){return Pn}),t.d(p,"computeOutShape",function(){return Xn}),t.d(p,"collectGatherOpShapeInfo",function(){return Hn});var f={};t.r(f),t.d(f,"axesAreInnerMostDims",function(){return Ec}),t.d(f,"combineLocations",function(){return Qc}),t.d(f,"computeOutAndReduceShapes",function(){return Ll}),t.d(f,"expandShapeToKeepDim",function(){return Eu}),t.d(f,"assertAxesAreInnerMostDims",function(){return Bl}),t.d(f,"getAxesPermutation",function(){return zl}),t.d(f,"getUndoAxesPermutation",function(){return Jc}),t.d(f,"getInnerMostAxes",function(){return Ru}),t.d(f,"getBroadcastDims",function(){return So}),t.d(f,"getReductionAxes",function(){return so}),t.d(f,"assertAndGetBroadcastShape",function(){return Zs}),t.d(f,"assertParamsConsistent",function(){return p1}),t.d(f,"computeOutShape",function(){return f1}),t.d(f,"computeDilation2DInfo",function(){return Yu}),t.d(f,"computePool2DInfo",function(){return Pe}),t.d(f,"computePool3DInfo",function(){return me}),t.d(f,"computeConv2DInfo",function(){return He}),t.d(f,"computeConv3DInfo",function(){return st}),t.d(f,"computeDefaultPad",function(){return Ae}),t.d(f,"tupleValuesAreOne",function(){return St}),t.d(f,"eitherStridesOrDilationsAreOne",function(){return _t}),t.d(f,"convertConv2DDataFormat",function(){return en}),t.d(f,"checkPadOnDimRoundingMode",function(){return Kt}),t.d(f,"getFusedDyActivation",function(){return Ld}),t.d(f,"getFusedBiasGradient",function(){return Bd}),t.d(f,"applyActivation",function(){return zd}),t.d(f,"shouldFuse",function(){return Oc}),t.d(f,"RowPartitionType",function(){return lu}),t.d(f,"combineRaggedTensorToTensorShapes",function(){return m1}),t.d(f,"getRowPartitionTypesHelper",function(){return g1}),t.d(f,"getRaggedRank",function(){return em}),t.d(f,"validateDefaultValueShape",function(){return b1}),t.d(f,"PARALLELIZE_THRESHOLD",function(){return Vh}),t.d(f,"computeOptimalWindowSize",function(){return x1}),t.d(f,"slice_util",function(){return c}),t.d(f,"upcastType",function(){return Fi.c}),t.d(f,"getImageCenter",function(){return y1}),t.d(f,"getReshaped",function(){return w1}),t.d(f,"getPermuted",function(){return v1}),t.d(f,"getReshapedPermuted",function(){return k1}),t.d(f,"getSliceBeginCoords",function(){return I1}),t.d(f,"getSliceSize",function(){return C1}),t.d(f,"prepareAndValidate",function(){return vn}),t.d(f,"validateUpdateShape",function(){return fn}),t.d(f,"validateInput",function(){return Vn}),t.d(f,"calculateShapes",function(){return hs}),t.d(f,"SELU_SCALEALPHA",function(){return _1}),t.d(f,"SELU_SCALE",function(){return S1}),t.d(f,"ERF_P",function(){return $1}),t.d(f,"ERF_A1",function(){return T1}),t.d(f,"ERF_A2",function(){return tm}),t.d(f,"ERF_A3",function(){return N1}),t.d(f,"ERF_A4",function(){return E1}),t.d(f,"ERF_A5",function(){return R1}),t.d(f,"warn",function(){return nc.b}),t.d(f,"log",function(){return nc.a}),t.d(f,"mergeRealAndImagArrays",function(){return nm}),t.d(f,"splitRealAndImagArrays",function(){return A1}),t.d(f,"complexWithEvenIndex",function(){return O1}),t.d(f,"complexWithOddIndex",function(){return F1}),t.d(f,"getComplexWithIndex",function(){return D1}),t.d(f,"assignToTypedArray",function(){return M1}),t.d(f,"exponents",function(){return P1}),t.d(f,"exponent",function(){return L1}),t.d(f,"decodeEinsumEquation",function(){return k}),t.d(f,"getEinsumPermutation",function(){return S}),t.d(f,"checkEinsumDimSizes",function(){return _}),t.d(f,"getEinsumComputePath",function(){return T}),t.d(f,"isIdentityPermutation",function(){return O}),t.d(f,"prepareSplitSize",function(){return z}),t.d(f,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",function(){return K}),t.d(f,"getSparseFillEmptyRowsNegativeIndexErrorMessage",function(){return Q}),t.d(f,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",function(){return ue}),t.d(f,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",function(){return ae}),t.d(f,"getSparseReshapeNegativeOutputDimErrorMessage",function(){return Re}),t.d(f,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",function(){return ke}),t.d(f,"getSparseReshapeInputOutputMultipleErrorMessage",function(){return Ge}),t.d(f,"getSparseReshapeInputOutputMismatchErrorMessage",function(){return qe}),t.d(f,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",function(){return Ne}),t.d(f,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",function(){return Ke}),t.d(f,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",function(){return an}),t.d(f,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",function(){return kn}),t.d(f,"segment_util",function(){return p}),t.d(f,"fromUint8ToStringArray",function(){return Qn}),t.d(f,"fromStringArrayToUint8",function(){return Wn});var x={};t.r(x),t.d(x,"nonMaxSuppressionV3Impl",function(){return Kf}),t.d(x,"nonMaxSuppressionV4Impl",function(){return Xf}),t.d(x,"nonMaxSuppressionV5Impl",function(){return Yf}),t.d(x,"whereImpl",function(){return Lh});var b=t(3),m=(t(50),t(9)),I=t(17);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return N.instance==null&&(N.instance=new N),N.instance}static registerSaveRouter(g){N.getInstance().saveRouters.push(g)}static registerLoadRouter(g){N.getInstance().loadRouters.push(g)}static getSaveHandlers(g){return N.getHandlers(g,"save")}static getLoadHandlers(g,v){return N.getHandlers(g,"load",v)}static getHandlers(g,v,C){const $=[];return(v==="load"?N.getInstance().loadRouters:N.getInstance().saveRouters).forEach(M=>{const W=M(g,C);W!==null&&$.push(W)}),$}}const E=w=>N.registerSaveRouter(w),D=w=>N.registerLoadRouter(w),U=w=>N.getSaveHandlers(w),L=(w,g)=>N.getLoadHandlers(w,g),Y="tensorflowjs",V="models_store",P="model_info_store";function oe(){if(!Object(m.c)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const w=typeof window=="undefined"?self:window,g=w.indexedDB||w.mozIndexedDB||w.webkitIndexedDB||w.msIndexedDB||w.shimIndexedDB;if(g==null)throw new Error("The current browser does not appear to support IndexedDB.");return g}function ne(w){const g=w.result;g.createObjectStore(V,{keyPath:"modelPath"}),g.createObjectStore(P,{keyPath:"modelPath"})}class ge{constructor(g){if(this.indexedDB=oe(),g==null||!g)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=g}async save(g){if(g.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,g)}async load(){return this.databaseAction(this.modelPath)}databaseAction(g,v){return new Promise((C,$)=>{const M=this.indexedDB.open(Y,1);M.onupgradeneeded=()=>ne(M),M.onsuccess=()=>{const W=M.result;if(v==null){const J=W.transaction(V,"readonly"),le=J.objectStore(V).get(this.modelPath);le.onsuccess=()=>{if(le.result==null)return W.close(),$(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));C(le.result.modelArtifacts)},le.onerror=ve=>(W.close(),$(le.error)),J.oncomplete=()=>W.close()}else{const J=Object(I.h)(v),le=W.transaction(P,"readwrite");let ve=le.objectStore(P);const Xe=ve.put({modelPath:this.modelPath,modelArtifactsInfo:J});let Ve;Xe.onsuccess=()=>{Ve=W.transaction(V,"readwrite");const kt=Ve.objectStore(V).put({modelPath:this.modelPath,modelArtifacts:v,modelArtifactsInfo:J});kt.onsuccess=()=>C({modelArtifactsInfo:J}),kt.onerror=Zt=>{ve=le.objectStore(P);const gn=ve.delete(this.modelPath);gn.onsuccess=()=>(W.close(),$(kt.error)),gn.onerror=En=>(W.close(),$(kt.error))}},Xe.onerror=kt=>(W.close(),$(Xe.error)),le.oncomplete=()=>{Ve==null?W.close():Ve.oncomplete=()=>W.close()}}},M.onerror=W=>$(M.error)})}}ge.URL_SCHEME="indexeddb://";const ye=w=>{return Object(m.c)().getBool("IS_BROWSER")&&!Array.isArray(w)&&w.startsWith(ge.URL_SCHEME)?(g=w.slice(ge.URL_SCHEME.length),new ge(g)):null;var g};N.registerSaveRouter(ye),N.registerLoadRouter(ye);class Ee{constructor(){this.indexedDB=oe()}async listModels(){return new Promise((g,v)=>{const C=this.indexedDB.open(Y,1);C.onupgradeneeded=()=>ne(C),C.onsuccess=()=>{const $=C.result,M=$.transaction(P,"readonly"),W=M.objectStore(P).getAll();W.onsuccess=()=>{const J={};for(const le of W.result)J[le.modelPath]=le.modelArtifactsInfo;g(J)},W.onerror=J=>($.close(),v(W.error)),M.oncomplete=()=>$.close()},C.onerror=$=>v(C.error)})}async removeModel(g){var v;return g=(v=g).startsWith(ge.URL_SCHEME)?v.slice(ge.URL_SCHEME.length):v,new Promise((C,$)=>{const M=this.indexedDB.open(Y,1);M.onupgradeneeded=()=>ne(M),M.onsuccess=()=>{const W=M.result,J=W.transaction(P,"readwrite"),le=J.objectStore(P),ve=le.get(g);let Xe;ve.onsuccess=()=>{if(ve.result==null)return W.close(),$(new Error(`Cannot find model with path '${g}' in IndexedDB.`));{const Ve=le.delete(g),kt=()=>{Xe=W.transaction(V,"readwrite");const Zt=Xe.objectStore(V).delete(g);Zt.onsuccess=()=>C(ve.result.modelArtifactsInfo),Zt.onerror=gn=>$(ve.error)};Ve.onsuccess=kt,Ve.onerror=Zt=>(kt(),W.close(),$(ve.error))}},ve.onerror=Ve=>(W.close(),$(ve.error)),J.oncomplete=()=>{Xe==null?W.close():Xe.oncomplete=()=>W.close()}},M.onerror=W=>$(M.error)})}}var X=t(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const je="/",Be="tensorflowjs_models",tt="info",ct="model_topology",Me="weight_specs",wt="weight_data",at="model_metadata";function Gt(w){return{info:[Be,w,tt].join(je),topology:[Be,w,ct].join(je),weightSpecs:[Be,w,Me].join(je),weightData:[Be,w,wt].join(je),modelMetadata:[Be,w,at].join(je)}}function Ht(w){for(const g of Object.values(w))window.localStorage.removeItem(g)}function dn(w){const g=w.split(je);if(g.length<3)throw new Error(`Invalid key format: ${w}`);return g.slice(1,g.length-1).join(je)}class mn{constructor(g){if(!Object(m.c)().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,g==null||!g)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=g,this.keys=Gt(this.modelPath)}async save(g){if(g.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const v=JSON.stringify(g.modelTopology),C=JSON.stringify(g.weightSpecs),$=Object(I.h)(g);try{this.LS.setItem(this.keys.info,JSON.stringify($)),this.LS.setItem(this.keys.topology,v),this.LS.setItem(this.keys.weightSpecs,C),this.LS.setItem(this.keys.weightData,Object(I.a)(g.weightData));const M={format:g.format,generatedBy:g.generatedBy,convertedBy:g.convertedBy,signature:g.signature!=null?g.signature:void 0,userDefinedMetadata:g.userDefinedMetadata!=null?g.userDefinedMetadata:void 0,modelInitializer:g.modelInitializer!=null?g.modelInitializer:void 0,trainingConfig:g.trainingConfig!=null?g.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(M)),{modelArtifactsInfo:$}}catch{throw Ht(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${$.modelTopologyBytes}, weightSpecsBytes=${$.weightSpecsBytes}, weightDataBytes=${$.weightDataBytes}.`)}}}async load(){const g=JSON.parse(this.LS.getItem(this.keys.info));if(g==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(g.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const v={},C=JSON.parse(this.LS.getItem(this.keys.topology));if(C==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);v.modelTopology=C;const $=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if($==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);v.weightSpecs=$;const M=this.LS.getItem(this.keys.modelMetadata);if(M!=null){const J=JSON.parse(M);v.format=J.format,v.generatedBy=J.generatedBy,v.convertedBy=J.convertedBy,J.signature!=null&&(v.signature=J.signature),J.userDefinedMetadata!=null&&(v.userDefinedMetadata=J.userDefinedMetadata),J.modelInitializer!=null&&(v.modelInitializer=J.modelInitializer),J.trainingConfig!=null&&(v.trainingConfig=J.trainingConfig)}const W=this.LS.getItem(this.keys.weightData);if(W==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return v.weightData=Object(I.b)(W),v}}mn.URL_SCHEME="localstorage://";const Rn=w=>{return Object(m.c)().getBool("IS_BROWSER")&&!Array.isArray(w)&&w.startsWith(mn.URL_SCHEME)?(g=w.slice(mn.URL_SCHEME.length),new mn(g)):null;var g};N.registerSaveRouter(Rn),N.registerLoadRouter(Rn);class ee{constructor(){Object(X.b)(Object(m.c)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Object(X.b)(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const g={},v=Be+je,C=je+tt;for(let $=0;$<this.LS.length;++$){const M=this.LS.key($);M.startsWith(v)&&M.endsWith(C)&&(g[dn(M)]=JSON.parse(this.LS.getItem(M)))}return g}async removeModel(g){var v;const C=Gt(g=(v=g).startsWith(mn.URL_SCHEME)?v.slice(mn.URL_SCHEME.length):v);if(this.LS.getItem(C.info)==null)throw new Error(`Cannot find model at path '${g}'`);const $=JSON.parse(this.LS.getItem(C.info));return Ht(C),$}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const se="://";class we{constructor(){this.managers={}}static getInstance(){return we.instance==null&&(we.instance=new we),we.instance}static registerManager(g,v){Object(X.b)(g!=null,()=>"scheme must not be undefined or null."),g.endsWith(se)&&(g=g.slice(0,g.indexOf(se))),Object(X.b)(g.length>0,()=>"scheme must not be an empty string.");const C=we.getInstance();Object(X.b)(C.managers[g]==null,()=>`A model store manager is already registered for scheme '${g}'.`),C.managers[g]=v}static getManager(g){const v=we.getInstance().managers[g];if(v==null)throw new Error(`Cannot find model manager for scheme '${g}'`);return v}static getSchemes(){return Object.keys(we.getInstance().managers)}}function pt(w){if(w.indexOf(se)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${we.getSchemes().join(",")}`);return{scheme:w.split(se)[0],path:w.split(se)[1]}}async function bt(w,g,v=!1){Object(X.b)(w!==g,()=>`Old path and new path are the same: '${w}'`);const C=N.getLoadHandlers(w);Object(X.b)(C.length>0,()=>`Copying failed because no load handler is found for source URL ${w}.`),Object(X.b)(C.length<2,()=>`Copying failed because more than one (${C.length}) load handlers for source URL ${w}.`);const $=C[0],M=N.getSaveHandlers(g);Object(X.b)(M.length>0,()=>`Copying failed because no save handler is found for destination URL ${g}.`),Object(X.b)(M.length<2,()=>`Copying failed because more than one (${C.length}) save handlers for destination URL ${g}.`);const W=M[0],J=pt(w).scheme,le=pt(w).path,ve=J===pt(w).scheme,Xe=await $.load();v&&ve&&await we.getManager(J).removeModel(le);const Ve=await W.save(Xe);return v&&!ve&&await we.getManager(J).removeModel(le),Ve.modelArtifactsInfo}async function At(){const w=we.getSchemes(),g={};for(const v of w){const C=await we.getManager(v).listModels();for(const $ in C)g[v+se+$]=C[$]}return g}async function $e(w){const g=pt(w);return we.getManager(g.scheme).removeModel(g.path)}async function ht(w,g){return bt(w,g,!1)}async function Pt(w,g){return bt(w,g,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ot{fetch(g,v){return fetch(g,v)}now(){return performance.now()}encode(g,v){if(v!=="utf-8"&&v!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${v}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(g)}decode(g,v){return new TextDecoder(v).decode(g)}}if(Object(m.c)().get("IS_BROWSER")){Object(m.c)().setPlatform("browser",new Ot);try{we.registerManager(mn.URL_SCHEME,new ee)}catch{}try{we.registerManager(ge.URL_SCHEME,new Ee)}catch{}}t(109);var xn=t(14);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(w,g="float32",v){return g=g||"float32",X.c(w),new xn.b(w,g,v)}var pe=t(4),be=t(1),Qe=t(2);const Un=Object(Qe.b)({cast_:function(w,g){const v=Object(be.a)(w,"x","cast");if(!X.B(g))throw new Error(`Failed to cast to unknown dtype ${g}`);if(g==="string"&&v.dtype!=="string"||g!=="string"&&v.dtype==="string")throw new Error("Only strings can be casted to strings");const C={x:v},$={dtype:g};return b.a.runKernel(pe.x,C,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ws=Object(Qe.b)({clone_:function(w){const g={x:Object(be.a)(w,"x","clone","string_or_numeric")};return b.a.runKernel(pe.tb,g)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(w,g=!1){console.log(w.toString(g))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Object(b.b)();const As={buffer:Dn,cast:Un,clone:Ws,print:Gs};Object(xn.e)(As);function xs(w){return new Promise(g=>setTimeout(g)).then(w)}class ds{constructor(g){if(!Object(m.c)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");g.startsWith(ds.URL_SCHEME)&&(g=g.slice(ds.URL_SCHEME.length)),g!=null&&g.length!==0||(g="model"),this.modelJsonFileName=g+".json",this.weightDataFileName=g+".weights.bin"}async save(g){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const v=window.URL.createObjectURL(new Blob([g.weightData],{type:"application/octet-stream"}));if(g.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const C=[{paths:["./"+this.weightDataFileName],weights:g.weightSpecs}],$=Object(I.i)(g,C),M=window.URL.createObjectURL(new Blob([JSON.stringify($)],{type:"application/json"})),W=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(W.download=this.modelJsonFileName,W.href=M,await xs(()=>W.dispatchEvent(new MouseEvent("click"))),g.weightData!=null){const J=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;J.download=this.weightDataFileName,J.href=v,await xs(()=>J.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Object(I.h)(g)}}}}ds.URL_SCHEME="downloads://";class Ys{constructor(g){if(g==null||g.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${g}`);this.jsonFile=g[0],this.weightsFiles=g.slice(1)}async load(){return new Promise((g,v)=>{const C=new FileReader;C.onload=$=>{const M=JSON.parse($.target.result),W=M.modelTopology;if(W==null)return void v(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(M.weightsManifest==null)return void v(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(this.weightsFiles.length===0)return void g({modelTopology:W});const J=Object(I.g)(M,le=>this.loadWeights(le));g(J)},C.onerror=$=>v(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),C.readAsText(this.jsonFile)})}loadWeights(g){const v=[],C=[];for(const W of g)v.push(...W.weights),C.push(...W.paths);const $=this.checkManifestAndWeightFiles(g),M=C.map(W=>this.loadWeightsFile(W,$[W]));return Promise.all(M).then(W=>[v,Object(I.d)(W)])}loadWeightsFile(g,v){return new Promise((C,$)=>{const M=new FileReader;M.onload=W=>{const J=W.target.result;C(J)},M.onerror=W=>$(`Failed to weights data from file of path '${g}'.`),M.readAsArrayBuffer(v)})}checkManifestAndWeightFiles(g){const v=[],C=this.weightsFiles.map(M=>Object(I.c)(M.name)),$={};for(const M of g)M.paths.forEach(W=>{const J=Object(I.c)(W);if(v.indexOf(J)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${J}'`);if(v.push(J),C.indexOf(J)===-1)throw new Error(`Weight file with basename '${J}' is not provided.`);$[W]=this.weightsFiles[C.indexOf(J)]});if(v.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${v.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return $}}function pn(w){return new Ys(w)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(w,g,v,C){(function(M){Object(X.b)(M!=null&&Array.isArray(M)&&M.length>0,()=>"promises must be a none empty array")})(w),function(M,W){Object(X.b)(M>=0&&M<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${M}`),Object(X.b)(W>=0&&W<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${W}`),Object(X.b)(W>=M,()=>`startFraction must be no more than endFraction, but got startFraction ${M} and endFraction ${W}`)}(v=v==null?0:v,C=C==null?1:C);let $=0;return Promise.all(w.map(M=>(M.then(W=>{const J=v+ ++$/w.length*(C-v);return g(J),W}),M)))}N.registerSaveRouter(w=>Object(m.c)().getBool("IS_BROWSER")&&!Array.isArray(w)&&w.startsWith(ds.URL_SCHEME)?function(g="model"){return new ds(g)}(w.slice(ds.URL_SCHEME.length)):null);var ts=t(52);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $s(w,g){g==null&&(g={});const v=g.fetchFunc==null?Object(m.c)().platform.fetch:g.fetchFunc,C=w.map(M=>v(M,g.requestInit,{isBinary:!0})),$=(g.onProgress==null?await Promise.all(C):await Nn(C,g.onProgress,0,.5)).map(M=>M.arrayBuffer());return g.onProgress==null?await Promise.all($):await Nn($,g.onProgress,.5,1)}async function Ns(w,g="",v,C){return ys($=>$s($,{requestInit:C}))(w,g,v)}function ys(w){return async(g,v="",C)=>{const $=g.map(()=>!1),M={},W=C!=null?C.map(()=>!1):[],J=[];if(g.forEach((Zt,gn)=>{let En=0;Zt.weights.forEach(qn=>{const Is="quantization"in qn?qn.quantization.dtype:qn.dtype,Sn=ts.a[Is]*X.O(qn.shape),Tn=()=>{$[gn]=!0,M[gn]==null&&(M[gn]=[]),M[gn].push({manifestEntry:qn,groupOffset:En,sizeBytes:Sn})};C!=null?C.forEach((ns,is)=>{ns===qn.name&&(Tn(),W[is]=!0)}):Tn(),J.push(qn.name),En+=Sn})}),!W.every(Zt=>Zt)){const Zt=C.filter((gn,En)=>!W[En]);throw new Error(`Could not find weights in manifest with names: ${Zt.join(", ")}. 
Manifest JSON has weights with names: ${J.join(", ")}.`)}const le=$.reduce((Zt,gn,En)=>(gn&&Zt.push(En),Zt),[]),ve=[];le.forEach(Zt=>{g[Zt].paths.forEach(gn=>{const En=v+(v.endsWith("/")?"":"/")+gn;ve.push(En)})});const Xe=await w(ve),Ve={};let kt=0;return le.forEach(Zt=>{const gn=g[Zt].paths.length;let En=0;for(let Tn=0;Tn<gn;Tn++)En+=Xe[kt+Tn].byteLength;const qn=new ArrayBuffer(En),Is=new Uint8Array(qn);let Sn=0;for(let Tn=0;Tn<gn;Tn++){const ns=new Uint8Array(Xe[kt+Tn]);Is.set(ns,Sn),Sn+=ns.byteLength}M[Zt].forEach(Tn=>{const ns=qn.slice(Tn.groupOffset,Tn.groupOffset+Tn.sizeBytes),is=Object(I.e)(ns,[Tn.manifestEntry]);for(const cs in is)Ve[cs]=is[cs]}),kt+=gn}),Ve}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vs{constructor(g,v){if(this.DEFAULT_METHOD="POST",v==null&&(v={}),this.weightPathPrefix=v.weightPathPrefix,this.onProgress=v.onProgress,this.weightUrlConverter=v.weightUrlConverter,v.fetchFunc!=null?(Object(X.b)(typeof v.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=v.fetchFunc):this.fetch=Object(m.c)().platform.fetch,Object(X.b)(g!=null&&g.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(g)&&Object(X.b)(g.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${g.length}).`),this.path=g,v.requestInit!=null&&v.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=v.requestInit||{}}async save(g){if(g.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const v=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);v.body=new FormData;const C=[{paths:["./model.weights.bin"],weights:g.weightSpecs}],$=Object(I.i)(g,C);v.body.append("model.json",new Blob([JSON.stringify($)],{type:"application/json"}),"model.json"),g.weightData!=null&&v.body.append("model.weights.bin",new Blob([g.weightData],{type:"application/octet-stream"}),"model.weights.bin");const M=await this.fetch(this.path,v);if(M.ok)return{modelArtifactsInfo:Object(I.h)(g),responses:[M]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${M.status}.`)}async load(){const g=await this.fetch(this.path,this.requestInit);if(!g.ok)throw new Error(`Request to ${this.path} failed with status code ${g.status}. Please verify this URL points to the model JSON of the model to load.`);let v;try{v=await g.json()}catch{let W=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?W+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":W+=" Please make sure the server is serving valid JSON for this request.",new Error(W)}const C=v.modelTopology,$=v.weightsManifest;if(C==null&&$==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Object(I.g)(v,M=>this.loadWeights(M))}async loadWeights(g){const v=Array.isArray(this.path)?this.path[1]:this.path,[C,$]=function(Xe){const Ve=Xe.lastIndexOf("/"),kt=Xe.lastIndexOf("?"),Zt=Xe.substring(0,Ve),gn=kt>Ve?Xe.substring(kt):"";return[Zt+"/",gn]}(v),M=this.weightPathPrefix||C,W=[];for(const Xe of g)W.push(...Xe.weights);const J=[],le=[];for(const Xe of g)for(const Ve of Xe.paths)this.weightUrlConverter!=null?le.push(this.weightUrlConverter(Ve)):J.push(M+Ve+$);this.weightUrlConverter&&J.push(...await Promise.all(le));const ve=await $s(J,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[W,Object(I.d)(ve)]}}function Us(w){return w.match(Vs.URL_SCHEME_REGEX)!=null}Vs.URL_SCHEME_REGEX=/^https?:\/\//;const jt=(w,g)=>{if(typeof fetch=="undefined"&&(g==null||g.fetchFunc==null))return null;{let v=!0;if(v=Array.isArray(w)?w.every(C=>Us(C)):Us(w),v)return re(w,g)}return null};function re(w,g){return new Vs(w,g)}function de(w,g){return re(w,g)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */N.registerSaveRouter(jt),N.registerLoadRouter(jt);class ot{constructor(g){this.modelArtifacts=g}load(){return this.modelArtifacts}}class Ct{constructor(g){this.saveHandler=g}save(g){return this.saveHandler(g)}}class Yt{constructor(g){g.load&&(this.load=()=>Promise.resolve(g.load())),g.save&&(this.save=v=>Promise.resolve(g.save(v)))}}function on(w,g,v,C){const $=arguments;return new Yt(tn(...$))}function tn(w,g,v,C){return arguments.length===1?w.modelTopology!=null||w.weightSpecs!=null?new ot(w):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ot({modelTopology:w})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ot({modelTopology:w,weightSpecs:g,weightData:v,trainingConfig:C}))}function bn(w){return new Ct(w)}function On(w){return new Ct(w)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Mn=t(10);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wn=Object(Qe.b)({matMul_:function(w,g,v=!1,C=!1){let $=Object(be.a)(w,"a","matMul"),M=Object(be.a)(g,"b","matMul");[$,M]=Object(Mn.makeTypesMatch)($,M);const W={a:$,b:M},J={transposeA:v,transposeB:C};return b.a.runKernel(pe.s,W,J)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gs=Object(Qe.b)({oneHot_:function(w,g,v=1,C=0,$="int32"){if(g<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${g}`);const M={indices:Object(be.a)(w,"indices","oneHot","int32")},W={dtype:$,depth:g,onValue:v,offValue:C};return b.a.runKernel(pe.fc,M,W)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(){Object(m.c)().set("PROD",!0)}function xr(){Object(m.c)().set("DEBUG",!0)}function Ir(){Object(m.c)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function qs(w){Object(m.c)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(w+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ta(){b.a.disposeVariables()}function pa(){return b.a}function rr(){return b.a.memory()}function eo(w){return b.a.profile(w)}function Qs(w,g){return b.a.tidy(w,g)}function mr(w){Object(Mn.getTensorsInContainer)(w).forEach(g=>g.dispose())}function $r(w){return b.a.keep(w)}function ia(w){return b.a.time(w)}function Pr(w){return b.a.setBackend(w)}function Cr(){return b.a.ready()}function Ba(){return b.a.backendName}function za(w){b.a.removeBackend(w)}function to(w){return b.a.findBackend(w)}function Wo(w){return b.a.findBackendFactory(w)}function si(w,g,v=1){return b.a.registerBackend(w,g,v)}function fo(){return b.a.backend}function no(w,g){Object(m.c)().setPlatform(w,g)}Object(xn.d)(qs);var Ta=t(22);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mo=Object(Qe.b)({imag_:function(w){const g={input:Object(be.a)(w,"input","imag")};return b.a.runKernel(pe.ub,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ar=Object(Qe.b)({neg_:function(w){const g={x:Object(be.a)(w,"x","neg")};return b.a.runKernel(pe.ac,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Na=Object(Qe.b)({real_:function(w){const g={input:Object(be.a)(w,"input","real")};return b.a.runKernel(pe.pc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ea=Object(Qe.b)({transpose_:function(w,g,v){const C=Object(be.a)(w,"x","transpose");if(g==null&&(g=C.shape.map((W,J)=>J).reverse()),X.b(C.rank===g.length,()=>`Error in transpose: rank of input ${C.rank} must match length of perm ${g}.`),g.forEach(W=>{X.b(W>=0&&W<C.rank,()=>"All entries in 'perm' must be between 0 and "+(C.rank-1)+` but got ${g}`)}),C.rank<=1)return C.clone();const $={x:C},M={perm:g};return C.dtype==="complex64"?Qs(()=>{let W=Na(C),J=mo(C);return W=b.a.runKernel(pe.kd,{x:W},M),J=b.a.runKernel(pe.kd,{x:J},M),v&&(J=Ar(J)),Object(Ta.a)(W,J)}):b.a.runKernel(pe.kd,$,M)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vo=Object(Qe.b)({confusionMatrix_:function(w,g,v){const C=Object(be.a)(w,"labels","confusionMatrix"),$=Object(be.a)(g,"predictions","confusionMatrix");X.b(v==null||v>0&&Number.isInteger(v),()=>`If provided, numClasses must be a positive integer, but got ${v}`),X.b(C.rank===1,()=>`Expected the rank of labels to be 1, but got ${C.rank}`),X.b($.rank===1,()=>`Expected the rank of predictions to be 1, but got ${$.rank}`),X.b(C.shape[0]===$.shape[0],()=>`Mismatch in the number of examples: ${C.shape[0]} vs. ${$.shape[0]}. Labels and predictions should have the same number of elements.`),X.b(v>0&&Number.isInteger(v),()=>`numClasses is required to be a positive integer, but got ${v}`);const M=gs(Un(C,"int32"),v),W=gs(Un($,"int32"),v),J=Ea(M),le=wn(J,W);return Un(le,"int32")}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function So(w,g){const v=w.length,C=[];for(let $=0;$<v;$++){const M=v-1-$,W=w[M]||1;(g[g.length-1-$]||1)>1&&W===1&&C.unshift(M)}return C}function so(w,g){const v=[];for(let C=0;C<g.length;C++){const $=w[w.length-C-1],M=g.length-C-1,W=g[M];($==null||$===1&&W>1)&&v.unshift(M)}return v}function Zs(w,g){const v=[],C=Math.max(w.length,g.length);for(let $=0;$<C;$++){let M=w[w.length-$-1];M==null&&(M=1);let W=g[g.length-$-1];if(W==null&&(W=1),M===1)v.unshift(W);else if(W===1)v.unshift(M);else{if(M!==W)throw Error(`Operands could not be broadcast together with shapes ${w} and ${g}.`);v.unshift(M)}}return v}var Kr=t(31),Ra=t(20);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(w,g,v){if(Object(X.d)(w),g!=null&&g.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const C=Object(be.c)(w,v);if(C.length!==3&&C.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(C.length===1&&g==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(Ra.a)(w,g,C,v)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let na;function $o(w,g=3){if(g>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(w==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let v=!1,C=!1,$=!1,M=!1,W=!1,J=!1;if(w.data instanceof Uint8Array)v=!0;else if(typeof ImageData!="undefined"&&w instanceof ImageData)C=!0;else if(typeof HTMLVideoElement!="undefined"&&w instanceof HTMLVideoElement)$=!0;else if(typeof HTMLImageElement!="undefined"&&w instanceof HTMLImageElement)M=!0;else if(w.getContext!=null)W=!0;else{if(!(typeof ImageBitmap!="undefined"&&w instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${w.constructor.name}`);J=!0}if(Object(Kr.c)(pe.kb,b.a.backendName)!=null){const kt={pixels:w},Zt={numChannels:g};return b.a.runKernel(pe.kb,kt,Zt)}const[le,ve]=$?[w.videoWidth,w.videoHeight]:[w.width,w.height];let Xe,Ve;if(W)Xe=w.getContext("2d").getImageData(0,0,le,ve).data;else if(C||v)Xe=w.data;else if(M||$||J){if(na==null)if(typeof document=="undefined"){if(typeof OffscreenCanvas=="undefined"||typeof OffscreenCanvasRenderingContext2D=="undefined")throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");na=new OffscreenCanvas(1,1).getContext("2d")}else na=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});na.canvas.width=le,na.canvas.height=ve,na.drawImage(w,0,0,le,ve),Xe=na.getImageData(0,0,le,ve).data}if(g===4)Ve=new Int32Array(Xe);else{const kt=le*ve;Ve=new Int32Array(kt*g);for(let Zt=0;Zt<kt;Zt++)for(let gn=0;gn<g;++gn)Ve[Zt*g+gn]=Xe[4*Zt+gn]}return fa(Ve,[ve,le,g],"int32")}function We(w){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")&&!(w instanceof ImageBitmap)&&function(g){return g!=null&&g.width!==0&&g.height!==0}(w)&&!function(g){return g!=null&&g.data instanceof Uint8Array}(w)}async function It(w,g=3){let v=null;if(Object(m.c)().getBool("WRAP_TO_IMAGEBITMAP")&&We(w)){let C;try{C=await createImageBitmap(w,{premultiplyAlpha:"none"})}catch{C=null}v=C!=null&&C.width===w.width&&C.height===w.height?C:w}else v=w;return $o(v,g)}async function Ut(w,g){let v=Object(be.a)(w,"img","toPixels");if(!(w instanceof xn.a)){const ve=v;v=Un(ve,"int32"),ve.dispose()}if(v.rank!==2&&v.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${v.rank}.`);const[C,$]=v.shape.slice(0,2),M=v.rank===2?1:v.shape[2];if(M>4||M===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${M}`);if(v.dtype!=="float32"&&v.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${v.dtype}. Please use float32 or int32 tensors.`);const W=await v.data(),J=v.dtype==="float32"?255:1,le=new Uint8ClampedArray($*C*4);for(let ve=0;ve<C*$;++ve){const Xe=[0,0,0,255];for(let kt=0;kt<M;kt++){const Zt=W[ve*M+kt];if(v.dtype==="float32"){if(Zt<0||Zt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Zt}.`)}else if(v.dtype==="int32"&&(Zt<0||Zt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Zt}.`);M===1?(Xe[0]=Zt*J,Xe[1]=Zt*J,Xe[2]=Zt*J):Xe[kt]=Zt*J}const Ve=4*ve;le[Ve+0]=Math.round(Xe[0]),le[Ve+1]=Math.round(Xe[1]),le[Ve+2]=Math.round(Xe[2]),le[Ve+3]=Math.round(Xe[3])}if(g!=null){g.width=$,g.height=C;const ve=g.getContext("2d"),Xe=new ImageData(le,$,C);ve.putImageData(Xe,0,0)}return v!==w&&v.dispose(),le}const sn=Object(Qe.b)({fromPixels_:$o});function vn(w,g){const v=w.shape.length,C=g.shape.length;if(v<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${v}.`);if(C<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${C}.`);if(g.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${g.dtype}.`);if(g.shape[C-1]>v)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${g.shape[C-1]} vs. ${v}`);if(Object(X.O)(w.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${w.shape}.`);const $=g.shape,M=$[$.length-1];let W=1;for(let Ve=0;Ve<$.length-1;++Ve)W*=$[Ve];const J=w.shape,le=$.slice();le.pop();let ve=1;for(let Ve=M;Ve<v;++Ve)ve*=J[Ve],le.push(J[Ve]);const Xe=[...Object(X.j)(w.shape).map(Ve=>Ve/ve),1].slice(0,M);return[le,W,ve,Xe]}function fn(w,g,v){const C=g.rank>1?g.shape[g.rank-1]:1,$=g.rank>1?g.rank-1:1,M=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${v.shape}, indices.shape: ${g.shape}, shape: ${w}, sliceDim: ${C}, and batchDim: ${$}.`;if(v.rank<$)throw new Error(M+` update.rank < ${$}. `);if(w.length<C+(v.rank-$))throw new Error(M+` Output shape length < ${C+(v.rank-$)}`);if(v.rank!==$+w.length-C)throw new Error(M+" update.rank != "+($+w.length-C));for(let W=0;W<$;++W)if(v.shape[W]!==g.shape[W])throw new Error(M+` updates.shape[${W}] (${v.shape[W]}) != indices.shape[${W}] (${g.shape[W]}).`);for(let W=0;W<v.rank-$;++W)if(v.shape[W+$]!==w[W+C])throw new Error(M+` updates.shape[${W+$}] (${v.shape[W+$]}) != shape[${W+$}] (${w[W+$]})`)}function Vn(w,g,v){if(g.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${g.rank}.`);if(w.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${w.rank}.`);if(g.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${g.dtype}`);if(v.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${v}`);if(v.length===0){if(g.size===0)throw new Error(`Indices specified for empty output. indices shape: ${g.shape}`);if(w.size===0)throw new Error(`Updates specified for empty output. updates shape: ${w.shape}`)}fn(v,g,w)}function hs(w,g,v){const C=g.shape.length,$=C>1?g.shape[C-1]:1,M=v.length;let W=1;for(let le=$;le<M;++le)W*=v[le];const J=$<1?1:$;return{sliceRank:$,numUpdates:Object(X.O)(g.shape)/J,sliceSize:W,strides:[...Object(X.j)(v.slice(0,$)),1],outputSize:Object(X.O)(v)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(w,g,v){const C=w.shape.length;X.b(C===g.length,()=>`Error in slice${C}D: Length of begin ${g} must match the rank of the array (${C}).`),X.b(C===v.length,()=>`Error in slice${C}D: Length of size ${v} must match the rank of the array (${C}).`);for(let $=0;$<C;++$)X.b(g[$]+v[$]<=w.shape[$],()=>`Error in slice${C}D: begin[${$}] + size[${$}] (${g[$]+v[$]}) would overflow input.shape[${$}] (${w.shape[$]})`)}function dr(w){const g=[];let v=0;for(;w>0;)1&w&&g.push(v),w/=2,v++;return g}function Js(w,g,v){const C=[];for(let $=0;$<w.length;$++)C[$]=Math.ceil((g[$]-w[$])/v[$]);return C}function ga(w,g,v,C){const $=[...w];for(let M=$.length;M<C.length;M++)$.push(1);for(let M=0;M<v;M++)M===0?$[g]=1:($.splice(g,0,1),$.pop());return $}function ur(w,g,v){return v<=w?v:v-(g-1)}function Or(w,g){const v=[];for(let C=0;C<w;C++)v.push(g+C);return v}function ro(w,g,v,C,$,M,W,J,le){const ve=w.length;let Xe=new Array(ve),Ve=new Array(ve),kt=new Array(ve);if(g.length&&v>0){const Zt=g[0],gn=v+1;Xe=Wa(W,Zt,gn,C,w),Ve=Va(J,Zt,gn,$,w),kt=ga(M,Zt,gn,w)}else for(let Zt=0;Zt<ve;Zt++)Xe[Zt]=_i(W,C,M,w,Zt,le),Ve[Zt]=ri(J,$,M,w,Zt,le),kt[Zt]=Qi(M,Zt,le);return{begin:Xe,end:Ve,strides:kt}}function Wa(w,g,v,C,$){const M=[...$],W=Or(v,g);for(let J=0;J<M.length;J++)if(W.indexOf(J)>-1)M[J]=0;else{const le=ur(g,v,J);let ve=C[le];w&1<<le&&(ve=0),M[J]=ve}return M}function Va(w,g,v,C,$){const M=[...$],W=Or(v,g);for(let J=0;J<M.length;J++)if(W.indexOf(J)>-1)M[J]=Number.MAX_SAFE_INTEGER;else{const le=ur(g,v,J);let ve=C[le];w&1<<le&&(ve=Number.MAX_SAFE_INTEGER),M[J]=ve}for(let J=0;J<M.length;J++){const le=$[J];M[J]<0&&(M[J]+=le),M[J]=X.i(0,M[J],$[J])}return M}function Qi(w,g,v){let C=w[g];return(v&1<<g||C==null)&&(C=1),C}function _i(w,g,v,C,$,M){let W=g[$];const J=v[$]||1;(w&1<<$||M&1<<$||W==null)&&(W=J>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const le=C[$];return W<0&&(W+=le),W=X.i(0,W,le-1),W}function ri(w,g,v,C,$,M){let W=g[$];const J=v[$]||1;(w&1<<$||M&1<<$||W==null)&&(W=J>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const le=C[$];return W<0&&(W+=le),W=J>0?X.i(0,W,le):X.i(-1,W,le-1),W}function $u(w,g,v){let C=v.length;for(let $=0;$<v.length;$++)if(v[$]>1){C=$;break}for(let $=C+1;$<v.length;$++)if(g[$]>0||v[$]!==w[$])return!1;return!0}function go(w,g){let v=w.length>0?w[w.length-1]:1;for(let C=0;C<w.length-1;C++)v+=w[C]*g[C];return v}function bo(w,g,v){let C;const $=w.shape.length;let M;return C=typeof g=="number"?[g,...new Array($-1).fill(0)]:g.length<$?g.concat(new Array($-g.length).fill(0)):g.slice(),C.forEach(W=>{X.b(W!==-1,()=>"slice() does not support negative begin indexing.")}),M=v==null?new Array($).fill(-1):typeof v=="number"?[v,...new Array($-1).fill(-1)]:v.length<$?v.concat(new Array($-v.length).fill(-1)):v,M=M.map((W,J)=>W>=0?W:(X.b(W===-1,()=>`Negative size values should be exactly -1 but got ${W} for the slice() size at index ${J}.`),w.shape[J]-C[J])),[C,M]}function Ua(w,g,v,C,$,M,W,J,le){let ve;if(C==null?(ve=new Array(g.length),ve.fill(1)):ve=C,W!=null&&(W&W-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let Xe=!1;const Ve={dims:ve.length,numAddAxisAfterEllipsis:0,begin:g.slice(),end:v.slice(),strides:ve.slice(),beginMask:$,endMask:M,ellipsisMask:W,newAxisMask:J,shrinkAxisMask:le};for(let Sn=0;Sn<Ve.dims;Sn++)Xe&&(1<<Sn&J)!=0&&Ve.numAddAxisAfterEllipsis++,1<<Sn&W&&(Xe=!0);Xe||(Ve.ellipsisMask|=1<<Ve.dims,Ve.dims++);const kt={dims:w.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};(function(Sn,Tn){Tn.beginMask=0,Tn.endMask=0,Tn.shrinkAxisMask=0;let ns=0;Tn.beginValid=Sn.begin!=null,Tn.endValid=Sn.end!=null,Tn.begin=new Array(Tn.dims),Tn.end=new Array(Tn.dims),Tn.strides=new Array(Tn.dims),Tn.finalShapeGatherIndices=[],Tn.finalShapeGatherIndicesSparse=[],Tn.inputShapeGatherIndicesSparse=new Array(Tn.dims);for(let is=0;is<Sn.dims;is++)if(1<<is&Sn.ellipsisMask){const cs=Math.min(Tn.dims-(Sn.dims-is)+1+Sn.numAddAxisAfterEllipsis,Tn.dims);for(;ns<cs;ns++)Tn.begin[ns]=0,Tn.end[ns]=0,Tn.strides[ns]=1,Tn.beginMask|=1<<ns,Tn.endMask|=1<<ns,Tn.finalShapeGatherIndices.push(ns),Tn.finalShapeGatherIndicesSparse.push(-1),Tn.inputShapeGatherIndicesSparse[ns]=is}else if(1<<is&Sn.newAxisMask)Tn.finalShapeGatherIndices.push(-2),Tn.finalShapeGatherIndicesSparse.push(-1);else{if(ns===Tn.begin.length)throw Error(`Index out of range using input dim ${ns}; input has only ${Tn.dims} dims, ${Tn.begin.length}.`);Sn.begin!=null&&(Tn.begin[ns]=Sn.begin[is]),Sn.end!=null&&(Tn.end[ns]=Sn.end[is]),Tn.strides[ns]=Sn.strides[is],Sn.beginMask&1<<is&&(Tn.beginMask|=1<<ns),Sn.endMask&1<<is&&(Tn.endMask|=1<<ns),Sn.shrinkAxisMask&1<<is?(Tn.finalShapeGatherIndices.push(-1),Tn.finalShapeGatherIndicesSparse.push(-1),Tn.shrinkAxisMask|=1<<ns):(Tn.finalShapeGatherIndices.push(ns),Tn.finalShapeGatherIndicesSparse.push(is)),Tn.inputShapeGatherIndicesSparse[ns]=is,ns++}})(Ve,kt);let Zt=!0,gn=!0,En=!0;const qn=[],Is=[];for(let Sn=0;Sn<w.length;++Sn){if(kt.strides[Sn]===0)throw Error(`strides[${Sn}] must be non-zero`);const Tn=!!(kt.shrinkAxisMask&1<<Sn),ns=w[Sn];if(ns===-1){qn.push(Tn?1:-1);continue}const is=[kt.beginMask&1<<Sn,kt.endMask&1<<Sn],cs=[kt.strides[Sn]>0?0:-1,kt.strides[Sn]>0?ns:ns-1];if(Tn&&kt.strides[Sn]<=0)throw Error("only stride 1 allowed on non-range indexing.");En=En&&kt.strides[Sn]===1;const Bs=!!(kt.beginMask&1<<Sn&&kt.endMask&1<<Sn);if(kt.beginValid&&kt.endValid){if(Tn){const lr=kt.begin[Sn]<0?ns+kt.begin[Sn]:kt.begin[Sn];if(kt.begin[Sn]=lr,kt.end[Sn]=kt.begin[Sn]+1,lr<0||lr>=ns)throw Error(`slice index ${kt.begin[Sn]} of dimension ${Sn} out of bounds.`)}else kt.begin[Sn]=Wr(kt.begin[Sn],0,kt.strides[Sn],ns,is,cs),kt.end[Sn]=Wr(kt.end[Sn],1,kt.strides[Sn],ns,is,cs);const os=kt.strides[Sn]===1&&kt.begin[Sn]===0&&kt.end[Sn]===ns;Zt=Zt&&os,gn=gn&&(Sn===0&&kt.strides[Sn]===1||os)}else Zt=Zt&&kt.strides[Sn]===1&&Bs,gn=gn&&(Sn===0&&kt.strides[Sn]===1||Bs);let zs,Ts=!1;if(kt.beginValid&&kt.endValid?(zs=kt.end[Sn]-kt.begin[Sn],Ts=!0):Tn?(zs=1,Ts=!0):Bs&&ns>=0&&(zs=kt.strides[Sn]<0?-ns:ns,Ts=!0),Ts){let os;os=zs===0||zs<0!=kt.strides[Sn]<0?0:Math.trunc(zs/kt.strides[Sn])+(zs%kt.strides[Sn]!=0?1:0),qn.push(os)}else qn.push(-1)}for(let Sn=0;Sn<kt.finalShapeGatherIndices.length;++Sn){const Tn=kt.finalShapeGatherIndices[Sn];Tn>=0?Is.push(qn[Tn]):Tn===-2&&Is.push(1)}return{finalShapeSparse:Is.filter((Sn,Tn)=>kt.finalShapeGatherIndices[Tn]!==-2),finalShape:Is,isIdentity:Zt,sliceDim0:gn,isSimpleSlice:En,begin:kt.begin,end:kt.end,strides:kt.strides}}function Wr(w,g,v,C,$,M){if($[g])return v>0?M[g]:M[g+1&1];{const W=w<0?C+w:w;return W<M[0]?M[0]:W>M[1]?M[1]:W}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ji{getClassName(){return this.constructor.className}static fromConfig(g,v){return new g(v)}}class Xr{constructor(){this.classNameMap={}}static getMap(){return Xr.instance==null&&(Xr.instance=new Xr),Xr.instance}static register(g){Xr.getMap().classNameMap[g.className]=[g,g.fromConfig]}}function ja(w){Object(X.b)(w.className!=null,()=>"Class being registered does not have the static className property defined."),Object(X.b)(typeof w.className=="string",()=>"className is required to be a string, but got type "+typeof w.className),Object(X.b)(w.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Xr.register(w)}var To=t(6);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai=.1;function Tu(w,g,v){return v==null&&(v=oi()),Uo(w,g,(C,$)=>ao(C,$,v))}function oi(){return b.a.backend.floatPrecision()===32?.001:ai}function Uo(w,g,v){let C=!0;if((Object(X.A)(w)||Object(X.A)(g))&&(C=!1),Object(X.A)(w)&&Object(X.A)(g)&&(C=!0),C){const W=w.constructor.name,J=g.constructor.name;if(W!==J)throw new Error(`Arrays are of different type. Actual: ${W}. Expected: ${J}`)}if(Array.isArray(w)&&Array.isArray(g)){const W=Object(be.c)(w),J=Object(be.c)(g);if(!Object(X.a)(W,J))throw new Error(`Arrays have different shapes. Actual: [${W}]. Expected: [${J}]`)}const $=Object(X.A)(w)?w:Object(X.m)(w),M=Object(X.A)(g)?g:Object(X.m)(g);if($.length!==M.length)throw new Error(`Arrays have different lengths actual: ${$.length} vs expected: ${M.length}.
Actual:   ${$}.
Expected: ${M}.`);for(let W=0;W<M.length;++W){const J=$[W],le=M[W];if(!v(J,le))throw new Error(`Arrays differ: actual[${W}] = ${J}, expected[${W}] = ${le}.
Actual:   ${$}.
Expected: ${M}.`)}typeof expect!="undefined"&&expect().nothing()}function Nu(w,g){w().then(()=>g.fail(),()=>g()),typeof expect!="undefined"&&expect().nothing()}function Ls(w,g){const v=typeof g=="string"||typeof g=="number"||typeof g=="boolean"?[g]:g;return Object(X.z)(w)||Object(X.z)(w[0])||Object(X.z)(g)||Object(X.z)(g[0])?Uo(w,v,(C,$)=>C==$):Uo(w,g,(C,$)=>ao(C,$,0))}function Lr(w,g,v){if(v==null&&(v=oi()),!ao(w,g,v))throw new Error(`Numbers differ: actual === ${w}, expected === ${g}`);typeof expect!="undefined"&&expect().nothing()}function ao(w,g,v){return!isFinite(w)&&!isFinite(g)||!(isNaN(w)||isNaN(g)||Math.abs(w-g)>v)}function Si(w,g,v){for(let C=0;C<w.length;C++)if(w[C]<g||w[C]>v)throw new Error(`Value out of range:${w[C]} low: ${g}, high: ${v}`)}function eu(w,g){const v=new Float32Array(w),C=new Float32Array(g);if(v.length!==C.length)throw new Error(`Expected ArrayBuffer to be of length ${C.length}, but it was ${v.length}`);for(let $=0;$<C.length;$++)if(v[$]!==C[$])throw new Error(`Expected ArrayBuffer value at ${$} to be ${C[$]} but got ${v[$]} instead`)}function No(w){for(let g=0;g<w.length;g++){const v=w[g];Array.isArray(v)?No(v):w[g]=Object(To.encodeString)(v)}return w}function $i(w){const g=document.createElement("video");return"playsInline"in g&&(g.playsInline=!0),g.muted=!0,g.loop=!0,g.style.position="fixed",g.style.left="0px",g.style.top="0px",g.preload="auto",g.appendChild(w),new Promise(v=>{g.addEventListener("loadeddata",C=>v(g)),g.load()})}async function Ti(w){await w.play(),"requestVideoFrameCallback"in w&&await new Promise(g=>{w.requestVideoFrameCallback(g)})}/** @license See the LICENSE file. */const ii="3.20.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bs=Object(Qe.b)({add_:function(w,g){let v=Object(be.a)(w,"a","add"),C=Object(be.a)(g,"b","add");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.d,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jn=Object(Qe.b)({floorDiv_:function(w,g){let v=Object(be.a)(w,"a","floorDiv"),C=Object(be.a)(g,"b","floorDiv");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.jb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hr=Object(Qe.b)({div_:function(w,g){let v=Object(be.a)(w,"a","div"),C=Object(be.a)(g,"b","div");if([v,C]=Object(Mn.makeTypesMatch)(v,C),v.dtype==="int32"&&C.dtype==="int32")return jn(v,C);const $={a:v,b:C};return b.a.runKernel(pe.qc,$,{})}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gn=Object(Qe.b)({mul_:function(w,g){let v=Object(be.a)(w,"a","mul"),C=Object(be.a)(g,"b","mul");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.Zb,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aa=Object(Qe.b)({sqrt_:function(w){const g={x:Object(be.a)(w,"x","sqrt","float32")};return b.a.runKernel(pe.Vc,g)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vr=Object(Qe.b)({square_:function(w){const g=Object(be.a)(w,"x","square");return b.a.runKernel("Square",{x:g},{})}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua=Object(Qe.b)({zerosLike_:function(w){const g={x:Object(be.a)(w,"x","zerosLike")};return b.a.runKernel(pe.pd,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tu(w){return X.b(X.u(w),()=>"The f passed in grad(f) must be a function"),(g,v)=>{const C=Object(be.a)(g,"x","tf.grad","string_or_numeric"),$=v!=null?Object(be.a)(v,"dy","tf.grad"):null;return b.a.tidy(()=>{const{value:M,grads:W}=b.a.gradients(()=>w(C),[C],$);return $!=null&&X.e(M.shape,$.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Go(W),W[0]})}}function ui(w){return X.b(X.u(w),()=>"The f passed in grads(f) must be a function"),(g,v)=>{X.b(Array.isArray(g),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const C=Object(be.b)(g,"args","tf.grads","string_or_numeric"),$=v!=null?Object(be.a)(v,"dy","tf.grads"):null;return b.a.tidy(()=>{const{value:M,grads:W}=b.a.gradients(()=>w(...C),C,$);return $!=null&&X.e(M.shape,$.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Go(W),W})}}function jo(w){return X.b(X.u(w),()=>"The f passed in valueAndGrad(f) must be a function"),(g,v)=>{X.b(g instanceof xn.a,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),X.b(v==null||v instanceof xn.a,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:C,value:$}=b.a.gradients(()=>w(g),[g],v);return Go(C),{grad:C[0],value:$}}}function Ku(w){return X.b(X.u(w),()=>"The f passed in valueAndGrads(f) must be a function"),(g,v)=>{X.b(Array.isArray(g)&&g.every($=>$ instanceof xn.a),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),X.b(v==null||v instanceof xn.a,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const C=b.a.gradients(()=>w(...g),g,v);return v!=null&&X.e(C.value.shape,v.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Go(C.grads),C}}function Ur(w,g){X.b(X.u(w),()=>"The f passed in variableGrads(f) must be a function"),X.b(g==null||Array.isArray(g)&&g.every(le=>le instanceof xn.c),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const v=g!=null;if(!v){g=[];for(const le in b.a.registeredVariables)g.push(b.a.registeredVariables[le])}const C=v?g.filter(le=>!le.trainable):null,$=g.length;g=g.filter(le=>le.trainable),X.b(g.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${$} variables is trainable.`);const{value:M,grads:W}=b.a.gradients(w,g,null,!0);X.b(W.some(le=>le!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),X.b(M.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${M.rank} tensor`);const J={};return g.forEach((le,ve)=>{W[ve]!=null&&(J[le.name]=W[ve])}),C!=null&&C.forEach(le=>J[le.name]=null),{value:M,grads:J}}function oo(w){return b.a.customGrad(w)}function Go(w){if(w.filter(g=>g==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(w,g){if((Object(X.A)(w)&&g!=="string"||Array.isArray(w))&&g!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(g==="string"&&Object(X.A)(w)&&!(w instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(Ra.a)(w,[],[],g)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xo extends Ji{minimize(g,v=!1,C){const{value:$,grads:M}=this.computeGradients(g,C);if(C!=null){const W=C.map(J=>({name:J.name,tensor:M[J.name]}));this.applyGradients(W)}else this.applyGradients(M);return mr(M),v?$:($.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(g,v){return Ur(g,v)}dispose(){this.iterations_!=null&&mr(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(g){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(g){return this.iterations_=(await g[0].tensor.data())[0],g.slice(1)}}Object.defineProperty(xo,Symbol.hasInstance,{value:w=>w.minimize!=null&&w.computeGradients!=null&&w.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ni extends xo{constructor(g,v,C=null){super(),this.learningRate=g,this.rho=v,this.epsilon=C,this.accumulatedGrads=[],this.accumulatedUpdates=[],C==null&&(this.epsilon=b.a.backend.epsilon())}applyGradients(g){(Array.isArray(g)?g.map(v=>v.name):Object.keys(g)).forEach((v,C)=>{const $=b.a.registeredVariables[v];this.accumulatedGrads[C]==null&&(this.accumulatedGrads[C]={originalName:`${v}/accum_grad`,variable:Qs(()=>ua($).variable(!1))}),this.accumulatedUpdates[C]==null&&(this.accumulatedUpdates[C]={originalName:`${v}/accum_var`,variable:Qs(()=>ua($).variable(!1))});const M=Array.isArray(g)?g[C].tensor:g[v];if(M==null)return;const W=this.accumulatedGrads[C].variable,J=this.accumulatedUpdates[C].variable;Qs(()=>{const le=bs(Gn(W,this.rho),Gn(Vr(M),1-this.rho)),ve=Gn(hr(Aa(bs(J,this.epsilon)),Aa(bs(W,this.epsilon))),M),Xe=bs(Gn(J,this.rho),Gn(Vr(ve),1-this.rho));W.assign(le),J.assign(Xe);const Ve=bs(Gn(ve,-this.learningRate),$);$.assign(Ve)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(mr(this.accumulatedGrads.map(g=>g.variable)),mr(this.accumulatedUpdates.map(g=>g.variable)))}async getWeights(){const g=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(g.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(g){const v=(g=await this.extractIterations(g)).length/2;this.accumulatedGrads=g.slice(0,v).map(C=>({originalName:C.name,variable:C.tensor.variable(!1)})),this.accumulatedUpdates=g.slice(v,2*v).map(C=>({originalName:C.name,variable:C.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(g,v){return new g(v.learningRate,v.rho,v.epsilon)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nu(w,g,v){const C={shape:w,value:g,dtype:v};return b.a.runKernel(pe.gb,{},C)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Ni.className="Adadelta",ja(Ni);class ci extends xo{constructor(g,v=.1){super(),this.learningRate=g,this.initialAccumulatorValue=v,this.accumulatedGrads=[]}applyGradients(g){(Array.isArray(g)?g.map(v=>v.name):Object.keys(g)).forEach((v,C)=>{const $=b.a.registeredVariables[v];this.accumulatedGrads[C]==null&&(this.accumulatedGrads[C]={originalName:`${v}/accumulator`,variable:Qs(()=>nu($.shape,this.initialAccumulatorValue).variable(!1))});const M=Array.isArray(g)?g[C].tensor:g[v];if(M==null)return;const W=this.accumulatedGrads[C].variable;Qs(()=>{const J=bs(W,Vr(M));W.assign(J);const le=bs(Gn(hr(M,Aa(bs(J,b.a.backend.epsilon()))),-this.learningRate),$);$.assign(le)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&mr(this.accumulatedGrads.map(g=>g.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(g=>({name:g.originalName,tensor:g.variable})))}async setWeights(g){g=await this.extractIterations(g),this.accumulatedGrads=g.map(v=>({originalName:v.name,variable:v.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(g,v){return new g(v.learningRate,v.initialAccumulatorValue)}}ci.className="Adagrad",ja(ci);const li=Object(Qe.b)({pow_:function(w,g){let v=Object(be.a)(w,"base","pow"),C=Object(be.a)(g,"exp","pow");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.kc,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Os=Object(Qe.b)({sub_:function(w,g){let v=Object(be.a)(w,"a","sub"),C=Object(be.a)(g,"b","sub");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.dd,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ei extends xo{constructor(g,v,C,$=null){super(),this.learningRate=g,this.beta1=v,this.beta2=C,this.epsilon=$,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Qs(()=>{this.accBeta1=ar(v).variable(),this.accBeta2=ar(C).variable()}),$==null&&(this.epsilon=b.a.backend.epsilon())}applyGradients(g){const v=Array.isArray(g)?g.map(C=>C.name):Object.keys(g);Qs(()=>{const C=Os(1,this.accBeta1),$=Os(1,this.accBeta2);v.forEach((M,W)=>{const J=b.a.registeredVariables[M];this.accumulatedFirstMoment[W]==null&&(this.accumulatedFirstMoment[W]={originalName:`${M}/m`,variable:Qs(()=>ua(J).variable(!1))}),this.accumulatedSecondMoment[W]==null&&(this.accumulatedSecondMoment[W]={originalName:`${M}/v`,variable:Qs(()=>ua(J).variable(!1))});const le=Array.isArray(g)?g[W].tensor:g[M];if(le==null)return;const ve=this.accumulatedFirstMoment[W].variable,Xe=this.accumulatedSecondMoment[W].variable,Ve=bs(Gn(ve,this.beta1),Gn(le,1-this.beta1)),kt=bs(Gn(Xe,this.beta2),Gn(Vr(le),1-this.beta2)),Zt=hr(Ve,C),gn=hr(kt,$);ve.assign(Ve),Xe.assign(kt);const En=bs(Gn(hr(Zt,bs(Aa(gn),this.epsilon)),-this.learningRate),J);J.assign(En)}),this.accBeta1.assign(Gn(this.accBeta1,this.beta1)),this.accBeta2.assign(Gn(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&mr(this.accumulatedFirstMoment.map(g=>g.variable)),this.accumulatedSecondMoment!=null&&mr(this.accumulatedSecondMoment.map(g=>g.variable))}async getWeights(){const g=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(g.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(g){g=await this.extractIterations(g),Qs(()=>{this.accBeta1.assign(li(this.beta1,this.iterations_+1)),this.accBeta2.assign(li(this.beta2,this.iterations_+1))});const v=g.length/2;this.accumulatedFirstMoment=g.slice(0,v).map(C=>({originalName:C.name,variable:C.tensor.variable(!1)})),this.accumulatedSecondMoment=g.slice(v,2*v).map(C=>({originalName:C.name,variable:C.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(g,v){return new g(v.learningRate,v.beta1,v.beta2,v.epsilon)}}Ei.className="Adam",ja(Ei);const Ia=Object(Qe.b)({abs_:function(w){const g=Object(be.a)(w,"x","abs");if(g.dtype==="complex64"){const v={x:g};return b.a.runKernel(pe.B,v)}{const v={x:g};return b.a.runKernel(pe.a,v)}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const su=Object(Qe.b)({maximum_:function(w,g){let v=Object(be.a)(w,"a","maximum"),C=Object(be.a)(g,"b","maximum");[v,C]=Object(Mn.makeTypesMatch)(v,C),v.dtype==="bool"&&(v=Un(v,"int32"),C=Un(C,"int32")),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Sb,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ri extends xo{constructor(g,v,C,$=null,M=0){super(),this.learningRate=g,this.beta1=v,this.beta2=C,this.epsilon=$,this.decay=M,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Qs(()=>{this.iteration=ar(0).variable(),this.accBeta1=ar(v).variable()}),$==null&&(this.epsilon=b.a.backend.epsilon())}applyGradients(g){const v=Array.isArray(g)?g.map(C=>C.name):Object.keys(g);Qs(()=>{const C=Os(1,this.accBeta1),$=hr(-this.learningRate,bs(Gn(this.iteration,this.decay),1));v.forEach((M,W)=>{const J=b.a.registeredVariables[M];this.accumulatedFirstMoment[W]==null&&(this.accumulatedFirstMoment[W]={originalName:`${M}/m`,variable:ua(J).variable(!1)}),this.accumulatedWeightedInfNorm[W]==null&&(this.accumulatedWeightedInfNorm[W]={originalName:`${M}/v`,variable:ua(J).variable(!1)});const le=Array.isArray(g)?g[W].tensor:g[M];if(le==null)return;const ve=this.accumulatedFirstMoment[W].variable,Xe=this.accumulatedWeightedInfNorm[W].variable,Ve=bs(Gn(ve,this.beta1),Gn(le,1-this.beta1)),kt=Gn(Xe,this.beta2),Zt=Ia(le),gn=su(kt,Zt);ve.assign(Ve),Xe.assign(gn);const En=bs(Gn(hr($,C),hr(Ve,bs(gn,this.epsilon))),J);J.assign(En)}),this.iteration.assign(bs(this.iteration,1)),this.accBeta1.assign(Gn(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&mr(this.accumulatedFirstMoment.map(g=>g.variable)),this.accumulatedWeightedInfNorm!=null&&mr(this.accumulatedWeightedInfNorm.map(g=>g.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(g){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(g,v){return new g(v.learningRate,v.beta1,v.beta2,v.epsilon,v.decay)}}Ri.className="Adamax",ja(Ri);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai extends xo{constructor(g){super(),this.learningRate=g,this.setLearningRate(g)}applyGradients(g){(Array.isArray(g)?g.map(v=>v.name):Object.keys(g)).forEach((v,C)=>{const $=Array.isArray(g)?g[C].tensor:g[v];if($==null)return;const M=b.a.registeredVariables[v];Qs(()=>{const W=bs(Gn(this.c,$),M);M.assign(W)})}),this.incrementIterations()}setLearningRate(g){this.learningRate=g,this.c!=null&&this.c.dispose(),this.c=$r(ar(-g))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(g){if((g=await this.extractIterations(g)).length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(g,v){return new g(v.learningRate)}}Ai.className="SGD",ja(Ai);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ru extends Ai{constructor(g,v,C=!1){super(g),this.learningRate=g,this.momentum=v,this.useNesterov=C,this.accumulations=[],this.m=ar(this.momentum)}applyGradients(g){(Array.isArray(g)?g.map(v=>v.name):Object.keys(g)).forEach((v,C)=>{const $=b.a.registeredVariables[v];this.accumulations[C]==null&&(this.accumulations[C]={originalName:`${v}/momentum`,variable:Qs(()=>ua($).variable(!1))});const M=this.accumulations[C].variable,W=Array.isArray(g)?g[C].tensor:g[v];W!=null&&Qs(()=>{let J;const le=bs(Gn(this.m,M),W);J=this.useNesterov?bs(Gn(this.c,bs(W,Gn(le,this.m))),$):bs(Gn(this.c,le),$),M.assign(le),$.assign(J)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&mr(this.accumulations.map(g=>g.variable))}setMomentum(g){this.momentum=g}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(g=>({name:g.originalName,tensor:g.variable})))}async setWeights(g){g=await this.extractIterations(g),this.accumulations=g.map(v=>({originalName:v.name,variable:v.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(g,v){return new g(v.learningRate,v.momentum,v.useNesterov)}}ru.className="Momentum",ja(ru);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oi extends xo{constructor(g,v=.9,C=0,$=null,M=!1){if(super(),this.learningRate=g,this.decay=v,this.momentum=C,this.epsilon=$,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=M,$==null&&(this.epsilon=b.a.backend.epsilon()),g==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(g){(Array.isArray(g)?g.map(v=>v.name):Object.keys(g)).forEach((v,C)=>{const $=b.a.registeredVariables[v],M=!1;this.accumulatedMeanSquares[C]==null&&(this.accumulatedMeanSquares[C]={originalName:`${v}/rms`,variable:Qs(()=>ua($).variable(M))}),this.accumulatedMoments[C]==null&&(this.accumulatedMoments[C]={originalName:`${v}/momentum`,variable:Qs(()=>ua($).variable(M))}),this.accumulatedMeanGrads[C]==null&&this.centered&&(this.accumulatedMeanGrads[C]={originalName:`${v}/mg`,variable:Qs(()=>ua($).variable(M))});const W=Array.isArray(g)?g[C].tensor:g[v];if(W==null)return;const J=this.accumulatedMeanSquares[C].variable,le=this.accumulatedMoments[C].variable;Qs(()=>{const ve=bs(Gn(J,this.decay),Gn(Vr(W),1-this.decay));if(this.centered){const Xe=this.accumulatedMeanGrads[C].variable,Ve=bs(Gn(Xe,this.decay),Gn(W,1-this.decay)),kt=hr(Gn(W,this.learningRate),Aa(Os(ve,bs(Vr(Ve),this.epsilon)))),Zt=bs(Gn(le,this.momentum),kt);J.assign(ve),Xe.assign(Ve),le.assign(Zt);const gn=Os($,Zt);$.assign(gn)}else{const Xe=bs(Gn(J,this.decay),Gn(Vr(W),1-this.decay)),Ve=bs(Gn(le,this.momentum),hr(Gn(W,this.learningRate),Aa(bs(Xe,this.epsilon))));J.assign(Xe),le.assign(Ve);const kt=Os($,Ve);$.assign(kt)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&mr(this.accumulatedMeanSquares.map(g=>g.variable)),this.accumulatedMeanGrads!=null&&this.centered&&mr(this.accumulatedMeanGrads.map(g=>g.variable)),this.accumulatedMoments!=null&&mr(this.accumulatedMoments.map(g=>g.variable))}async getWeights(){const g=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&g.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(g.map(v=>({name:v.originalName,tensor:v.variable})))}async setWeights(g){g=await this.extractIterations(g);const v=this.centered?g.length/3:g.length/2,C=!1;this.accumulatedMeanSquares=g.slice(0,v).map($=>({originalName:$.name,variable:$.tensor.variable(C)})),this.accumulatedMoments=g.slice(v,2*v).map($=>({originalName:$.name,variable:$.tensor.variable(C)})),this.centered&&(this.accumulatedMeanGrads=g.slice(2*v,3*v).map($=>({originalName:$.name,variable:$.tensor.variable(C)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(g,v){return new g(v.learningRate,v.decay,v.momentum,v.epsilon,v.centered)}}Oi.className="RMSProp",ja(Oi);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eo{static sgd(g){return new Ai(g)}static momentum(g,v,C=!1){return new ru(g,v,C)}static rmsprop(g,v=.9,C=0,$=null,M=!1){return new Oi(g,v,C,$,M)}static adam(g=.001,v=.9,C=.999,$=null){return new Ei(g,v,C,$)}static adadelta(g=.001,v=.95,C=null){return new Ni(g,v,C)}static adamax(g=.002,v=.9,C=.999,$=null,M=0){return new Ri(g,v,C,$,M)}static adagrad(g,v=.1){return new ci(g,v)}}var Fi=t(34);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cc=Object(Qe.b)({acos_:function(w){const g={x:Object(be.a)(w,"x","acos")};return b.a.runKernel(pe.b,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Di=Object(Qe.b)({acosh_:function(w){const g={x:Object(be.a)(w,"x","acosh")};return b.a.runKernel(pe.c,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ro=Object(Qe.b)({addN_:function(w){X.b(Array.isArray(w),()=>"The argument passed to tf.addN() must be a list of tensors"),X.b(w.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${w.length}`);const g=w.map(($,M)=>Object(be.a)($,`tensors${M}`,"addN")),v=g[0];g.forEach($=>{if($.dtype!==v.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),g.forEach($=>{if(!X.a($.shape,v.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const C=g;return b.a.runKernel(pe.e,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const au=Object(Qe.b)({all_:function(w,g=null,v=!1){const C={x:Object(be.a)(w,"x","all","bool")},$={axis:g,keepDims:v};return b.a.runKernel(pe.f,C,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mi=Object(Qe.b)({any_:function(w,g=null,v=!1){const C={x:Object(be.a)(w,"x","any","bool")},$={axis:g,keepDims:v};return b.a.runKernel(pe.g,C,$)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _c=Object(Qe.b)({argMax_:function(w,g=0){const v={x:Object(be.a)(w,"x","argMax")},C={axis:g};return b.a.runKernel(pe.h,v,C)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const di=Object(Qe.b)({argMin_:function(w,g=0){const v={x:Object(be.a)(w,"x","argMin")},C={axis:g};return b.a.runKernel(pe.i,v,C)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi=Object(Qe.b)({asin_:function(w){const g={x:Object(be.a)(w,"x","asin")};return b.a.runKernel(pe.j,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ou=Object(Qe.b)({asinh_:function(w){const g={x:Object(be.a)(w,"x","asinh")};return b.a.runKernel(pe.k,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xu=Object(Qe.b)({atan_:function(w){const g={x:Object(be.a)(w,"x","atan")};return b.a.runKernel(pe.l,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sc=Object(Qe.b)({atan2_:function(w,g){let v=Object(be.a)(w,"a","atan2"),C=Object(be.a)(g,"b","atan2");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.m,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $c=Object(Qe.b)({atanh_:function(w){const g={x:Object(be.a)(w,"x","atanh")};return b.a.runKernel(pe.n,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(w,g,v,C,$="NHWC",M){return He(w,[...g,w[3]],v,M,C,null,null,en($))}function Pe(w,g,v,C,$,M,W="channelsLast"){const[J,le]=rt(g);let ve;if(W==="channelsLast")ve=[J,le,w[3],w[3]];else{if(W!=="channelsFirst")throw new Error(`Unknown dataFormat ${W}`);ve=[J,le,w[1],w[1]]}return He(w,ve,v,C,$,M,!1,W)}function me(w,g,v,C,$,M,W="NDHWC"){const[J,le,ve]=xt(g);let Xe,Ve;if(W==="NDHWC")Ve="channelsLast",Xe=[J,le,ve,w[4],w[4]];else{if(W!=="NCDHW")throw new Error(`Unknown dataFormat ${W}`);Ve="channelsFirst",Xe=[J,le,ve,w[1],w[1]]}return st(w,Xe,v,C,$,!1,Ve,M)}function He(w,g,v,C,$,M,W=!1,J="channelsLast"){let[le,ve,Xe,Ve]=[-1,-1,-1,-1];if(J==="channelsLast")[le,ve,Xe,Ve]=w;else{if(J!=="channelsFirst")throw new Error(`Unknown dataFormat ${J}`);[le,Ve,ve,Xe]=w}const[kt,Zt,,gn]=g,[En,qn]=rt(v),[Is,Sn]=rt(C),Tn=Nt(kt,Is),ns=Nt(Zt,Sn),{padInfo:is,outHeight:cs,outWidth:Bs}=function(os,lr,Dr,Br,Tr,ra,Yr,Xo,Oo){let sc,Ou,rc;if(typeof os=="number"){sc={top:os,bottom:os,left:os,right:os,type:os===0?"VALID":"NUMBER"};const Ui=function(gi,ji,du,Fc,Gl){Fc==null&&(Fc=Ae(gi,ji,du));const Hl=gi[0],ql=gi[1],Kl=vt((Hl-ji+2*Fc)/du+1,Gl),rl=vt((ql-ji+2*Fc)/du+1,Gl);return[Kl,rl]}([lr,Dr],ra,Br,os,Xo);Ou=Ui[0],rc=Ui[1]}else if(os==="same"){Ou=Math.ceil(lr/Br),rc=Math.ceil(Dr/Tr);const Ui=Math.max(0,(Ou-1)*Br+ra-lr),gi=Math.max(0,(rc-1)*Tr+Yr-Dr),ji=Math.floor(Ui/2),du=Ui-ji,Fc=Math.floor(gi/2);sc={top:ji,bottom:du,left:Fc,right:gi-Fc,type:"SAME"}}else if(os==="valid")sc={top:0,bottom:0,left:0,right:0,type:"VALID"},Ou=Math.ceil((lr-ra+1)/Br),rc=Math.ceil((Dr-Yr+1)/Tr);else{if(typeof os!="object")throw Error(`Unknown padding parameter: ${os}`);{const Ui=Oo==="channelsLast"?os[1][0]:os[2][0],gi=Oo==="channelsLast"?os[1][1]:os[2][1],ji=Oo==="channelsLast"?os[2][0]:os[3][0],du=Oo==="channelsLast"?os[2][1]:os[3][1];sc={top:Ui,bottom:gi,left:ji,right:du,type:Ui===0&&gi===0&&ji===0&&du===0?"VALID":"EXPLICIT"},Ou=vt((lr-ra+Ui+gi)/Br+1,Xo),rc=vt((Dr-Yr+ji+du)/Tr+1,Xo)}}return{padInfo:sc,outHeight:Ou,outWidth:rc}}($,ve,Xe,En,qn,Tn,ns,M,J),zs=W?gn*Ve:gn;let Ts;return J==="channelsFirst"?Ts=[le,zs,cs,Bs]:J==="channelsLast"&&(Ts=[le,cs,Bs,zs]),{batchSize:le,dataFormat:J,inHeight:ve,inWidth:Xe,inChannels:Ve,outHeight:cs,outWidth:Bs,outChannels:zs,padInfo:is,strideHeight:En,strideWidth:qn,filterHeight:kt,filterWidth:Zt,effectiveFilterHeight:Tn,effectiveFilterWidth:ns,dilationHeight:Is,dilationWidth:Sn,inShape:w,outShape:Ts,filterShape:g}}function st(w,g,v,C,$,M=!1,W="channelsLast",J){let[le,ve,Xe,Ve,kt]=[-1,-1,-1,-1,-1];if(W==="channelsLast")[le,ve,Xe,Ve,kt]=w;else{if(W!=="channelsFirst")throw new Error(`Unknown dataFormat ${W}`);[le,kt,ve,Xe,Ve]=w}const[Zt,gn,En,,qn]=g,[Is,Sn,Tn]=xt(v),[ns,is,cs]=xt(C),Bs=Nt(Zt,ns),zs=Nt(gn,is),Ts=Nt(En,cs),{padInfo:os,outDepth:lr,outHeight:Dr,outWidth:Br}=function(Yr,Xo,Oo,sc,Ou,rc,Ui,gi,ji,du,Fc){let Gl,Hl,ql,Kl;if(typeof Yr=="number"){Gl={top:Yr,bottom:Yr,left:Yr,right:Yr,front:Yr,back:Yr,type:Yr===0?"VALID":"NUMBER"};const rl=function(Xl,Yl,sm,Wd,al,Uh){al==null&&(al=Ae(Xl,Yl,Wd));const rm=Xl[0],QN=Xl[1],JN=Xl[2],eE=vt((rm-Yl+2*al)/Wd+1,Uh),tE=vt((QN-Yl+2*al)/Wd+1,Uh),nE=vt((JN-Yl+2*al)/Wd+1,Uh);return[eE,tE,nE,sm]}([Xo,Oo,sc,1],gi,1,Ou,Yr,Fc);Hl=rl[0],ql=rl[1],Kl=rl[2]}else if(Yr==="same"){Hl=Math.ceil(Xo/Ou),ql=Math.ceil(Oo/rc),Kl=Math.ceil(sc/Ui);const rl=(Hl-1)*Ou+gi-Xo,Xl=(ql-1)*rc+ji-Oo,Yl=(Kl-1)*Ui+du-sc,sm=Math.floor(rl/2),Wd=rl-sm,al=Math.floor(Xl/2),Uh=Xl-al,rm=Math.floor(Yl/2);Gl={top:al,bottom:Uh,left:rm,right:Yl-rm,front:sm,back:Wd,type:"SAME"}}else{if(Yr!=="valid")throw Error(`Unknown padding parameter: ${Yr}`);Gl={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Hl=Math.ceil((Xo-gi+1)/Ou),ql=Math.ceil((Oo-ji+1)/rc),Kl=Math.ceil((sc-du+1)/Ui)}return{padInfo:Gl,outDepth:Hl,outHeight:ql,outWidth:Kl}}($,ve,Xe,Ve,Is,Sn,Tn,Bs,zs,Ts,J),Tr=M?qn*kt:qn;let ra;return W==="channelsFirst"?ra=[le,Tr,lr,Dr,Br]:W==="channelsLast"&&(ra=[le,lr,Dr,Br,Tr]),{batchSize:le,dataFormat:W,inDepth:ve,inHeight:Xe,inWidth:Ve,inChannels:kt,outDepth:lr,outHeight:Dr,outWidth:Br,outChannels:Tr,padInfo:os,strideDepth:Is,strideHeight:Sn,strideWidth:Tn,filterDepth:Zt,filterHeight:gn,filterWidth:En,effectiveFilterDepth:Bs,effectiveFilterHeight:zs,effectiveFilterWidth:Ts,dilationDepth:ns,dilationHeight:is,dilationWidth:cs,inShape:w,outShape:ra,filterShape:g}}function Ae(w,g,v,C=1){const $=Nt(g,C);return Math.floor((w[0]*(v-1)-v+$)/2)}function rt(w){return typeof w=="number"?[w,w,w]:w.length===2?[w[0],w[1],1]:w}function xt(w){return typeof w=="number"?[w,w,w]:w}function Nt(w,g){return g<=1?w:w+(w-1)*(g-1)}function vt(w,g){if(!g)return Math.trunc(w);switch(g){case"round":return Math.round(w);case"ceil":return Math.ceil(w);case"floor":return Math.floor(w);default:throw new Error(`Unknown roundingMode ${g}`)}}function St(w){const[g,v,C]=rt(w);return g===1&&v===1&&C===1}function _t(w,g){return St(w)||St(g)}function en(w){if(w==="NHWC")return"channelsLast";if(w==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${w}`)}function Kt(w,g,v){if(v!=null){if(typeof g=="string")throw Error(`Error in ${w}: pad must be an integer when using dimRoundingMode ${v} but got pad ${g}.`);if(typeof g=="number")X.b(X.v(g),()=>`Error in ${w}: pad must be an integer when using dimRoundingMode ${v} but got pad ${g}.`);else{if(typeof g!="object")throw Error(`Error in ${w}: Unknown padding parameter: ${g}`);g.forEach(C=>{C.forEach($=>{X.b(X.v($),()=>`Error in ${w}: pad must be an integer when using dimRoundingMode ${v} but got pad ${$}.`)})})}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ze=Object(Qe.b)({reshape_:function(w,g){const v={x:Object(be.a)(w,"x","reshape","string_or_numeric")},C={shape:g};return b.a.runKernel(pe.uc,v,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt=Object(Qe.b)({avgPool_:function(w,g,v,C,$){const M=Object(be.a)(w,"x","avgPool","float32");X.b(_t(v,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${v} and dilations '1'`);let W=M,J=!1;M.rank===3&&(J=!0,W=Ze(M,[1,M.shape[0],M.shape[1],M.shape[2]])),X.b(W.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${W.rank}.`),Kt("avgPool",C,$);const le={x:W},ve={filterSize:g,strides:v,pad:C,dimRoundingMode:$};let Xe=b.a.runKernel(pe.o,le,ve);return Xe=Un(Xe,M.dtype),J?Ze(Xe,[Xe.shape[1],Xe.shape[2],Xe.shape[3]]):Xe}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jt=Object(Qe.b)({avgPool3d_:function(w,g,v,C,$,M="NDHWC"){const W=Object(be.a)(w,"x","avgPool3d","float32");let J=W,le=!1;W.rank===4&&(le=!0,J=Ze(W,[1,W.shape[0],W.shape[1],W.shape[2],W.shape[3]])),X.b(J.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${J.rank}.`),X.b(M==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${M}`),Kt("avgPool3d",C,$);const ve={x:J},Xe={filterSize:g,strides:v,pad:C,dimRoundingMode:$,dataFormat:M};let Ve=b.a.runKernel(pe.p,ve,Xe);return Ve=Un(Ve,J.dtype),le?Ze(Ve,[Ve.shape[1],Ve.shape[2],Ve.shape[3],Ve.shape[4]]):Ve}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const un=Object(Qe.b)({concat_:function(w,g=0){Object(X.b)(w.length>=1,()=>"Pass at least one tensor to concat");const v=Object(be.b)(w,"tensors","concat","string_or_numeric");if(v[0].dtype==="complex64"&&v.forEach(M=>{if(M.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${M.dtype}. `)}),v.length===1)return Ws(v[0]);const C=v,$={axis:g};return b.a.runKernel(pe.C,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const In=Object(Qe.b)({sigmoid_:function(w){const g={x:Object(be.a)(w,"x","sigmoid","float32")};return b.a.runKernel(pe.Hc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xt=Object(Qe.b)({slice_:function(w,g,v){const C=Object(be.a)(w,"x","slice","string_or_numeric");if(C.rank===0)throw new Error("Slicing scalar is not possible");const $={x:C},M={begin:g,size:v};return b.a.runKernel(pe.Lc,$,M)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $n=Object(Qe.b)({tanh_:function(w){const g={x:Object(be.a)(w,"x","tanh","float32")};return b.a.runKernel(pe.gd,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jn=Object(Qe.b)({basicLSTMCell_:function(w,g,v,C,$,M){const W=Object(be.a)(w,"forgetBias","basicLSTMCell"),J=Object(be.a)(g,"lstmKernel","basicLSTMCell"),le=Object(be.a)(v,"lstmBias","basicLSTMCell"),ve=Object(be.a)(C,"data","basicLSTMCell"),Xe=Object(be.a)($,"c","basicLSTMCell"),Ve=Object(be.a)(M,"h","basicLSTMCell"),kt=un([ve,Ve],1),Zt=wn(kt,J),gn=bs(Zt,le),En=gn.shape[0],qn=gn.shape[1]/4,Is=[En,qn],Sn=Xt(gn,[0,0],Is),Tn=Xt(gn,[0,qn],Is),ns=Xt(gn,[0,2*qn],Is),is=Xt(gn,[0,3*qn],Is),cs=bs(Gn(In(Sn),$n(Tn)),Gn(Xe,In(bs(W,ns))));return[cs,Gn($n(cs),In(is))]}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ss=Object(Qe.b)({batchToSpaceND_:function(w,g,v){const C=Object(be.a)(w,"x","batchToSpaceND"),$=g.reduce((J,le)=>J*le);X.b(C.rank>=1+g.length,()=>`input rank is ${C.rank} but should be > than blockShape.length ${g.length}`),X.b(v.length===g.length,()=>`crops.length is ${v.length} but should be equal to blockShape.length  ${g.length}`),X.b(C.shape[0]%$==0,()=>`input tensor batch is ${C.shape[0]} but is not divisible by the product of the elements of blockShape ${g.join(" * ")} === ${$}`);const M={x:C},W={blockShape:g,crops:v};return b.a.runKernel(pe.t,M,W)}}),Ms=Object(Qe.b)({batchNorm_:function(w,g,v,C,$,M){M==null&&(M=.001);const W=Object(be.a)(w,"x","batchNorm"),J=Object(be.a)(g,"mean","batchNorm"),le=Object(be.a)(v,"variance","batchNorm");let ve,Xe;$!=null&&(ve=Object(be.a)($,"scale","batchNorm")),C!=null&&(Xe=Object(be.a)(C,"offset","batchNorm")),X.b(J.rank===le.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),X.b(Xe==null||J.rank===Xe.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),X.b(ve==null||J.rank===ve.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const Ve=function(En){let qn;return qn=En.rank===0||En.rank===1?Ze(En,[1,1,1,En.size]):En.rank===2?Ze(En,[1,1,En.shape[0],En.shape[1]]):En.rank===3?Ze(En,[1,En.shape[0],En.shape[1],En.shape[2]]):En,qn}(W),kt={x:Ve,scale:ve,offset:Xe,mean:J,variance:le},Zt={varianceEpsilon:M},gn=b.a.runKernel(pe.lb,kt,Zt);return Ze(gn,W.shape)}}),Ps=Object(Qe.b)({batchNorm2d_:function(w,g,v,C,$,M){const W=Object(be.a)(w,"x","batchNorm"),J=Object(be.a)(g,"mean","batchNorm"),le=Object(be.a)(v,"variance","batchNorm");let ve,Xe;return $!=null&&(ve=Object(be.a)($,"scale","batchNorm")),C!=null&&(Xe=Object(be.a)(C,"offset","batchNorm")),X.b(W.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${W.rank}.`),X.b(J.rank===2||J.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${J.rank}.`),X.b(le.rank===2||le.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${le.rank}.`),ve!=null&&X.b(ve.rank===2||ve.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${ve.rank}.`),Xe!=null&&X.b(Xe.rank===2||Xe.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${Xe.rank}.`),Ms(W,J,le,Xe,ve,M)}}),Fs=Object(Qe.b)({batchNorm3d_:function(w,g,v,C,$,M){const W=Object(be.a)(w,"x","batchNorm"),J=Object(be.a)(g,"mean","batchNorm"),le=Object(be.a)(v,"variance","batchNorm");let ve,Xe;return $!=null&&(ve=Object(be.a)($,"scale","batchNorm")),C!=null&&(Xe=Object(be.a)(C,"offset","batchNorm")),X.b(W.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${W.rank}.`),X.b(J.rank===3||J.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${J.rank}.`),X.b(le.rank===3||le.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${le.rank}.`),ve!=null&&X.b(ve.rank===3||ve.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${ve.rank}.`),Xe!=null&&X.b(Xe.rank===3||Xe.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${Xe.rank}.`),Ms(W,J,le,Xe,ve,M)}}),pr=Object(Qe.b)({batchNorm4d_:function(w,g,v,C,$,M){const W=Object(be.a)(w,"x","batchNorm"),J=Object(be.a)(g,"mean","batchNorm"),le=Object(be.a)(v,"variance","batchNorm");let ve,Xe;return $!=null&&(ve=Object(be.a)($,"scale","batchNorm")),C!=null&&(Xe=Object(be.a)(C,"offset","batchNorm")),X.b(W.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${W.rank}.`),X.b(J.rank===4||J.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${J.rank}.`),X.b(le.rank===4||le.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${le.rank}.`),ve!=null&&X.b(ve.rank===4||ve.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${ve.rank}.`),Xe!=null&&X.b(Xe.rank===4||Xe.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${Xe.rank}.`),Ms(W,J,le,Xe,ve,M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er=Object(Qe.b)({bincount_:function(w,g,v){const C=Object(be.a)(w,"x","bincount"),$=Object(be.a)(g,"weights","bincount");X.b(C.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${C.dtype}`),X.b(v>=0,()=>`size must be non-negative, but got ${v}.`),X.b($.size===C.size||$.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${C.shape}, weights shape: ${$.shape}.`);const M={x:C,weights:$},W={size:v};return b.a.runKernel(pe.u,M,W)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fr=Object(Qe.b)({broadcastArgs_:function(w,g){const v=Object(be.a)(w,"s0","broadcastArgs","int32"),C=Object(be.a)(g,"s1","broadcastArgs","int32");if(v.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${v.rank}`);if(C.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${C.rank}`);const $={s0:v,s1:C};return b.a.runKernel(pe.v,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cr=Object(Qe.b)({broadcastTo_:function(w,g){let v=Object(be.a)(w,"broadcastTo","x");const C=v.shape;if(g.some(le=>!(le>0)||le%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${g}].`);if(g.length<v.rank)throw new Error(`broadcastTo(): shape.length=${g.length} < input.rank=${v.rank}.`);if(g.length>v.rank){const le=v.shape.slice();for(;le.length<g.length;)le.unshift(1);v=Ze(v,le)}const $=v.shape,M=Array.from(g);for(let le=g.length-1;le>=0;le--)if($[le]===g[le])M[le]=1;else if(v.shape[le]!==1)throw new Error(`broadcastTo(): [${C}] cannot be broadcast to [${g}].`);if(M.map((le,ve)=>le>1?ve:-1).filter(le=>le>=0).length===0)return Ws(v);const W={x:v},J={reps:M};return b.a.runKernel(pe.hd,W,J)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jr=Object(Qe.b)({ceil_:function(w){const g={x:Object(be.a)(w,"x","ceil","float32")};return b.a.runKernel(pe.y,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ca=Object(Qe.b)({clipByValue_:function(w,g,v){const C=Object(be.a)(w,"x","clipByValue");X.b(g<=v,()=>`Error in clip: min (${g}) must be less than or equal to max (${v}).`);const $={x:C},M={clipValueMin:g,clipValueMax:v};return b.a.runKernel(pe.z,$,M)}}),yo=Object(Qe.b)({concat1d_:function(w){return un(w,0)}}),Ao=Object(Qe.b)({concat2d_:function(w,g){return un(w,g)}}),Li=Object(Qe.b)({concat3d_:function(w,g){return un(w,g)}}),hi=Object(Qe.b)({concat4d_:function(w,g){return un(w,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wo=Object(Qe.b)({conv2d_:function(w,g,v,C,$="NHWC",M=[1,1],W){const J=Object(be.a)(w,"x","conv2d","float32"),le=Object(be.a)(g,"filter","conv2d","float32");let ve=J,Xe=!1;J.rank===3&&(Xe=!0,ve=Ze(J,[1,J.shape[0],J.shape[1],J.shape[2]])),X.b(ve.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${ve.rank}.`),X.b(le.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${le.rank}.`),Kt("conv2d",C,W);const Ve=$==="NHWC"?ve.shape[3]:ve.shape[1];X.b(Ve===le.shape[2],()=>`Error in conv2d: depth of input (${Ve}) must match input depth for filter ${le.shape[2]}.`),X.b(_t(v,M),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${v} and dilations '${M}'`);const kt={x:ve,filter:le},Zt={strides:v,pad:C,dataFormat:$,dilations:M,dimRoundingMode:W},gn=b.a.runKernel(pe.D,kt,Zt);return Xe?Ze(gn,[gn.shape[1],gn.shape[2],gn.shape[3]]):gn}}),Ho=Object(Qe.b)({conv1d_:function(w,g,v,C,$="NWC",M=1,W){const J=Object(be.a)(w,"x","conv1d"),le=Object(be.a)(g,"filter","conv1d");let ve=J,Xe=!1;J.rank===2&&(Xe=!0,ve=Ze(J,[1,J.shape[0],J.shape[1]])),X.b(ve.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${ve.rank}.`),X.b(le.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${le.rank}.`),Kt("conv1d",C,W),X.b(ve.shape[2]===le.shape[1],()=>`Error in conv1d: depth of input (${ve.shape[2]}) must match input depth for filter ${le.shape[1]}.`),X.b(_t(v,M),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${v} and dilation '${M}'`),X.b($==="NWC",()=>`Error in conv1d: got dataFormat of ${$} but only NWC is currently supported.`);const Ve=Ze(le,[1,le.shape[0],le.shape[1],le.shape[2]]),kt=Ze(ve,[ve.shape[0],1,ve.shape[1],ve.shape[2]]),Zt=wo(kt,Ve,[1,v],C,"NHWC",[1,M],W);return Ze(Zt,Xe?[Zt.shape[2],Zt.shape[3]]:[Zt.shape[0],Zt.shape[2],Zt.shape[3]])}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo=Object(Qe.b)({conv2DBackpropInput_:function(w,g,v,C,$,M="NHWC",W){X.b(w.length===g.rank,()=>`Length of inShape (${w.length}) and rank of dy (${g.rank}) must match`);let J=w,le=g,ve=!1;g.rank===3&&(ve=!0,le=Ze(g,[1,g.shape[0],g.shape[1],g.shape[2]]),J=[1,w[0],w[1],w[2]]),X.b(J.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${J.length}.`),X.b(le.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${le.rank}`),X.b(v.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${v.rank}`);const Xe=M==="NHWC"?J[3]:J[1],Ve=M==="NHWC"?le.shape[3]:le.shape[1];X.b(Xe===v.shape[2],()=>`Error in conv2dDerInput: depth of input (${Xe}) must match input depth for filter ${v.shape[2]}.`),X.b(Ve===v.shape[3],()=>`Error in conv2dDerInput: depth of output (${Ve}) must match output depth for filter ${v.shape[3]}.`),Kt("conv2dDerInput",$,W);const kt={dy:le,filter:v},Zt={strides:C,pad:$,dataFormat:M,dimRoundingMode:W,inputShape:J},gn=b.a.runKernel(pe.F,kt,Zt);return ve?Ze(gn,[gn.shape[1],gn.shape[2],gn.shape[3]]):gn}}),Bi=Object(Qe.b)({conv2dTranspose_:function(w,g,v,C,$,M){const W=Object(be.a)(w,"x","conv2dTranspose"),J=Object(be.a)(g,"filter","conv2dTranspose");return qo(v,W,J,C,$,"NHWC",M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ca=Object(Qe.b)({conv3d_:function(w,g,v,C,$="NDHWC",M=[1,1,1]){const W=Object(be.a)(w,"x","conv3d"),J=Object(be.a)(g,"filter","conv3d");let le=W,ve=!1;W.rank===4&&(ve=!0,le=Ze(W,[1,W.shape[0],W.shape[1],W.shape[2],W.shape[3]])),X.b(le.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${le.rank}.`),X.b(J.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${J.rank}.`),X.b(le.shape[4]===J.shape[3],()=>`Error in conv3d: depth of input (${le.shape[4]}) must match input depth for filter ${J.shape[3]}.`),X.b(_t(v,M),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${v} and dilations '${M}'`),X.b($==="NDHWC",()=>`Error in conv3d: got dataFormat of ${$} but only NDHWC is currently supported.`);const Xe={x:le,filter:J},Ve={strides:v,pad:C,dataFormat:$,dilations:M},kt=b.a.runKernel(pe.G,Xe,Ve);return ve?Ze(kt,[kt.shape[1],kt.shape[2],kt.shape[3],kt.shape[4]]):kt}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zi=Object(Qe.b)({conv3DBackpropInput_:function(w,g,v,C,$){X.b(w.length===g.rank,()=>`Length of inShape (${w.length}) and rank of dy (${g.rank}) must match`);let M=w,W=g,J=!1;g.rank===4&&(J=!0,W=Ze(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]]),M=[1,w[0],w[1],w[2],w[3]]);const le=M[4],ve=W.shape[4];X.b(M.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${M.length}.`),X.b(W.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${W.rank}`),X.b(v.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${v.rank}`),X.b(le===v.shape[3],()=>`Error in conv3dDerInput: depth of input (${le}) must match input depth for filter ${v.shape[3]}.`),X.b(ve===v.shape[4],()=>`Error in conv3dDerInput: depth of output (${ve}) must match output depth for filter ${v.shape[4]}.`);const Xe={dy:W,filter:v},Ve={pad:$,strides:C,inputShape:M},kt=b.a.runKernel(pe.I,Xe,Ve);return J?Ze(kt,[kt.shape[1],kt.shape[2],kt.shape[3],kt.shape[4]]):kt}}),Zu=Object(Qe.b)({conv3dTranspose_:function(w,g,v,C,$){const M=Object(be.a)(w,"x","conv3dTranspose"),W=Object(be.a)(g,"filter","conv3dTranspose");return zi(v,M,W,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wi=Object(Qe.b)({cos_:function(w){const g={x:Object(be.a)(w,"x","cos","float32")};return b.a.runKernel(pe.J,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qu=Object(Qe.b)({cosh_:function(w){const g={x:Object(be.a)(w,"x","cosh","float32")};return b.a.runKernel(pe.K,g)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ol=Object(Qe.b)({cumprod_:function(w,g=0,v=!1,C=!1){const $={x:Object(be.a)(w,"x","cumprod")},M={axis:g,exclusive:v,reverse:C};return b.a.runKernel(pe.M,$,M)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kc=Object(Qe.b)({cumsum_:function(w,g=0,v=!1,C=!1){const $={x:Object(be.a)(w,"x","cumsum")},M={axis:g,exclusive:v,reverse:C};return b.a.runKernel(pe.N,$,M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fl=Object(Qe.b)({denseBincount_:function(w,g,v,C=!1){const $=Object(be.a)(w,"x","denseBincount"),M=Object(be.a)(g,"weights","denseBincount");X.b($.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${$.dtype}`),X.b($.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${$.rank}.`),X.b(v>=0,()=>`size must be non-negative, but got ${v}.`),X.b(M.size===$.size||M.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$.shape}, weights shape: ${M.shape}.`);const W={x:$,weights:M},J={size:v,binaryOutput:C};return b.a.runKernel(pe.O,W,J)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xc=Object(Qe.b)({depthToSpace_:function(w,g,v="NHWC"){const C=Object(be.a)(w,"x","depthToSpace","float32"),$=v==="NHWC"?C.shape[1]:C.shape[2],M=v==="NHWC"?C.shape[2]:C.shape[3],W=v==="NHWC"?C.shape[3]:C.shape[1];X.b(g>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${g}`),X.b($*g>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${$} and ${g}  for depthToSpace with input shape
    ${C.shape}`),X.b(M*g>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${M} and ${g} for depthToSpace with input shape
        ${C.shape}`),X.b(W%(g*g)==0,()=>`Dimension size must be evenly divisible by ${g*g} but is ${W} for depthToSpace with input shape ${C.shape}`);const J={x:C},le={blockSize:g,dataFormat:v};return b.a.runKernel(pe.P,J,le)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc=Object(Qe.b)({depthwiseConv2d_:function(w,g,v,C,$="NHWC",M=[1,1],W){const J=Object(be.a)(w,"x","depthwiseConv2d","float32"),le=Object(be.a)(g,"filter","depthwiseConv2d","float32");let ve=J,Xe=!1;J.rank===3&&(Xe=!0,ve=Ze(J,[1,J.shape[0],J.shape[1],J.shape[2]])),X.b(ve.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${ve.rank}.`),X.b(le.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${le.rank}.`);const Ve=$==="NHWC"?ve.shape[3]:ve.shape[1];X.b(Ve===le.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${Ve}) must match the inChannels dimension in filter ${le.shape[2]}.`),Kt("depthwiseConv2d",C,W);const kt={x:ve,filter:le},Zt={strides:v,pad:C,dataFormat:$,dilations:M,dimRoundingMode:W},gn=b.a.runKernel(pe.Q,kt,Zt);return Xe?Ze(gn,[gn.shape[1],gn.shape[2],gn.shape[3]]):gn}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju=Object(Qe.b)({diag_:function(w){const g={x:Object(be.a)(w,"x","diag")};return b.a.runKernel(pe.T,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yc=Object(Qe.b)({dilation2d_:function(w,g,v,C,$=[1,1],M="NHWC"){const W=Object(be.a)(w,"x","dilation2d"),J=Object(be.a)(g,"filter","dilation2d");X.b(W.rank===3||W.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${W.rank}.`),X.b(J.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${J.rank}.`),X.b(M==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${M}`);let le=W,ve=!1;W.rank===3&&(le=Ze(W,[1,W.shape[0],W.shape[1],W.shape[2]]),ve=!0);const Xe={x:le,filter:J},Ve={strides:v,pad:C,dilations:$},kt=b.a.runKernel(pe.U,Xe,Ve);return ve?Ze(kt,[kt.shape[1],kt.shape[2],kt.shape[3]]):kt}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nc=Object(Qe.b)({equal_:function(w,g){let v=Object(be.a)(w,"a","equal","string_or_numeric"),C=Object(be.a)(g,"b","equal","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.ab,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iu=Object(Qe.b)({where_:function(w,g,v){const C=Object(be.a)(g,"a","where"),$=Object(be.a)(v,"b","where"),M=Object(be.a)(w,"condition","where","bool"),W=Zs(Zs(M.shape,C.shape),$.shape),J={condition:cr(M,W),t:cr(C,W),e:cr($,W)};return b.a.runKernel(pe.Fc,J)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dl=Object(Qe.b)({divNoNan_:function(w,g){let v=Object(be.a)(w,"a","div"),C=Object(be.a)(g,"b","div");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $=hr(v,C),M=ua($),W=Nc(C,M);return iu(W,M,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ml=Object(Qe.b)({dot_:function(w,g){const v=Object(be.a)(w,"t1","dot"),C=Object(be.a)(g,"t2","dot");X.b(!(v.rank!==1&&v.rank!==2||C.rank!==1&&C.rank!==2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${v.rank} and ${C.rank}.`);const $=v.rank===1?v.size:v.shape[1],M=C.rank===1?C.size:C.shape[0];if(X.b($===M,()=>`Error in dot: inner dimensions of inputs must match, but got ${$} and ${M}.`),v.rank===1&&C.rank===1){const W=Ze(v,[1,-1]),J=Ze(C,[-1,1]),le=wn(W,J);return Ze(le,[])}if(v.rank===1&&C.rank===2){const W=Ze(v,[1,-1]),J=Ze(C,[C.shape[0],C.shape[1]]),le=wn(W,J);return Ze(le,[le.size])}if(v.rank===2&&C.rank===1){const W=Ze(C,[-1,1]),J=wn(v,W);return Ze(J,[J.size])}{const W=Ze(C,[C.shape[0],C.shape[1]]);return wn(v,W)}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pl=Object(Qe.b)({einsum_:function(w,...g){const v=g.map(($,M)=>Object(be.a)($,`tensors${M}`,"einsum")),C={equation:w};return b.a.runKernel(pe.X,v,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zc=Object(Qe.b)({elu_:function(w){const g={x:Object(be.a)(w,"x","elu","float32")};return b.a.runKernel(pe.Y,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ec=Object(Qe.b)({erf_:function(w){let g=Object(be.a)(w,"x","erf");X.b(g.dtype==="int32"||g.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),g.dtype==="int32"&&(g=Un(g,"float32"));const v={x:g};return b.a.runKernel(pe.bb,v)}});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ec(w,g){for(let v=0;v<w.length;++v)if(w[w.length-v-1]!==g-1-v)return!1;return!0}function Qc(w,g,v){const C=w.length+g.length,$=[];let M=0,W=0;for(let J=0;J<C;J++)v.indexOf(J)===-1?$.push(w[M++]):$.push(g[W++]);return $}function Ll(w,g){const v=[],C=w.length;for(let $=0;$<C;$++)g.indexOf($)===-1&&v.push(w[$]);return[v,g.map($=>w[$])]}function Eu(w,g){return Qc(w,g.map(v=>1),g)}function Bl(w,g,v){X.b(Ec(g,v),()=>`${w} supports only inner-most axes for now. Got axes ${g} and rank-${v} input.`)}function zl(w,g){if(Ec(w,g))return null;const v=[];for(let C=0;C<g;++C)w.indexOf(C)===-1&&v.push(C);return w.forEach(C=>v.push(C)),v}function Jc(w){return w.map((g,v)=>[v,g]).sort((g,v)=>g[1]-v[1]).map(g=>g[0])}function Ru(w,g){const v=[];for(let C=g-w;C<g;++C)v.push(C);return v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uu=Object(Qe.b)({max_:function(w,g=null,v=!1){const C={x:Object(be.a)(w,"x","max")},$={reductionIndices:g,keepDims:v};return b.a.runKernel(pe.Mb,C,$)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tc=Object(Qe.b)({min_:function(w,g=null,v=!1){const C={x:Object(be.a)(w,"x","min")},$={axis:g,keepDims:v};return b.a.runKernel(pe.Ub,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gr=Object(Qe.b)({sum_:function(w,g=null,v=!1){let C=Object(be.a)(w,"x","sum");C.dtype==="bool"&&(C=Un(C,"int32"));const $={x:C},M={axis:g,keepDims:v};return b.a.runKernel(pe.ed,$,M)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rc(w,g,v=null){if(w.rank===0)return Ia(w);if(w.rank!==1&&v===null)return Rc(Ze(w,[-1]),g,v);if(w.rank===1||typeof v=="number"||Array.isArray(v)&&v.length===1){if(g===1)return gr(Ia(w),v);if(g===1/0)return uu(Ia(w),v);if(g===-1/0)return tc(Ia(w),v);if(g==="euclidean"||g===2)return Aa(gr(li(Ia(w),ar(2,"int32")),v));throw new Error(`Error in norm: invalid ord value: ${g}`)}if(Array.isArray(v)&&v.length===2){if(g===1)return uu(gr(Ia(w),v[0]),v[1]-1);if(g===1/0)return uu(gr(Ia(w),v[1]),v[0]);if(g===-1/0)return tc(gr(Ia(w),v[1]),v[0]);if(g==="fro"||g==="euclidean")return Aa(gr(Vr(w),v));throw new Error(`Error in norm: invalid ord value: ${g}`)}throw new Error(`Error in norm: invalid axis: ${v}`)}const Au=Object(Qe.b)({norm_:function(w,g="euclidean",v=null,C=!1){const $=Rc(w=Object(be.a)(w,"x","norm"),g,v);let M=$.shape;if(C){const W=Object(X.I)(v,w.shape);M=Eu($.shape,W)}return Ze($,M)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el=Object(Qe.b)({euclideanNorm_:function(w,g=null,v=!1){return Au(w,"euclidean",g,v)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ko=Object(Qe.b)({exp_:function(w){const g={x:Object(be.a)(w,"x","exp")};return b.a.runKernel(pe.cb,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Se=Object(Qe.b)({expandDims_:function(w,g=0){const v=Object(be.a)(w,"x","expandDims","string_or_numeric");X.b(g<=v.rank,()=>"Axis must be <= rank of the tensor");const C={input:v},$={dim:g};return b.a.runKernel(pe.db,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe=Object(Qe.b)({expm1_:function(w){const g={x:Object(be.a)(w,"x","expm1")};return b.a.runKernel(pe.eb,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z=Object(Qe.b)({tile_:function(w,g){const v=Object(be.a)(w,"x","tile","string_or_numeric");X.b(v.rank===g.length,()=>`Error in transpose: rank of input ${v.rank} must match length of reps ${g}.`);const C={x:v},$={reps:g};return b.a.runKernel(pe.hd,C,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fe=Object(Qe.b)({eye_:function(w,g,v,C="float32"){g==null&&(g=w);const $=Dn([w,g],C),M=w<=g?w:g;for(let J=0;J<M;++J)$.set(1,J,J);const W=Ze($.toTensor(),[w,g]);if(v==null)return W;if(v.length===1)return Z(Se(W,0),[v[0],1,1]);if(v.length===2)return Z(Se(Se(W,0),0),[v[0],v[1],1,1]);if(v.length===3)return Z(Se(Se(Se(W,0),0),0),[v[0],v[1],v[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${v.length}D.`)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H=Object(Qe.b)({floor_:function(w){const g={x:Object(be.a)(w,"x","floor","float32")};return b.a.runKernel(pe.ib,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ce=Object(Qe.b)({gather_:function(w,g,v=0,C=0){const $={x:Object(be.a)(w,"x","gather"),indices:Object(be.a)(g,"indices","gather","int32")},M={axis:v,batchDims:C};return b.a.runKernel(pe.pb,$,M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ce=Object(Qe.b)({greater_:function(w,g){let v=Object(be.a)(w,"a","greater","string_or_numeric"),C=Object(be.a)(g,"b","greater","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.qb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const De=Object(Qe.b)({greaterEqual_:function(w,g){let v=Object(be.a)(w,"a","greaterEqual","string_or_numeric"),C=Object(be.a)(g,"b","greaterEqual","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.rb,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fe=Object(Qe.b)({isFinite_:function(w){const g={x:Object(be.a)(w,"x","isFinite")};return b.a.runKernel(pe.vb,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ie=Object(Qe.b)({isInf_:function(w){const g={x:Object(be.a)(w,"x","isInf")};return b.a.runKernel(pe.wb,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Te=Object(Qe.b)({isNaN_:function(w){const g={x:Object(be.a)(w,"x","isNaN")};return b.a.runKernel(pe.xb,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ye=Object(Qe.b)({leakyRelu_:function(w,g=.2){const v={x:Object(be.a)(w,"x","leakyRelu")},C={alpha:g};return b.a.runKernel(pe.Ab,v,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Le=Object(Qe.b)({less_:function(w,g){let v=Object(be.a)(w,"a","less","string_or_numeric"),C=Object(be.a)(g,"b","less","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Bb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=Object(Qe.b)({lessEqual_:function(w,g){let v=Object(be.a)(w,"a","lessEqual","string_or_numeric"),C=Object(be.a)(g,"b","lessEqual","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Cb,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gt(w,g,v){if(v<=0)throw new Error("The number of values should be positive.");const C={start:w,stop:g,num:v};return b.a.runKernel(pe.Db,{},C)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lt=Object(Qe.b)({localResponseNormalization_:function(w,g=5,v=1,C=1,$=.5){const M=Object(be.a)(w,"x","localResponseNormalization");X.b(M.rank===4||M.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${M.rank}.`),X.b(X.v(g),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${g}.`);let W=M,J=!1;M.rank===3&&(J=!0,W=Ze(M,[1,M.shape[0],M.shape[1],M.shape[2]]));const le={x:W},ve={depthRadius:g,bias:v,alpha:C,beta:$},Xe=b.a.runKernel(pe.yb,le,ve);return J?Ze(Xe,[Xe.shape[1],Xe.shape[2],Xe.shape[3]]):Xe}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ft=Object(Qe.b)({log_:function(w){const g={x:Object(be.a)(w,"x","log","float32")};return b.a.runKernel(pe.Eb,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yt=Object(Qe.b)({log1p_:function(w){const g={x:Object(be.a)(w,"x","log1p")};return b.a.runKernel(pe.Fb,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $t=Object(Qe.b)({softplus_:function(w){const g={x:Object(be.a)(w,"x","softplus")};return b.a.runKernel(pe.Nc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bt=Object(Qe.b)({logSigmoid_:function(w){const g=Object(be.a)(w,"x","logSigmoid");return oo(C=>({value:Ar($t(Ar(C))),gradFunc:$=>Gn($,In(Ar(C)))}))(g)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G=Object(Qe.b)({logSoftmax_:function(w,g=-1){const v=Object(be.a)(w,"logits","logSoftmax");if(g===-1&&(g=v.rank-1),g!==v.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${v.rank} and axis was ${g}`);return oo(($,M)=>{const W=uu($,g,!0),J=Os($,W),le=Os(Un(J,"float32"),ft(gr(Ko(J),g,!0)));return M([le]),{value:le,gradFunc:(ve,Xe)=>{const[Ve]=Xe,kt=Ko(Ve);return Os(ve,Gn(gr(ve,g,!0),kt))}}})(v)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A=Object(Qe.b)({logSumExp_:function(w,g=null,v=!1){const C=Object(be.a)(w,"x","logSumExp"),$=Object(X.I)(g,C.shape),M=uu(C,$,!0),W=Os(C,M),J=Ko(W),le=gr(J,$),ve=ft(le),Xe=bs(Ze(M,ve.shape),ve);if(v){const Ve=Eu(Xe.shape,$);return Ze(Xe,Ve)}return Xe}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R=Object(Qe.b)({logicalAnd_:function(w,g){const v=Object(be.a)(w,"a","logicalAnd","bool"),C=Object(be.a)(g,"b","logicalAnd","bool");Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Hb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q=Object(Qe.b)({logicalNot_:function(w){const g={x:Object(be.a)(w,"x","logicalNot","bool")};return b.a.runKernel(pe.Ib,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j=Object(Qe.b)({logicalOr_:function(w,g){const v=Object(be.a)(w,"a","logicalOr","bool"),C=Object(be.a)(g,"b","logicalOr","bool");Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Jb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const te=Object(Qe.b)({logicalXor_:function(w,g){const v=Object(be.a)(w,"a","logicalXor","bool"),C=Object(be.a)(g,"b","logicalXor","bool");return Zs(v.shape,C.shape),R(j(w,g),q(R(w,g)))}}),ie=2147483648;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const he=Object(Qe.b)({searchSorted_:function(w,g,v="left"){const C=Object(be.a)(w,"sortedSequence","searchSorted"),$=Object(be.a)(g,"values","searchSorted"),M=C.shape[C.shape.length-1],W=$.shape[$.shape.length-1],J=Ze(C,[-1,M]),le=Ze($,[-1,W]);if(J.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(J.shape[0]!==le.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Object(X.O)(le.shape)>=ie)throw new Error("values tensor size must less than 2147483648");if(J.shape[1]>=ie)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${J.shape[1]}`);const ve={sortedSequence:J,values:le},Xe={side:v};return b.a.runKernel(pe.Ec,ve,Xe)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xe(w,g){return he(w,g,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _e=Object(Qe.b)({maxPool_:function(w,g,v,C,$){const M=Object(be.a)(w,"x","maxPool");let W=M,J=!1;M.rank===3&&(J=!0,W=Ze(M,[1,M.shape[0],M.shape[1],M.shape[2]])),X.b(W.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${W.rank}.`),X.b(_t(v,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${v} and dilations '1'`),Kt("maxPool",C,$);const le={x:W},ve={filterSize:g,strides:v,pad:C,dimRoundingMode:$},Xe=b.a.runKernel(pe.Nb,le,ve);return J?Ze(Xe,[Xe.shape[1],Xe.shape[2],Xe.shape[3]]):Xe}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ue=Object(Qe.b)({maxPool3d_:function(w,g=[1,1,1],v,C,$,M="NDHWC"){const W=Object(be.a)(w,"x","maxPool3d");let J=W,le=!1;W.rank===4&&(le=!0,J=Ze(W,[1,W.shape[0],W.shape[1],W.shape[2],W.shape[3]])),X.b(J.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${J.rank}.`),X.b(M==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${M}`),Kt("maxPool3d",C,$);const ve={x:J},Xe={filterSize:g,strides:v,pad:C,dimRoundingMode:$,dataFormat:M},Ve=b.a.runKernel(pe.Ob,ve,Xe);return le?Ze(Ve,[Ve.shape[1],Ve.shape[2],Ve.shape[3],Ve.shape[4]]):Ve}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nt=Object(Qe.b)({maxPoolWithArgmax_:function(w,g,v,C,$=!1){const M={x:Object(be.a)(w,"x","maxPoolWithArgmax")},W={filterSize:g,strides:v,pad:C,includeBatchInIndex:$},J=b.a.runKernel(pe.Rb,M,W);return{result:J[0],indexes:J[1]}}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const it=Object(Qe.b)({mean_:function(w,g=null,v=!1){const C={x:Object(be.a)(w,"x","mean")},$={axis:g,keepDims:v};return b.a.runKernel(pe.Tb,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function et(w,g="float32"){if(g==="complex64"){const C=et(w,"float32"),$=et(w,"float32");return Object(Ta.a)(C,$)}const v=Object(X.F)(Object(X.O)(w),g);return b.a.makeTensor(v,w,g)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dt(w,g="float32"){if(g==="complex64"){const C=dt(w,"float32"),$=et(w,"float32");return Object(Ta.a)(C,$)}const v=Object(X.D)(Object(X.O)(w),g);return b.a.makeTensor(v,w,g)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ut(w,g,{indexing:v="xy"}={}){if(v!=="xy"&&v!=="ij")throw new TypeError(`${v} is not a valid third argument to meshgrid`);if(w===void 0)return[];let C=Object(be.a)(w,"x","meshgrid",w instanceof xn.a?w.dtype:"float32");if(g===void 0)return[C];let $=Object(be.a)(g,"y","meshgrid",g instanceof xn.a?g.dtype:"float32");const M=Object(X.O)(C.shape),W=Object(X.O)($.shape);return v==="xy"?(C=Ze(C,[1,-1]),$=Ze($,[-1,1]),[wn(dt([W,1],C.dtype),C),wn($,dt([1,M],$.dtype))]):(C=Ze(C,[-1,1]),$=Ze($,[1,-1]),[wn(C,dt([1,W],C.dtype)),wn(dt([M,1],$.dtype),$)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Et=Object(Qe.b)({minimum_:function(w,g){let v=Object(be.a)(w,"a","minimum"),C=Object(be.a)(g,"b","minimum");[v,C]=Object(Mn.makeTypesMatch)(v,C),v.dtype==="bool"&&(v=Un(v,"int32"),C=Un(C,"int32")),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Vb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tt=Object(Qe.b)({mirrorPad_:function(w,g,v){X.b(v==="reflect"||v==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${v}.`);const C=Object(be.a)(w,"x","mirrorPad");if(C.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");X.b(g.length===C.rank,()=>`Padding doesn't match input. Must be ${C.rank}. Got ${g.length}.`);const $=v==="reflect"?1:0;for(let J=0;J<C.rank;J++)X.b(g[J].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),X.b(g[J][0]>=0&&g[J][0]<=C.shape[J]-$&&g[J][1]>=0&&g[J][1]<=C.shape[J]-$,()=>`Padding in dimension ${J} cannot be greater than or equal to ${C.shape[J]-$} or less than 0 for input of shape ${C.shape}`);const M={paddings:g,mode:v},W={x:C};return b.a.runKernel(pe.Wb,W,M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dt=Object(Qe.b)({mod_:function(w,g){let v=Object(be.a)(w,"a","mod"),C=Object(be.a)(g,"b","mod");[v,C]=Object(Mn.makeTypesMatch)(v,C);const $={a:v,b:C};return b.a.runKernel(pe.Xb,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wt=Object(Qe.b)({moments_:function(w,g=null,v=!1){w=Object(be.a)(w,"x","moments");const C=Object(X.I)(g,w.shape),$=it(w,C,v);let M=$.shape;v||(M=Eu($.shape,C));const W=Vr(Os(Un(w,"float32"),Ze($,M)));return{mean:$,variance:it(W,C,v)}}}),qt=Object(Qe.b)({multiRNNCell_:function(w,g,v,C){const $=Object(be.a)(g,"data","multiRNNCell"),M=Object(be.b)(v,"c","multiRNNCell"),W=Object(be.b)(C,"h","multiRNNCell");let J=$;const le=[];for(let Ve=0;Ve<w.length;Ve++){const kt=w[Ve](J,M[Ve],W[Ve]);le.push(kt[0]),le.push(kt[1]),J=kt[1]}const ve=[],Xe=[];for(let Ve=0;Ve<le.length;Ve+=2)ve.push(le[Ve]),Xe.push(le[Ve+1]);return[ve,Xe]}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cn=Object(Qe.b)({multinomial_:function(w,g,v,C=!1){const $=Object(be.a)(w,"logits","multinomial"),M=$.size,W=$.rank;if(M<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${M}.`);if(W>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${W}`);v=v||Math.random();const J={logits:W===1?Ze($,[1,-1]):$},le={numSamples:g,seed:v,normalized:C},ve=b.a.runKernel(pe.Yb,J,le);return W===1?Ze(ve,[ve.size]):ve}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rn=Object(Qe.b)({notEqual_:function(w,g){let v=Object(be.a)(w,"a","notEqual","string_or_numeric"),C=Object(be.a)(g,"b","notEqual","string_or_numeric");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.ec,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yn=Object(Qe.b)({onesLike_:function(w){const g={x:Object(be.a)(w,"x","onesLike")};return b.a.runKernel(pe.gc,g)}}),Fn=Object(Qe.b)({outerProduct_:function(w,g){const v=Object(be.a)(w,"v1","outerProduct"),C=Object(be.a)(g,"v2","outerProduct");X.b(v.rank===1&&C.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${v.rank} and ${C.rank}.`);const $=Ze(v,[-1,1]),M=Ze(C,[1,-1]);return wn($,M)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _n=Object(Qe.b)({pad_:function(w,g,v=0){const C=Object(be.a)(w,"x","pad");if(C.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const $={paddings:g,constantValue:v},M={x:C};return b.a.runKernel(pe.ic,M,$)}}),ss=Object(Qe.b)({pad1d_:function(w,g,v=0){return Object(X.b)(g.length===2,()=>"Invalid number of paddings. Must be length of 2."),_n(w,[g],v)}}),zn=Object(Qe.b)({pad2d_:function(w,g,v=0){return Object(X.b)(g.length===2&&g[0].length===2&&g[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_n(w,g,v)}}),Kn=Object(Qe.b)({pad3d_:function(w,g,v=0){return Object(X.b)(g.length===3&&g[0].length===2&&g[1].length===2&&g[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_n(w,g,v)}}),us=Object(Qe.b)({pad4d_:function(w,g,v=0){return Object(X.b)(g.length===4&&g[0].length===2&&g[1].length===2&&g[2].length===2&&g[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_n(w,g,v)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ps=Object(Qe.b)({spaceToBatchND_:function(w,g,v){const C=Object(be.a)(w,"x","spaceToBatchND");X.b(C.rank>=1+g.length,()=>`input rank ${C.rank} should be > than [blockShape] ${g.length}`),X.b(v.length===g.length,()=>`paddings.shape[0] ${v.length} must be equal to [blockShape] ${g.length}`),X.b(C.shape.reduce((W,J,le)=>le>0&&le<=g.length?W&&(J+v[le-1][0]+v[le-1][1])%g[le-1]==0:W,!0),()=>`input spatial dimensions ${C.shape.slice(1)} with paddings ${v.toString()} must be divisible by blockShapes ${g.toString()}`);const $={x:C},M={blockShape:g,paddings:v};return b.a.runKernel(pe.Oc,$,M)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const es=Object(Qe.b)({pool_:function(w,g,v,C,$,M,W){$==null&&($=[1,1]),M==null&&(M=1),C===0&&(C="valid");const J=Object(be.a)(w,"x","maxPool");let le=J,ve=!1;J.rank===3&&(ve=!0,le=Ze(J,[1,J.shape[0],J.shape[1],J.shape[2]])),X.b(_t(M,$),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${M} and dilations '${$}'`);const Xe=Pe(le.shape,g,M,$,C),Ve=[Xe.dilationHeight,Xe.dilationWidth];let kt;kt=C==="same"?function(ns,is){const cs=ns.map((Ts,os)=>Ts+(Ts-1)*(is[os]-1)).map(Ts=>Ts-1),Bs=cs.map(Ts=>Math.floor(Ts/2)),zs=cs.map((Ts,os)=>Ts-Bs[os]);return cs.map((Ts,os)=>[Bs[os],zs[os]])}([Xe.filterHeight,Xe.filterWidth],Ve):[[0,0],[0,0]];const Zt=Ve[0]===1&&Ve[1]===1,[gn,En]=function(ns,is,cs){const Bs=cs.map(Tr=>Tr[0]),zs=cs.map(Tr=>Tr[1]),Ts=ns.concat(Bs,zs),os=is.map((Tr,ra)=>(Tr-Ts[ra]%Tr)%Tr),lr=zs.map((Tr,ra)=>Tr+os[ra]),Dr=is.map((Tr,ra)=>[Bs[ra],lr[ra]]),Br=is.map((Tr,ra)=>[0,os[ra]]);return[Dr,Br]}([Xe.inHeight,Xe.inWidth],Ve,kt),qn=Zt?C:"valid",Is=Zt?le:ps(le,Ve,gn),Sn=(v==="avg"?()=>Lt(Is,g,M,qn,W):()=>_e(Is,g,M,qn,W))(),Tn=Zt?Sn:Ss(Sn,Ve,En);return ve?Ze(Tn,[Tn.shape[1],Tn.shape[2],Tn.shape[3]]):Tn}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ks=Object(Qe.b)({prelu_:function(w,g){const v={x:Object(be.a)(w,"x","prelu"),alpha:Object(be.a)(g,"alpha","prelu")};return b.a.runKernel(pe.lc,v)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ks=Object(Qe.b)({prod_:function(w,g=null,v=!1){let C=Object(be.a)(w,"x","prod");C.dtype==="bool"&&(C=Un(C,"int32"));const $={x:C},M={axis:g,keepDims:v};return b.a.runKernel(pe.mc,$,M)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sa=Object(Qe.b)({raggedTensorToTensor_:function(w,g,v,C,$){const M=Object(be.a)(w,"shape","raggedTensorToTensor","int32"),W=Object(be.a)(g,"values","raggedTensorToTensor"),J={shape:M,values:W,defaultValue:Object(be.a)(v,"defaultValue","raggedTensorToTensor",W.dtype),rowPartitionTensors:C.map((ve,Xe)=>Object(be.a)(ve,`tensors${Xe}`,"raggedTensorToTensor","int32"))},le={rowPartitionTypes:$};return b.a.runKernel(pe.nc,J,le)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const or=Object(Qe.b)({rand_:function(w,g,v){const C=Object(X.O)(w);let $=null;if(v==null||v==="float32")$=new Float32Array(C);else if(v==="int32")$=new Int32Array(C);else{if(v!=="bool")throw new Error(`Unknown data type ${v}`);$=new Uint8Array(C)}for(let M=0;M<C;M++)$[M]=g();return b.a.makeTensor($,w,v)}});var _r=t(49);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yr{constructor(g,v,C,$,M){this.mean=g,this.stdDev=v,this.dtype=C,this.nextVal=NaN,this.truncated=$,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const W=M||Math.random();this.random=_r.alea(W.toString())}nextValue(){if(!isNaN(this.nextVal)){const $=this.nextVal;return this.nextVal=NaN,$}let g,v,C=!1;for(;!C;){let $,M,W;do $=2*this.random()-1,M=2*this.random()-1,W=$*$+M*M;while(W>=1||W===0);const J=Math.sqrt(-2*Math.log(W)/W);g=this.mean+this.stdDev*$*J,v=this.mean+this.stdDev*M*J,this.truncated&&!this.isValidTruncated(g)||(C=!0)}return this.truncated&&!this.isValidTruncated(v)||(this.nextVal=this.convertValue(v)),this.convertValue(g)}convertValue(g){return this.dtype==null||this.dtype==="float32"?g:Math.round(g)}isValidTruncated(g){return g<=this.upper&&g>=this.lower}}class Ga{constructor(g,v,C,$){this.alpha=g,this.beta=1/v,this.dtype=C;const M=$||Math.random();this.randu=_r.alea(M.toString()),this.randn=new yr(0,1,C,!1,this.randu()),this.d=g<1?g+2/3:g-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let g,v,C,$,M,W;for(;;){do $=this.randn.nextValue(),W=1+this.c*$;while(W<=0);if(W*=W*W,g=$*$,v=1-.331*g*g,C=.5*g+this.d*(1-W+Math.log(W)),M=this.randu(),M<v||Math.log(M)<C)break}return W=1/this.beta*this.d*W,this.alpha<1&&(W*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(W)}convertValue(g){return this.dtype==="float32"?g:Math.round(g)}}class ma{constructor(g=0,v=1,C,$){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=g,this.range=v-g,this.dtype=C,$==null&&($=Math.random()),typeof $=="number"&&($=$.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${g} - ${v} <= 1 and dtype is not float`);this.random=_r.alea($)}convertValue(g){return this.canReturnFloat()?g:Math.round(g)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ha=Object(Qe.b)({randomGamma_:function(w,g,v=1,C="float32",$){if(v==null&&(v=1),C==null&&(C="float32"),C!=="float32"&&C!=="int32")throw new Error(`Unsupported data type ${C}`);const M=new Ga(g,v,C,$),W=Dn(w,C);for(let J=0;J<W.values.length;J++)W.values[J]=M.nextValue();return W.toTensor()}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vo=Object(Qe.b)({randomNormal_:function(w,g=0,v=1,C,$){if(C!=null&&C==="bool")throw new Error(`Unsupported data type ${C}`);const M=new yr(g,v,C,!1,$),W=Dn(w,C);for(let J=0;J<W.values.length;J++)W.values[J]=M.nextValue();return W.toTensor()}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pi=Object(Qe.b)({randomStandardNormal_:function(w,g,v){if(g!=null&&g==="bool")throw new Error(`Unsupported data type ${g}`);return vo(w,0,1,g,v)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fi=Object(Qe.b)({randomUniform_:function(w,g=0,v=1,C="float32",$){const M=Dn(w,C),W=new ma(g,v,null,$);for(let J=0;J<M.values.length;J++)M.values[J]=W.nextValue();return M.toTensor()}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ac(w,g,v=1,C="float32"){if(v===0)throw new Error("Cannot have a step of zero");const $={start:w,stop:g,step:v,dtype:C};return b.a.runKernel(pe.oc,{},$)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tl=Object(Qe.b)({reciprocal_:function(w){const g={x:Object(be.a)(w,"x","reciprocal")};return b.a.runKernel(pe.rc,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nl=Object(Qe.b)({relu_:function(w){const g={x:Object(be.a)(w,"x","relu")};return b.a.runKernel(pe.sc,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pd=Object(Qe.b)({relu6_:function(w){const g={x:Object(be.a)(w,"x","relu6")};return b.a.runKernel(pe.tc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mi=Object(Qe.b)({reverse_:function(w,g){const v={x:Object(be.a)(w,"x","reverse")},C={dims:g};return b.a.runKernel(pe.zc,v,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bb=Object(Qe.b)({reverse1d_:function(w){const g=Object(be.a)(w,"x","reverse");return X.b(g.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${g.rank}.`),mi(g,0)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb=Object(Qe.b)({reverse2d_:function(w,g){const v=Object(be.a)(w,"x","reverse");return X.b(v.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${v.rank}.`),mi(v,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wb=Object(Qe.b)({reverse3d_:function(w,g){const v=Object(be.a)(w,"x","reverse");return X.b(v.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${v.rank}.`),mi(v,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb=Object(Qe.b)({reverse4d_:function(w,g){const v=Object(be.a)(w,"x","reverse");return X.b(v.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${v.rank}.`),mi(v,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pf=Object(Qe.b)({round_:function(w){const g={x:Object(be.a)(w,"x","round")};return b.a.runKernel(pe.Bc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ub=Object(Qe.b)({rsqrt_:function(w){const g={x:Object(be.a)(w,"x","rsqrt","float32")};return b.a.runKernel(pe.Cc,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jb=Object(Qe.b)({selu_:function(w){const g={x:Object(be.a)(w,"x","selu")};return b.a.runKernel(pe.Gc,g)}}),Gb=Object(Qe.b)({separableConv2d_:function(w,g,v,C,$,M=[1,1],W="NHWC"){const J=Object(be.a)(w,"x","separableConv2d"),le=Object(be.a)(g,"depthwiseFilter","separableConv2d"),ve=Object(be.a)(v,"pointwiseFilter","separableConv2d");let Xe=J,Ve=!1;if(J.rank===3&&(Ve=!0,Xe=Ze(J,[1,J.shape[0],J.shape[1],J.shape[2]])),W==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");X.b(Xe.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${Xe.rank}.`),X.b(le.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${le.rank}.`),X.b(ve.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${le.rank}.`),X.b(ve.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${ve.shape[0]}.`),X.b(ve.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${ve.shape[1]}.`);const kt=le.shape[2],Zt=le.shape[3];X.b(ve.shape[2]===kt*Zt,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${kt*Zt}, but got ${ve.shape[2]}.`);const gn=Tc(Xe,le,C,$,W,M),En=wo(gn,ve,1,"valid",W);return Ve?Ze(En,[En.shape[1],En.shape[2],En.shape[3]]):En}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hb=async function(w,g){const v=Object(be.a)(w,"x","setdiff1d"),C=Object(be.a)(g,"y","setdiff1d");X.b(v.dtype===C.dtype,()=>`x and y should have the same dtype, but got x (${v.dtype}) and y (${C.dtype}).`),X.b(v.rank===1,()=>`x should be 1D tensor, but got x (${v.shape}).`),X.b(C.rank===1,()=>`y should be 1D tensor, but got y (${C.shape}).`);const $=await v.data(),M=await C.data(),W=new Set(M);let J=0;for(let Xe=0;Xe<$.length;Xe++)W.has($[Xe])||J++;const le=new xn.b([J],v.dtype),ve=new xn.b([J],"int32");for(let Xe=0,Ve=0;Xe<$.length;Xe++)W.has($[Xe])||(le.values[Ve]=$[Xe],ve.values[Ve]=Xe,Ve++);return[le.toTensor(),ve.toTensor()]};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb=Object(Qe.b)({sign_:function(w){const g={x:Object(be.a)(w,"x","sign")};return b.a.runKernel(pe.Ic,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb=Object(Qe.b)({sin_:function(w){const g={x:Object(be.a)(w,"x","sin","float32")};return b.a.runKernel(pe.Jc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xb=Object(Qe.b)({sinh_:function(w){const g={x:Object(be.a)(w,"x","sinh")};return b.a.runKernel(pe.Kc,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yb=Object(Qe.b)({slice1d_:function(w,g,v){const C=Object(be.a)(w,"x","slice1d");return X.b(C.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${C.rank} tensor`),Xt(C,[g],[v])}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zb=Object(Qe.b)({slice2d_:function(w,g,v){const C=Object(be.a)(w,"x","slice2d");return X.b(C.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${C.rank} tensor`),Xt(C,g,v)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qb=Object(Qe.b)({slice3d_:function(w,g,v){const C=Object(be.a)(w,"x","slice3d");return X.b(C.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${C.rank} tensor`),Xt(C,g,v)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jb=Object(Qe.b)({slice4d_:function(w,g,v){const C=Object(be.a)(w,"x","slice4d");return X.b(C.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${C.rank} tensor`),Xt(C,g,v)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ex=Object(Qe.b)({softmax_:function(w,g=-1){const v=Object(be.a)(w,"logits","softmax","float32");if(g===-1&&(g=v.rank-1),g!==v.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${v.rank} and dim was ${g}`);const C={logits:v},$={dim:g};return b.a.runKernel(pe.Mc,C,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oh=Object(Qe.b)({fft_:function(w){Object(X.b)(w.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${w.dtype}.`);const g={input:w};return b.a.runKernel(pe.fb,g)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wl=Object(Qe.b)({ifft_:function(w){Object(X.b)(w.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${w.dtype}.`);const g={input:w};return b.a.runKernel(pe.sb,g)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lf=Object(Qe.b)({irfft_:function(w){const g=w.shape[w.shape.length-1],v=w.size/g;let C;if(g<=2){const $=Ze(w,[v,g]);C=Wl($)}else{const $=[v,2*(g-1)],M=Ze(Na(w),[v,g]),W=Ze(mo(w),[v,g]),J=mi(Xt(M,[0,1],[v,g-2]),1),le=Gn(mi(Xt(W,[0,1],[v,g-2]),1),ar(-1)),ve=un([M,J],1),Xe=un([W,le],1),Ve=Ze(Object(Ta.a)(ve,Xe),[$[0],$[1]]);C=Wl(Ve)}if(C=Na(C),w.rank===3&&w.shape[0]!==0){const $=C,M=w.shape[0];C=Ze(C,[M,C.shape[0]/M,C.shape[1]]),$.dispose()}return C}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vl=Object(Qe.b)({split_:function(w,g,v=0){const C={x:Object(be.a)(w,"x","split")},$={numOrSizeSplits:g,axis:v};return b.a.runKernel(pe.Uc,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fh=Object(Qe.b)({rfft_:function(w,g){Object(X.b)(w.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${w.dtype}`);let v=w.shape[w.shape.length-1];const C=w.size/v;let $;if(g!=null&&g<v){const gn=w.shape.map(qn=>0),En=w.shape.map(qn=>qn);En[w.shape.length-1]=g,$=Xt(w,gn,En),v=g}else if(g!=null&&g>v){const gn=w.shape.map(En=>En);gn[w.shape.length-1]=g-v,$=un([w,et(gn)],w.shape.length-1),v=g}else $=w;const M=ua($),W=Ze(Object(Ta.a)($,M),[C,v]),J=Oh(W),le=Math.floor(v/2)+1,ve=Na(J),Xe=mo(J),Ve=Vl(ve,[le,v-le],ve.shape.length-1),kt=Vl(Xe,[le,v-le],Xe.shape.length-1),Zt=$.shape.slice();return Zt[$.shape.length-1]=le,Ze(Object(Ta.a)(Ve[0],kt[0]),Zt)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bf=Object(Qe.b)({squaredDifference_:function(w,g){let v=Object(be.a)(w,"a","squaredDifference"),C=Object(be.a)(g,"b","squaredDifference");[v,C]=Object(Mn.makeTypesMatch)(v,C),Zs(v.shape,C.shape);const $={a:v,b:C};return b.a.runKernel(pe.Xc,$,{})}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dh=Object(Qe.b)({squeeze_:function(w,g){const v=Object(be.a)(w,"x","squeeze","string_or_numeric");return Ze(v,Object(X.Q)(v.shape,g).newShape)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul=Object(Qe.b)({stack_:function(w,g=0){const v=Object(be.b)(w,"tensors","stack","string_or_numeric");X.b(v.length>=1,()=>"Pass at least one tensor to tf.stack"),v.length>0&&X.b(g<=v[0].rank,()=>"Axis must be <= rank of the tensor");const C=v,$={axis:g};return b.a.runKernel(pe.hc,C,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zf=Object(Qe.b)({step_:function(w,g=0){const v={x:Object(be.a)(w,"x","step")},C={alpha:g};return b.a.runKernel(pe.Yc,v,C)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tx=Object(Qe.b)({stridedSlice_:function(w,g,v,C,$=0,M=0,W=0,J=0,le=0){const ve={x:Object(be.a)(w,"x","stridedSlice","string_or_numeric")},Xe={begin:g,end:v,strides:C,beginMask:$,endMask:M,ellipsisMask:W,newAxisMask:J,shrinkAxisMask:le};return b.a.runKernel(pe.Zc,ve,Xe)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx=Object(Qe.b)({tan_:function(w){const g={x:Object(be.a)(w,"x","tan","float32")};return b.a.runKernel(pe.fd,g)}});var Mh=t(32);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vi(w,g){Object(X.d)(w);const v=Object(be.c)(w,g);if(v.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(Ra.a)(w,null,v,g)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jl(w,g,v){if(Object(X.d)(w),g!=null&&g.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const C=Object(be.c)(w,v);if(C.length!==2&&C.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(C.length===1&&g==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(Ra.a)(w,g,C,v)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(w,g,v){if(Object(X.d)(w),g!=null&&g.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const C=Object(be.c)(w,v);if(C.length!==4&&C.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(C.length===1&&g==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(Ra.a)(w,g,C,v)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rx(w,g,v){if(Object(X.d)(w),g!=null&&g.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const C=Object(be.c)(w,v);if(C.length!==5&&C.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(C.length===1&&g==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(Ra.a)(w,g,C,v)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(w,g,v){if(Object(X.d)(w),g!=null&&g.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const C=Object(be.c)(w,v);if(C.length!==6&&C.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(C.length===1&&g==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return g=g||C,Object(Ra.a)(w,g,C,v)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ox=Object(Qe.b)({topk_:function(w,g=1,v=!0){const C=Object(be.a)(w,"x","topk");if(C.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const $=C.shape[C.shape.length-1];if(g<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${g}`);if(g>$)throw new Error(`'k' passed to topk() must be <= the last dimension (${$}) but got ${g}`);const M={x:C},W={k:g,sorted:v},[J,le]=b.a.runKernel(pe.id,M,W);return{values:J,indices:le}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ix=Object(Qe.b)({truncatedNormal_:function(w,g=0,v=1,C,$){if(C!=null&&C==="bool")throw new Error("Unsupported data type $ { dtype }");const M=new yr(g,v,C,!0,$),W=Dn(w,C);for(let J=0;J<W.values.length;J++)W.values[J]=M.nextValue();return W.toTensor()}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ux=Object(Qe.b)({unique_:function(w,g=0){const v=Object(be.a)(w,"x","unique","string_or_numeric");Object(X.b)(v.rank>0,()=>"The input tensor must be at least 1D");const C={x:v},$={axis:g},[M,W]=b.a.runKernel(pe.ld,C,$);return{values:M,indices:W}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cx=Object(Qe.b)({unsortedSegmentSum_:function(w,g,v){const C=Object(be.a)(w,"x","unsortedSegmentSum"),$=Object(be.a)(g,"segmentIds","unsortedSegmentSum","int32");Object(X.b)(Object(X.v)(v),()=>"numSegments must be of dtype int");const M={x:C,segmentIds:$},W={numSegments:v};return b.a.runKernel(pe.nd,M,W)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ph=Object(Qe.b)({unstack_:function(w,g=0){const v=Object(be.a)(w,"x","unstack","string_or_numeric");X.b(g>=-v.shape.length&&g<v.shape.length,()=>`Axis = ${g} is not in [-${v.shape.length}, ${v.shape.length})`);const C={value:v},$={axis:g};return b.a.runKernel(pe.md,C,$)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wf(w,g){return he(w,g,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lx(w,g=!0,v,C){return b.a.makeVariable(w,g,v,C)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lh(w,g){const v=[];for(let M=0;M<g.length;M++)g[M]&&v.push(M);const C=Dn(w,"int32"),$=Dn([v.length,w.length],"int32");for(let M=0;M<v.length;M++){const W=C.indexToLoc(v[M]),J=M*w.length;$.values.set(W,J)}return $.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bh=async function(w){const g=Object(be.a)(w,"condition","whereAsync","bool"),v=await g.data(),C=Lh(g.shape,v);return w!==g&&g.dispose(),C};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dx=async function(w,g,v){const C=Object(be.a)(w,"tensor","boolMask"),$=Object(be.a)(g,"mask","boolMask","bool"),M=v==null?0:v,W=$.rank,J=C.shape;X.b(W>0,()=>"mask cannot be scalar"),X.e(J.slice(M,M+W),$.shape,"mask's shape must match the first K dimensions of tensor's shape,");let le=1;for(let En=M;En<M+W;En++)le*=J[En];const ve=J.slice(0,M).concat([le],J.slice(M+W)),Xe=Ze(C,ve),Ve=Ze($,[-1]),kt=await Bh(Ve),Zt=Dh(kt,[1]),gn=ce(Xe,Zt,M);return w!==C&&C.dispose(),g!==$&&$.dispose(),Zt.dispose(),Xe.dispose(),Ve.dispose(),kt.dispose(),gn};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vf=Object(Qe.b)({movingAverage_:function(w,g,v,C,$=!0){const M=Object(be.a)(w,"v","movingAverage"),W=Object(be.a)(g,"x","movingAverage"),J=Object(be.a)(v,"decay","movingAverage");Object(Mn.assertTypesMatch)(M,W),X.b(X.a(M.shape,W.shape),()=>"Shape mismatch in v and x");const le=ar(1),ve=Os(le,J);let Xe=Gn(Os(W,M),ve);if($){X.b(C!=null,()=>"When using zeroDebias: true, step is required.");const Ve=Object(be.a)(C,"step","movingAverage");Xe=hr(Xe,Os(le,li(J,Ve)))}return bs(M,Xe)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hx=Object(Qe.b)({scatterND_:function(w,g,v){const C=Object(be.a)(w,"indices","scatterND","int32"),$=Object(be.a)(g,"updates","scatterND");Vn($,C,v);const M={indices:C,updates:$},W={shape:v};return b.a.runKernel(pe.Dc,M,W)}}),px=Object(Qe.b)({sparseToDense_:function(w,g,v,C=0){const $=Object(be.a)(w,"sparseIndices","sparseToDense","int32"),M=Object(be.a)(g,"sparseValues","sparseToDense","string_or_numeric"),W=Object(be.a)(C,"defaultValue","sparseToDense",M.dtype);(function(ve,Xe,Ve,kt){if(ve.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${ve.dtype}.`);if(ve.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${ve.shape}.`);const Zt=ve.rank>0?ve.shape[0]:1,gn=ve.rank>1?ve.shape[1]:1;if(Ve.length!==gn)throw new Error(`outputShape has incorrect number of elements:, ${Ve.length}, should be: ${gn}.`);const En=Xe.size;if(Xe.rank!==0&&(Xe.rank!==1||En!==Zt))throw new Error(`sparseValues has incorrect shape ${Xe.shape}, should be [] or [${Zt}]`);if(Xe.dtype!==kt.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")})($,M,v,W);const J={sparseIndices:$,sparseValues:M,defaultValue:W},le={outputShape:v};return b.a.runKernel(pe.Tc,J,le)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fx=Object(Qe.b)({gatherND_:function(w,g){const v=Object(be.a)(g,"indices","gatherND","int32"),C={params:Object(be.a)(w,"x","gatherND","string_or_numeric"),indices:v};return b.a.runKernel(pe.ob,C)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mx=Object(Qe.b)({dropout_:function(w,g,v,C){const $=Object(be.a)(w,"x","dropout");if(X.b($.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${$.dtype} tensor instead.`),X.b(g>=0&&g<1,()=>`rate must be a float in the range [0, 1), but got ${g}.`),g===0)return w instanceof xn.a?$.clone():$;const M=function(le,ve){if(ve==null)return le.shape.slice();if(X.a(le.shape,ve))return ve;if(le.shape.length===ve.length){const Xe=[];for(let Ve=0;Ve<le.shape.length;Ve++)ve[Ve]==null&&le.shape[Ve]!=null?Xe.push(le.shape[Ve]):Xe.push(ve[Ve]);return Xe}return ve}($,v),W=1-g,J=hr(H(bs(fi(M,0,1,"float32",C),W)),W);return Gn($,J)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uf(w){return Math.floor(Math.pow(2,Math.ceil(Math.log(w)/Math.log(2))))}function zh(w,g,v){const C=1-w%2,$=new Float32Array(w);for(let M=0;M<w;++M){const W=2*Math.PI*M/(w+C-1);$[M]=g-v*Math.cos(W)}return Vi($,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gx=async function(w,g,v=1){const C=Object(be.a)(w,"predictions","inTopK"),$=Object(be.a)(g,"targets","inTopK");Object(X.b)(C.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${C.rank}`),Object(X.b)(C.rank-1===$.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${C.rank} and targets rank ${$.rank}`),Object(X.e)(C.shape.slice(0,C.shape.length-1),$.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const M=C.shape[C.shape.length-1];Object(X.b)(v>0&&v<=M,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${M}), but got ${v}`);const W=await C.data(),J=await $.data(),[le,ve]=[W.length/M,M],Xe=Object(X.o)("bool",le);for(let Ve=0;Ve<le;Ve++){const kt=Ve*ve,Zt=W.subarray(kt,kt+ve),gn=[];for(let En=0;En<Zt.length;En++)gn.push({value:Zt[En],index:En});gn.sort((En,qn)=>qn.value-En.value),Xe[Ve]=0;for(let En=0;En<v;En++)if(gn[En].index===J[Ve]){Xe[Ve]=1;break}}return w!==C&&C.dispose(),g!==$&&$.dispose(),Object(Mh.a)(Xe,$.shape,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bx=Object(Qe.b)({conv2DBackpropFilter_:function(w,g,v,C,$,M="NHWC",W){let J=w;w.rank===3&&(J=Ze(w,[1,w.shape[0],w.shape[1],w.shape[2]]));let le=g;le.rank===3&&(le=Ze(g,[1,g.shape[0],g.shape[1],g.shape[2]])),X.b(J.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${J.shape}.`),X.b(le.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${le.shape}.`),X.b(v.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${v}.`);const ve=M==="NHWC"?J.shape[3]:J.shape[1],Xe=M==="NHWC"?le.shape[3]:le.shape[1];X.b(ve===v[2],()=>`Error in conv2dDerFilter: depth of input ${ve}) must match input depth in filter (${v[2]}.`),X.b(Xe===v[3],()=>`Error in conv2dDerFilter: depth of dy (${Xe}) must match output depth for filter (${v[3]}).`),Kt("conv2dDerFilter",$,W);const Ve={x:J,dy:le},kt={strides:C,pad:$,dataFormat:M,dimRoundingMode:W,filterShape:v};return b.a.runKernel(pe.E,Ve,kt)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ld(w,g,v){if(v==null||v==="linear")return w;if(v==="relu")return Gn(w,zf(g));throw new Error(`Cannot compute gradient for fused activation ${v}.`)}function Bd(w,g){let v=g;const C=so(w.shape,g.shape);return C.length>0&&(v=gr(v,C)),Ze(v,w.shape)}function zd(w,g,v,C){if(g==="linear")return w;if(g==="relu")return nl(w);if(g==="elu")return Zc(w);if(g==="relu6")return Pd(w);if(g==="prelu")return ks(w,v);if(g==="leakyrelu")return Ye(w,C);if(g==="sigmoid")return In(w);throw new Error(`Unknown fused activation ${g}.`)}const Oc=(w,g)=>!(w>0)||g==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xx=Object(Qe.b)({fusedConv2d_:function({x:w,filter:g,strides:v,pad:C,dataFormat:$="NHWC",dilations:M=[1,1],dimRoundingMode:W,bias:J,activation:le="linear",preluActivationWeights:ve,leakyreluAlpha:Xe}){if(le=le||"linear",Oc(b.a.state.gradientDepth,le)===!1){X.b($==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${$} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let cs=wo(w,g,v,C,$,M,W);return J!=null&&(cs=bs(cs,J)),zd(cs,le,ve,Xe)}const Ve=Object(be.a)(w,"x","conv2d","float32"),kt=Object(be.a)(g,"filter","conv2d","float32");let Zt=Ve,gn=!1;Ve.rank===3&&(gn=!0,Zt=Ze(Ve,[1,Ve.shape[0],Ve.shape[1],Ve.shape[2]])),X.b(Zt.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Zt.rank}.`),X.b(kt.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${kt.rank}.`),Kt("fused conv2d",C,W);const En=$==="NHWC"?Zt.shape[3]:Zt.shape[1];X.b(kt.shape[2]===En,()=>`Error in conv2d: depth of input (${En}) must match input depth for filter ${kt.shape[2]}.`),X.b(_t(v,M),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${v} and dilations '${M}'`);const qn=He(Zt.shape,kt.shape,v,M,C,W);let Is,Sn;if(J!=null&&(Is=Object(be.a)(J,"bias","fused conv2d"),[Is]=Object(Mn.makeTypesMatch)(Is,Ve),$==="NHWC"?Zs(qn.outShape,Is.shape):(X.b(Is.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Is.shape.length}.`),X.b(Is.shape.length===0||Is.shape[0]===qn.outChannels||Is.shape[0]===1,()=>`Error in fused conv2d: bias shape (${Is.shape}) is not compatible with the number of output channels (${qn.outChannels})`))),ve!=null){const cs=ve.shape;if(X.b(cs.length<=1||cs.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${cs.length}.`),cs.length===1)X.b(cs[0]===1||cs[0]===qn.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${cs}) is not compatible with the number of output channels (${qn.outChannels}).`);else if(cs.length===3)try{Zs(cs,qn.outShape)}catch{const zs=`Error in fused conv2d: PReLU activation weights (${cs}) is not compatible with the output shape of the conv2d (${qn.outShape}).`;throw Error(zs)}Sn=Object(be.a)(ve,"prelu weights","fused conv2d")}const Tn=(cs,Bs)=>{X.b($==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${$} but only NHWC is currently supported.`);const[zs,Ts,os,lr]=Bs,Dr=Ld(cs,os,le);X.b(St(M),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${M}'`);const Br=[qo(Ts.shape,Dr,zs,v,C),bx(Ts,Dr,zs.shape,v,C)];if(lr!=null){const Tr=Bd(lr,Dr);Br.push(Tr)}return Br},ns={x:Zt,filter:kt,bias:Is,preluActivationWeights:Sn},is={strides:v,pad:C,dataFormat:$,dilations:M,dimRoundingMode:W,activation:le,leakyreluAlpha:Xe};return J==null?oo((Bs,zs,Ts)=>{let os=b.a.runKernel(pe.mb,ns,is);return Ts([zs,Bs,os]),gn&&(os=Ze(os,[os.shape[1],os.shape[2],os.shape[3]])),{value:os,gradFunc:Tn}})(Zt,kt):oo((Bs,zs,Ts,os)=>{let lr=b.a.runKernel(pe.mb,ns,is);return os([zs,Bs,lr,Ts]),gn&&(lr=Ze(lr,[lr.shape[1],lr.shape[2],lr.shape[3]])),{value:lr,gradFunc:Tn}})(Zt,kt,Is)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yx=Object(Qe.b)({depthwiseConv2dNativeBackpropFilter_:function(w,g,v,C,$,M=[1,1],W){let J=w;w.rank===3&&(J=Ze(w,[1,w.shape[0],w.shape[1],w.shape[2]]));let le=g;le.rank===3&&(le=Ze(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const ve={x:J,dy:le},Xe={strides:C,pad:$,dimRoundingMode:W,dilations:M,filterShape:v};return b.a.runKernel(pe.R,ve,Xe)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wx=Object(Qe.b)({depthwiseConv2dNativeBackpropInput_:function(w,g,v,C,$,M=[1,1],W){let J=g,le=!1;g.rank===3&&(le=!0,J=Ze(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const ve={dy:J,filter:v},Xe={strides:C,pad:$,dimRoundingMode:W,dilations:M,inputShape:w},Ve=b.a.runKernel(pe.S,ve,Xe);return le?Ze(Ve,[Ve.shape[1],Ve.shape[2],Ve.shape[3]]):Ve}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vx=Object(Qe.b)({fusedDepthwiseConv2d_:function({x:w,filter:g,strides:v,pad:C,dataFormat:$="NHWC",dilations:M=[1,1],dimRoundingMode:W,bias:J,activation:le="linear",preluActivationWeights:ve,leakyreluAlpha:Xe}){if(Oc(b.a.state.gradientDepth,le)===!1){let is=Tc(w,g,v,C,$,M,W);return J!=null&&(is=bs(is,J)),zd(is,le,ve,Xe)}const Ve=Object(be.a)(w,"x","depthwiseConv2d","float32"),kt=Object(be.a)(g,"filter","depthwiseConv2d","float32");let Zt=Ve,gn=!1;Ve.rank===3&&(gn=!0,Zt=Ze(Ve,[1,Ve.shape[0],Ve.shape[1],Ve.shape[2]])),X.b(Zt.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Zt.rank}.`),X.b(kt.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${kt.rank}.`),X.b(Zt.shape[3]===kt.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Zt.shape[3]}) must match the inChannels dimension in filter ${kt.shape[2]}.`),M==null&&(M=[1,1]),X.b(_t(v,M),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${v} and dilations '${M}'`),Kt("fused depthwiseConv2d",C,W);const En=He(Zt.shape,kt.shape,v,M,C,W,!0);let qn,Is;J!=null&&(qn=Object(be.a)(J,"bias","fused conv2d"),[qn]=Object(Mn.makeTypesMatch)(qn,Ve),Zs(En.outShape,qn.shape)),ve!=null&&(Is=Object(be.a)(ve,"prelu weights","fused depthwiseConv2d"));const Sn=(is,cs)=>{X.b(St(M),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${M}'`);const[Bs,zs,Ts,os]=cs,lr=Ld(is,Ts,le),Dr=wx(zs.shape,lr,Bs,v,C,M,W),Br=yx(zs,lr,Bs.shape,v,C,M,W);return os!=null?[Dr,Br,Bd(qn,lr)]:[Dr,Br]},Tn={x:Zt,filter:kt,bias:qn,preluActivationWeights:Is},ns={strides:v,pad:C,dataFormat:$,dilations:M,dimRoundingMode:W,activation:le,leakyreluAlpha:Xe};return J==null?oo((cs,Bs,zs)=>{let Ts=b.a.runKernel(pe.nb,Tn,ns);return zs([Bs,cs,Ts]),gn&&(Ts=Ze(Ts,[Ts.shape[1],Ts.shape[2],Ts.shape[3]])),{value:Ts,gradFunc:Sn}})(Zt,kt):oo((cs,Bs,zs,Ts)=>{let os=b.a.runKernel(pe.nb,Tn,ns);return Ts([Bs,cs,os,zs]),gn&&(os=Ze(os,[os.shape[1],os.shape[2],os.shape[3]])),{value:os,gradFunc:Sn}})(Zt,kt,qn)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kx=Object(Qe.b)({fusedMatMul_:function({a:w,b:g,transposeA:v=!1,transposeB:C=!1,bias:$,activation:M="linear",preluActivationWeights:W,leakyreluAlpha:J=.2}){if(Oc(b.a.state.gradientDepth,M)===!1){let os=wn(w,g,v,C);return $!=null&&(os=bs(os,$)),zd(os,M,W,J)}let le=Object(be.a)(w,"a","fused matMul"),ve=Object(be.a)(g,"b","fused matMul");[le,ve]=Object(Mn.makeTypesMatch)(le,ve);const Xe=v?le.shape[le.rank-2]:le.shape[le.rank-1],Ve=C?ve.shape[ve.rank-1]:ve.shape[ve.rank-2],kt=v?le.shape[le.rank-1]:le.shape[le.rank-2],Zt=C?ve.shape[ve.rank-2]:ve.shape[ve.rank-1],gn=le.shape.slice(0,-2),En=ve.shape.slice(0,-2),qn=X.O(gn),Is=X.O(En);X.b(Xe===Ve,()=>`Error in fused matMul: inner shapes (${Xe}) and (${Ve}) of Tensors with shapes ${le.shape} and ${ve.shape} and transposeA=${v} and transposeB=${C} must match.`);const Sn=Zs(le.shape.slice(0,-2),ve.shape.slice(0,-2)).concat([kt,Zt]),Tn=Ze(le,v?[qn,Xe,kt]:[qn,kt,Xe]),ns=Ze(ve,C?[Is,Zt,Ve]:[Is,Ve,Zt]);let is,cs;$!=null&&(is=Object(be.a)($,"bias","fused matMul"),[is]=Object(Mn.makeTypesMatch)(is,le),Zs(Sn,is.shape)),W!=null&&(cs=Object(be.a)(W,"prelu weights","fused matMul"));const Bs=(os,lr)=>{const[Dr,Br,Tr,ra]=lr,Yr=Ld(Ze(os,Tr.shape),Tr,M);let Xo,Oo;return v||C?!v&&C?(Xo=wn(Yr,Br,!1,!1),Oo=wn(Yr,Dr,!0,!1)):v&&!C?(Xo=wn(Br,Yr,!1,!0),Oo=wn(Dr,Yr,!1,!1)):(Xo=wn(Br,Yr,!0,!0),Oo=wn(Yr,Dr,!0,!0)):(Xo=wn(Yr,Br,!1,!0),Oo=wn(Dr,Yr,!0,!1)),$!=null?[Xo,Oo,Bd(ra,Yr)]:[Xo,Oo]},zs={a:Tn,b:ns,bias:is,preluActivationWeights:cs},Ts={transposeA:v,transposeB:C,activation:M,leakyreluAlpha:J};return $==null?oo((lr,Dr,Br)=>{const Tr=b.a.runKernel(pe.qd,zs,Ts);return Br([lr,Dr,Tr]),{value:Ze(Tr,Sn),gradFunc:Bs}})(Tn,ns):oo((lr,Dr,Br,Tr)=>{const ra=b.a.runKernel(pe.qd,zs,Ts);return Tr([lr,Dr,ra,Br]),{value:Ze(ra,Sn),gradFunc:Bs}})(Tn,ns,is)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jf=Object(Qe.b)({hammingWindow_:function(w){return zh(w,.54,.46)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gf=Object(Qe.b)({hannWindow_:function(w){return zh(w,.5,.5)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hf=Object(Qe.b)({frame_:function(w,g,v,C=!1,$=0){let M=0;const W=[];for(;M+g<=w.size;)W.push(Xt(w,M,g)),M+=v;if(C)for(;M<w.size;){const J=M+g-w.size,le=un([Xt(w,M,g-J),nu([J],$)]);W.push(le),M+=v}return W.length===0?jl([],[0,g]):Ze(un(W),[W.length,g])}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ix=Object(Qe.b)({stft_:function(w,g,v,C,$=Gf){C==null&&(C=Uf(g));const M=Hf(w,g,v),W=Gn(M,$(g));return Fh(W,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cx=Object(Qe.b)({cropAndResize_:function(w,g,v,C,$="bilinear",M=0){const W=Object(be.a)(w,"image","cropAndResize"),J=Object(be.a)(g,"boxes","cropAndResize","float32"),le=Object(be.a)(v,"boxInd","cropAndResize","int32"),ve=J.shape[0];X.b(W.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${W.rank}.`),X.b(J.rank===2&&J.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${ve},4] but had shape ${J.shape}.`),X.b(le.rank===1&&le.shape[0]===ve,()=>`Error in cropAndResize: boxInd must be have size [${ve}] but had shape ${J.shape}.`),X.b(C.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${C.length}.`),X.b(C[0]>=1&&C[1]>=1,()=>`cropSize must be atleast [1,1], but was ${C}`),X.b($==="bilinear"||$==="nearest",()=>`method must be bilinear or nearest, but was ${$}`);const Xe={image:W,boxes:J,boxInd:le},Ve={method:$,extrapolationValue:M,cropSize:C};return b.a.runKernel(pe.L,Xe,Ve)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _x=Object(Qe.b)({flipLeftRight_:function(w){const g=Object(be.a)(w,"image","flipLeftRight","float32");X.b(g.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${g.rank}.`);const v={image:g};return b.a.runKernel(pe.hb,v,{})}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qf=Object(Qe.b)({grayscaleToRGB_:function(w){const g=Object(be.a)(w,"image","grayscaleToRGB"),v=g.rank-1,C=g.shape[v];X.b(g.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${g.rank}.`),X.b(C===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${C}.`);const $=new Array(g.rank);return $.fill(1,0,v),$[v]=3,Z(g,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sx=Object(Qe.b)({rotateWithOffset_:function(w,g,v=0,C=.5){const $=Object(be.a)(w,"image","rotateWithOffset","float32");X.b($.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${$.rank}.`);const M={image:$},W={radians:g,fillValue:v,center:C};return b.a.runKernel(pe.Ac,M,W)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sl(w,g,v,C,$,M){C==null&&(C=.5),$==null&&($=Number.NEGATIVE_INFINITY),M==null&&(M=0);const W=w.shape[0];return v=Math.min(v,W),X.b(0<=C&&C<=1,()=>`iouThreshold must be in [0, 1], but was '${C}'`),X.b(w.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${w.rank}'`),X.b(w.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${w.shape[1]}`),X.b(g.rank===1,()=>"scores must be a 1D tensor"),X.b(g.shape[0]===W,()=>`scores has incompatible shape with boxes. Expected ${W}, but was ${g.shape[0]}`),X.b(0<=M&&M<=1,()=>`softNmsSigma must be in [0, 1], but was '${M}'`),{maxOutputSize:v,iouThreshold:C,scoreThreshold:$,softNmsSigma:M}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $x=Object(Qe.b)({nonMaxSuppression_:function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY){const M=Object(be.a)(w,"boxes","nonMaxSuppression","float32"),W=Object(be.a)(g,"scores","nonMaxSuppression","float32"),J=sl(M,W,v,C,$),le={maxOutputSize:v=J.maxOutputSize,iouThreshold:C=J.iouThreshold,scoreThreshold:$=J.scoreThreshold};return b.a.runKernel(pe.bc,{boxes:M,scores:W},le)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tx(w,g,v){const C=function(M,W,J){return function(le,ve,Xe){let Ve=0,kt=le.length,Zt=0,gn=!1;for(;Ve<kt;){Zt=Ve+(kt-Ve>>>1);const En=Xe(ve,le[Zt]);En>0?Ve=Zt+1:(kt=Zt,gn=!En)}return gn?Ve:-Ve-1}(M,W,J||Nx)}(w,g,v),$=C<0?-(C+1):C;w.splice($,0,g)}function Nx(w,g){return w>g?1:w<g?-1:0}function Kf(w,g,v,C,$){return Wh(w,g,v,C,$,0)}function Xf(w,g,v,C,$,M){return Wh(w,g,v,C,$,0,!1,M,!0)}function Yf(w,g,v,C,$,M){return Wh(w,g,v,C,$,M,!0)}function Wh(w,g,v,C,$,M,W=!1,J=!1,le=!1){const ve=[];for(let qn=0;qn<g.length;qn++)g[qn]>$&&ve.push({score:g[qn],boxIndex:qn,suppressBeginIndex:0});ve.sort(Zf);const Xe=M>0?-.5/M:0,Ve=[],kt=[];for(;Ve.length<v&&ve.length>0;){const qn=ve.pop(),{score:Is,boxIndex:Sn,suppressBeginIndex:Tn}=qn;if(Is<$)break;let ns=!1;for(let is=Ve.length-1;is>=Tn;--is){const cs=Ex(w,Sn,Ve[is]);if(cs>=C){ns=!0;break}if(qn.score=qn.score*Rx(C,Xe,cs),qn.score<=$)break}qn.suppressBeginIndex=Ve.length,ns||(qn.score===Is?(Ve.push(Sn),kt.push(qn.score)):qn.score>$&&Tx(ve,qn,Zf))}const Zt=Ve.length,gn=v-Zt;J&&gn>0&&(Ve.push(...new Array(gn).fill(0)),kt.push(...new Array(gn).fill(0)));const En={selectedIndices:Ve};return W&&(En.selectedScores=kt),le&&(En.validOutputs=Zt),En}function Ex(w,g,v){const C=w.subarray(4*g,4*g+4),$=w.subarray(4*v,4*v+4),M=Math.min(C[0],C[2]),W=Math.min(C[1],C[3]),J=Math.max(C[0],C[2]),le=Math.max(C[1],C[3]),ve=Math.min($[0],$[2]),Xe=Math.min($[1],$[3]),Ve=Math.max($[0],$[2]),kt=Math.max($[1],$[3]),Zt=(J-M)*(le-W),gn=(Ve-ve)*(kt-Xe);if(Zt<=0||gn<=0)return 0;const En=Math.max(M,ve),qn=Math.max(W,Xe),Is=Math.min(J,Ve),Sn=Math.min(le,kt),Tn=Math.max(Is-En,0)*Math.max(Sn-qn,0);return Tn/(Zt+gn-Tn)}function Rx(w,g,v){const C=Math.exp(g*v*v);return v<=w?C:0}function Zf(w,g){return w.score-g.score||w.score===g.score&&g.boxIndex-w.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ax=async function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY){const M=Object(be.a)(w,"boxes","nonMaxSuppressionAsync"),W=Object(be.a)(g,"scores","nonMaxSuppressionAsync"),J=sl(M,W,v,C,$);v=J.maxOutputSize,C=J.iouThreshold,$=J.scoreThreshold;const le=await Promise.all([M.data(),W.data()]),ve=le[0],Xe=le[1],{selectedIndices:Ve}=Kf(ve,Xe,v,C,$);return M!==w&&M.dispose(),W!==g&&W.dispose(),Vi(Ve,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ox=Object(Qe.b)({nonMaxSuppressionWithScore_:function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY,M=0){const W=Object(be.a)(w,"boxes","nonMaxSuppression"),J=Object(be.a)(g,"scores","nonMaxSuppression"),le=sl(W,J,v,C,$,M),ve={boxes:W,scores:J},Xe={maxOutputSize:v=le.maxOutputSize,iouThreshold:C=le.iouThreshold,scoreThreshold:$=le.scoreThreshold,softNmsSigma:M=le.softNmsSigma},Ve=b.a.runKernel(pe.dc,ve,Xe);return{selectedIndices:Ve[0],selectedScores:Ve[1]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fx=async function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY,M=0){const W=Object(be.a)(w,"boxes","nonMaxSuppressionAsync"),J=Object(be.a)(g,"scores","nonMaxSuppressionAsync"),le=sl(W,J,v,C,$,M);v=le.maxOutputSize,C=le.iouThreshold,$=le.scoreThreshold,M=le.softNmsSigma;const ve=await Promise.all([W.data(),J.data()]),Xe=ve[0],Ve=ve[1],{selectedIndices:kt,selectedScores:Zt}=Yf(Xe,Ve,v,C,$,M);return W!==w&&W.dispose(),J!==g&&J.dispose(),{selectedIndices:Vi(kt,"int32"),selectedScores:Vi(Zt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dx=Object(Qe.b)({nonMaxSuppressionPadded_:function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY,M=!1){const W=Object(be.a)(w,"boxes","nonMaxSuppression"),J=Object(be.a)(g,"scores","nonMaxSuppression"),le=sl(W,J,v,C,$,null),ve={boxes:W,scores:J},Xe={maxOutputSize:le.maxOutputSize,iouThreshold:le.iouThreshold,scoreThreshold:le.scoreThreshold,padToMaxOutputSize:M},Ve=b.a.runKernel(pe.cc,ve,Xe);return{selectedIndices:Ve[0],validOutputs:Ve[1]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mx=async function(w,g,v,C=.5,$=Number.NEGATIVE_INFINITY,M=!1){const W=Object(be.a)(w,"boxes","nonMaxSuppressionAsync"),J=Object(be.a)(g,"scores","nonMaxSuppressionAsync"),le=sl(W,J,v,C,$,null),ve=le.maxOutputSize,Xe=le.iouThreshold,Ve=le.scoreThreshold,[kt,Zt]=await Promise.all([W.data(),J.data()]),{selectedIndices:gn,validOutputs:En}=Xf(kt,Zt,ve,Xe,Ve,M);return W!==w&&W.dispose(),J!==g&&J.dispose(),{selectedIndices:Vi(gn,"int32"),validOutputs:ar(En,"int32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Px=Object(Qe.b)({resizeBilinear_:function(w,g,v=!1,C=!1){const $=Object(be.a)(w,"images","resizeBilinear");X.b($.rank===3||$.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$.rank}.`),X.b(g.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${g}.`),X.b(C===!1||v===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let M=$,W=!1;$.rank===3&&(W=!0,M=Ze($,[1,$.shape[0],$.shape[1],$.shape[2]]));const J={images:M},le={alignCorners:v,halfPixelCenters:C,size:g},ve=b.a.runKernel(pe.vc,J,le);return W?Ze(ve,[ve.shape[1],ve.shape[2],ve.shape[3]]):ve}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lx=Object(Qe.b)({resizeNearestNeighbor_:function(w,g,v=!1,C=!1){const $=Object(be.a)(w,"images","resizeNearestNeighbor");X.b($.rank===3||$.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$.rank}.`),X.b(g.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${g}.`),X.b($.dtype==="float32"||$.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),X.b(C===!1||v===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let M=$,W=!1;$.rank===3&&(W=!0,M=Ze($,[1,$.shape[0],$.shape[1],$.shape[2]]));const J={images:M},le={alignCorners:v,halfPixelCenters:C,size:g},ve=b.a.runKernel(pe.xc,J,le);return W?Ze(ve,[ve.shape[1],ve.shape[2],ve.shape[3]]):ve}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bx=Object(Qe.b)({threshold_:function(w,g="binary",v=!1,C=.5){const $=Object(be.a)(w,"image","threshold"),M=$.shape[0]*$.shape[1];let W,J,le,ve,Xe=Gn(Vi([C]),255);if(X.b($.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${$.rank}.`),X.b($.shape[2]===3||$.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${$.shape[2]}.`),X.b($.dtype==="int32"||$.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${$.dtype}.`),X.b(g==="otsu"||g==="binary",()=>`Method must be binary or otsu, but was ${g}`),$.shape[2]===3){[W,J,le]=Vl($,[1,1,1],-1);const kt=Gn(W,.2989),Zt=Gn(J,.587),gn=Gn(le,.114);ve=bs(bs(kt,Zt),gn)}else ve=w;g==="otsu"&&(Xe=function(kt,Zt){let gn,En,qn,Is,Sn,Tn,ns=Vi([-1]),is=Vi([0]),cs=Vi([0]);for(let Bs=0;Bs<kt.size-1;Bs++){gn=Xt(kt,0,Bs+1),En=Xt(kt,Bs+1),Sn=hr(gr(gn),Zt),Tn=hr(gr(En),Zt);const zs=gr(Gn(gn,Ac(0,gn.size)));qn=hr(zs,gr(gn));const Ts=nu(En.shape,gn.size),os=bs(Ac(0,En.size),Ts),lr=Gn(En,os);Is=hr(gr(lr),gr(En));const Dr=Os(qn,Is),Br=Os(qn,Is),Tr=Gn(Sn,Tn);cs=Gn(Gn(Tr,Dr),Br);const ra=Ce(cs,is);is=iu(ra,cs,is),ns=iu(ra,Vi([Bs]),ns)}return ns}(er(Un(Pf(ve),"int32"),Object(Mh.a)([]),256),M));const Ve=v?Je(ve,Xe):Ce(ve,Xe);return Un(Gn(Ve,255),"int32")}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zx=Object(Qe.b)({transform_:function(w,g,v="nearest",C="constant",$=0,M){const W=Object(be.a)(w,"image","transform","float32"),J=Object(be.a)(g,"transforms","transform","float32");X.b(W.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${W.rank}.`),X.b(J.rank===2&&(J.shape[0]===W.shape[0]||J.shape[0]===1)&&J.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),X.b(M==null||M.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${M}.`);const le={image:W,transforms:J},ve={interpolation:v,fillMode:C,fillValue:$,outputShape:M};return b.a.runKernel(pe.jd,le,ve)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wx=Object(Qe.b)({bandPart_:function(w,g,v){Object(X.b)(g%1==0,()=>`bandPart(): numLower must be an integer, got ${g}.`),Object(X.b)(v%1==0,()=>`bandPart(): numUpper must be an integer, got ${v}.`);const C=Object(be.a)(w,"a","bandPart");Object(X.b)(C.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${C.rank}.`);const $=C.shape,[M,W]=C.shape.slice(-2);if(!(g<=M))throw new Error(`bandPart(): numLower (${g}) must not be greater than the number of rows (${M}).`);if(!(v<=W))throw new Error(`bandPart(): numUpper (${v}) must not be greater than the number of columns (${W}).`);g<0&&(g=M),v<0&&(v=W);const J=Ze(Ac(0,M,1,"int32"),[-1,1]),le=Ac(0,W,1,"int32"),ve=Os(J,le),Xe=R(Je(ve,ar(+g,"int32")),De(ve,ar(-v,"int32"))),Ve=et([M,W],C.dtype);return Ze(Ul(Ph(Ze(C,[-1,M,W])).map(kt=>iu(Xe,kt,Ve))),$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vx=Object(Qe.b)({gramSchmidt_:function(w){let g;if(Array.isArray(w)){g=!1,Object(X.b)(w!=null&&w.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const $=w[0].shape[0];for(let M=1;M<w.length;++M)Object(X.b)(w[M].shape[0]===$,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${w[M].shape[0]} vs. ${$})`)}else g=!0,w=Vl(w,w.shape[0],0).map($=>Dh($,[0]));Object(X.b)(w.length<=w[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${w.length}) exceeds number of dimensions (${w[0].shape[0]}).`);const v=[],C=w;for(let $=0;$<w.length;++$)v.push(b.a.tidy(()=>{let M=C[$];if($>0)for(let W=0;W<$;++W){const J=Gn(gr(Gn(v[W],M)),v[W]);M=Os(M,J)}return hr(M,Au(M,"euclidean"))}));return g?Ul(v,0):v}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qf(w,g=!1){return b.a.tidy(()=>{Object(X.b)(w.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${w.shape.length}D Tensor.`);const v=w.shape[0],C=w.shape[1];let $=fe(v),M=Ws(w);const W=jl([[1]],[1,1]);let J=Ws(W);const le=v>=C?C:v;for(let ve=0;ve<le;++ve){const Xe=M,Ve=J,kt=$;[J,M,$]=b.a.tidy(()=>{const Zt=Xt(M,[ve,ve],[v-ve,1]),gn=Au(Zt),En=Xt(M,[ve,ve],[1,1]),qn=iu(Ce(En,0),jl([[-1]]),jl([[1]])),Is=Os(En,Gn(qn,gn)),Sn=hr(Zt,Is);J=Sn.shape[0]===1?Ws(W):un([W,Xt(Sn,[1,0],[Sn.shape[0]-1,Sn.shape[1]])],0);const Tn=Ar(hr(wn(qn,Is),gn)),ns=Xt(M,[ve,0],[v-ve,C]),is=Gn(Tn,J),cs=Ea(J);if(ve===0)M=Os(ns,wn(is,wn(cs,ns)));else{const Ts=Os(ns,wn(is,wn(cs,ns)));M=un([Xt(M,[0,0],[ve,C]),Ts],0)}const Bs=Ea(is),zs=Xt($,[0,ve],[v,$.shape[1]-ve]);if(ve===0)$=Os(zs,wn(wn(zs,J),Bs));else{const Ts=Os(zs,wn(wn(zs,J),Bs));$=un([Xt($,[0,0],[v,ve]),Ts],1)}return[J,M,$]}),mr([Xe,Ve,kt])}return!g&&v>C&&($=Xt($,[0,0],[v,C]),M=Xt(M,[0,0],[C,C])),[$,M]})}const Ux=Object(Qe.b)({qr_:function(w,g=!1){if(Object(X.b)(w.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${w.rank}`),w.rank===2)return Qf(w,g);{const v=w.shape.slice(0,w.shape.length-2).reduce((W,J)=>W*J),C=Ph(Ze(w,[v,w.shape[w.shape.length-2],w.shape[w.shape.length-1]]),0),$=[],M=[];return C.forEach(W=>{const[J,le]=Qf(W,g);$.push(J),M.push(le)}),[Ze(Ul($,0),w.shape),Ze(Ul(M,0),w.shape)]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var io;(function(w){w[w.NONE=0]="NONE",w[w.MEAN=1]="MEAN",w[w.SUM=2]="SUM",w[w.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(io||(io={}));const cu=Object(Qe.b)({computeWeightedLoss_:function(w,g,v=io.SUM_BY_NONZERO_WEIGHTS){const C=Object(be.a)(w,"losses","computeWeightedLoss");let $=null;g!=null&&($=Object(be.a)(g,"weights","computeWeightedLoss"));const M=$==null?C:Gn(C,$);if(v===io.NONE)return M;if(v===io.SUM)return gr(M);if(v===io.MEAN){if($==null)return it(M);{const W=C.size/$.size,J=hr(gr(M),gr($));return W>1?hr(J,ar(W)):J}}if(v===io.SUM_BY_NONZERO_WEIGHTS){if($==null)return hr(gr(M),ar(C.size));{const W=Gn($,dt(C.shape)),J=Un(gr(rn(W,ar(0))),"float32");return hr(gr(M),J)}}throw Error(`Unknown reduction: ${v}`)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jx=Object(Qe.b)({absoluteDifference_:function(w,g,v,C=io.SUM_BY_NONZERO_WEIGHTS){const $=Object(be.a)(w,"labels","absoluteDifference"),M=Object(be.a)(g,"predictions","absoluteDifference");let W=null;v!=null&&(W=Object(be.a)(v,"weights","absoluteDifference")),Object(X.e)($.shape,M.shape,"Error in absoluteDifference: ");const J=Ia(Os($,M));return cu(J,W,C)}}),Gx=Object(Qe.b)({cosineDistance_:function(w,g,v,C,$=io.SUM_BY_NONZERO_WEIGHTS){const M=Object(be.a)(w,"labels","cosineDistance"),W=Object(be.a)(g,"predictions","cosineDistance");let J=null;C!=null&&(J=Object(be.a)(C,"weights","cosineDistance")),Object(X.e)(M.shape,W.shape,"Error in cosineDistance: ");const le=ar(1),ve=Os(le,gr(Gn(M,W),v,!0));return cu(ve,J,$)}}),Hx=Object(Qe.b)({hingeLoss_:function(w,g,v,C=io.SUM_BY_NONZERO_WEIGHTS){let $=Object(be.a)(w,"labels","hingeLoss");const M=Object(be.a)(g,"predictions","hingeLoss");let W=null;v!=null&&(W=Object(be.a)(v,"weights","hingeLoss")),Object(X.e)($.shape,M.shape,"Error in hingeLoss: ");const J=ar(1);$=Os(Gn(ar(2),$),J);const le=nl(Os(J,Gn($,M)));return cu(le,W,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qx=Object(Qe.b)({huberLoss_:function(w,g,v,C=1,$=io.SUM_BY_NONZERO_WEIGHTS){const M=Object(be.a)(w,"labels","huberLoss"),W=Object(be.a)(g,"predictions","huberLoss");let J=null;v!=null&&(J=Object(be.a)(v,"weights","huberLoss")),Object(X.e)(M.shape,W.shape,"Error in huberLoss: ");const le=ar(C),ve=Ia(Os(W,M)),Xe=Et(ve,le),Ve=Os(ve,Xe),kt=bs(Gn(ar(.5),Vr(Xe)),Gn(le,Ve));return cu(kt,J,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kx=Object(Qe.b)({logLoss_:function(w,g,v,C=1e-7,$=io.SUM_BY_NONZERO_WEIGHTS){const M=Object(be.a)(w,"labels","logLoss"),W=Object(be.a)(g,"predictions","logLoss");let J=null;v!=null&&(J=Object(be.a)(v,"weights","logLoss")),Object(X.e)(M.shape,W.shape,"Error in logLoss: ");const le=ar(1),ve=ar(C),Xe=Ar(Gn(M,ft(bs(W,ve)))),Ve=Gn(Os(le,M),ft(bs(Os(le,W),ve))),kt=Os(Xe,Ve);return cu(kt,J,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xx=Object(Qe.b)({meanSquaredError_:function(w,g,v,C=io.SUM_BY_NONZERO_WEIGHTS){const $=Object(be.a)(w,"labels","meanSquaredError"),M=Object(be.a)(g,"predictions","meanSquaredError");let W=null;v!=null&&(W=Object(be.a)(v,"weights","meanSquaredError")),Object(X.e)($.shape,M.shape,"Error in meanSquaredError: ");const J=Bf($,M);return cu(J,W,C)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yx=Object(Qe.b)({sigmoidCrossEntropy_:function(w,g,v,C=0,$=io.SUM_BY_NONZERO_WEIGHTS){let M=Object(be.a)(w,"multiClassLabels","sigmoidCrossEntropy");const W=Object(be.a)(g,"logits","sigmoidCrossEntropy");let J=null;if(v!=null&&(J=Object(be.a)(v,"weights","sigmoidCrossEntropy")),Object(X.e)(M.shape,W.shape,"Error in sigmoidCrossEntropy: "),C>0){const ve=ar(C),Xe=ar(1),Ve=ar(.5);M=bs(Gn(M,Os(Xe,ve)),Gn(Ve,ve))}const le=function(ve,Xe){const Ve=Object(be.a)(ve,"labels","sigmoidCrossEntropyWithLogits"),kt=Object(be.a)(Xe,"logits","sigmoidCrossEntropyWithLogits");Object(X.e)(Ve.shape,kt.shape,"Error in sigmoidCrossEntropyWithLogits: ");const Zt=nl(kt),gn=Gn(kt,Ve),En=yt(Ko(Ar(Ia(kt))));return bs(Os(Zt,gn),En)}(M,W);return cu(le,J,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zx=Object(Qe.b)({softmaxCrossEntropy_:function(w,g,v,C=0,$=io.SUM_BY_NONZERO_WEIGHTS){let M=Object(be.a)(w,"onehotLabels","softmaxCrossEntropy");const W=Object(be.a)(g,"logits","softmaxCrossEntropy");let J=null;if(v!=null&&(J=Object(be.a)(v,"weights","softmaxCrossEntropy")),Object(X.e)(M.shape,W.shape,"Error in softmaxCrossEntropy: "),C>0){const ve=ar(C),Xe=ar(1),Ve=ar(M.shape[1]);M=bs(Gn(M,Os(Xe,ve)),hr(ve,Ve))}const le=function(ve,Xe,Ve=-1){if(Ve===-1&&(Ve=Xe.rank-1),Ve!==Xe.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${Xe.rank} and dim was ${Ve}`);return oo((Zt,gn,En)=>{const qn=A(gn,[Ve],!0),Is=Os(Un(gn,"float32"),qn);En([Zt,Is]);const Sn=Ar(Gn(Is,Zt));return{value:gr(Sn,[Ve]),gradFunc:(Tn,ns)=>{const[is,cs]=ns,Bs=Eu(Tn.shape,[Ve]);return[Gn(Ze(Tn,Bs),Os(Un(is,"float32"),Ko(cs))),Gn(Ze(Tn,Bs),Os(Ko(cs),Un(is,"float32")))]}}})(ve,Xe)}(M,W);return cu(le,J,$)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qx=Object(Qe.b)({sparseFillEmptyRows_:function(w,g,v,C){const $=Object(be.a)(w,"indices","sparseFillEmptyRows","int32"),M=Object(be.a)(g,"values","sparseFillEmptyRows"),W=Object(be.a)(v,"denseShape","sparseFillEmptyRows","int32"),J=Object(be.a)(C,"defaultValue","sparseFillEmptyRows",M.dtype);if($.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${$.shape}`);if(M.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${M.shape}`);if(W.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${W.shape}`);if(J.rank!==0)throw new Error(`Default value should be a scalar but received shape ${J.shape}`);const le={indices:$,values:M,denseShape:W,defaultValue:J},ve=b.a.runKernel(pe.Pc,le);return{outputIndices:ve[0],outputValues:ve[1],emptyRowIndicator:ve[2],reverseIndexMap:ve[3]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jx=Object(Qe.b)({sparseReshape_:function(w,g,v){const C=Object(be.a)(w,"inputIndices","sparseReshape","int32"),$=Object(be.a)(g,"inputShape","sparseReshape","int32"),M=Object(be.a)(v,"newShape","sparseReshape","int32");if(C.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${C.shape}`);if($.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${$.shape}`);if(M.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${M.shape}`);const W={inputIndices:C,inputShape:$,newShape:M},J=b.a.runKernel(pe.Qc,W);return{outputIndices:J[0],outputShape:J[1]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e1=Object(Qe.b)({sparseSegmentMean_:function(w,g,v){const C=Object(be.a)(w,"data","sparseSegmentMean"),$=Object(be.a)(g,"indices","sparseSegmentMean","int32"),M=Object(be.a)(v,"segmentIds","sparseSegmentMean","int32");if(C.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if($.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${$.shape}`);if(M.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${M.shape}`);const W={data:C,indices:$,segmentIds:M};return b.a.runKernel(pe.Rc,W)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t1=Object(Qe.b)({sparseSegmentSum_:function(w,g,v){const C=Object(be.a)(w,"data","sparseSegmentSum"),$=Object(be.a)(g,"indices","sparseSegmentSum","int32"),M=Object(be.a)(v,"segmentIds","sparseSegmentSum","int32");if(C.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if($.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${$.shape}`);if(M.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${M.shape}`);const W={data:C,indices:$,segmentIds:M};return b.a.runKernel(pe.Sc,W)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n1=Object(Qe.b)({stringNGrams_:function(w,g,v,C,$,M,W,J){const le=Object(be.a)(w,"data","stringNGrams","string");if(le.dtype!=="string")throw new Error("Data must be of datatype string");if(le.shape.length!==1)throw new Error(`Data must be a vector, saw: ${le.shape}`);const ve=Object(be.a)(g,"dataSplits","stringNGrams");if(ve.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const Xe={separator:v,nGramWidths:C,leftPad:$,rightPad:M,padWidth:W,preserveShortSequences:J},Ve={data:le,dataSplits:ve},kt=b.a.runKernel(pe.ad,Ve,Xe);return{nGrams:kt[0],nGramsSplits:kt[1]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s1=Object(Qe.b)({stringSplit_:function(w,g,v=!0){const C=Object(be.a)(w,"input","stringSplit","string"),$=Object(be.a)(g,"delimiter","stringSplit","string");if(C.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${C.shape}`);if($.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${$.shape}`);const M={skipEmpty:v},W={input:C,delimiter:$},J=b.a.runKernel(pe.bd,W,M);return{indices:J[0],values:J[1],shape:J[2]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1=Object(Qe.b)({stringToHashBucketFast_:function(w,g){const v=Object(be.a)(w,"input","stringToHashBucketFast","string"),C={numBuckets:g};if(g<=0)throw new Error("Number of buckets must be at least 1");const $={input:v};return b.a.runKernel(pe.cd,$,C)}}),a1={fft:Oh,ifft:Wl,rfft:Fh,irfft:Lf},o1={hammingWindow:jf,hannWindow:Gf,frame:Hf,stft:Ix},i1={flipLeftRight:_x,grayscaleToRGB:qf,resizeNearestNeighbor:Lx,resizeBilinear:Px,rotateWithOffset:Sx,cropAndResize:Cx,nonMaxSuppression:$x,nonMaxSuppressionAsync:Ax,nonMaxSuppressionWithScore:Ox,nonMaxSuppressionWithScoreAsync:Fx,nonMaxSuppressionPadded:Dx,nonMaxSuppressionPaddedAsync:Mx,threshold:Bx,transform:zx},u1={bandPart:Wx,gramSchmidt:Vx,qr:Ux},c1={absoluteDifference:jx,computeWeightedLoss:cu,cosineDistance:Gx,hingeLoss:Hx,huberLoss:qx,logLoss:Kx,meanSquaredError:Xx,sigmoidCrossEntropy:Yx,softmaxCrossEntropy:Zx},l1={sparseFillEmptyRows:Qx,sparseReshape:Jx,sparseSegmentMean:e1,sparseSegmentSum:t1},d1={stringNGrams:n1,stringSplit:s1,stringToHashBucketFast:r1},h1={sgd:Eo.sgd,momentum:Eo.momentum,adadelta:Eo.adadelta,adagrad:Eo.adagrad,rmsprop:Eo.rmsprop,adamax:Eo.adamax,adam:Eo.adam};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var lu,Jf=t(95);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(w,g){const v=w[0].length;w.forEach(($,M)=>{X.b($.length===v,()=>`Error in concat${v}D: rank of tensors[${M}] must be the same as the rank of the rest (${v})`)}),X.b(g>=0&&g<v,()=>`Error in concat${v}D: axis must be between 0 and ${v-1}.`);const C=w[0];w.forEach(($,M)=>{for(let W=0;W<v;W++)X.b(W===g||$[W]===C[W],()=>`Error in concat${v}D: Shape of tensors[${M}] (${$}) does not match the shape of the rest (${C}) along the non-concatenated axis ${M}.`)})}function f1(w,g){const v=w[0].slice();for(let C=1;C<w.length;C++)v[g]+=w[C][g];return v}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1(w,g,v){let C=new Array;if(v==null&&g==null)return C;if(g==null)for(;C.length<w+v.length;)C.push(-1);else C=g.slice();if(v==null)return C;if(w+v.length!==C.length)throw new Error(`rt input.shape and shape=${g} are incompatible: rt input.rank = ${w+v.length}, but shape.rank = ${C.length}`);for(let $=1;$<v.length;++$){const M=v[$],W=C[C.length-v.length+$],J=C[W];if(M>=0)if(J>=0){if(J!==M)throw new Error(`rt input.shape and shape=${g} are incompatible: rt input.shape[${$+w}] = ${M} but shape[${$+w}] = ${J}`)}else C[W]=M}return C}function g1(w){const g={FIRST_DIM_SIZE:lu.FIRST_DIM_SIZE,VALUE_ROWIDS:lu.VALUE_ROWIDS,ROW_LENGTHS:lu.ROW_LENGTHS,ROW_SPLITS:lu.ROW_SPLITS,ROW_LIMITS:lu.ROW_LIMITS,ROW_STARTS:lu.ROW_STARTS},v=[];for(const C of w){if(!(C in g))break;v.push(g[C])}return v}function em(w){return w.length===0?0:w[0]===lu.FIRST_DIM_SIZE?w.length-1:w.length}function b1(w,g){if(w==null||g==null)return;const v=w.length,C=g.length;if(v>=C)throw new Error(`defaultValue.shape=${w} and ragged tensor flatValues.shape=${g}, are incompatible: defaultValue.rank = ${v} must be less than ragged tensor input flatValues.rank = ${C})`);for(let $=0;$<Math.min(v,C-1);++$){const M=w[$],W=g[$+1];if(M>=0&&W>=0&&M!==1&&M!==W)throw new Error(`defaultValue.shape=${w}, and ragged tensor input flatValues.shape=${g} are incompatible: defaultValue.shape[${$-w.length}] = ${M} but ragged tensor input.flatValues.shape[${$-w.length}] = ${W}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(w){w[w.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",w[w.VALUE_ROWIDS=1]="VALUE_ROWIDS",w[w.ROW_LENGTHS=2]="ROW_LENGTHS",w[w.ROW_SPLITS=3]="ROW_SPLITS",w[w.ROW_LIMITS=4]="ROW_LIMITS",w[w.ROW_STARTS=5]="ROW_STARTS"})(lu||(lu={}));const Vh=30;function x1(w){return w<=Vh?w:Object(X.G)(w,Math.floor(Math.sqrt(w)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1(w,g,v){return[v*(typeof w=="number"?w:w[0]),g*(typeof w=="number"?w:w[1])]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(w,g,v,C=!0){let $=[];if(C)$=$.concat(g.slice(0)),$.push(w[0]/v),$=$.concat(w.slice(1));else{$=$.concat(w[0]);const M=g.length;for(let W=0;W<M;++W)$=$.concat([w[W+1]/g[W],g[W]]);$=$.concat(w.slice(M+1))}return $}function v1(w,g,v=!0){const C=[];if(v){C.push(g);for(let $=g+1;$<w;++$)$<=2*g?(C.push($),C.push($-(g+1))):C.push($)}else{const $=[],M=[];for(let W=1;W<w;++W)W>=2*g+1||W%2==1?M.push(W):$.push(W);C.push(...$),C.push(0),C.push(...M)}return C}function k1(w,g,v,C=!0){const $=[];C?$.push(w[0]/v):$.push(w[0]*v);for(let M=1;M<w.length;++M)M<=g.length?C?$.push(g[M-1]*w[M]):$.push(w[M]/g[M-1]):$.push(w[M]);return $}function I1(w,g){const v=[0];for(let C=0;C<g;++C)v.push(w[C][0]);return v}function C1(w,g,v){const C=w.slice(0,1);for(let $=0;$<v;++$)C.push(w[$+1]-g[$][0]-g[$][1]);return C}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _1=1.7580993408473768,S1=1.0507009873554805,$1=.3275911,T1=.254829592,tm=-.284496736,N1=1.421413741,E1=-1.453152027,R1=1.061405429;var nc=t(30);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nm(w,g){if(w.length!==g.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${w.length}, imag: ${g.length}.`);const v=new Float32Array(2*w.length);for(let C=0;C<v.length;C+=2)v[C]=w[C/2],v[C+1]=g[C/2];return v}function A1(w){const g=new Float32Array(w.length/2),v=new Float32Array(w.length/2);for(let C=0;C<w.length;C+=2)g[C/2]=w[C],v[C/2]=w[C+1];return{real:g,imag:v}}function O1(w){const g=Math.ceil(w.length/4),v=new Float32Array(g),C=new Float32Array(g);for(let $=0;$<w.length;$+=4)v[Math.floor($/4)]=w[$],C[Math.floor($/4)]=w[$+1];return{real:v,imag:C}}function F1(w){const g=Math.floor(w.length/4),v=new Float32Array(g),C=new Float32Array(g);for(let $=2;$<w.length;$+=4)v[Math.floor($/4)]=w[$],C[Math.floor($/4)]=w[$+1];return{real:v,imag:C}}function D1(w,g){return{real:w[2*g],imag:w[2*g+1]}}function M1(w,g,v,C){w[2*C]=g,w[2*C+1]=v}function P1(w,g){const v=new Float32Array(w/2),C=new Float32Array(w/2);for(let $=0;$<Math.ceil(w/2);$++){const M=(g?2:-2)*Math.PI*($/w);v[$]=Math.cos(M),C[$]=Math.sin(M)}return{real:v,imag:C}}function L1(w,g,v){const C=(v?2:-2)*Math.PI*(w/g);return{real:Math.cos(C),imag:Math.sin(C)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F="->",y=/->/g;function k(w,g){const v=((w=w.replace(/\s/g,"")).length-w.replace(y,"").length)/F.length;if(v<1)throw new Error("Equations without an arrow are not supported.");if(v>1)throw new Error('Equation must contain exactly one arrow ("->").');const[C,$]=w.split(F);Object(X.b)(C.indexOf("...")===-1,()=>'The ellipsis notation ("...") is not supported yet.');const M=C.split(","),W=M.length;if(g!==W)throw new Error(`Expected ${W} input tensors, received ${g}`);if(W>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const J=[];for(let Ve=0;Ve<$.length;++Ve){const kt=$[Ve];if(!M.some(Zt=>Zt.indexOf(kt)!==-1))throw new Error(`Output subscripts contain the label ${kt} not present in the input subscripts.`);J.indexOf(kt)===-1&&J.push(kt)}for(let Ve=0;Ve<C.length;++Ve){const kt=C[Ve];J.indexOf(kt)===-1&&kt!==","&&J.push(kt)}const le=new Array(M.length);for(let Ve=0;Ve<W;++Ve){if(new Set(M[Ve].split("")).size!==M[Ve].length)throw new Error(`Found duplicate axes in input component ${M[Ve]}. Support for duplicate axes in input is not implemented yet.`);le[Ve]=[];for(let kt=0;kt<M[Ve].length;++kt)le[Ve].push(J.indexOf(M[Ve][kt]))}const ve=J.length,Xe=[];for(let Ve=$.length;Ve<ve;++Ve)Xe.push(Ve);return{allDims:J,summedDims:Xe,idDims:le}}function S(w,g){let v=new Array(w);v.fill(-1);for(let $=0;$<g.length;++$)v[g[$]]=$;const C=[];for(let $=0;$<w;++$)v[$]===-1&&C.push($);return v=v.filter($=>$!==-1),{permutationIndices:v,expandDims:C}}function _(w,g,v){const C=new Array(w);for(let $=0;$<v.length;++$){const M=v[$].shape;for(let W=0;W<g[$].length;++W)C[g[$][W]]===void 0?C[g[$][W]]=M[W]:Object(X.b)(C[g[$][W]]===M[W],()=>`Expected dimension ${C[g[$][W]]} at axis ${W} of input shaped ${JSON.stringify(M)}, but got dimension ${M[W]}`)}}function T(w,g){const v=w,C=[];let $=0;w.length===0&&v.push(-1),$=w.length+1;for(let W=0;W<$;++W)C.push([]);const M=[];for(let W=0;W<v.length;++W){const J=B(g,v[W]);for(const le of J)M.indexOf(le)===-1&&(C[W].push(le),M.push(le))}return{path:v,steps:C}}function O(w){return w.every((g,v)=>g===v)}function B(w,g){const v=[];for(let C=0;C<w.length;++C)w[C].length!==0&&w[C].indexOf(g)===-1&&g!==-1||v.push(C);return v}function z(w,g,v=0){let C=[];if(typeof g=="number")Object(X.b)(w.shape[v]%g==0,()=>"Number of splits must evenly divide the axis."),C=new Array(g).fill(w.shape[v]/g);else{const $=g.reduce((W,J)=>(J===-1&&(W+=1),W),0);Object(X.b)($<=1,()=>"There should be only one negative value in split array.");const M=g.indexOf(-1);if(M!==-1){const W=g.reduce((J,le)=>le>0?J+le:J);g[M]=w.shape[v]-W}Object(X.b)(w.shape[v]===g.reduce((W,J)=>W+J),()=>"The sum of sizes must match the size of the axis dimension."),C=g}return C}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K(w){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${w}`}function Q(w,g){return`indices(${w}, 0) is invalid: ${g} < 0`}function ue(w,g,v){return`indices(${w}, 0) is invalid: ${g} >= ${v}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ae(w,g){return`only one output dimension may be -1, not both ${w} and ${g}`}function Re(w,g){return`size ${w} must be non-negative, not ${g}`}function ke(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Ge(w,g){return`Input to reshape is a SparseTensor with ${Object(X.O)(w)}
  dense values, but the requested shape requires a multiple of ${Object(X.O)(g)}. inputShape=${w} outputShape= ${g}`}function qe(w,g){return`Input to reshape is a tensor with ${Object(X.O)(w)} dense values, but the requested shape has ${Object(X.O)(g)}. inputShape=${w} outputShape=${g}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ne(){return"segment ids must be >= 0"}function Ke(){return"segment ids are not increasing"}function an(w,g){return`Segment id ${w} out of range [0, ${g}), possibly because segmentIds input is not sorted.`}function kn(w,g,v){return`Bad: indices[${w}] == ${g} out of range [0, ${v})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(w,g){let v,C=!1;for(w<=Vh?(v=w,C=!0):v=Object(X.G)(w,Math.floor(Math.sqrt(w)));!C;)v>g||v===w?C=!0:v=Object(X.G)(w,v+1);return v}function Xn(w,g,v){const C=[],$=w.length;for(let M=0;M<$;M++)M!==g?C.push(w[M]):C.push(v);return C}function Hn(w,g,v,C){const $=g.shape.length,M=w.shape.length;if(C!==0&&(C<-$||C>$))throw new Error(`Expect batchDims in the range of [-${$}, ${$}], but got ${C}`);if(C<0&&(C+=$),C>M)throw new Error(`batchDims (${C}) must be less than rank(x) (
    ${M}).`);if(v<C)throw new Error(`batchDims (${C}) must be less than or equal to axis (${v}).`);for(let Ve=0;Ve<C;++Ve)if(w.shape[Ve]!==g.shape[Ve])throw new Error(`x.shape[${Ve}]: ${w.shape[Ve]} should be equal to indices.shape[${Ve}]: ${g.shape[Ve]}.`);const W=w.shape[v],J=[];let le=1,ve=1,Xe=1;for(let Ve=0;Ve<C;++Ve)J.push(w.shape[Ve]),le*=w.shape[Ve];for(let Ve=C;Ve<v;Ve++)J.push(w.shape[Ve]),ve*=w.shape[Ve];for(let Ve=C;Ve<$;Ve++)J.push(g.shape[Ve]);for(let Ve=v+1;Ve<M;Ve++)J.push(w.shape[Ve]),Xe*=w.shape[Ve];return{batchSize:le,sliceSize:Xe,outerSize:ve,dimSize:W,outputShape:J}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(w){try{return w.map(g=>Object(To.decodeString)(g))}catch(g){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${g}`)}}function Wn(w){return w.map(g=>Object(To.encodeString)(g))}var vs=t(55),fs=t(51);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(s,e,t){t.d(e,"c",function(){return u}),t.d(e,"a",function(){return h}),t.d(e,"b",function(){return l});var n=t(3),r=t(9),a=t(14),o=t(15),i=t(6);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u(p,f){let x=p;if(Object(o.A)(p))return f==="string"?[]:[p.length];if(!Array.isArray(p))return[];const b=[];for(;Array.isArray(x)||Object(o.A)(x)&&f!=="string";)b.push(x.length),x=x[0];return Array.isArray(p)&&Object(r.c)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&c(p,b,[]),b}function c(p,f,x){if(x=x||[],!Array.isArray(p)&&!Object(o.A)(p))return void Object(o.b)(f.length===0,()=>`Element arr[${x.join("][")}] is a primitive, but should be an array/TypedArray of ${f[0]} elements`);Object(o.b)(f.length>0,()=>`Element arr[${x.join("][")}] should be a primitive, but is an array of ${p.length} elements`),Object(o.b)(p.length===f[0],()=>`Element arr[${x.join("][")}] should have ${f[0]} elements, but has ${p.length} elements`);const b=f.slice(1);for(let m=0;m<p.length;++m)c(p[m],b,x.concat(m))}function d(p,f,x,b){if(p!=="string_or_numeric"){if(p==null)throw new Error("Expected dtype cannot be null.");if(p!=="numeric"&&p!==f||p==="numeric"&&f==="string")throw new Error(`Argument '${x}' passed to '${b}' must be ${p} tensor, but got ${f} tensor`)}}function h(p,f,x,b="numeric"){if(p instanceof a.a)return d(b,p.dtype,f,x),p;let m=Object(o.r)(p);if(m!=="string"&&["bool","int32","float32"].indexOf(b)>=0&&(m=b),d(b,m,f,x),p==null||!Object(o.A)(p)&&!Array.isArray(p)&&typeof p!="number"&&typeof p!="boolean"&&typeof p!="string"){const E=p==null?"null":p.constructor.name;throw new Error(`Argument '${f}' passed to '${x}' must be a Tensor or TensorLike, but got '${E}'`)}const I=u(p,m);Object(o.A)(p)||Array.isArray(p)||(p=[p]);const N=m!=="string"?Object(i.toTypedArray)(p,m):Object(o.m)(p,[],!0);return n.a.makeTensor(N,I,m)}function l(p,f,x,b="numeric"){if(!Array.isArray(p))throw new Error(`Argument ${f} passed to ${x} must be a \`Tensor[]\` or \`TensorLike[]\``);return p.map((m,I)=>h(m,`${f}[${I}]`,x,b))}},function(s,e,t){t.d(e,"a",function(){return a}),t.d(e,"b",function(){return o});var n=t(3),r=t(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a="__op";function o(i){const u=Object.keys(i);if(u.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${u.length} keys.`);let c=u[0];const d=i[c];c.endsWith("_")&&(c=c.substring(0,c.length-1)),c+=a;const h=(...l)=>{n.a.startScope(c);try{const p=d(...l);return Object(r.x)(p)&&console.error("Cannot return a Promise inside of tidy."),n.a.endScope(p),p}catch(p){throw n.a.endScope(null),p}};return Object.defineProperty(h,"name",{value:c,configurable:!0}),h}},function(s,e,t){t.d(e,"b",function(){return N}),t.d(e,"a",function(){return E});var n=t(51),r=t(9),a=t(38),o=t(4),i=t(31),u=t(30),c=t(6),d=t(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h{constructor(L,Y){this.backendTimer=L,this.logger=Y,Y==null&&(this.logger=new p)}profileKernel(L,Y,V){let P;const oe=()=>{P=V()};let ne;const ge=c.now();if(this.backendTimer.timerAvailable())ne=this.backendTimer.time(oe);else{oe();for(const ye of P)ye.dataSync();ne=Promise.resolve({kernelMs:c.now()-ge})}if(Object(r.c)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let ye=0;ye<P.length;ye++){const Ee=P[ye];Ee.data().then(X=>{l(X,Ee.dtype,L)})}return{kernelName:L,outputs:P,inputs:Y,timeMs:ne.then(ye=>ye.kernelMs),extraInfo:ne.then(ye=>ye.getExtraProfileInfo!=null?ye.getExtraProfileInfo():"")}}logKernelProfile(L){const{kernelName:Y,outputs:V,timeMs:P,inputs:oe,extraInfo:ne}=L;V.forEach(ge=>{Promise.all([ge.data(),P,ne]).then(ye=>{this.logger.logKernelProfile(Y,ge,ye[0],ye[1],oe,ye[2])})})}}function l(U,L,Y){if(L!=="float32")return!1;for(let V=0;V<U.length;V++){const P=U[V];if(isNaN(P)||!isFinite(P))return console.warn(`Found ${P} in the result of '${Y}'`),!0}return!1}class p{logKernelProfile(L,Y,V,P,oe,ne){const ge=typeof P=="number"?d.L(`${P}ms`,9):P.error,ye=d.L(L,25),Ee=Y.rank,X=Y.size,je=d.L(Y.shape.toString(),14);let Be="";for(const tt in oe){const ct=oe[tt];if(ct!=null){const Me=ct.shape||Y.shape,wt=Me.length;Be+=`${tt}: ${wt}D ${wt>0?Me:""} `}}console.log(`%c${ye}	%c${ge}	%c${Ee}D ${je}	%c${X}	%c${Be}	%c${ne}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var f=t(14),x=t(10);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(U){return U.kernelName!=null}class m{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(L=>L.name)))}}}dispose(){for(const L in this.registeredVariables)this.registeredVariables[L].dispose()}}class I{constructor(L){this.ENV=L,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new m}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const L=this.getSortedBackends();for(let Y=0;Y<L.length;Y++){const V=L[Y];if(await this.initializeBackend(V).success)return void await this.setBackend(V)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:L,asyncInit:Y}=this.initializeBackendsAndReturnBest();if(Y)throw new Error(`The highest priority backend '${L}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(L)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(L){if(!(L in this.registry)){if(!(L in this.registryFactory))return null;{const{asyncInit:Y}=this.initializeBackend(L);if(Y)return null}}return this.registry[L]}findBackendFactory(L){return L in this.registryFactory?this.registryFactory[L].factory:null}registerBackend(L,Y,V=1){return L in this.registryFactory?(u.b(`${L} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[L]={factory:Y,priority:V},!0)}async setBackend(L){if(this.registryFactory[L]==null)throw new Error(`Backend name '${L}' not found in registry`);if(this.backendName=L,this.registry[L]==null){this.backendInstance=null;const{success:Y,asyncInit:V}=this.initializeBackend(L);if(!(V?await Y:Y))return!1}return this.backendInstance=this.registry[L],this.setupRegisteredKernels(),this.profiler=new h(this.backendInstance),!0}setupRegisteredKernels(){Object(i.d)(this.backendName).forEach(L=>{L.setupFunc!=null&&L.setupFunc(this.backendInstance)})}disposeRegisteredKernels(L){Object(i.d)(L).forEach(Y=>{Y.disposeFunc!=null&&Y.disposeFunc(this.registry[L])})}initializeBackend(L){const Y=this.registryFactory[L];if(Y==null)throw new Error(`Cannot initialize backend ${L}, no registration found.`);try{const V=Y.factory();if(!V||V instanceof n.b||typeof V.then!="function")return this.registry[L]=V,{success:!0,asyncInit:!1};{const P=++this.pendingBackendInitId,oe=V.then(ne=>!(P<this.pendingBackendInitId)&&(this.registry[L]=ne,this.pendingBackendInit=null,!0)).catch(ne=>(P<this.pendingBackendInitId||(this.pendingBackendInit=null,u.b(`Initialization of backend ${L} failed`),u.b(ne.stack||ne.message)),!1));return this.pendingBackendInit=oe,{success:oe,asyncInit:!0}}}catch(V){return u.b(`Initialization of backend ${L} failed`),u.b(V.stack||V.message),{success:!1,asyncInit:!1}}}removeBackend(L){if(!(L in this.registryFactory))throw new Error(`${L} backend not found in registry`);this.backendName===L&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,L in this.registry&&(this.disposeRegisteredKernels(L),this.registry[L].dispose(),delete this.registry[L]),delete this.registryFactory[L],this.backendName===L&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((L,Y)=>this.registryFactory[Y].priority-this.registryFactory[L].priority)}initializeBackendsAndReturnBest(){const L=this.getSortedBackends();for(let Y=0;Y<L.length;Y++){const V=L[Y],{success:P,asyncInit:oe}=this.initializeBackend(V);if(oe||P)return{name:V,asyncInit:oe}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(L,Y){const V=this.state.tensorInfo.get(Y),P=V.backend,oe=this.readSync(Y),ne=P.refCount(Y);P.disposeData(Y,!0),V.backend=L,L.move(Y,oe,V.shape,V.dtype,ne),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(L,Y){let V,P=null;if(Y==null){if(typeof L!="function")throw new Error("Please provide a function to tidy()");Y=L}else{if(typeof L!="string"&&!(L instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof Y!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");P=L}return this.scopedRun(()=>this.startScope(P),()=>this.endScope(V),()=>(V=Y(),V instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),V))}scopedRun(L,Y,V){L();try{const P=V();return Y(),P}catch(P){throw Y(),P}}nextTensorId(){return I.nextTensorId++}nextVariableId(){return I.nextVariableId++}clone(L){const Y=E.runKernel(o.tb,{x:L}),V={x:L};return this.addTapeNode(this.state.activeScope.name,V,[Y],P=>({x:()=>{const oe={x:P},ne={dtype:"float32"};return E.runKernel(o.x,oe,ne)}}),[],{}),Y}runKernel(L,Y,V){if(this.backendName==null&&this.backend,Object(i.c)(L,this.backendName)==null)throw new Error(`Kernel '${L}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:L,inputs:Y,attrs:V})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(L,Y,V){const P=this.backend.numDataIds();let oe=0;V.forEach(ye=>{oe+=ye.dtype==="complex64"?3:1});const ne=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],ge=P-Y-oe-ne;if(ge>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${ge} data ids) after running '${L}'`)}runKernelFunc(L){let Y,V=[];const P=this.isTapeOn(),oe=this.state.numBytes,ne=this.state.numTensors;let ge,ye;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),this.backendName==null&&this.backend;const Ee=b(L)?L.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(b(L)){const{kernelName:ct,inputs:Me,attrs:wt}=L;this.backendName==null&&this.backend;const at=Object(i.c)(ct,this.backendName);d.b(at!=null,()=>`Cannot find registered kernel '${ct}' for backend '${this.backendName}'`),ge=()=>{const Gt=this.backend.numDataIds();ye=at.kernelFunc({inputs:Me,attrs:wt,backend:this.backend});const Ht=Array.isArray(ye)?ye:[ye];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(ct,Gt,Ht);const dn=Ht.map(mn=>mn.rank!=null?mn:this.makeTensorFromTensorInfo(mn));if(P){const mn=this.getTensorsForGradient(ct,Me,dn);V=this.saveTensorsForBackwardMode(mn)}return dn}}else{const{forwardFunc:ct}=L,Me=wt=>{P&&(V=wt.map(at=>this.keep(this.clone(at))))};ge=()=>{const wt=this.backend.numDataIds();ye=this.tidy(()=>ct(this.backend,Me));const at=Array.isArray(ye)?ye:[ye];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Ee,wt,at),at}}const{inputs:X,attrs:je}=L,Be=b(L)?null:L.backwardsFunc;let tt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(tt=this.profiler.profileKernel(Ee,X,()=>ge()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(tt),Y=tt.outputs):Y=ge()}),P&&this.addTapeNode(Ee,X,Y,Be,V,je),this.state.profiling&&this.state.activeProfile.kernels.push({name:Ee,bytesAdded:this.state.numBytes-oe,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-ne,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(X).map(ct=>X[ct]!=null?X[ct].shape:null),outputShapes:Y.map(ct=>ct.shape),kernelTimeMs:tt.timeMs,extraInfo:tt.extraInfo}),Array.isArray(ye)?Y:Y[0]}saveTensorsForBackwardMode(L){return L.map(V=>this.keep(this.clone(V)))}getTensorsForGradient(L,Y,V){const P=Object(i.b)(L);if(P!=null){const oe=P.inputsToSave||[],ne=P.outputsToSave||[];let ge;P.saveAllInputs?(d.b(Array.isArray(Y),()=>"saveAllInputs is true, expected inputs to be an array."),ge=Object.keys(Y).map(Ee=>Y[Ee])):ge=oe.map(Ee=>Y[Ee]);const ye=V.filter((Ee,X)=>ne[X]);return ge.concat(ye)}return[]}makeTensor(L,Y,V,P){if(L==null)throw new Error("Values passed to engine.makeTensor() are null");V=V||"float32",P=P||this.backend;let oe=L;V==="string"&&d.z(L[0])&&(oe=L.map(ye=>c.encodeString(ye)));const ne=P.write(oe,Y,V),ge=new f.a(Y,V,ne,this.nextTensorId());if(this.trackTensor(ge,P),V==="string"){const ye=this.state.tensorInfo.get(ne),Ee=Object(d.f)(oe);this.state.numBytes+=Ee-ye.bytes,ye.bytes=Ee}return ge}makeTensorFromDataId(L,Y,V,P){const oe={dataId:L,shape:Y,dtype:V=V||"float32"};return this.makeTensorFromTensorInfo(oe,P)}makeTensorFromTensorInfo(L,Y){const{dataId:V,shape:P,dtype:oe}=L,ne=new f.a(P,oe,V,this.nextTensorId());return this.trackTensor(ne,Y),ne}makeVariable(L,Y=!0,V,P){V=V||this.nextVariableId().toString(),P!=null&&P!==L.dtype&&(L=L.cast(P));const oe=new f.c(L,Y,V,this.nextTensorId());if(this.state.registeredVariables[oe.name]!=null)throw new Error(`Variable with name ${oe.name} was already registered`);return this.state.registeredVariables[oe.name]=oe,this.incRef(oe,this.backend),oe}trackTensor(L,Y){this.state.numTensors++,L.dtype==="string"&&this.state.numStringTensors++;let V=0;L.dtype!=="complex64"&&L.dtype!=="string"&&(V=L.size*d.g(L.dtype)),this.state.numBytes+=V,this.state.tensorInfo.has(L.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(L.dataId,{backend:Y||this.backend,dtype:L.dtype,shape:L.shape,bytes:V})),L instanceof f.c||this.track(L)}incRef(L,Y){this.trackTensor(L,Y),this.backend.incRef(L.dataId)}removeDataId(L,Y){this.state.tensorInfo.has(L)&&this.state.tensorInfo.get(L).backend===Y&&(this.state.tensorInfo.delete(L),this.state.numDataBuffers--)}disposeTensor(L){if(!this.state.tensorInfo.has(L.dataId))return;const Y=this.state.tensorInfo.get(L.dataId);if(this.state.numTensors--,L.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=Y.bytes),L.dtype!=="complex64"&&L.dtype!=="string"){const V=L.size*d.g(L.dtype);this.state.numBytes-=V}Y.backend.disposeData(L.dataId)&&this.removeDataId(L.dataId,Y.backend)}disposeVariables(){for(const L in this.state.registeredVariables){const Y=this.state.registeredVariables[L];this.disposeVariable(Y)}}disposeVariable(L){this.disposeTensor(L),this.state.registeredVariables[L.name]!=null&&delete this.state.registeredVariables[L.name]}memory(){const L=this.backend.memory();return L.numTensors=this.state.numTensors,L.numDataBuffers=this.state.numDataBuffers,L.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(L.unreliable=!0,L.reasons==null&&(L.reasons=[]),L.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),L}async profile(L){this.state.profiling=!0;const Y=this.state.numBytes,V=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await L(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(P=>P.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-Y,this.state.activeProfile.newTensors=this.state.numTensors-V;for(const P of this.state.activeProfile.kernels)P.kernelTimeMs=await P.kernelTimeMs,P.extraInfo=await P.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(L,Y,V,P,oe,ne){const ge={id:this.state.nextTapeNodeId++,kernelName:L,inputs:Y,outputs:V,saved:oe},ye=Object(i.b)(L);ye!=null&&(P=ye.gradFunc),P!=null&&(ge.gradient=Ee=>(Ee=Ee.map((X,je)=>{if(X==null){const Be=V[je],tt=d.F(Be.size,Be.dtype);return this.makeTensor(tt,Be.shape,Be.dtype)}return X}),P(Ee.length>1?Ee:Ee[0],oe,ne))),this.state.activeTape.push(ge)}keep(L){return L.kept=!0,L}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(L){const Y={track:[],name:"unnamed scope",id:this.state.nextScopeId++};L&&(Y.name=L),this.state.scopeStack.push(Y),this.state.activeScope=Y}endScope(L){const Y=Object(x.getTensorsInContainer)(L),V=new Set(Y.map(oe=>oe.id));for(let oe=0;oe<this.state.activeScope.track.length;oe++){const ne=this.state.activeScope.track[oe];ne.kept||V.has(ne.id)||ne.dispose()}const P=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],Y.forEach(oe=>{oe.kept||oe.scopeId!==P.id||this.track(oe)})}gradients(L,Y,V,P=!1){if(d.b(Y.length>0,()=>"gradients() received an empty list of xs."),V!=null&&V.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${V.dtype}'`);const oe=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",L));d.b(oe instanceof f.a,()=>"The result y returned by f() must be a tensor.");const ne=function(ge,ye,Ee){const X={},je={};for(let Me=0;Me<ye.length;Me++)X[ye[Me].id]=!0;for(let Me=0;Me<ge.length;Me++){const wt=ge[Me],at=wt.inputs;for(const Gt in at){const Ht=at[Gt];let dn=!1;for(let mn=0;mn<ye.length;mn++)if(X[Ht.id]){wt.outputs.forEach(Rn=>X[Rn.id]=!0),dn=!0,je[wt.id]=!0;break}if(dn)break}}const Be={};Be[Ee.id]=!0;const tt={};for(let Me=ge.length-1;Me>=0;Me--){const wt=ge[Me],at=wt.inputs;for(let Gt=0;Gt<wt.outputs.length;Gt++)if(Be[wt.outputs[Gt].id]){for(const Ht in at)Be[at[Ht].id]=!0,tt[wt.id]=!0;break}}const ct=[];for(let Me=0;Me<ge.length;Me++){const wt=ge[Me];if(je[wt.id]&&tt[wt.id]){const at={};for(const Ht in wt.inputs){const dn=wt.inputs[Ht];X[dn.id]&&(at[Ht]=dn)}const Gt=Object.assign({},wt);Gt.inputs=at,Gt.outputs=wt.outputs,ct.push(Gt)}}return ct}(this.state.activeTape,Y,oe);if(!P&&ne.length===0&&Y.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const ge={};ge[oe.id]=V==null?function(Ee){const X=Object(d.D)(Object(d.O)(Ee),"float32");return E.makeTensor(X,Ee,"float32")}(oe.shape):V,function(Ee,X,je,Be){for(let tt=X.length-1;tt>=0;tt--){const ct=X[tt],Me=[];if(ct.outputs.forEach(at=>{const Gt=Ee[at.id];Gt!=null?Me.push(Gt):Me.push(null)}),ct.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${ct.kernelName}.`);const wt=ct.gradient(Me);for(const at in ct.inputs){if(!(at in wt))throw new Error(`Cannot backprop through input ${at}. Available gradients found: ${Object.keys(wt)}.`);const Gt=je(()=>wt[at]());if(Gt.dtype!=="float32")throw new Error(`Error in gradient for op ${ct.kernelName}. The gradient of input ${at} must have 'float32' dtype, but has '${Gt.dtype}'`);const Ht=ct.inputs[at];if(!d.a(Gt.shape,Ht.shape))throw new Error(`Error in gradient for op ${ct.kernelName}. The gradient of input '${at}' has shape '${Gt.shape}', which does not match the shape of the input '${Ht.shape}'`);if(Ee[Ht.id]==null)Ee[Ht.id]=Gt;else{const dn=Ee[Ht.id];Ee[Ht.id]=Be(dn,Gt),dn.dispose()}}}}(ge,ne,Ee=>this.tidy(Ee),D);const ye=Y.map(Ee=>ge[Ee.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(Ee=>{for(const X of Ee.saved)X.dispose()}),this.state.activeTape=null),{value:oe,grads:ye}})}customGrad(L){return d.b(d.u(L),()=>"The f passed in customGrad(f) must be a function."),(...Y)=>{let V;d.b(Y.every(oe=>oe instanceof f.a),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const P={};return Y.forEach((oe,ne)=>{P[ne]=oe}),this.runKernelFunc({forwardFunc:(oe,ne)=>(V=L(...Y,ne),d.b(V.value instanceof f.a,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),d.b(d.u(V.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),V.value),backwardsFunc:(oe,ne)=>{const ge=V.gradFunc(oe,ne),ye=Array.isArray(ge)?ge:[ge];d.b(ye.length===Y.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),d.b(ye.every(X=>X instanceof f.a),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Ee={};return ye.forEach((X,je)=>{Ee[je]=()=>X}),Ee},inputs:P})}}readSync(L){return this.state.tensorInfo.get(L).backend.readSync(L)}read(L){return this.state.tensorInfo.get(L).backend.read(L)}readToGPU(L,Y){return this.state.tensorInfo.get(L).backend.readToGPU(L,Y)}async time(L){const Y=Object(c.now)(),V=await this.backend.time(L);return V.wallMs=Object(c.now)()-Y,V}track(L){return this.state.activeScope!=null&&(L.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(L)),L}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new m;for(const L in this.registry)this.disposeRegisteredKernels(L),this.registry[L].dispose(),delete this.registry[L];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function N(){const U=Object(a.b)();if(U._tfengine==null){const L=new r.b(U);U._tfengine=new I(L)}return Object(r.d)(U._tfengine.ENV),Object(f.f)(()=>U._tfengine),U._tfengine}I.nextTensorId=0,I.nextVariableId=0;const E=N();function D(U,L){const Y={a:U,b:L};return E.runKernel(o.d,Y)}},function(s,e,t){t.d(e,"a",function(){return n}),t.d(e,"b",function(){return r}),t.d(e,"c",function(){return a}),t.d(e,"d",function(){return o}),t.d(e,"e",function(){return i}),t.d(e,"f",function(){return u}),t.d(e,"g",function(){return c}),t.d(e,"h",function(){return d}),t.d(e,"i",function(){return h}),t.d(e,"j",function(){return l}),t.d(e,"k",function(){return p}),t.d(e,"l",function(){return f}),t.d(e,"n",function(){return x}),t.d(e,"m",function(){return b}),t.d(e,"o",function(){return m}),t.d(e,"r",function(){return I}),t.d(e,"p",function(){return N}),t.d(e,"q",function(){return E}),t.d(e,"s",function(){return D}),t.d(e,"t",function(){return U}),t.d(e,"u",function(){return L}),t.d(e,"w",function(){return Y}),t.d(e,"v",function(){return V}),t.d(e,"x",function(){return P}),t.d(e,"y",function(){return oe}),t.d(e,"z",function(){return ne}),t.d(e,"A",function(){return ge}),t.d(e,"B",function(){return ye}),t.d(e,"C",function(){return Ee}),t.d(e,"D",function(){return X}),t.d(e,"E",function(){return je}),t.d(e,"F",function(){return Be}),t.d(e,"G",function(){return tt}),t.d(e,"H",function(){return ct}),t.d(e,"I",function(){return Me}),t.d(e,"J",function(){return wt}),t.d(e,"K",function(){return at}),t.d(e,"M",function(){return Gt}),t.d(e,"N",function(){return Ht}),t.d(e,"L",function(){return dn}),t.d(e,"O",function(){return mn}),t.d(e,"P",function(){return Rn}),t.d(e,"Q",function(){return ee}),t.d(e,"R",function(){return se}),t.d(e,"S",function(){return we}),t.d(e,"T",function(){return pt}),t.d(e,"U",function(){return bt}),t.d(e,"W",function(){return At}),t.d(e,"V",function(){return $e}),t.d(e,"qc",function(){return ht}),t.d(e,"X",function(){return Pt}),t.d(e,"Y",function(){return Ot}),t.d(e,"Z",function(){return xn}),t.d(e,"bb",function(){return Dn}),t.d(e,"ab",function(){return pe}),t.d(e,"cb",function(){return be}),t.d(e,"db",function(){return Qe}),t.d(e,"eb",function(){return Un}),t.d(e,"fb",function(){return Ws}),t.d(e,"gb",function(){return Gs}),t.d(e,"hb",function(){return As}),t.d(e,"ib",function(){return xs}),t.d(e,"jb",function(){return ds}),t.d(e,"lb",function(){return Ys}),t.d(e,"pb",function(){return pn}),t.d(e,"ob",function(){return Nn}),t.d(e,"qb",function(){return ts}),t.d(e,"rb",function(){return $s}),t.d(e,"tb",function(){return Ns}),t.d(e,"sb",function(){return ys}),t.d(e,"ub",function(){return Vs}),t.d(e,"vb",function(){return Us}),t.d(e,"wb",function(){return jt}),t.d(e,"xb",function(){return re}),t.d(e,"Ab",function(){return de}),t.d(e,"Bb",function(){return ot}),t.d(e,"Cb",function(){return Ct}),t.d(e,"Db",function(){return Yt}),t.d(e,"Eb",function(){return on}),t.d(e,"Fb",function(){return tn}),t.d(e,"Hb",function(){return bn}),t.d(e,"Ib",function(){return On}),t.d(e,"Jb",function(){return Mn}),t.d(e,"Kb",function(){return wn}),t.d(e,"Gb",function(){return gs}),t.d(e,"Lb",function(){return Hs}),t.d(e,"yb",function(){return xr}),t.d(e,"zb",function(){return Ir}),t.d(e,"Mb",function(){return qs}),t.d(e,"Sb",function(){return ta}),t.d(e,"Nb",function(){return pa}),t.d(e,"Qb",function(){return rr}),t.d(e,"Ob",function(){return eo}),t.d(e,"Pb",function(){return Qs}),t.d(e,"Rb",function(){return mr}),t.d(e,"Tb",function(){return $r}),t.d(e,"Ub",function(){return ia}),t.d(e,"Vb",function(){return Pr}),t.d(e,"Wb",function(){return Cr}),t.d(e,"Xb",function(){return Ba}),t.d(e,"Yb",function(){return za}),t.d(e,"Zb",function(){return to}),t.d(e,"ac",function(){return Wo}),t.d(e,"ec",function(){return si}),t.d(e,"bc",function(){return fo}),t.d(e,"cc",function(){return no}),t.d(e,"dc",function(){return Ta}),t.d(e,"gc",function(){return mo}),t.d(e,"fc",function(){return Ar}),t.d(e,"hc",function(){return Na}),t.d(e,"ic",function(){return Ea}),t.d(e,"jc",function(){return Vo}),t.d(e,"kc",function(){return So}),t.d(e,"lc",function(){return so}),t.d(e,"mc",function(){return Zs}),t.d(e,"nc",function(){return Kr}),t.d(e,"oc",function(){return Ra}),t.d(e,"pc",function(){return fa}),t.d(e,"rc",function(){return na}),t.d(e,"sc",function(){return $o}),t.d(e,"uc",function(){return We}),t.d(e,"xc",function(){return It}),t.d(e,"yc",function(){return Ut}),t.d(e,"vc",function(){return sn}),t.d(e,"wc",function(){return vn}),t.d(e,"tc",function(){return fn}),t.d(e,"zc",function(){return Vn}),t.d(e,"Bc",function(){return hs}),t.d(e,"Cc",function(){return Es}),t.d(e,"Dc",function(){return dr}),t.d(e,"Ec",function(){return Js}),t.d(e,"Fc",function(){return ga}),t.d(e,"Gc",function(){return ur}),t.d(e,"Lc",function(){return Or}),t.d(e,"Jc",function(){return ro}),t.d(e,"Kc",function(){return Wa}),t.d(e,"Ic",function(){return Va}),t.d(e,"Hc",function(){return Qi}),t.d(e,"Nc",function(){return _i}),t.d(e,"Vc",function(){return ri}),t.d(e,"ed",function(){return $u}),t.d(e,"Oc",function(){return go}),t.d(e,"Uc",function(){return bo}),t.d(e,"Mc",function(){return Ua}),t.d(e,"Pc",function(){return Wr}),t.d(e,"Qc",function(){return Ji}),t.d(e,"Rc",function(){return Xr}),t.d(e,"Sc",function(){return ja}),t.d(e,"Tc",function(){return To}),t.d(e,"Xc",function(){return ai}),t.d(e,"Wc",function(){return Tu}),t.d(e,"Zc",function(){return oi}),t.d(e,"ad",function(){return Uo}),t.d(e,"bd",function(){return Nu}),t.d(e,"cd",function(){return Ls}),t.d(e,"dd",function(){return Lr}),t.d(e,"fd",function(){return ao}),t.d(e,"gd",function(){return Si}),t.d(e,"hd",function(){return eu}),t.d(e,"id",function(){return No}),t.d(e,"jd",function(){return $i}),t.d(e,"kd",function(){return Ti}),t.d(e,"ld",function(){return ii}),t.d(e,"md",function(){return bs}),t.d(e,"nd",function(){return jn}),t.d(e,"od",function(){return hr}),t.d(e,"pd",function(){return Gn}),t.d(e,"Yc",function(){return Aa}),t.d(e,"kb",function(){return Vr}),t.d(e,"Ac",function(){return ua}),t.d(e,"qd",function(){return tu}),t.d(e,"mb",function(){return ui}),t.d(e,"nb",function(){return jo});const n="Abs",r="Acos",a="Acosh",o="Add",i="AddN",u="All",c="Any",d="ArgMax",h="ArgMin",l="Asin",p="Asinh",f="Atan",x="Atanh",b="Atan2",m="AvgPool",I="AvgPoolGrad",N="AvgPool3D",E="AvgPool3DGrad",D="BatchMatMul",U="BatchToSpaceND",L="Bincount",Y="BroadcastTo",V="BroadcastArgs",P="Cast",oe="Ceil",ne="ClipByValue",ge="Complex",ye="ComplexAbs",Ee="Concat",X="Conv2D",je="Conv2DBackpropFilter",Be="Conv2DBackpropInput",tt="Conv3D",ct="Conv3DBackpropFilterV2",Me="Conv3DBackpropInputV2",wt="Cos",at="Cosh",Gt="Cumprod",Ht="Cumsum",dn="CropAndResize",mn="DenseBincount",Rn="DepthToSpace",ee="DepthwiseConv2dNative",se="DepthwiseConv2dNativeBackpropFilter",we="DepthwiseConv2dNativeBackpropInput",pt="Diag",bt="Dilation2D",At="Dilation2DBackpropInput",$e="Dilation2DBackpropFilter",ht="RealDiv",Pt="Einsum",Ot="Elu",xn="EluGrad",Dn="Erf",pe="Equal",be="Exp",Qe="ExpandDims",Un="Expm1",Ws="FFT",Gs="Fill",As="FlipLeftRight",xs="Floor",ds="FloorDiv",Ys="FusedBatchNorm",pn="GatherV2",Nn="GatherNd",ts="Greater",$s="GreaterEqual",Ns="Identity",ys="IFFT",Vs="Imag",Us="IsFinite",jt="IsInf",re="IsNan",de="LeakyRelu",ot="Less",Ct="LessEqual",Yt="LinSpace",on="Log",tn="Log1p",bn="LogicalAnd",On="LogicalNot",Mn="LogicalOr",wn="LogicalXor",gs="LogSoftmax",Hs="LowerBound",xr="LRN",Ir="LRNGrad",qs="Max",ta="Maximum",pa="MaxPool",rr="MaxPoolGrad",eo="MaxPool3D",Qs="MaxPool3DGrad",mr="MaxPoolWithArgmax",$r="Mean",ia="Min",Pr="Minimum",Cr="MirrorPad",Ba="Mod",za="Multinomial",to="Multiply",Wo="Neg",si="NotEqual",fo="NonMaxSuppressionV3",no="NonMaxSuppressionV4",Ta="NonMaxSuppressionV5",mo="OnesLike",Ar="OneHot",Na="Pack",Ea="PadV2",Vo="Pool",So="Pow",so="Prelu",Zs="Prod",Kr="RaggedTensorToTensor",Ra="Range",fa="Real",na="Reciprocal",$o="Relu",We="Reshape",It="ResizeNearestNeighbor",Ut="ResizeNearestNeighborGrad",sn="ResizeBilinear",vn="ResizeBilinearGrad",fn="Relu6",Vn="Reverse",hs="Round",Es="Rsqrt",dr="ScatterNd",Js="SearchSorted",ga="Select",ur="Selu",Or="Slice",ro="Sin",Wa="Sinh",Va="Sign",Qi="Sigmoid",_i="Softplus",ri="Sqrt",$u="Sum",go="SpaceToBatchND",bo="SplitV",Ua="Softmax",Wr="SparseFillEmptyRows",Ji="SparseReshape",Xr="SparseSegmentMean",ja="SparseSegmentSum",To="SparseToDense",ai="SquaredDifference",Tu="Square",oi="StridedSlice",Uo="StringNGrams",Nu="StringSplit",Ls="StringToHashBucketFast",Lr="Sub",ao="Tan",Si="Tanh",eu="Tile",No="TopK",$i="Transform",Ti="Transpose",ii="Unique",bs="Unpack",jn="UnsortedSegmentSum",hr="UpperBound",Gn="ZerosLike",Aa="Step",Vr="FromPixels",ua="RotateWithOffset",tu="_FusedMatMul",ui="FusedConv2D",jo="FusedDepthwiseConv2D"},function(s,e,t){t.d(e,"a",function(){return o}),t.d(e,"i",function(){return i}),t.d(e,"j",function(){return u}),t.d(e,"k",function(){return c}),t.d(e,"l",function(){return d}),t.d(e,"m",function(){return h}),t.d(e,"n",function(){return l}),t.d(e,"h",function(){return p}),t.d(e,"d",function(){return f}),t.d(e,"s",function(){return x}),t.d(e,"u",function(){return b}),t.d(e,"v",function(){return m}),t.d(e,"e",function(){return I}),t.d(e,"p",function(){return N}),t.d(e,"r",function(){return E}),t.d(e,"t",function(){return D}),t.d(e,"q",function(){return U}),t.d(e,"o",function(){return L}),t.d(e,"b",function(){return Y}),t.d(e,"g",function(){return V}),t.d(e,"c",function(){return P}),t.d(e,"f",function(){return oe});var n=t(0),r=t(39),a=t(11);function o(ne,ge){if(!ne)throw new Error(ge)}function i(ne){return typeof ne=="boolean"}function u(ne){return typeof ne=="number"&&Number.isInteger(ne)}function c(ne){return ne instanceof Array&&ne.every(ge=>u(ge))}function d(ne){return ne instanceof Array&&ne.every(ge=>u(ge)&&ge>0||ge===null)}function h(ne){return ne instanceof Float32Array||ne instanceof Int32Array||ne instanceof Uint32Array||ne instanceof Int16Array||ne instanceof Uint16Array||ne instanceof Int8Array||ne instanceof Uint8Array}function l(ne){return ne[0]===0&&ne[1]===1||ne[0]===1&&ne[1]===2||ne[0]===2&&ne[1]===3}function p(ne){if(ne==="float32")return Float32Array;if(ne==="int32")return Int32Array;if(ne==="uint32")return Uint32Array;if(ne==="float16")return Uint16Array;if(ne==="int8")return Int8Array;if(ne==="uint8")return Uint8Array;throw new Error("Type is not supported.")}function f(ne){let ge;return ne.dtype==="float32"?ge=a.d.float32:ne.dtype==="int32"&&(ge=a.d.int32),{type:ge,dimensions:ne.shape}}function x(ne){o(ne.type in a.d,"The operand type is invalid."),ne.dimensions&&o(c(ne.dimensions),"The dimensions is invalid.")}function b(ne,ge,ye){o(h(ne),"The value is not a typed array."),o(ne instanceof p(ge),"The type of value is invalid."),o(ne.length===N(ye),`the value length ${ne.length} is invalid, size of [${ye}] ${N(ye)} is expected.`)}function m(ne,ge){ge===a.d.int32?o(Number.isInteger(ne),"the value is not an int32."):ge===a.d.uint32?o(Number.isInteger(ne)&&ne>=0,"the value is not an uint32."):ge===a.d.int8?o(Number.isInteger(ne)&&ne>=-128&&ne<=127,"the value is not an int8."):ge===a.d.uint8&&o(Number.isInteger(ne)&&ne>=0&&ne<=255,"the value is not an uint8.")}function I(ne,ge){const ye=function(Ee){if(Ee==="float32")return"float32";if(Ee==="int32")return"int32";throw new Error("The operand type is not supported by TF.js.")}(ne.type);if(ne.dimensions!==void 0){o(h(ge),"Only ArrayBufferView value is supported.");const Ee=ge;b(Ee,ne.type,ne.dimensions);const X=function(je){let Be;if(je instanceof Float32Array)Be=new Float32Array(je.length);else if(je instanceof Int32Array)Be=new Int32Array(je.length);else if(je instanceof Uint32Array)Be=new Uint32Array(je.length);else if(je instanceof Uint16Array)Be=new Uint16Array(je.length);else if(je instanceof Int8Array)Be=new Int8Array(je.length);else{if(!(je instanceof Uint8Array))throw new Error("Type is not supported.");Be=new Uint8Array(je.length)}return Be.set(je),Be}(Ee);return n.tensor(X,ne.dimensions,ye)}return typeof ge=="number"?(m(ge,ne.type),n.scalar(ge,ye)):(b(ge,ne.type,ne.dimensions),n.scalar(ge[0],ye))}function N(ne){return ne===void 0||c(ne)&&ne.length===0?1:ne.reduce((ge,ye)=>ye>0?ge*ye:ge,1)}function E(ne,ge=""){o(ne instanceof a.c,`The parameter ${ge} is not an operand.`)}function D(ne,ge=""){o(ne===void 0||ne instanceof a.c,`The parameter ${ge} is not an optional operand.`)}function U(ne,ge){if(typeof ne!="undefined"&&ne.length>0){for(let ye=0;ye<ne.length;++ye)if(ne[ye]>=ge||ne[ye]<-ge)return!1}return!0}function L(ne){return ne.reduce((ge,ye)=>ge*ye)}function Y(ne,ge){o(ne.length===ge.length,`The actual length ${ne.length} is not equal to expected length ${ge.length}.`);for(let ye=0;ye<ne.length;++ye)o(ne[ye]===ge[ye],`${ne[ye]} is not equal to ${ge[ye]} of index ${ye}.`)}function V(ne,ge,ye,Ee,X,je,Be){let tt;if(je===r.a.explicit)tt=[[0,0],[ye[0],ye[1]],[ye[2],ye[3]],[0,0]];else{tt=[[0,0],[0,0],[0,0],[0,0]];const ct=[0,0];if(Be===void 0)for(let Me=0;Me<2;++Me)ct[Me]=Ee[Me]*(Math.ceil(ne.shape[1+Me]/Ee[Me])-1)+((ge.shape[Me]-1)*X[Me]+1)-ne.shape[1+Me];else for(let Me=0;Me<2;++Me)ct[Me]=(ne.shape[1+Me]-1)*Ee[Me]+ge.shape[Me]+(ge.shape[Me]-1)*(X[Me]-1)+Be[Me]-ne.shape[1+Me]*Ee[Me];if(je===r.a["same-upper"])for(let Me=0;Me<2;++Me)tt[Me+1][0]=ct[Me]-Math.ceil(ct[Me]/2),tt[Me+1][1]=Math.ceil(ct[Me]/2);else for(let Me=0;Me<2;++Me)tt[Me+1][0]=ct[Me]-Math.floor(ct[Me]/2),tt[Me+1][1]=Math.floor(ct[Me]/2)}return tt}function P(ne,ge,ye,Ee,X,je,Be){const tt=((ye+X-1)/X-1)*X+(Ee+(Ee-1)*(ge-1)),ct=tt>ye?tt-ye:0;switch(ne){case r.a["same-upper"]:je=Math.floor(ct/2),Be=Math.floor((ct+1)/2);break;case r.a["same-lower"]:je=Math.floor((ct+1)/2),Be=Math.floor(ct/2)}return[je,Be]}function oe(ne,ge){const ye=[],Ee=ne.length,X=ge.length,je=Math.max(Ee,X);for(let Be=0;Be<je;++Be){let tt=ne[Ee-Be-1];tt===void 0&&(tt=1);let ct=ge[X-Be-1];if(ct===void 0&&(ct=1),tt===1)ye.unshift(ct);else if(ct===1)ye.unshift(tt);else{if(tt!==ct)throw new Error(`Shapes [${ne}] and [${ge}] are incompatible.`);ye.unshift(tt)}}return ye}},function(s,e,t){t.r(e),t.d(e,"shuffle",function(){return r.M}),t.d(e,"shuffleCombo",function(){return r.N}),t.d(e,"clamp",function(){return r.i}),t.d(e,"nearestLargerEven",function(){return r.H}),t.d(e,"swap",function(){return r.S}),t.d(e,"sum",function(){return r.R}),t.d(e,"randUniform",function(){return r.J}),t.d(e,"distSquared",function(){return r.l}),t.d(e,"assert",function(){return r.b}),t.d(e,"assertShapesMatch",function(){return r.e}),t.d(e,"assertNonNull",function(){return r.d}),t.d(e,"flatten",function(){return r.m}),t.d(e,"sizeFromShape",function(){return r.O}),t.d(e,"isScalarShape",function(){return r.y}),t.d(e,"arraysEqual",function(){return r.a}),t.d(e,"isInt",function(){return r.v}),t.d(e,"tanh",function(){return r.T}),t.d(e,"sizeToSquarishShape",function(){return r.P}),t.d(e,"createShuffledIndices",function(){return r.k}),t.d(e,"rightPad",function(){return r.L}),t.d(e,"repeatedTry",function(){return r.K}),t.d(e,"inferFromImplicitShape",function(){return r.s}),t.d(e,"parseAxisParam",function(){return r.I}),t.d(e,"squeezeShape",function(){return r.Q}),t.d(e,"getTypedArrayFromDType",function(){return r.o}),t.d(e,"getArrayFromDType",function(){return r.n}),t.d(e,"checkConversionForErrors",function(){return r.h}),t.d(e,"isValidDtype",function(){return r.B}),t.d(e,"hasEncodingLoss",function(){return r.p}),t.d(e,"isTypedArray",function(){return r.A}),t.d(e,"bytesPerElement",function(){return r.g}),t.d(e,"bytesFromStringArray",function(){return r.f}),t.d(e,"isString",function(){return r.z}),t.d(e,"isBoolean",function(){return r.t}),t.d(e,"isNumber",function(){return r.w}),t.d(e,"inferDtype",function(){return r.r}),t.d(e,"isFunction",function(){return r.u}),t.d(e,"nearestDivisor",function(){return r.G}),t.d(e,"computeStrides",function(){return r.j}),t.d(e,"toNestedArray",function(){return r.U}),t.d(e,"makeOnesTypedArray",function(){return r.D}),t.d(e,"makeZerosTypedArray",function(){return r.F}),t.d(e,"makeZerosNestedTypedArray",function(){return r.E}),t.d(e,"assertNonNegativeIntegerDimensions",function(){return r.c}),t.d(e,"locToIndex",function(){return r.C}),t.d(e,"indexToLoc",function(){return r.q}),t.d(e,"isPromise",function(){return r.x}),t.d(e,"hexToLong",function(){return i}),t.d(e,"fingerPrint64",function(){return I}),t.d(e,"createScalarValue",function(){return N}),t.d(e,"toTypedArray",function(){return E}),t.d(e,"now",function(){return D}),t.d(e,"fetch",function(){return U}),t.d(e,"encodeString",function(){return L}),t.d(e,"decodeString",function(){return Y});var n=t(9),r=t(15),a=t(92);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=t.n(a).a||a;function i(V){return o.fromString(V,!0,16)}const u=i("c3a5c85c97cb3127"),c=i("b492b66fbe98f273"),d=i("9ae16a3b2f90404f");function h(V){return V.xor(V.shru(47))}function l(V,P,oe){const ne=V.slice(P,P+oe);return o.fromBytes(Array.from(ne),!0,!0)}function p(V,P){return l(V,P,8)}function f(V,P){return l(V,P,4)}function x(V,P){return P===0?V:V.shru(P).or(V.shl(64-P))}function b(V,P,oe=i("9ddfea08eb382d69")){let ne=V.xor(P).mul(oe);ne=ne.xor(ne.shru(47));let ge=P.xor(ne).mul(oe);return ge=ge.xor(ge.shru(47)),ge=ge.mul(oe),ge}function m(V,P,oe,ne){return function(ge,ye,Ee,X,je,Be){je=je.add(ge),Be=x(Be.add(je).add(X),21);const tt=je;return je=(je=je.add(ye)).add(Ee),Be=Be.add(x(je,44)),[je.add(X),Be.add(tt)]}(p(V,P),p(V,P+8),p(V,P+16),p(V,P+24),oe,ne)}function I(V,P=V.length){const oe=o.fromNumber(81,!0);if(P<=32)return P<=16?function(Me,wt=Me.length){if(wt>=8){const at=d.add(2*wt),Gt=p(Me,0).add(d),Ht=p(Me,wt-8);return b(x(Ht,37).mul(at).add(Gt),x(Gt,25).add(Ht).mul(at),at)}if(wt>=4){const at=d.add(2*wt);return b(f(Me,0).shl(3).add(wt),f(Me,wt-4),at)}if(wt>0){const at=Me[0]+(Me[wt>>1]<<8),Gt=wt+(Me[wt-1]<<2);return h(d.mul(at).xor(u.mul(Gt))).mul(d)}return d}(V,P):function(Me,wt=Me.length){const at=d.add(2*wt),Gt=p(Me,0).mul(c),Ht=p(Me,8),dn=p(Me,wt-8).mul(at),mn=p(Me,wt-16).mul(d);return b(x(Gt.add(Ht),43).add(x(dn,30)).add(mn),Gt.add(x(Ht.add(d),18)).add(dn),at)}(V,P);if(P<=64)return function(Me,wt=Me.length){const at=d.add(2*wt),Gt=p(Me,0).mul(d),Ht=p(Me,8),dn=p(Me,wt-8).mul(at),mn=p(Me,wt-16).mul(d),Rn=x(Gt.add(Ht),43).add(x(dn,30)).add(mn),ee=b(Rn,Gt.add(x(Ht.add(d),18)).add(dn),at),se=p(Me,16).mul(at),we=p(Me,24),pt=Rn.add(p(Me,wt-32)).mul(at),bt=ee.add(p(Me,wt-24)).mul(at);return b(x(se.add(we),43).add(x(pt,30)).add(bt),se.add(x(we.add(Gt),18)).add(pt),at)}(V,P);let ne=oe,ge=oe.mul(c).add(113),ye=h(ge.mul(d).add(113)).mul(d),Ee=[o.UZERO,o.UZERO],X=[o.UZERO,o.UZERO];ne=ne.mul(d).add(p(V,0));let je=0;const Be=64*(P-1>>6),tt=Be+(P-1&63)-63;do ne=x(ne.add(ge).add(Ee[0]).add(p(V,je+8)),37).mul(c),ge=x(ge.add(Ee[1]).add(p(V,je+48)),42).mul(c),ne=ne.xor(X[1]),ge=ge.add(Ee[0]).add(p(V,je+40)),ye=x(ye.add(X[0]),33).mul(c),Ee=m(V,je,Ee[1].mul(c),ne.add(X[0])),X=m(V,je+32,ye.add(X[1]),ge.add(p(V,je+16))),[ye,ne]=[ne,ye],je+=64;while(je!==Be);const ct=c.add(ye.and(255).shl(1));return je=tt,X[0]=X[0].add(P-1&63),Ee[0]=Ee[0].add(X[0]),X[0]=X[0].add(Ee[0]),ne=x(ne.add(ge).add(Ee[0]).add(p(V,je+8)),37).mul(ct),ge=x(ge.add(Ee[1]).add(p(V,je+48)),42).mul(ct),ne=ne.xor(X[1].mul(9)),ge=ge.add(Ee[0].mul(9).add(p(V,je+40))),ye=x(ye.add(X[0]),33).mul(ct),Ee=m(V,je,Ee[1].mul(ct),ne.add(X[0])),X=m(V,je+32,ye.add(X[1]),ge.add(p(V,je+16))),[ye,ne]=[ne,ye],b(b(Ee[0],X[0],ct).add(h(ge).mul(u)).add(ye),b(Ee[1],X[1],ct).add(ne),ct)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(V,P){return P==="string"?L(V):E([V],P)}function E(V,P){if(P==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(V)&&(V=r.m(V)),Object(n.c)().getBool("DEBUG")&&r.h(V,P),function(oe,ne){return oe instanceof Float32Array&&ne==="float32"||oe instanceof Int32Array&&ne==="int32"||oe instanceof Uint8Array&&ne==="bool"}(V,P))return V;if(P==null||P==="float32"||P==="complex64")return new Float32Array(V);if(P==="int32")return new Int32Array(V);if(P==="bool"){const oe=new Uint8Array(V.length);for(let ne=0;ne<oe.length;++ne)Math.round(V[ne])!==0&&(oe[ne]=1);return oe}throw new Error(`Unknown data type ${P}`)}function D(){return Object(n.c)().platform.now()}function U(V,P){return Object(n.c)().platform.fetch(V,P)}function L(V,P="utf-8"){return P=P||"utf-8",Object(n.c)().platform.encode(V,P)}function Y(V,P="utf-8"){return P=P||"utf-8",Object(n.c)().platform.decode(V,P)}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o){Array.isArray(a)||(a=[a]),a.forEach(i=>{i!=null&&n.util.assert(i.dtype!=="complex64",()=>`${o} does not support complex64 tensors in the CPU backend.`)})}},function(s,e,t){t.d(e,"a",function(){return a}),t.d(e,"b",function(){return o});var n=t(0),r=t(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(i,u,c){return({inputs:d,attrs:h,backend:l})=>{const{x:p}=d;if(Object(r.a)(p,i),p.dtype==="string"||c==="string")throw new Error("unaryKernelFunc does not support string input/output");const f=l,x=f.data.get(p.dataId).values,b=n.util.sizeFromShape(p.shape),m=c||p.dtype,I=n.util.getArrayFromDType(m,b);for(let N=0;N<b;++N)I[N]=u(x[N],h);return f.makeTensorInfo(p.shape,m,I)}}function o(i,u,c){return({inputs:d,attrs:h,backend:l})=>{const{x:p}=d;if(Object(r.a)(p,i),p.dtype==="string"||c==="string")throw new Error("unaryKernelFunc does not support string input/output");const f=l,x=f.data.get(p.dataId).values,b=c||p.dtype,m=u(x,b,h);return f.makeTensorInfo(p.shape,b,m)}}},function(s,e,t){t.d(e,"b",function(){return a}),t.d(e,"c",function(){return i}),t.d(e,"a",function(){return u}),t.d(e,"d",function(){return c});var n=t(15);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r="tfjsflags";class a{constructor(h){this.global=h,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=o,this.populateURLFlags()}setPlatform(h,l){this.platform!=null&&(i().getBool("IS_TEST")||i().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${h}.`)),this.platformName=h,this.platform=l}registerFlag(h,l,p){if(this.flagRegistry[h]={evaluationFn:l,setHook:p},this.urlFlags[h]!=null){const f=this.urlFlags[h];i().getBool("IS_TEST")||i().getBool("PROD")||console.warn(`Setting feature override from URL ${h}: ${f}.`),this.set(h,f)}}async getAsync(h){return h in this.flags||(this.flags[h]=await this.evaluateFlag(h)),this.flags[h]}get(h){if(h in this.flags)return this.flags[h];const l=this.evaluateFlag(h);if(Object(n.x)(l))throw new Error(`Flag ${h} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[h]=l,this.flags[h]}getNumber(h){return this.get(h)}getBool(h){return this.get(h)}getFlags(){return this.flags}get features(){return this.flags}set(h,l){if(this.flagRegistry[h]==null)throw new Error(`Cannot set flag ${h} as it has not been registered.`);this.flags[h]=l,this.flagRegistry[h].setHook!=null&&this.flagRegistry[h].setHook(l)}evaluateFlag(h){if(this.flagRegistry[h]==null)throw new Error(`Cannot evaluate flag '${h}': no evaluation function found.`);return this.flagRegistry[h].evaluationFn()}setFlags(h){this.flags=Object.assign({},h)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const h=this.getQueryParams(this.global.location.search);r in h&&h.tfjsflags.split(",").forEach(l=>{const[p,f]=l.split(":");this.urlFlags[p]=function(x,b){if((b=b.toLowerCase())==="true"||b==="false")return b==="true";if(""+ +b===b)return+b;throw new Error(`Could not parse value flag value ${b} for flag ${x}.`)}(p,f)})}}function o(d){const h={};return d.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(l,...p)=>(function(f,x,b){f[decodeURIComponent(x)]=decodeURIComponent(b||"")}(h,p[0],p[1]),p.join("="))),h}function i(){return u}let u=null;function c(d){u=d}},function(s,e,t){t.r(e),t.d(e,"makeTypesMatch",function(){return o}),t.d(e,"assertTypesMatch",function(){return i}),t.d(e,"isTensorInList",function(){return u}),t.d(e,"getTensorsInContainer",function(){return c});var n=t(14),r=t(34),a=t(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(h,l){if(h.dtype===l.dtype)return[h,l];const p=Object(r.c)(h.dtype,l.dtype);return[h.cast(p),l.cast(p)]}function i(h,l){Object(a.b)(h.dtype===l.dtype,()=>`The dtypes of the first(${h.dtype}) and second(${l.dtype}) input must match`)}function u(h,l){return l.some(p=>p.id===h.id)}function c(h){const l=[];return d(h,l,new Set),l}function d(h,l,p){if(h==null)return;if(h instanceof n.a)return void l.push(h);if(f=h,!Array.isArray(f)&&typeof f!="object")return;var f;const x=h;for(const b in x){const m=x[b];p.has(m)||(p.add(m),d(m,l,p))}}},function(s,e,t){t.d(e,"d",function(){return n}),t.d(e,"c",function(){return a}),t.d(e,"b",function(){return o}),t.d(e,"a",function(){return i}),t.d(e,"e",function(){return u});var n,r=t(5);(function(c){c.float32="float32",c.float16="float16",c.int32="int32",c.uint32="uint32",c.int8="int8",c.uint8="uint8"})(n||(n={}));class a{get builder(){return this.builder_}constructor(d){this.builder_=d}}class o extends a{constructor(d,h,l){super(l),r.a(typeof d=="string","The name parameter is invalid"),this.name=d,r.s(h),this.desc=h}}class i extends a{static createScalar(d,h=n.float32,l){return r.a(h in n,"The operand type is invalid."),r.v(d,h),new i({type:h},d,l)}static createTensor(d,h,l){r.a(r.m(h),"Only ArrayBufferView value type is supported.");const p=h;return r.s(d),r.u(p,d.type,d.dimensions),new i(d,p.slice(),l)}constructor(d,h,l){super(l),this.desc=d,this.value=h}}class u extends a{constructor(d){super(d.builder),this.operation=d}}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a){return(o,i,u,c,d)=>{const h=n.backend_util.assertAndGetBroadcastShape(o,i),l=h.length,p=n.util.computeStrides(h),f=n.util.sizeFromShape(h),x=n.util.getTypedArrayFromDType(d,f),b=o.length,m=i.length,I=n.util.computeStrides(o),N=n.util.computeStrides(i),E=n.backend_util.getBroadcastDims(o,h),D=n.backend_util.getBroadcastDims(i,h);if(E.length+D.length===0)for(let U=0;U<x.length;++U)x[U]=a(u[U%u.length],c[U%c.length]);else for(let U=0;U<x.length;++U){const L=n.util.indexToLoc(U,l,p),Y=L.slice(-b);E.forEach(ne=>Y[ne]=0);const V=n.util.locToIndex(Y,b,I),P=L.slice(-m);D.forEach(ne=>P[ne]=0);const oe=n.util.locToIndex(P,m,N);x[U]=a(u[V],c[oe])}return[x,h]}}},function(s,e,t){t.d(e,"a",function(){return i}),t.d(e,"b",function(){return u});var n=t(0),r=t(7),a=t(25),o=t(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i(c,d,h,l){return h==null?({inputs:p,backend:f})=>{const{a:x,b}=p,m=f;Object(r.a)([x,b],c);const I=m.data.get(x.dataId).values,N=m.data.get(b.dataId).values,E=x.dtype==="string"?n.backend_util.fromUint8ToStringArray(I):I,D=x.dtype==="string"?n.backend_util.fromUint8ToStringArray(N):N,U=l||x.dtype,[L,Y]=d(x.shape,b.shape,E,D,U);return m.makeTensorInfo(Y,U,L)}:({inputs:p,backend:f})=>{const{a:x,b}=p,m=f;if(x.dtype==="complex64"||b.dtype==="complex64"){const I=Object(a.a)({inputs:{x},backend:m,attrs:{dtype:"complex64"}}),N=m.data.get(I.dataId),E=N.complexTensorInfos.real,D=N.complexTensorInfos.imag,U=m.data.get(E.dataId).values,L=m.data.get(D.dataId).values,Y=Object(a.a)({inputs:{x:b},backend:m,attrs:{dtype:"complex64"}}),V=m.data.get(Y.dataId),P=V.complexTensorInfos.real,oe=V.complexTensorInfos.imag,ne=m.data.get(P.dataId).values,ge=m.data.get(oe.dataId).values,[ye,Ee,X]=h(x.shape,b.shape,U,L,ne,ge),je=m.makeTensorInfo(X,"float32",ye),Be=m.makeTensorInfo(X,"float32",Ee),tt=Object(o.a)({inputs:{real:je,imag:Be},backend:m});return m.disposeIntermediateTensorInfo(I),m.disposeIntermediateTensorInfo(Y),m.disposeIntermediateTensorInfo(je),m.disposeIntermediateTensorInfo(Be),tt}{const I=m.data.get(x.dataId).values,N=m.data.get(b.dataId).values,E=l||x.dtype,[D,U]=d(x.shape,b.shape,I,N,E);return m.makeTensorInfo(U,E,D)}}}function u(c){return(d,h,l,p,f,x)=>{const b=n.backend_util.assertAndGetBroadcastShape(d,h),m=n.util.sizeFromShape(b),I=b.length,N=n.util.computeStrides(b),E=n.util.getTypedArrayFromDType("float32",m),D=n.util.getTypedArrayFromDType("float32",m),U=n.backend_util.getBroadcastDims(d,b),L=n.backend_util.getBroadcastDims(h,b),Y=n.backend_util.mergeRealAndImagArrays(l,p),V=n.backend_util.mergeRealAndImagArrays(f,x),P=d.length,oe=n.util.computeStrides(d),ne=h.length,ge=n.util.computeStrides(h);if(U.length+L.length===0)for(let ye=0;ye<E.length;ye++){const Ee=ye%Y.length,X=ye%V.length,je=c(Y[2*Ee],Y[2*Ee+1],V[2*X],V[2*X+1]);E[ye]=je.real,D[ye]=je.imag}else for(let ye=0;ye<E.length;ye++){const Ee=n.util.indexToLoc(ye,I,N),X=Ee.slice(-P);U.forEach(Me=>X[Me]=0);const je=n.util.locToIndex(X,P,oe),Be=Ee.slice(-ne);L.forEach(Me=>Be[Me]=0);const tt=n.util.locToIndex(Be,ne,ge),ct=c(Y[2*je],Y[2*je+1],V[2*tt],V[2*tt+1]);E[ye]=ct.real,D[ye]=ct.imag}return[E,D,b]}}},function(s,e,t){t.d(e,"b",function(){return h}),t.d(e,"f",function(){return f}),t.d(e,"e",function(){return x}),t.d(e,"d",function(){return b}),t.d(e,"a",function(){return m}),t.d(e,"c",function(){return I});var n=t(38),r=t(15);function a(N,E,D,U){const L=Object(r.j)(E),Y=function(ne,ge,ye,Ee){const X=Object(r.O)(ge),je=Ee[Ee.length-1],Be=new Array(je).fill(0),tt=ge.length,ct=ye==="complex64"?c(ne):ne;if(tt>1)for(let Me=0;Me<X/je;Me++){const wt=Me*je;for(let at=0;at<je;at++)Be[at]=Math.max(Be[at],o(ct[wt+at],0,ye).length)}return Be}(N,E,D,L),V=E.length,P=u(N,E,D,L,Y),oe=["Tensor"];return U&&(oe.push(`  dtype: ${D}`),oe.push(`  rank: ${V}`),oe.push(`  shape: [${E}]`),oe.push("  values:")),oe.push(P.map(ne=>"    "+ne).join(`
`)),oe.join(`
`)}function o(N,E,D){let U;return U=Array.isArray(N)?`${parseFloat(N[0].toFixed(7))} + ${parseFloat(N[1].toFixed(7))}j`:Object(r.z)(N)?`'${N}'`:D==="bool"?i(N):parseFloat(N.toFixed(7)).toString(),Object(r.L)(U,E)}function i(N){return N===0?"false":"true"}function u(N,E,D,U,L,Y=!0){const V=D==="complex64"?2:1,P=E[0],oe=E.length;if(oe===0)return D==="complex64"?[o(c(N)[0],0,D)]:D==="bool"?[i(N[0])]:[N[0].toString()];if(oe===1){if(P>20){const Be=3*V;let tt=Array.from(N.slice(0,Be)),ct=Array.from(N.slice((P-3)*V,P*V));return D==="complex64"&&(tt=c(tt),ct=c(ct)),["["+tt.map((Me,wt)=>o(Me,L[wt],D)).join(", ")+", ..., "+ct.map((Me,wt)=>o(Me,L[P-3+wt],D)).join(", ")+"]"]}return["["+(D==="complex64"?c(N):Array.from(N)).map((Be,tt)=>o(Be,L[tt],D)).join(", ")+"]"]}const ne=E.slice(1),ge=U.slice(1),ye=U[0]*V,Ee=[];if(P>20){for(let Be=0;Be<3;Be++){const tt=Be*ye,ct=tt+ye;Ee.push(...u(N.slice(tt,ct),ne,D,ge,L,!1))}Ee.push("...");for(let Be=P-3;Be<P;Be++){const tt=Be*ye,ct=tt+ye;Ee.push(...u(N.slice(tt,ct),ne,D,ge,L,Be===P-1))}}else for(let Be=0;Be<P;Be++){const tt=Be*ye,ct=tt+ye;Ee.push(...u(N.slice(tt,ct),ne,D,ge,L,Be===P-1))}const X=oe===2?",":"";Ee[0]="["+Ee[0]+X;for(let Be=1;Be<Ee.length-1;Be++)Ee[Be]=" "+Ee[Be]+X;let je=`,
`;for(let Be=2;Be<oe;Be++)je+=`
`;return Ee[Ee.length-1]=" "+Ee[Ee.length-1]+"]"+(Y?"":je),Ee}function c(N){const E=[];for(let D=0;D<N.length;D+=2)E.push([N[D],N[D+1]]);return E}var d=t(6);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h{constructor(E,D,U){if(this.dtype=D,this.shape=E.slice(),this.size=r.O(E),U!=null){const L=U.length;r.b(L===this.size,()=>`Length of values '${L}' does not match the size inferred by the shape '${this.size}'.`)}if(D==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=U||r.n(D,this.size),this.strides=Object(r.j)(E)}set(E,...D){D.length===0&&(D=[0]),r.b(D.length===this.rank,()=>`The number of provided coordinates (${D.length}) must match the rank (${this.rank})`);const U=this.locToIndex(D);this.values[U]=E}get(...E){E.length===0&&(E=[0]);let D=0;for(const L of E){if(L<0||L>=this.shape[D]){const Y=`Requested out of range element at ${E}.   Buffer shape=${this.shape}`;throw new Error(Y)}D++}let U=E[E.length-1];for(let L=0;L<E.length-1;++L)U+=this.strides[L]*E[L];return this.values[U]}locToIndex(E){if(this.rank===0)return 0;if(this.rank===1)return E[0];let D=E[E.length-1];for(let U=0;U<E.length-1;++U)D+=this.strides[U]*E[U];return D}indexToLoc(E){if(this.rank===0)return[];if(this.rank===1)return[E];const D=new Array(this.shape.length);for(let U=0;U<D.length-1;++U)D[U]=Math.floor(E/this.strides[U]),E-=D[U]*this.strides[U];return D[D.length-1]=E,D}get rank(){return this.shape.length}toTensor(){return l().makeTensor(this.values,this.shape,this.dtype)}}let l=null,p=null;function f(N){l=N}function x(N){p=N}function b(N){}class m{constructor(E,D,U,L){this.kept=!1,this.isDisposedInternal=!1,this.shape=E.slice(),this.dtype=D||"float32",this.size=r.O(E),this.strides=Object(r.j)(E),this.dataId=U,this.id=L,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const E=await this.data();return p.buffer(this.shape,this.dtype,E)}bufferSync(){return p.buffer(this.shape,this.dtype,this.dataSync())}async array(){const E=await this.data();return Object(r.U)(this.shape,E,this.dtype==="complex64")}arraySync(){return Object(r.U)(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const E=l().read(this.dataId);if(this.dtype==="string"){const D=await E;try{return D.map(U=>d.decodeString(U))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return E}dataToGPU(E){return this.throwIfDisposed(),l().readToGPU(this.dataId,E)}dataSync(){this.throwIfDisposed();const E=l().readSync(this.dataId);if(this.dtype==="string")try{return E.map(D=>d.decodeString(D))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return E}async bytes(){this.throwIfDisposed();const E=await l().read(this.dataId);return this.dtype==="string"?E:new Uint8Array(E.buffer)}dispose(){this.isDisposed||(l().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(E=!1){return p.print(this,E)}clone(){return this.throwIfDisposed(),p.clone(this)}toString(E=!1){return a(this.dataSync(),this.shape,this.dtype,E)}cast(E){return this.throwIfDisposed(),p.cast(this,E)}variable(E=!0,D,U){return this.throwIfDisposed(),l().makeVariable(this,E,D,U)}}Object.defineProperty(m,Symbol.hasInstance,{value:N=>!!N&&N.data!=null&&N.dataSync!=null&&N.throwIfDisposed!=null}),Object(n.a)("Tensor",()=>m);class I extends m{constructor(E,D,U,L){super(E.shape,E.dtype,E.dataId,L),this.trainable=D,this.name=U}assign(E){if(E.dtype!==this.dtype)throw new Error(`dtype of the new value (${E.dtype}) and previous value (${this.dtype}) must match`);if(!r.a(E.shape,this.shape))throw new Error(`shape of the new value (${E.shape}) and previous value (${this.shape}) must match`);l().disposeTensor(this),this.dataId=E.dataId,l().incRef(this,null)}dispose(){l().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(I,Symbol.hasInstance,{value:N=>N instanceof m&&N.assign!=null&&N.assign instanceof Function})},function(s,e,t){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n($e){let ht=$e.length,Pt=0;for(;ht>0;)Pt=Math.random()*ht|0,ht--,i($e,ht,Pt)}function r($e,ht){if($e.length!==ht.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${$e.length}Second array length was ${ht.length}`);let Pt=$e.length,Ot=0;for(;Pt>0;)Ot=Math.random()*Pt|0,Pt--,i($e,Pt,Ot),i(ht,Pt,Ot)}function a($e,ht,Pt){return Math.max($e,Math.min(ht,Pt))}function o($e){return $e%2==0?$e:$e+1}function i($e,ht,Pt){const Ot=$e[ht];$e[ht]=$e[Pt],$e[Pt]=Ot}function u($e){let ht=0;for(let Pt=0;Pt<$e.length;Pt++)ht+=$e[Pt];return ht}function c($e,ht){const Pt=Math.random();return ht*Pt+(1-Pt)*$e}function d($e,ht){let Pt=0;for(let Ot=0;Ot<$e.length;Ot++){const xn=Number($e[Ot])-Number(ht[Ot]);Pt+=xn*xn}return Pt}function h($e,ht){if(!$e)throw new Error(typeof ht=="string"?ht:ht())}function l($e,ht,Pt=""){h(m($e,ht),()=>Pt+` Shapes ${$e} and ${ht} must match`)}function p($e){h($e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function f($e,ht=[],Pt=!1){if(ht==null&&(ht=[]),Array.isArray($e)||X($e)&&!Pt)for(let Ot=0;Ot<$e.length;++Ot)f($e[Ot],ht,Pt);else ht.push($e);return ht}function x($e){if($e.length===0)return 1;let ht=$e[0];for(let Pt=1;Pt<$e.length;Pt++)ht*=$e[Pt];return ht}function b($e){return $e.length===0}function m($e,ht){if($e===ht)return!0;if($e==null||ht==null||$e.length!==ht.length)return!1;for(let Pt=0;Pt<$e.length;Pt++)if($e[Pt]!==ht[Pt])return!1;return!0}function I($e){return $e%1==0}function N($e){if(Math.tanh!=null)return Math.tanh($e);if($e===1/0)return 1;if($e===-1/0)return-1;{const ht=Math.exp(2*$e);return(ht-1)/(ht+1)}}function E($e){const ht=Math.ceil(Math.sqrt($e));return[ht,Math.ceil($e/ht)]}function D($e){const ht=new Uint32Array($e);for(let Pt=0;Pt<$e;++Pt)ht[Pt]=Pt;return n(ht),ht}function U($e,ht){return ht<=$e.length?$e:$e+" ".repeat(ht-$e.length)}function L($e,ht=Ot=>0,Pt){return new Promise((Ot,xn)=>{let Dn=0;const pe=()=>{if($e())return void Ot();Dn++;const be=ht(Dn);Pt!=null&&Dn>=Pt?xn():setTimeout(pe,be)};pe()})}function Y($e,ht){let Pt=1,Ot=-1;for(let Dn=0;Dn<$e.length;++Dn)if($e[Dn]>=0)Pt*=$e[Dn];else if($e[Dn]===-1){if(Ot!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Ot} and dim ${Dn}`);Ot=Dn}else if($e[Dn]<0)throw Error(`Shapes can not be < 0. Found ${$e[Dn]} at dim ${Dn}`);if(Ot===-1){if(ht>0&&ht!==Pt)throw Error(`Size(${ht}) must match the product of shape ${$e}`);return $e}if(Pt===0)throw Error(`Cannot infer the missing size in [${$e}] when there are 0 elements`);if(ht%Pt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${ht} / ${Pt}`);const xn=$e.slice();return xn[Ot]=ht/Pt,xn}function V($e,ht){const Pt=ht.length;return h(($e=$e==null?ht.map((Ot,xn)=>xn):[].concat($e)).every(Ot=>Ot>=-Pt&&Ot<Pt),()=>`All values in axis param must be in range [-${Pt}, ${Pt}) but got axis ${$e}`),h($e.every(Ot=>I(Ot)),()=>`All values in axis param must be integers but got axis ${$e}`),$e.map(Ot=>Ot<0?Pt+Ot:Ot)}function P($e,ht){const Pt=[],Ot=[],xn=ht!=null&&Array.isArray(ht)&&ht.length===0,Dn=ht==null||xn?null:V(ht,$e).sort();let pe=0;for(let be=0;be<$e.length;++be){if(Dn!=null){if(Dn[pe]===be&&$e[be]!==1)throw new Error(`Can't squeeze axis ${be} since its dim '${$e[be]}' is not 1`);(Dn[pe]==null||Dn[pe]>be)&&$e[be]===1&&(Pt.push($e[be]),Ot.push(be)),Dn[pe]<=be&&pe++}$e[be]!==1&&(Pt.push($e[be]),Ot.push(be))}return{newShape:Pt,keptDims:Ot}}function oe($e,ht){let Pt=null;if($e==null||$e==="float32")Pt=new Float32Array(ht);else if($e==="int32")Pt=new Int32Array(ht);else{if($e!=="bool")throw new Error(`Unknown data type ${$e}`);Pt=new Uint8Array(ht)}return Pt}function ne($e,ht){let Pt=null;if($e==null||$e==="float32")Pt=new Float32Array(ht);else if($e==="int32")Pt=new Int32Array(ht);else if($e==="bool")Pt=new Uint8Array(ht);else{if($e!=="string")throw new Error(`Unknown data type ${$e}`);Pt=new Array(ht)}return Pt}function ge($e,ht){for(let Pt=0;Pt<$e.length;Pt++){const Ot=$e[Pt];if(isNaN(Ot)||!isFinite(Ot))throw Error(`A tensor of type ${ht} being uploaded contains ${Ot}.`)}}function ye($e){return $e==="bool"||$e==="complex64"||$e==="float32"||$e==="int32"||$e==="string"}function Ee($e,ht){return ht!=="complex64"&&(ht!=="float32"||$e==="complex64")&&(ht!=="int32"||$e==="float32"||$e==="complex64")&&(ht!=="bool"||$e!=="bool")}function X($e){return $e instanceof Float32Array||$e instanceof Int32Array||$e instanceof Uint8Array||$e instanceof Uint8ClampedArray}function je($e){if($e==="float32"||$e==="int32")return 4;if($e==="complex64")return 8;if($e==="bool")return 1;throw new Error(`Unknown dtype ${$e}`)}function Be($e){if($e==null)return 0;let ht=0;return $e.forEach(Pt=>ht+=Pt.length),ht}function tt($e){return typeof $e=="string"||$e instanceof String}function ct($e){return typeof $e=="boolean"}function Me($e){return typeof $e=="number"}function wt($e){return Array.isArray($e)?wt($e[0]):$e instanceof Float32Array?"float32":$e instanceof Int32Array||$e instanceof Uint8Array||$e instanceof Uint8ClampedArray?"int32":Me($e)?"float32":tt($e)?"string":ct($e)?"bool":"float32"}function at($e){return!!($e&&$e.constructor&&$e.call&&$e.apply)}function Gt($e,ht){for(let Pt=ht;Pt<$e;++Pt)if($e%Pt==0)return Pt;return $e}function Ht($e){const ht=$e.length;if(ht<2)return[];const Pt=new Array(ht-1);Pt[ht-2]=$e[ht-1];for(let Ot=ht-3;Ot>=0;--Ot)Pt[Ot]=Pt[Ot+1]*$e[Ot+1];return Pt}function dn($e,ht,Pt,Ot=!1){const xn=new Array;if(ht.length===1){const Dn=ht[0]*(Ot?2:1);for(let pe=0;pe<Dn;pe++)xn[pe]=Pt[$e+pe]}else{const Dn=ht[0],pe=ht.slice(1),be=pe.reduce((Qe,Un)=>Qe*Un)*(Ot?2:1);for(let Qe=0;Qe<Dn;Qe++)xn[Qe]=dn($e+Qe*be,pe,Pt,Ot)}return xn}function mn($e,ht,Pt=!1){if($e.length===0)return ht[0];const Ot=$e.reduce((xn,Dn)=>xn*Dn)*(Pt?2:1);if(Ot===0)return[];if(Ot!==ht.length)throw new Error(`[${$e}] does not match the input size ${ht.length}${Pt?" for a complex tensor":""}.`);return dn(0,$e,ht,Pt)}function Rn($e,ht){const Pt=ee($e,ht);for(let Ot=0;Ot<Pt.length;Ot++)Pt[Ot]=1;return Pt}function ee($e,ht){if(ht==null||ht==="float32"||ht==="complex64")return new Float32Array($e);if(ht==="int32")return new Int32Array($e);if(ht==="bool")return new Uint8Array($e);throw new Error(`Unknown data type ${ht}`)}function se($e,ht){const Pt=$e.reduce((Ot,xn)=>Ot*xn,1);if(ht==null||ht==="float32")return mn($e,new Float32Array(Pt));if(ht==="int32")return mn($e,new Int32Array(Pt));if(ht==="bool")return mn($e,new Uint8Array(Pt));throw new Error(`Unknown data type ${ht}`)}function we($e){$e.forEach(ht=>{h(Number.isInteger(ht)&&ht>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${$e}].`)})}function pt($e,ht,Pt){if(ht===0)return 0;if(ht===1)return $e[0];let Ot=$e[$e.length-1];for(let xn=0;xn<$e.length-1;++xn)Ot+=Pt[xn]*$e[xn];return Ot}function bt($e,ht,Pt){if(ht===0)return[];if(ht===1)return[$e];const Ot=new Array(ht);for(let xn=0;xn<Ot.length-1;++xn)Ot[xn]=Math.floor($e/Pt[xn]),$e-=Ot[xn]*Pt[xn];return Ot[Ot.length-1]=$e,Ot}function At($e){return $e&&$e.then&&typeof $e.then=="function"}t.d(e,"M",function(){return n}),t.d(e,"N",function(){return r}),t.d(e,"i",function(){return a}),t.d(e,"H",function(){return o}),t.d(e,"S",function(){return i}),t.d(e,"R",function(){return u}),t.d(e,"J",function(){return c}),t.d(e,"l",function(){return d}),t.d(e,"b",function(){return h}),t.d(e,"e",function(){return l}),t.d(e,"d",function(){return p}),t.d(e,"m",function(){return f}),t.d(e,"O",function(){return x}),t.d(e,"y",function(){return b}),t.d(e,"a",function(){return m}),t.d(e,"v",function(){return I}),t.d(e,"T",function(){return N}),t.d(e,"P",function(){return E}),t.d(e,"k",function(){return D}),t.d(e,"L",function(){return U}),t.d(e,"K",function(){return L}),t.d(e,"s",function(){return Y}),t.d(e,"I",function(){return V}),t.d(e,"Q",function(){return P}),t.d(e,"o",function(){return oe}),t.d(e,"n",function(){return ne}),t.d(e,"h",function(){return ge}),t.d(e,"B",function(){return ye}),t.d(e,"p",function(){return Ee}),t.d(e,"A",function(){return X}),t.d(e,"g",function(){return je}),t.d(e,"f",function(){return Be}),t.d(e,"z",function(){return tt}),t.d(e,"t",function(){return ct}),t.d(e,"w",function(){return Me}),t.d(e,"r",function(){return wt}),t.d(e,"u",function(){return at}),t.d(e,"G",function(){return Gt}),t.d(e,"j",function(){return Ht}),t.d(e,"U",function(){return mn}),t.d(e,"D",function(){return Rn}),t.d(e,"F",function(){return ee}),t.d(e,"E",function(){return se}),t.d(e,"c",function(){return we}),t.d(e,"C",function(){return pt}),t.d(e,"q",function(){return bt}),t.d(e,"x",function(){return At})},function(s,e,t){t.d(e,"a",function(){return o}),t.d(e,"b",function(){return i});var n=t(0),r=t(7),a=t(46);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(u){const{inputs:c,attrs:d,backend:h}=u,{x:l}=c,{perm:p}=d;Object(r.a)(l,"transpose");const f=l.shape.length,x=new Array(f);for(let I=0;I<x.length;I++)x[I]=l.shape[p[I]];const b=h.data.get(l.dataId).values,m=Object(a.a)(b,l.shape,l.dtype,p,x);return{dataId:h.write(m,x,l.dtype),shape:x,dtype:l.dtype}}const i={kernelName:n.Transpose,backendName:"cpu",kernelFunc:o}},function(s,e,t){(function(n){t.d(e,"f",function(){return u}),t.d(e,"e",function(){return c}),t.d(e,"a",function(){return p}),t.d(e,"b",function(){return f}),t.d(e,"d",function(){return x}),t.d(e,"c",function(){return b}),t.d(e,"i",function(){return m}),t.d(e,"g",function(){return I}),t.d(e,"h",function(){return N});var r=t(22),a=t(32),o=t(15),i=t(52);async function u(D,U){const L=[],Y=[],V=Array.isArray(D)?D.map(P=>P.name):Object.keys(D);for(let P=0;P<V.length;++P){const oe=V[P],ne=Array.isArray(D)?D[P].tensor:D[oe];if(ne.dtype!=="float32"&&ne.dtype!=="int32"&&ne.dtype!=="bool"&&ne.dtype!=="string"&&ne.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${oe}': ${ne.dtype}`);const ge={name:oe,shape:ne.shape,dtype:ne.dtype};if(ne.dtype==="string"){const ye=new Promise(async Ee=>{const X=await ne.bytes(),je=X.reduce((ct,Me)=>ct+Me.length,0)+4*X.length,Be=new Uint8Array(je);let tt=0;for(let ct=0;ct<X.length;ct++){const Me=X[ct],wt=new Uint8Array(new Uint32Array([Me.length]).buffer);Be.set(wt,tt),tt+=4,Be.set(Me,tt),tt+=Me.length}Ee(Be)});Y.push(ye)}else Y.push(ne.data());U!=null&&(ge.group=U),L.push(ge)}return{data:d(await Promise.all(Y)),specs:L}}function c(D,U){const L={};let Y,V=0;for(const P of U){const oe=P.name,ne=P.dtype,ge=P.shape,ye=Object(o.O)(ge);let Ee;if("quantization"in P){const X=P.quantization;if(X.dtype==="uint8"||X.dtype==="uint16"){if(!("min"in X)||!("scale"in X))throw new Error(`Weight ${P.name} with quantization ${X.dtype} doesn't have corresponding metadata min and scale.`)}else{if(X.dtype!=="float16")throw new Error(`Weight ${P.name} has unknown quantization dtype ${X.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if(ne!=="float32")throw new Error(`Weight ${P.name} is quantized with ${X.dtype} which only supports weights of type float32 not ${ne}.`)}const je=i.a[X.dtype],Be=D.slice(V,V+ye*je),tt=X.dtype==="uint8"?new Uint8Array(Be):new Uint16Array(Be);if(ne==="float32")if(X.dtype==="uint8"||X.dtype==="uint16"){Ee=new Float32Array(tt.length);for(let ct=0;ct<tt.length;ct++){const Me=tt[ct];Ee[ct]=Me*X.scale+X.min}}else{if(X.dtype!=="float16")throw new Error(`Unsupported quantization type ${X.dtype} for weight type float32.`);Y===void 0&&(Y=E()),Ee=Y(tt)}else{if(ne!=="int32")throw new Error(`Unsupported dtype in weight '${oe}': ${ne}`);if(X.dtype!=="uint8"&&X.dtype!=="uint16")throw new Error(`Unsupported quantization type ${X.dtype} for weight type int32.`);Ee=new Int32Array(tt.length);for(let ct=0;ct<tt.length;ct++){const Me=tt[ct];Ee[ct]=Math.round(Me*X.scale+X.min)}}V+=ye*je}else if(ne==="string"){const X=Object(o.O)(P.shape);Ee=[];for(let je=0;je<X;je++){const Be=new Uint32Array(D.slice(V,V+4))[0];V+=4;const tt=new Uint8Array(D.slice(V,V+Be));Ee.push(tt),V+=Be}}else{const X=i.a[ne],je=D.slice(V,V+ye*X);if(ne==="float32")Ee=new Float32Array(je);else if(ne==="int32")Ee=new Int32Array(je);else if(ne==="bool")Ee=new Uint8Array(je);else{if(ne!=="complex64")throw new Error(`Unsupported dtype in weight '${oe}': ${ne}`);{Ee=new Float32Array(je);const Be=new Float32Array(Ee.length/2),tt=new Float32Array(Ee.length/2);for(let wt=0;wt<Be.length;wt++)Be[wt]=Ee[2*wt],tt[wt]=Ee[2*wt+1];const ct=Object(a.a)(Be,ge,"float32"),Me=Object(a.a)(tt,ge,"float32");L[oe]=Object(r.a)(ct,Me),ct.dispose(),Me.dispose()}}V+=ye*X}ne!=="complex64"&&(L[oe]=Object(a.a)(Ee,ge,ne))}return L}function d(D){if(D===null)throw new Error(`Invalid input value: ${JSON.stringify(D)}`);let U=0;const L=[];D.forEach(P=>{if(U+=P.byteLength,L.push(P.byteLength===P.buffer.byteLength?P:new P.constructor(P)),!(P instanceof Float32Array||P instanceof Int32Array||P instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${P.constructor.name}`)});const Y=new Uint8Array(U);let V=0;return L.forEach(P=>{Y.set(new Uint8Array(P.buffer),V),V+=P.byteLength}),Y.buffer}const h=typeof n!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function l(D){return h?n.byteLength(D):new Blob([D]).size}function p(D){if(h)return n.from(D).toString("base64");const U=new Uint8Array(D);let L="";for(let Y=0,V=U.length;Y<V;Y++)L+=String.fromCharCode(U[Y]);return btoa(L)}function f(D){if(h){const Y=n.from(D,"base64");return Y.buffer.slice(Y.byteOffset,Y.byteOffset+Y.byteLength)}const U=atob(D),L=new Uint8Array(U.length);for(let Y=0;Y<U.length;++Y)L.set([U.charCodeAt(Y)],Y);return L.buffer}function x(D){if(D.length===1)return D[0];let U=0;D.forEach(V=>{U+=V.byteLength});const L=new Uint8Array(U);let Y=0;return D.forEach(V=>{L.set(new Uint8Array(V),Y),Y+=V.byteLength}),L.buffer}function b(D){for(D=D.trim();D.endsWith("/");)D=D.slice(0,D.length-1);const U=D.split("/");return U[U.length-1]}function m(D,U){const L={modelTopology:D.modelTopology,format:D.format,generatedBy:D.generatedBy,convertedBy:D.convertedBy,weightsManifest:U};return D.signature!=null&&(L.signature=D.signature),D.userDefinedMetadata!=null&&(L.userDefinedMetadata=D.userDefinedMetadata),D.modelInitializer!=null&&(L.modelInitializer=D.modelInitializer),D.trainingConfig!=null&&(L.trainingConfig=D.trainingConfig),L}async function I(D,U){const L={modelTopology:D.modelTopology,format:D.format,generatedBy:D.generatedBy,convertedBy:D.convertedBy};if(D.trainingConfig!=null&&(L.trainingConfig=D.trainingConfig),D.weightsManifest!=null){const[Y,V]=await U(D.weightsManifest);L.weightSpecs=Y,L.weightData=V}return D.signature!=null&&(L.signature=D.signature),D.userDefinedMetadata!=null&&(L.userDefinedMetadata=D.userDefinedMetadata),D.modelInitializer!=null&&(L.modelInitializer=D.modelInitializer),L}function N(D){if(D.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:D.modelTopology==null?0:l(JSON.stringify(D.modelTopology)),weightSpecsBytes:D.weightSpecs==null?0:l(JSON.stringify(D.weightSpecs)),weightDataBytes:D.weightData==null?0:D.weightData.byteLength}}function E(){const D=function(){const Y=P=>{let oe=P<<13,ne=0;for(;(8388608&oe)==0;)ne-=8388608,oe<<=1;return oe&=-8388609,ne+=947912704,oe|ne},V=new Uint32Array(2048);V[0]=0;for(let P=1;P<1024;P++)V[P]=Y(P);for(let P=1024;P<2048;P++)V[P]=939524096+(P-1024<<13);return V}(),U=function(){const Y=new Uint32Array(64);Y[0]=0,Y[31]=1199570944,Y[32]=2147483648,Y[63]=3347054592;for(let V=1;V<31;V++)Y[V]=V<<23;for(let V=33;V<63;V++)Y[V]=2147483648+(V-32<<23);return Y}(),L=function(){const Y=new Uint32Array(64);for(let V=0;V<64;V++)Y[V]=1024;return Y[0]=Y[32]=0,Y}();return Y=>{const V=new ArrayBuffer(4*Y.length),P=new Uint32Array(V);for(let oe=0;oe<Y.length;oe++){const ne=Y[oe],ge=D[L[ne>>10]+(1023&ne)]+U[ne>>10];P[oe]=ge}return new Float32Array(V)}}}).call(this,t(105).Buffer)},function(s,e,t){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n(a){const{inputs:o,backend:i}=a,{real:u,imag:c}=o,d=i.data.get(u.dataId).values,h=i.data.get(c.dataId).values,l=i.makeTensorInfo(u.shape,"complex64");return i.data.get(l.dataId).complexTensorInfos={real:i.makeTensorInfo(u.shape,"float32",d),imag:i.makeTensorInfo(c.shape,"float32",h)},l}t.d(e,"a",function(){return n}),t.d(e,"b",function(){return r});const r={kernelName:t(0).Complex,backendName:"cpu",kernelFunc:n}},function(s,e,t){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n(a){const{inputs:o,backend:i}=a,{x:u}=o;return i.incRef(u.dataId),{dataId:u.dataId,shape:u.shape,dtype:u.dtype}}t.d(e,"a",function(){return n}),t.d(e,"b",function(){return r});const r={kernelName:t(0).Identity,backendName:"cpu",kernelFunc:n}},function(s,e,t){t.d(e,"a",function(){return o});var n=t(3),r=t(15),a=t(6);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(i,u,c,d){if(d==null&&(d=Object(r.r)(i)),d==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(r.A)(i)&&!Array.isArray(i)&&typeof i!="number"&&typeof i!="boolean"&&typeof i!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(u!=null){Object(r.c)(u);const h=Object(r.O)(u),l=Object(r.O)(c);Object(r.b)(h===l,()=>`Based on the provided shape, [${u}], the tensor should have ${h} values but has ${l}`);for(let p=0;p<c.length;++p){const f=c[p],x=p!==c.length-1||f!==Object(r.O)(u.slice(p));Object(r.b)(c[p]===u[p]||!x,()=>`Error creating a new Tensor. Inferred shape (${c}) does not match the provided shape (${u}). `)}}return Object(r.A)(i)||Array.isArray(i)||(i=[i]),u=u||c,i=d!=="string"?Object(a.toTypedArray)(i,d):Object(r.m)(i,[],!0),n.a.makeTensor(i,u,d)}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a){return(o,i,u)=>{const c=n.util.getTypedArrayFromDType(i,o.length);for(let d=0;d<o.length;++d)c[d]=a(o[d],u);return c}}},function(s,e,t){t.d(e,"a",function(){return u});var n=t(3),r=t(4),a=t(1),o=t(15),i=t(2);const u=Object(i.b)({complex_:function(c,d){const h=Object(a.a)(c,"real","complex"),l=Object(a.a)(d,"imag","complex");o.e(h.shape,l.shape,`real and imag shapes, ${h.shape} and ${l.shape}, must match in call to tf.complex().`);const p={real:h,imag:l};return n.a.runKernel(r.A,p)}})},function(s,e,t){t.d(e,"c",function(){return a}),t.d(e,"a",function(){return o}),t.d(e,"b",function(){return i});var n=t(0),r=t(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(u,c,d,h,l){const p=n.slice_util.isSliceContinous(h,c,d),f=n.util.sizeFromShape(d),x=n.util.computeStrides(h);if(p){const N=n.slice_util.computeFlatOffset(c,x);return l==="string"?u.slice(N,N+f):u.subarray(N,N+f)}const b=l==="string"?n.backend_util.fromUint8ToStringArray(u):u,m=Object(n.buffer)(h,l,b),I=Object(n.buffer)(d,l);for(let N=0;N<I.size;++N){const E=I.indexToLoc(N),D=E.map((U,L)=>U+c[L]);I.set(m.get(...D),...E)}return l==="string"?n.backend_util.fromStringArrayToUint8(I.values):I.values}function o(u){const{inputs:c,backend:d,attrs:h}=u,{x:l}=c,{begin:p,size:f}=h;Object(r.a)(l,"slice");const[x,b]=n.slice_util.parseSliceParams(l,p,f);n.slice_util.assertParamsValid(l,x,b);const m=a(d.data.get(l.dataId).values,x,b,l.shape,l.dtype);return d.makeTensorInfo(b,l.dtype,m)}const i={kernelName:n.Slice,backendName:"cpu",kernelFunc:o}},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return u}),t.d(e,"b",function(){return c});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((d,h)=>d+h),i=Object(a.b)((d,h,l,p)=>({real:d+l,imag:h+p})),u=Object(a.a)(n.Add,o,i),c={kernelName:n.Add,backendName:"cpu",kernelFunc:u}},function(s,e,t){t.d(e,"c",function(){return c}),t.d(e,"a",function(){return d}),t.d(e,"b",function(){return h});var n=t(0),r=t(12),a=t(89),o=t(18),i=t(19),u=t(26);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c(l,p,f,x){if(x==="int32")return[p,"int32",Int32Array.from(l)];if(x==="bool"){const b=n.util.toTypedArray([0],f),[m,I]=Object(r.a)((N,E)=>N!==E?1:0)(p,[],l,b,"bool");return[I,"bool",m]}throw new Error(`Error in Cast: failed to cast ${f} to ${x}`)}function d(l){const{inputs:p,backend:f,attrs:x}=l,{x:b}=p,{dtype:m}=x;if(m==="complex64"){if(b.dtype==="complex64")return Object(i.a)({inputs:{x:b},backend:f});const U=Object(a.a)(f,b.shape,b.dtype),L=d({inputs:{x:b},backend:f,attrs:{dtype:"float32"}}),Y=Object(o.a)({inputs:{real:L,imag:U},backend:f});return f.disposeIntermediateTensorInfo(U),f.disposeIntermediateTensorInfo(L),Y}if(b.dtype==="complex64"){const U=Object(u.a)({inputs:{input:b},backend:f}),L=d({inputs:{x:U},backend:f,attrs:{dtype:m}});return f.disposeIntermediateTensorInfo(U),L}if(!n.util.hasEncodingLoss(b.dtype,m)){const U=Object(i.a)({inputs:{x:b},backend:f});return{dataId:U.dataId,shape:U.shape,dtype:m}}const I=f.data.get(b.dataId).values,[N,E,D]=c(I,b.shape,b.dtype,m);return f.makeTensorInfo(N,E,D)}const h={kernelName:n.Cast,backendName:"cpu",kernelFunc:d}},function(s,e,t){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function n(a){const{inputs:o,backend:i}=a,{input:u}=o,c=i.data.get(u.dataId).complexTensorInfos.real,d=i.data.get(c.dataId).values;return i.makeTensorInfo(c.shape,c.dtype,d)}t.d(e,"a",function(){return n}),t.d(e,"b",function(){return r});const r={kernelName:t(0).Real,backendName:"cpu",kernelFunc:n}},function(s,e){s.exports=function(){throw new Error("define cannot be used indirect")}},function(s,e,t){t.r(e);var n=t(56);t.d(e,"simpleAbsImpl",function(){return n.b});var r=t(24);t.d(e,"addImpl",function(){return r.c});var a=t(35);t.d(e,"bincountImpl",function(){return a.a}),t.d(e,"bincountReduceImpl",function(){return a.b});var o=t(25);t.d(e,"castImpl",function(){return o.c});var i=t(57);t.d(e,"ceilImpl",function(){return i.b});var u=t(58);t.d(e,"concatImpl",function(){return u.a});var c=t(44);t.d(e,"equalImpl",function(){return c.c});var d=t(45);t.d(e,"expImpl",function(){return d.c});var h=t(59);t.d(e,"expm1Impl",function(){return h.b});var l=t(60);t.d(e,"floorImpl",function(){return l.b});var p=t(61);t.d(e,"gatherNdImpl",function(){return p.a});var f=t(62);t.d(e,"gatherV2Impl",function(){return f.a});var x=t(63);t.d(e,"greaterImpl",function(){return x.b});var b=t(64);t.d(e,"greaterEqualImpl",function(){return b.b});var m=t(65);t.d(e,"lessImpl",function(){return m.b});var I=t(66);t.d(e,"lessEqualImpl",function(){return I.b});var N=t(67);t.d(e,"linSpaceImpl",function(){return N.a});var E=t(68);t.d(e,"logImpl",function(){return E.b});var D=t(69);t.d(e,"maxImpl",function(){return D.a});var U=t(70);t.d(e,"maximumImpl",function(){return U.b});var L=t(71);t.d(e,"minimumImpl",function(){return L.b});var Y=t(29);t.d(e,"multiplyImpl",function(){return Y.c});var V=t(72);t.d(e,"negImpl",function(){return V.b});var P=t(73);t.d(e,"notEqualImpl",function(){return P.b});var oe=t(74);t.d(e,"prodImpl",function(){return oe.b});var ne=t(75);t.d(e,"raggedTensorToTensorImpl",function(){return ne.a});var ge=t(76);t.d(e,"rangeImpl",function(){return ge.a});var ye=t(77);t.d(e,"rsqrtImpl",function(){return ye.b});var Ee=t(33);t.d(e,"scatterImpl",function(){return Ee.a});var X=t(47);t.d(e,"sigmoidImpl",function(){return X.c});var je=t(23);t.d(e,"sliceImpl",function(){return je.c});var Be=t(78);t.d(e,"sparseFillEmptyRowsImpl",function(){return Be.a});var tt=t(79);t.d(e,"sparseReshapeImpl",function(){return tt.a});var ct=t(48);t.d(e,"sparseSegmentReductionImpl",function(){return ct.a});var Me=t(80);t.d(e,"sqrtImpl",function(){return Me.b});var wt=t(81);t.d(e,"squaredDifferenceImpl",function(){return wt.b});var at=t(82);t.d(e,"stridedSliceImpl",function(){return at.a});var Gt=t(83);t.d(e,"stringNGramsImpl",function(){return Gt.a});var Ht=t(84);t.d(e,"stringSplitImpl",function(){return Ht.a});var dn=t(85);t.d(e,"stringToHashBucketFastImpl",function(){return dn.a});var mn=t(36);t.d(e,"subImpl",function(){return mn.c});var Rn=t(86);t.d(e,"tileImpl",function(){return Rn.a});var ee=t(87);t.d(e,"topKImpl",function(){return ee.a});var se=t(46);t.d(e,"transposeImpl",function(){return se.a});var we=t(88);t.d(e,"uniqueImpl",function(){return we.a})},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return u}),t.d(e,"b",function(){return c});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((d,h)=>d*h),i=Object(a.b)((d,h,l,p)=>({real:d*l-h*p,imag:d*p+h*l})),u=Object(a.a)(n.Multiply,o,i),c={kernelName:n.Multiply,backendName:"cpu",kernelFunc:u}},function(s,e,t){t.d(e,"b",function(){return r}),t.d(e,"a",function(){return a});var n=t(9);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(...o){Object(n.c)().getBool("IS_TEST")||Object(n.c)().getBool("PROD")||console.warn(...o)}function a(...o){Object(n.c)().getBool("IS_TEST")||Object(n.c)().getBool("PROD")||console.log(...o)}},function(s,e,t){t.d(e,"c",function(){return u}),t.d(e,"b",function(){return c}),t.d(e,"d",function(){return d}),t.d(e,"f",function(){return h}),t.d(e,"e",function(){return l}),t.d(e,"h",function(){return p}),t.d(e,"g",function(){return f}),t.d(e,"a",function(){return x});var n=t(9),r=t(38),a=t(30);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)("kernelRegistry",()=>new Map),i=Object(r.a)("gradRegistry",()=>new Map);function u(m,I){const N=b(m,I);return o.get(N)}function c(m){return i.get(m)}function d(m){const I=o.entries(),N=[];for(;;){const{done:E,value:D}=I.next();if(E)break;const[U,L]=D,[Y]=U.split("_");Y===m&&N.push(L)}return N}function h(m){const{kernelName:I,backendName:N}=m,E=b(I,N);o.has(E)&&a.b(`The kernel '${I}' for backend '${N}' is already registered`),o.set(E,m)}function l(m){const{kernelName:I}=m;i.has(I)&&Object(n.c)().getBool("DEBUG")&&a.b(`Overriding the gradient for '${I}'`),i.set(I,m)}function p(m,I){const N=b(m,I);if(!o.has(N))throw new Error(`The kernel '${m}' for backend '${I}' is not registered`);o.delete(N)}function f(m){if(!i.has(m))throw new Error(`The gradient '${m}' for backend is not registered`);i.delete(m)}function x(m,I){d(m).forEach(N=>{h(Object.assign({},N,{backendName:I}))})}function b(m,I){return`${I}_${m}`}},function(s,e,t){t.d(e,"a",function(){return a});var n=t(1),r=t(20);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(o,i,u){const c=Object(n.c)(o,u);return Object(r.a)(o,i,c,u)}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c,d,h,l,p,f){const x=[u/c,c],b=a.values,m=o.values;if(u===0)return Object(n.buffer)(i,o.dtype);const I=Object(n.buffer)(x,o.dtype);typeof p=="string"||typeof p=="number"?I.values.fill(p):typeof p=="boolean"&&I.values.fill(+p);for(let N=0;N<d;N++){const E=[];let D=0;for(let U=0;U<h;U++){const L=b[N*h+U];E.push(L),D+=L*l[U]}if(D<0||D>=u/c)throw new Error(`Invalid indices: ${E} does not index into ${i}`);for(let U=0;U<c;U++)f?I.values[D*c+U]+=m[N*c+U]:I.values[D*c+U]=o.rank===0?m[0]:m[N*c+U]}return I}},function(s,e,t){/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var n,r,a,o,i;t.d(e,"a",function(){return n}),t.d(e,"c",function(){return c}),t.d(e,"b",function(){return d}),function(h){h.R0="R0",h.R1="R1",h.R2="R2",h.R3="R3",h.R4="R4",h.R5="R5",h.R6="R6"}(n||(n={})),function(h){h.float32="float32",h.int32="int32",h.bool="int32",h.complex64="complex64"}(r||(r={})),function(h){h.float32="float32",h.int32="int32",h.bool="bool",h.complex64="complex64"}(a||(a={})),function(h){h.float32="float32",h.int32="float32",h.bool="float32",h.complex64="complex64"}(o||(o={})),function(h){h.float32="complex64",h.int32="complex64",h.bool="complex64",h.complex64="complex64"}(i||(i={}));const u={float32:o,int32:r,bool:a,complex64:i};function c(h,l){if(h==="string"||l==="string"){if(h==="string"&&l==="string")return"string";throw new Error(`Can not upcast ${h} with ${l}`)}return u[h][l]}function d(h){return c(h,"int32")}},function(s,e,t){t.d(e,"a",function(){return r}),t.d(e,"b",function(){return a});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(o,i,u,c,d){const h=n.util.sizeFromShape(c),l=n.util.makeZerosTypedArray(d,u);for(let p=0;p<o.length;p++){const f=o[p];if(f<0)throw new Error("Input x must be non-negative!");f>=d||(l[f]+=h>0?i[p]:1)}return l}function a(o,i,u,c=!1){const d=o.shape[0],h=o.shape[1],l=Object(n.buffer)([d,u],i.dtype);for(let p=0;p<d;p++)for(let f=0;f<h;f++){const x=o.get(p,f);if(x<0)throw new Error("Input x must be non-negative!");x>=u||(c?l.set(1,p,x):i.size>0?l.set(l.get(p,x)+i.get(p,f),p,x):l.set(l.get(p,x)+1,p,x))}return l}},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return u}),t.d(e,"b",function(){return c});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((d,h)=>d-h),i=Object(a.b)((d,h,l,p)=>({real:d-l,imag:h-p})),u=Object(a.a)(n.Sub,o,i),c={kernelName:n.Sub,backendName:"cpu",kernelFunc:u}},function(s,e,t){t.d(e,"a",function(){return c}),t(97),t(98),t(99);var n,r,a,o=t(90),i=t(0),u=t(5);(function(d){d.default="default",d.webgpu="webgpu"})(n||(n={})),function(d){d.cpu="cpu",d.gpu="gpu"}(r||(r={})),function(d){d.default="default",d["high-performance"]="high-performance",d["low-power"]="low-power"}(a||(a={}));class c{constructor(h={}){u.a(h instanceof Object,"Invalid options."),h.deviceType!==void 0&&u.a(h.deviceType in r,"Invalid device type."),h.powerPreference!==void 0&&u.a(h.powerPreference in a,"Invalid power preference."),this.options_=h,this.type_=n.default}get options(){return this.options_}get type(){return this.type_}async compute(h,l,p){return await h.compute(l,p)}computeSync(h,l,p){u.a(typeof window=="undefined"&&typeof importScripts=="function","computeSync() should only be allowed in dedicated worker."),h.computeSync(l,p)}get tf(){return o.a(`https://unpkg.com/@tensorflow/tfjs-backend-wasm@${i.version_core}/dist/`),i}}},function(s,e,t){(function(n,r){/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a;function o(){if(a==null){let u;if(typeof window!="undefined")u=window;else if(typeof n!="undefined")u=n;else if(typeof r!="undefined")u=r;else{if(typeof self=="undefined")throw new Error("Could not find a global object");u=self}a=u}return a}function i(u,c){const d=function(){const h=o();return h._tfGlobals==null&&(h._tfGlobals=new Map),h._tfGlobals}();if(d.has(u))return d.get(u);{const h=c();return d.set(u,h),d.get(u)}}t.d(e,"b",function(){return o}),t.d(e,"a",function(){return i})}).call(this,t(40),t(41))},function(s,e,t){t.d(e,"e",function(){return c}),t.d(e,"b",function(){return d}),t.d(e,"a",function(){return h}),t.d(e,"c",function(){return l}),t.d(e,"i",function(){return p}),t.d(e,"h",function(){return f}),t.d(e,"g",function(){return x}),t.d(e,"j",function(){return b}),t.d(e,"f",function(){return m}),t.d(e,"d",function(){return Us});var n=t(37),r=t(53),a=t(11),o=t(0);class i{get builder(){return this.builder_}get outputs(){return this.outputs_}constructor(re){this.outputs_=[],this.builder_=re}compute(re){const de=new Map;for(const Ct of this.inputs())de.set(Ct,re.getTensor(Ct));const ot=o.tidy(()=>this.computeImpl(de));for(let Ct=0;Ct<this.outputs_.length;++Ct)re.setOutputTensor(this.outputs_[Ct],ot[Ct]);for(const Ct of this.inputs())re.releaseTensor(Ct)}dispose(){}}class u extends i{constructor(re){super(re),re&&this.createOutput()}createOutput(){this.outputs_.push(new a.e(this))}get output(){return this.outputs_[0]}computeImpl(re){return[this.run(re)]}}var c,d,h,l,p,f,x,b,m,I=t(5);class N extends u{constructor(re,de,ot,Ct={}){if(super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.mean_=de,I.r(ot),this.variance_=ot,I.t(Ct.scale),this.scale_=Ct.scale,I.t(Ct.bias),this.bias_=Ct.bias,Ct.axis!==void 0){const Yt=Ct.axis;I.a(I.j(Yt),"The axis parameter is invalid."),this.axis_=Yt}else this.axis_=1;if(Ct.epsilon!==void 0){const Yt=Ct.epsilon;I.a(typeof Yt=="number","The epsilon parameter is invalid"),this.epsilon_=Yt}else this.epsilon_=1e-5;this.activation_=Ct.activation}inputs(){const re=[this.input_,this.mean_,this.variance_];return this.scale_&&re.push(this.scale_),this.bias_&&re.push(this.bias_),re}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}run(re){const de=re.get(this.input_);I.a(this.axis_<de.rank&&this.axis_>=-de.rank,"The axis parameter is invalid.");const ot=this.axis_>=0?this.axis_:de.rank+this.axis_,Ct=re.get(this.mean_);I.a(Ct.rank===1,"The mean operand is not 1-D.");const Yt=re.get(this.variance_);let on,tn;I.a(Yt.rank===1,"The mean operand is not 1-D."),this.scale_&&(on=re.get(this.scale_),I.a(on.rank===1,"The scale operand is not 1-D.")),this.bias_&&(tn=re.get(this.bias_),I.a(tn.rank===1,"The bias operand is not 1-D."));const bn=Array.from(Array(de.rank).keys());bn[ot]=de.rank-1,bn[de.rank-1]=ot;const On=o.transpose(o.batchNorm(o.transpose(de,bn),Ct,Yt,tn,on,this.epsilon_),bn);return this.needCheckOutputShape_&&(I.b(On.shape,de.shape),this.needCheckOutputShape_=!1),On}}class E extends u{constructor(re,de){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.a_=re,I.r(de),this.b_=de}inputs(){return[this.a_,this.b_]}run(re){const de=re.get(this.a_),ot=re.get(this.b_),Ct=this.runOp(de,ot);if(this.needCheckOutputShape_){let Yt;if(this instanceof ne){const on=de.rank,tn=ot.rank;on===1&&tn===1?Yt=[]:on>=2&&tn===1?(Yt=de.shape.slice(),Yt[on-1]=1):on===1&&tn>=2?(Yt=ot.shape.slice(),Yt[tn-2]=1):on>=2&&tn>=2&&(Yt=I.f(de.shape.slice(0,-2),ot.shape.slice(0,-2)),Yt.push(de.shape[on-2]),Yt.push(ot.shape[tn-1]))}else Yt=I.f(de.shape,ot.shape);I.b(Ct.shape,Yt),this.needCheckOutputShape_=!1}return Ct}}class D extends E{runOp(re,de){return o.add(re,de)}}class U extends E{runOp(re,de){return o.sub(re,de)}}class L extends E{runOp(re,de){return o.mul(re,de)}}class Y extends E{runOp(re,de){return o.div(re,de)}}class V extends E{runOp(re,de){return o.maximum(re,de)}}class P extends E{runOp(re,de){return o.minimum(re,de)}}class oe extends E{runOp(re,de){return o.pow(re,de)}}class ne extends E{runOp(re,de){if(re.rank===1)return de.rank===1?o.dot(re,de):o.matMul(o.reshape(re,[1,-1]),de);if(de.rank===1)return o.matMul(re,o.reshape(de,[-1,1]));{const ot=re.rank>de.rank?re.rank:de.rank;let Ct=o.matMul(re,de);return Ct.rank!==ot&&(Ct=o.reshape(Ct,[1].concat(Ct.shape))),Ct}}}class ge extends u{constructor(re){re!==void 0?(super(re.builder),I.r(re),this.x_=re):(super(void 0),this.x_=void 0),this.needCheckOutputShape_=!0}inputs(){return[this.x_]}run(re){const de=re.get(this.x_),ot=this.runOp(de);return this.needCheckOutputShape_&&(I.b(ot.shape,de.shape),this.needCheckOutputShape_=!1),ot}}class ye extends ge{runOp(re){return o.abs(re)}}class Ee extends ge{runOp(re){return o.ceil(re)}}class X extends ge{runOp(re){return o.cos(re)}}class je extends ge{runOp(re){return o.exp(re)}}class Be extends ge{runOp(re){return o.floor(re)}}class tt extends ge{runOp(re){return o.log(re)}}class ct extends ge{runOp(re){return o.neg(re)}}class Me extends ge{runOp(re){return o.sin(re)}}class wt extends ge{runOp(re){return o.tan(re)}}class at extends ge{apply(re){return this.builder_=re.builder,I.r(re),this.x_=re,this.createOutput(),this.output}}class Gt extends at{runOp(re){return o.sigmoid(re)}}class Ht extends at{runOp(re){return o.tanh(re)}}class dn extends at{runOp(re){return o.relu(re)}}class mn extends at{runOp(re){return o.div(o.mul(re,o.maximum(0,o.minimum(6,o.add(re,3)))),6)}}class Rn extends at{get minValue(){return this.minValue_!==void 0?this.minValue_:-1/0}get maxValue(){return this.maxValue_!==void 0?this.maxValue_:1/0}constructor(re,de={}){if(re!==void 0?(super(re),I.r(re),this.x_=re):(super(void 0),this.x_=void 0),de.minValue!==void 0){const ot=de.minValue;I.a(typeof ot=="number","The minValue parameter is invalid"),this.minValue_=ot}if(de.maxValue!==void 0){const ot=de.maxValue;I.a(typeof ot=="number","The maxValue parameter is invalid"),this.maxValue_=ot}}runOp(re){return this.minValue_!==void 0&&this.maxValue_!==void 0?o.clipByValue(re,this.minValue_,this.maxValue_):this.minValue_!==void 0&&this.maxValue_===void 0?o.maximum(re,this.minValue_):this.minValue_===void 0&&this.maxValue_!==void 0?o.minimum(re,this.maxValue_):o.clone(re)}}class ee extends u{constructor(re,de){super(re[0].builder),this.needCheckOutputShape_=!0,I.a(re.every(ot=>ot instanceof a.c),"The parameter is not an operand."),this.inputs_=re,I.a(I.j(de),"The axis parameter is invalid."),this.axis_=de}inputs(){return this.inputs_}run(re){const de=[];for(const Ct of this.inputs())de.push(re.get(Ct));const ot=o.concat(de,this.axis_);if(this.needCheckOutputShape_){const Ct=de[0].shape.slice();for(let Yt=1;Yt<de.length;++Yt)Ct[this.axis_]+=de[Yt].shape[this.axis_];I.b(ot.shape,Ct),this.needCheckOutputShape_=!1}return ot}}class se extends at{get alpha(){return this.alpha_}constructor(re,de=.01){super(re),I.a(typeof de=="number","The alpha parameter is invalid."),this.alpha_=de}runOp(re){return o.leakyRelu(re,this.alpha_)}}class we extends u{constructor(re,de,ot={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.filter_=de,this.initOptions(ot.padding,ot.strides,ot.dilations,ot.groups,ot.inputLayout,ot.filterLayout,ot.autoPad,ot.bias,ot.activation)}initOptions(re=[0,0,0,0],de=[1,1],ot=[1,1],Ct=1,Yt=c.nchw,on=d.oihw,tn=h.explicit,bn,On){I.a(I.k(re)&&re.length===4,"The padding parameter is invalid."),this.padding_=re,I.a(I.k(de)&&de.length===2,"The strides parameter is invalid."),this.strides_=de,I.a(I.k(ot)&&ot.length===2,"The dilations parameter is invalid."),this.dilations_=ot,I.a(I.j(Ct),"The gourps parameter is invalid."),this.groups_=Ct,I.a(Yt in c,"The input layout parameter is invalid."),this.inputLayout_=Yt,I.a(on in d,"The filter layout parameter is invalid."),this.filterLayout_=on,I.a(tn in h,"The autoPad parameter is invalid."),this.autoPad_=tn,this.bias_=bn,this.bias_&&I.r(this.bias_),On instanceof dn?(this.fusedActivation_="relu",this.activation_=void 0):this.isRelu6(On)?(this.fusedActivation_="relu6",this.activation_=void 0):On instanceof se?(this.fusedActivation_="leakyrelu",this.leakyreluAlpha_=On.alpha,this.activation_=void 0):On instanceof Gt?(this.fusedActivation_="sigmoid",this.activation_=void 0):(this.fusedActivation_=void 0,this.activation_=On)}isRelu6(re){if(re instanceof Rn){const de=re;if(Math.abs(de.minValue-0)<1e-5&&Math.abs(de.maxValue-6)<1e-5)return!0}return!1}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}inputs(){const re=[this.input_,this.filter_];return this.bias_&&re.push(this.bias_),re}run(re){let de,ot,Ct=re.get(this.input_),Yt=!1;this.bias_&&(ot=re.get(this.bias_)),this.inputLayout_===c.nchw&&(Ct=o.transpose(Ct,[0,2,3,1]));const on=Ct.shape[3];this.filterTensor_===void 0?(de=re.get(this.filter_),this.filterLayout_===d.oihw?de=o.transpose(de,[2,3,1,0]):this.filterLayout_===d.ohwi?de=o.transpose(de,[1,2,3,0]):this.filterLayout_===d.ihwo&&(de=o.transpose(de,[1,2,0,3])),this.groups_!==1&&(de=o.transpose(de,[0,1,3,2])),this.filter_ instanceof a.a&&(this.filterTensor_=de,o.keep(this.filterTensor_))):de=this.filterTensor_;const tn=I.g(Ct,de,this.padding_,this.strides_,this.dilations_,this.autoPad_);let bn;if(this.groups_===1)bn=o.fused.conv2d({x:Ct,filter:de,strides:this.strides_,pad:tn,dataFormat:"NHWC",dilations:this.dilations_,bias:ot,activation:this.fusedActivation_,leakyreluAlpha:this.leakyreluAlpha_}),Yt=!0;else{if(this.groups_!==on||this.groups_!==de.shape[2])throw new Error(`The tf.js convolution doesn't support groups parameter ${this.groups_}`);if(tn instanceof Array&&tn[1][0]===tn[1][1]&&tn[1][0]===tn[2][0]&&tn[1][0]===tn[2][1]){const On=tn[1][0];bn=o.fused.depthwiseConv2d({x:Ct,filter:de,strides:this.strides_,pad:On,dataFormat:"NHWC",dilations:this.dilations_,bias:ot,activation:this.fusedActivation_,leakyreluAlpha:this.leakyreluAlpha_}),Yt=!0}else bn=o.depthwiseConv2d(Ct,de,this.strides_,tn,"NHWC",this.dilations_)}if(Yt||(ot&&(bn=o.add(bn,ot)),this.fusedActivation_==="relu"?bn=o.relu(bn):this.fusedActivation_==="relu6"?bn=o.clipByValue(bn,0,6):this.fusedActivation_==="leakyrelu"?bn=o.leakyRelu(bn,this.leakyreluAlpha_):this.fusedActivation_==="sigmoid"?bn=o.sigmoid(bn):this.fusedActivation_!==void 0&&I.a(!1,`The ${this.fusedActivation_} is un supported.`)),this.inputLayout_===c.nchw&&(bn=o.transpose(bn,[0,3,1,2])),this.needCheckOutputShape_){const On=de.shape[0]+(de.shape[0]-1)*(this.dilations_[0]-1),Mn=de.shape[1]+(de.shape[1]-1)*(this.dilations_[1]-1),wn=1+Math.floor((Ct.shape[1]-On+tn[1][0]+tn[1][1])/this.strides_[0]),gs=1+Math.floor((Ct.shape[2]-Mn+tn[2][0]+tn[2][1])/this.strides_[1]),Hs=this.groups_!==1?de.shape[2]:de.shape[3],xr=new Array(4);xr[0]=Ct.shape[0],xr[1]=wn,xr[2]=gs,xr[3]=Hs,this.inputLayout_===c.nchw&&(xr[1]=Hs,xr[2]=wn,xr[3]=gs),I.b(bn.shape,xr),this.needCheckOutputShape_=!1}return bn}dispose(){this.filterTensor_&&o.dispose(this.filterTensor_)}}class pt extends u{constructor(re,de,ot={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.filter_=de,this.initOptions(ot.padding,ot.strides,ot.dilations,ot.groups,ot.inputLayout,ot.filterLayout,ot.autoPad,ot.outputPadding,ot.outputSizes,ot.bias,ot.activation)}initOptions(re=[0,0,0,0],de=[1,1],ot=[1,1],Ct=1,Yt=c.nchw,on=l.iohw,tn=h.explicit,bn=[0,0],On,Mn,wn){I.a(I.k(re)&&re.length===4,"The padding parameter is invalid."),this.padding_=re,I.a(I.k(de)&&de.length===2,"The strides parameter is invalid."),this.strides_=de,I.a(I.k(ot)&&ot.length===2,"The dilations parameter is invalid."),this.dilations_=ot,I.a(this.dilations_.every(gs=>gs===1),"The tf.conv2dTranspose does not support dilations parameter."),I.a(I.j(Ct),"The gourps parameter is invalid."),this.groups_=Ct,I.a(this.groups_===1,"The tf.conv2dTranspose does not support groups parameter."),I.a(Yt in c,"The input layout parameter is invalid."),this.inputLayout_=Yt,I.a(on in l,"The filter layout parameter is invalid."),this.filterLayout_=on,I.a(tn in h,"The autoPad parameter is invalid."),this.autoPad_=tn,I.a(On===void 0||I.k(On)&&On.length===2,"The outputSizes parameter is invalid."),this.outputSizes_=On,On===void 0?(I.a(I.k(bn)&&bn.length===2,"The outputPadding parameter is invalid."),this.outputPadding_=bn):this.outputPadding_=[0,0],this.bias_=Mn,this.bias_&&I.r(this.bias_),wn instanceof dn?(this.fusedActivation_="relu",this.activation_=void 0):this.isRelu6(wn)?(this.fusedActivation_="relu6",this.activation_=void 0):wn instanceof se?(this.fusedActivation_="leakyrelu",this.leakyreluAlpha_=wn.alpha,this.activation_=void 0):wn instanceof Gt?(this.fusedActivation_="sigmoid",this.activation_=void 0):(this.fusedActivation_=void 0,this.activation_=wn)}isRelu6(re){if(re instanceof Rn){const de=re;if(Math.abs(de.minValue-0)<1e-5&&Math.abs(de.maxValue-6)<1e-5)return!0}return!1}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}inputs(){const re=[this.input_,this.filter_];return this.bias_&&re.push(this.bias_),re}run(re){let de,ot,Ct=re.get(this.input_);if(this.bias_&&(ot=re.get(this.bias_)),this.inputLayout_===c.nchw&&(Ct=o.transpose(Ct,[0,2,3,1])),this.filterTensor_===void 0){if(de=re.get(this.filter_),this.filterLayout_===l.iohw?de=o.transpose(de,[2,3,1,0]):this.filterLayout_===l.ohwi&&(de=o.transpose(de,[1,2,0,3])),this.groups_!==1)throw new Error("Unsupported the groups parameter by tfjs.convTranspose2d");this.filter_ instanceof a.a&&(this.filterTensor_=de,o.keep(this.filterTensor_))}else de=this.filterTensor_;const Yt=I.g(Ct,de,this.padding_,this.strides_,this.dilations_,this.autoPad_,this.outputPadding_);let on;const tn=[Ct.shape[0],0,0,de.shape[2]];if(this.outputSizes_!==void 0)tn[1]=this.outputSizes_[0],tn[2]=this.outputSizes_[1];else for(let On=0;On<2;++On)tn[On+1]=(Ct.shape[On+1]-1)*this.strides_[On]+de.shape[On]+(de.shape[On]-1)*(this.dilations_[On]-1)-Yt[On+1][0]-Yt[On+1][1]+this.outputPadding_[On];on=o.conv2dTranspose(Ct,de,tn,this.strides_,Yt),ot&&(on=o.add(on,ot)),this.fusedActivation_==="relu"?on=o.relu(on):this.fusedActivation_==="relu6"?on=o.clipByValue(on,0,6):this.fusedActivation_==="leakyrelu"?on=o.leakyRelu(on,this.leakyreluAlpha_):this.fusedActivation_==="sigmoid"?on=o.sigmoid(on):this.fusedActivation_!==void 0&&I.a(!1,`The ${this.fusedActivation_} is un supported.`);let bn=tn.slice();return this.inputLayout_===c.nchw&&(on=o.transpose(on,[0,3,1,2]),bn=[tn[0],tn[3],tn[1],tn[2]]),this.needCheckOutputShape_&&(I.b(on.shape,bn),this.needCheckOutputShape_=!1),on}dispose(){this.filterTensor_&&o.dispose(this.filterTensor_)}}class bt{static build(re,de,ot,Ct={}){I.r(de),I.r(ot),I.a(Ct.c===void 0||typeof Ct.c=="number"||Ct.c instanceof a.c,"The options.c is invalid."),I.a(Ct.aTranspose===void 0||I.i(Ct.aTranspose),"The options.aTranspose is invalid."),I.a(Ct.bTranspose===void 0||I.i(Ct.bTranspose),"The options.bTranspose is invalid."),I.a(Ct.alpha===void 0||typeof Ct.alpha=="number","The options.alpha is invalid."),I.a(Ct.beta===void 0||typeof Ct.beta=="number","The options.beta is invalid."),Ct.aTranspose&&(de=re.transpose(de)),Ct.bTranspose&&(ot=re.transpose(ot));const Yt=re.constant(Ct.alpha===void 0?1:Ct.alpha),on=re.constant(Ct.beta===void 0?1:Ct.beta),tn=re.matmul(re.mul(Yt,de),ot);return Ct.c?re.add(tn,re.mul(on,Ct.c)):tn}}class At extends i{constructor(re,de,ot,Ct,Yt,on={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.weight_=de,I.r(ot),this.recurrentWeight_=ot,I.a(I.j(Ct)&&Ct>0,"The steps parameter is invalid."),this.steps_=Ct,I.a(I.j(Yt)&&Yt>0,"The hiddenSize parameter is invalid."),this.hiddenSize_=Yt,this.initOptions(on.bias,on.recurrentBias,on.initialHiddenState,on.resetAfter,on.returnSequence,on.direction,on.layout,on.activations),this.outputs.push(new a.e(this)),this.returnSequence_&&this.outputs_.push(new a.e(this))}initOptions(re,de,ot,Ct=!0,Yt=!1,on=f.forward,tn=p.zrn,bn=[this.builder.sigmoid(),this.builder.tanh()]){I.t(re),this.bias_=re,I.t(de),this.recurrentBias_=de,I.t(ot),this.initialHiddenState_=ot,I.a(I.i(Ct),"The resetAfter parameter is not a boolean."),this.resetAfter_=Ct,I.a(I.i(Yt),"The resetAfter parameter is not a boolean."),this.returnSequence_=Yt,I.a(on in f,"The direction parameter is invalid."),this.direction_=on,I.a(tn in p,"The layout parameter is invalid."),this.layout_=tn,I.a(bn instanceof Array&&bn.length===2&&bn.every(On=>On instanceof at),"The activations parameter is invalid."),this.activations_=bn}inputs(){const re=[this.input_,this.weight_,this.recurrentWeight_];return this.bias_&&re.push(this.bias_),this.recurrentBias_&&re.push(this.recurrentBias_),this.initialHiddenState_&&re.push(this.initialHiddenState_),re}computeImpl(re){const de=re.get(this.input_),ot=re.get(this.weight_),Ct=re.get(this.recurrentWeight_),Yt=this.bias_?re.get(this.bias_):void 0,on=this.recurrentWeight_?re.get(this.recurrentBias_):void 0,tn=this.initialHiddenState_?re.get(this.initialHiddenState_):void 0,bn=this.steps_,On=this.hiddenSize_,Mn=this.resetAfter_,wn=this.returnSequence_,gs=this.layout_,Hs=this.activations_,xr=this.direction_,Ir=xr===f.both?2:1;let qs,ta=tn;ta===void 0&&(ta=o.zeros([Ir,1,On]));const pa=[],rr=[],eo=[],Qs=[];for(let $r=0;$r<Ir;++$r)pa.push(o.squeeze(o.slice(ot,[$r,0,0],[1,-1,-1]),[0])),rr.push(o.squeeze(o.slice(Ct,[$r,0,0],[1,-1,-1]),[0])),eo.push(Yt?o.squeeze(o.slice(Yt,[$r,0],[1,-1]),[0]):void 0),Qs.push(on?o.squeeze(o.slice(on,[$r,0],[1,-1]),[0]):void 0);for(let $r=0;$r<bn;++$r){const ia=[];let Pr;for(let Cr=0;Cr<Ir;++Cr)ia.push(o.squeeze(o.slice(ta,[Cr,0,0],[1,-1,-1]),[0]));for(let Cr=0;Cr<Ir;++Cr){const Ba=Cr===1||xr===f.backward?bn-$r-1:$r,za=o.squeeze(o.slice(de,[Ba,0,0],[1,-1,-1]),[0]),to=o.reshape($e.compute(za,pa[Cr],rr[Cr],ia[Cr],On,Hs,eo[Cr],Qs[Cr],Mn,gs),[1,-1,On]);Pr=Pr?o.concat([Pr,to],0):to}ta=Pr,wn&&(Pr=o.reshape(Pr,[1,Ir,-1,On]),qs=qs?o.concat([qs,Pr],0):Pr)}const mr=[ta];if(wn&&mr.push(qs),this.needCheckOutputShape_){const $r=[[Ir,de.shape[1],On]];wn&&$r.push([bn,Ir,de.shape[1],On]);for(let ia=0;ia<mr.length;++ia)I.b(mr[ia].shape,$r[ia]);this.needCheckOutputShape_=!1}return mr}}class $e extends u{constructor(re,de,ot,Ct,Yt,on={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.weight_=de,I.r(ot),this.recurrentWeight_=ot,I.r(Ct),this.hiddenState_=Ct,I.a(I.j(Yt)&&Yt>0,"The hiddenSize parameter is invalid."),this.hiddenSize_=Yt,this.initOptions(on.bias,on.recurrentBias,on.resetAfter,on.layout,on.activations)}initOptions(re,de,ot=!0,Ct=p.zrn,Yt=[this.builder.sigmoid(),this.builder.tanh()]){I.t(re),this.bias_=re,I.t(de),this.recurrentBias_=de,I.a(I.i(ot),"The resetAfter parameter is not a boolean."),this.resetAfter_=ot,I.a(Ct in p,"The layout parameter is invalid."),this.layout_=Ct,I.a(Yt instanceof Array&&Yt.length===2&&Yt.every(on=>on instanceof at),"The activations parameter is invalid."),this.activations_=Yt}inputs(){const re=[this.input_,this.weight_,this.recurrentWeight_,this.hiddenState_];return this.bias_&&re.push(this.bias_),this.recurrentBias_&&re.push(this.recurrentBias_),re}static compute(re,de,ot,Ct,Yt,on,tn,bn,On=!0,Mn=p.zrn){const wn=o.scalar(1),gs=o.scalar(0),Hs=Mn===p.zrn?{z:0,r:Yt,n:2*Yt}:{r:0,z:Yt,n:2*Yt},xr=on[0],Ir=on[1],qs=xr.runOp(o.add(o.add(tn?o.slice(tn,[Hs.z],[Yt]):gs,bn?o.slice(bn,[Hs.z],[Yt]):gs),o.add(o.matMul(re,o.transpose(o.slice(de,[Hs.z,0],[Yt,-1]))),o.matMul(Ct,o.transpose(o.slice(ot,[Hs.z,0],[Yt,-1])))))),ta=xr.runOp(o.add(o.add(tn?o.slice(tn,[Hs.r],[Yt]):gs,bn?o.slice(bn,[Hs.r],[Yt]):gs),o.add(o.matMul(re,o.transpose(o.slice(de,[Hs.r,0],[Yt,-1]))),o.matMul(Ct,o.transpose(o.slice(ot,[Hs.r,0],[Yt,-1]))))));let pa;return pa=On?Ir.runOp(o.add(tn?o.slice(tn,[Hs.n],[Yt]):gs,o.add(o.matMul(re,o.transpose(o.slice(de,[Hs.n,0],[Yt,-1]))),o.mul(ta,o.add(bn?o.slice(bn,[Hs.n],[Yt]):gs,o.matMul(Ct,o.transpose(o.slice(ot,[Hs.n,0],[Yt,-1])))))))):Ir.runOp(o.add(o.add(tn?o.slice(tn,[Hs.n],[Yt]):gs,bn?o.slice(bn,[Hs.n],[Yt]):gs),o.add(o.matMul(re,o.transpose(o.slice(de,[Hs.n,0],[Yt,-1]))),o.matMul(o.mul(ta,Ct),o.transpose(o.slice(ot,[Hs.n,0],[Yt,-1])))))),o.add(o.mul(qs,Ct),o.mul(pa,o.sub(wn,qs)))}run(re){const de=re.get(this.input_),ot=$e.compute(de,re.get(this.weight_),re.get(this.recurrentWeight_),re.get(this.hiddenState_),this.hiddenSize_,this.activations_,this.bias_?re.get(this.bias_):void 0,this.recurrentBias_?re.get(this.recurrentBias_):void 0,this.resetAfter_,this.layout_);if(this.needCheckOutputShape_){const Ct=[de.shape[0],this.hiddenSize_];I.b(ot.shape,Ct),this.needCheckOutputShape_=!1}return ot}}class ht extends u{constructor(re,de={}){if(super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.t(de.scale),this.scale_=de.scale,I.t(de.bias),this.bias_=de.bias,de.epsilon!==void 0){const ot=de.epsilon;I.a(typeof ot=="number","The epsilon parameter is invalid"),this.epsilon_=ot}else this.epsilon_=1e-5;de.layout!==void 0?(I.a(de.layout in c,"The layout parameter is invalid."),this.layout_=de.layout):this.layout_=c.nchw}inputs(){const re=[this.input_];return this.scale_&&re.push(this.scale_),this.bias_&&re.push(this.bias_),re}run(re){const de=re.get(this.input_);I.a(de.rank===4,"The input operand is not 4-D.");let ot,Ct,Yt=[2,3],on=[1,-1,1,1],tn=de.shape[1];this.layout_===c.nhwc&&(Yt=[1,2],on=[1,1,1,-1],tn=de.shape[3]),this.scale_&&(ot=re.get(this.scale_),I.a(ot.rank===1,"The scale operand is not 1-D."),I.a(ot.shape[0]===tn,"The length of scale is not equal to the size of the feature dimension of the input.")),this.bias_&&(Ct=re.get(this.bias_),I.a(Ct.rank===1,"The bias operand is not 1-D."),I.a(Ct.shape[0]===tn,"The length of bias is not equal to the size of the feature dimension of the input."));const bn=o.mean(de,Yt,!0),On=o.mean(o.pow(o.sub(de,bn),2),Yt,!0),Mn=o.div(o.sub(de,bn),o.sqrt(o.add(On,this.epsilon_))),wn=ot?o.mul(o.reshape(ot,on),Mn):Mn,gs=Ct?o.add(o.reshape(Ct,on),wn):wn;return this.needCheckOutputShape_&&(I.b(gs.shape,de.shape),this.needCheckOutputShape_=!1),gs}}class Pt extends u{constructor(re,de,ot={}){super(re.builder),this.mode_=x.constant,this.value_=0,this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.r(de),this.padding_=de,ot.mode!==void 0&&(I.a(ot.mode in x,"The mode parameter is invalid."),this.mode_=ot.mode),ot.value!==void 0&&(this.value_=ot.value)}inputs(){return[this.input_,this.padding_]}run(re){const de=re.get(this.input_),ot=re.get(this.padding_);I.a(ot.rank===2&&ot.dtype==="int32"&&ot.shape[0]===de.rank,"The padding operand is invalid.");const Ct=ot.arraySync(),Yt=de.shape.map((tn,bn)=>tn+Ct[bn][0]+Ct[bn][1]);let on;if(this.mode_===x.constant)on=o.pad(de,Ct,this.value_);else if(this.mode_===x.edge){const tn=new Array(Ct.length);let bn=de;for(;;){for(let On=0;On<Ct.length;++On){tn[On]=[0,0];for(let Mn=0;Mn<2;++Mn)Ct[On][Mn]>0?(tn[On][Mn]=1,Ct[On][Mn]-=1):tn[On][Mn]=0}if(tn.every(On=>On[0]===0&&On[1]===0))break;bn=o.mirrorPad(bn,tn,"symmetric")}on=bn}else{let tn;this.mode_===x.reflection?tn="reflect":this.mode_===x.symmetric&&(tn="symmetric"),on=o.mirrorPad(de,Ct,tn)}return this.needCheckOutputShape_&&(I.b(on.shape,Yt),this.needCheckOutputShape_=!1),on}}class Ot extends u{constructor(re,de={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,this.initOptions(de.windowDimensions,de.padding,de.strides,de.dilations,de.layout,de.autoPad,de.roundingType,de.outputSizes)}initOptions(re=[-1,-1],de=[0,0,0,0],ot=[1,1],Ct=[1,1],Yt=c.nchw,on=h.explicit,tn=b.floor,bn){I.a(I.k(re)&&re.length===2,"The padding parameter is invalid."),this.windowDimensions_=re,I.a(I.k(de)&&de.length===4,"The padding parameter is invalid."),this.padding_=de,I.a(I.k(ot)&&ot.length===2,"The strides parameter is invalid."),this.strides_=ot,I.a(I.k(Ct)&&Ct.length===2,"The dilations parameter is invalid."),this.dilations_=Ct,I.a(Yt in c,"The layout parameter is invalid."),this.layout_=Yt,I.a(on in h,"The autoPad parameter is invalid."),this.autoPad_=on,I.a(tn in b,"The roundingType parameter is invalid."),this.roundingType_=tn,bn&&I.a(I.k(bn)&&bn.length===2,"The outputSizes parameter is invalid."),this.outputSizes_=bn}inputs(){return[this.input_]}calculateOutputSizes(re,de){const ot=re[1],Ct=re[2],Yt=this.windowDimensions_[0],on=this.windowDimensions_[1];let tn,bn=this.padding_[0],On=this.padding_[1],Mn=this.padding_[2],wn=this.padding_[3];if(this.autoPad_!==h.explicit&&([bn,On]=I.c(this.autoPad_,this.dilations_[0],ot,Yt,this.strides_[0],bn,On),[Mn,wn]=I.c(this.autoPad_,this.dilations_[1],Ct,on,this.strides_[1],Mn,wn)),de===void 0)tn=Math.trunc;else switch(de){case"ceil":tn=Math.ceil;break;case"floor":tn=Math.floor;break;case"round":tn=Math.round}const gs=Yt+(Yt-1)*(this.dilations_[0]-1),Hs=on+(on-1)*(this.dilations_[1]-1);return[1+tn((ot-gs+bn+On)/this.strides_[0]),1+tn((Ct-Hs+Mn+wn)/this.strides_[1])]}run(re){let de=re.get(this.input_);this.layout_===c.nchw&&(de=o.transpose(de,[0,2,3,1]));const ot=this.windowDimensions_;let Ct;if(ot[0]===-1&&ot[1]===-1&&(ot[0]=de.shape[1],ot[1]=de.shape[2]),this.outputSizes_!==void 0){let bn=!1;for(const On of[void 0,"ceil","floor","round"]){const[Mn,wn]=this.calculateOutputSizes(de.shape,On);if(this.outputSizes_[0]===Mn&&this.outputSizes_[1]===wn){Ct=On,bn=!0;break}}I.a(bn,`The outputSizes [${this.outputSizes_}] is invalid.`)}else Ct=this.roundingType_===b.floor?"floor":"ceil";const Yt=this.getPoolingType();let on,tn;if(this.autoPad_===h.explicit)this.padding_.every(bn=>bn===0)?(on="valid",Ct=void 0):on=[[0,0],[this.padding_[0],this.padding_[1]],[this.padding_[2],this.padding_[3]],[0,0]];else if(this.autoPad_===h["same-upper"])on="same",Ct=void 0;else{on=[[0,0],[0,0],[0,0],[0,0]];const bn=[0,0];for(let Mn=0;Mn<2;++Mn)bn[Mn]=Math.ceil(de.shape[1+Mn]/this.strides_[Mn]);const On=[0,0];for(let Mn=0;Mn<2;++Mn)On[Mn]=this.strides_[Mn]*(bn[Mn]-1)+((ot[Mn]-1)*this.dilations_[Mn]+1)-de.shape[1+Mn];for(let Mn=0;Mn<2;++Mn)on[Mn+1][0]=On[Mn]-Math.floor(On[Mn]/2),on[Mn+1][1]=Math.floor(On[Mn]/2)}if(Yt==="l2"?(de=o.pow(de,2),tn=o.sqrt(o.pool(de,this.windowDimensions_,"avg",on,this.dilations_,this.strides_,Ct))):tn=o.pool(de,this.windowDimensions_,Yt,on,this.dilations_,this.strides_,Ct),this.layout_===c.nchw&&(tn=o.transpose(tn,[0,3,1,2])),this.needCheckOutputShape_){let bn,On,Mn;this.outputSizes_!==void 0?(bn=this.outputSizes_[0],On=this.outputSizes_[1]):(Ct=this.roundingType_===b.floor?"floor":"ceil",[bn,On]=this.calculateOutputSizes(de.shape,Ct)),Mn=this.layout_===c.nchw?[de.shape[0],de.shape[3],bn,On]:[de.shape[0],bn,On,de.shape[3]],I.b(tn.shape,Mn),this.needCheckOutputShape_=!1}return tn}}class xn extends Ot{getPoolingType(){return"avg"}}class Dn extends Ot{getPoolingType(){return"max"}}class pe extends Ot{getPoolingType(){return"l2"}}class be extends u{constructor(re,de={}){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,de.axes!==void 0?(I.a(I.k(de.axes),"The axes parameter is invalid."),this.axes_=de.axes):this.axes_=void 0,de.keepDimensions!==void 0?(I.a(I.i(de.keepDimensions),"The keepDimensions parameter is not a boolean."),this.keepDimensions_=de.keepDimensions):this.keepDimensions_=!1}inputs(){return[this.input_]}run(re){var de;const ot=re.get(this.input_);I.a(I.q(this.axes_,ot.rank),`The axes must be in range [-${ot.rank}, ${ot.rank})`);const Ct=this.runOp(ot,this.axes_,this.keepDimensions_);if(this.needCheckOutputShape_){const Yt=(de=this.axes_)!==null&&de!==void 0?de:[...Array(ot.rank).keys()];let on=ot.shape.slice();for(let tn=0;tn<Yt.length;++tn)Yt[tn]<0&&(Yt[tn]=ot.rank+Yt[tn]),on[Yt[tn]]=1;this.keepDimensions_||(on=on.filter((tn,bn)=>!(tn===1&&Yt.indexOf(bn)!==-1))),I.b(Ct.shape,on),this.needCheckOutputShape_=!1}return Ct}}class Qe extends be{runOp(re,de,ot){return o.logSumExp(re,de,ot)}}class Un extends be{runOp(re,de,ot){return o.max(re,de,ot)}}class Ws extends be{runOp(re,de,ot){return o.mean(re,de,ot)}}class Gs extends be{runOp(re,de,ot){return o.min(re,de,ot)}}class As extends be{runOp(re,de,ot){return o.prod(re,de,ot)}}class xs extends be{runOp(re,de,ot){return o.sum(re,de,ot)}}class ds extends be{runOp(re,de,ot){return o.sum(o.abs(re),de,ot)}}class Ys extends be{runOp(re,de,ot){return o.sqrt(o.sum(o.pow(re,2),de,ot))}}class pn extends u{constructor(re,de={}){if(super(re.builder),this.mode_=m["nearest-neighbor"],this.scales_=[1,1],this.axes_=[2,3],this.needCheckOutputShape_=!0,I.r(re),this.input_=re,de.scales!==void 0){const ot=de.scales;I.a(ot instanceof Array&&ot.every(Ct=>typeof Ct=="number")&&ot.length===2,"The scales parameter is invalid."),this.scales_=de.scales}de.sizes!==void 0&&(I.a(I.k(de.sizes)&&de.sizes.length===2,"The sizes parameter is invalid."),this.sizes_=de.sizes),de.axes!==void 0&&(I.a(I.k(de.axes)&&de.axes.length===2&&I.n(de.axes),"The axes parameter is invalid."),this.axes_=de.axes),I.a(this.scales_!==void 0||this.sizes_!==void 0,"The scales or sizes parameter is not provied."),de.mode!==void 0&&(I.a(de.mode in m,"The mode parameter is invalid."),this.mode_=de.mode)}inputs(){return[this.input_]}run(re){let de=re.get(this.input_);I.a(de.rank===4,"The input tensor is not 4-D.");const ot=de.shape.slice(),Ct=[0,0];let Yt;return this.sizes_!==void 0?(Ct[0]=this.sizes_[0],Ct[1]=this.sizes_[1]):this.scales_!==void 0&&(Ct[0]=Math.floor(de.shape[this.axes_[0]]*this.scales_[0]),Ct[1]=Math.floor(de.shape[this.axes_[1]]*this.scales_[1])),this.axes_[0]===0?de=o.transpose(de,[2,0,1,3]):this.axes_[0]===2&&(de=o.transpose(de,[0,2,3,1])),this.mode_===m["nearest-neighbor"]?Yt=o.image.resizeNearestNeighbor(de,Ct,!1,!0):this.mode_===m.linear&&(Yt=o.image.resizeBilinear(de,Ct,!1,!0)),this.axes_[0]===0?Yt=o.transpose(Yt,[1,2,0,3]):this.axes_[0]===2&&(Yt=o.transpose(Yt,[0,3,1,2])),this.needCheckOutputShape_&&(this.axes_.map((on,tn)=>ot[on]=Ct[tn]),I.b(Yt.shape,ot),this.needCheckOutputShape_=!1),Yt}}class Nn extends u{constructor(re,de){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.a(I.l(de)&&de.length!==0,"The newShape parameter is invalid."),this.newShape_=de}inputs(){return[this.input_]}run(re){const de=re.get(this.input_),ot=this.newShape_.slice(),Ct=ot.indexOf(null);Ct!==-1&&(ot[Ct]=-1,ot[Ct]=I.o(de.shape)/I.o(ot)*-1);const Yt=o.reshape(de,ot);return this.needCheckOutputShape_&&(I.b(Yt.shape,ot),this.needCheckOutputShape_=!1),Yt}}class ts extends u{constructor(re,de,ot,Ct){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.a(I.k(de),"The starts parameter is invalid."),this.starts_=de,I.a(I.k(ot)&&ot.every(Yt=>Yt>0||Yt===-1),"The sizes parameter is invalid."),this.sizes_=ot,I.a(ot.length==ot.length,"The length of sizes is not equal to the length of sizes.))"),I.a(Ct===void 0||I.k(Ct),"The axes parameter is invalid."),Ct!==void 0&&I.a(ot.length===Ct.length,"The length of axes is invalid.))"),this.axes_=Ct}inputs(){return[this.input_]}run(re){const de=re.get(this.input_),ot=de.shape.length;if(this.axes_===void 0){this.axes_=[];for(let tn=0;tn<ot;++tn)this.axes_.push(tn)}I.a(this.axes_.every(tn=>tn<ot&&tn>=-ot),"The value of axes is invalid."),I.a(this.starts_.length===this.axes_.length,"The length of starts is invalid."),I.a(this.sizes_.length===this.axes_.length,"The length of sizes is invalid.");const Ct=new Array(this.axes_.length).fill(0),Yt=new Array(this.axes_.length).fill(-1);for(let tn=0;tn<this.axes_.length;++tn){let bn=this.axes_[tn];bn<0&&(bn=ot+bn),Ct[bn]=this.starts_[tn]>=0?this.starts_[tn]:this.starts_[tn]+de.shape[bn],Yt[bn]=this.sizes_[tn]}const on=o.slice(de,Ct,Yt);if(this.needCheckOutputShape_){const tn=de.shape.slice();for(let bn=0;bn<this.axes_.length;++bn){const On=this.axes_[bn]>=0?this.axes_[bn]:this.axes_[bn]+ot,Mn=de.shape[On],wn=this.starts_[bn],gs=this.sizes_[bn];tn[On]=gs>=0?gs:wn>=0?Mn-wn:-wn}I.b(on.shape,tn)}return on}}class $s extends u{constructor(re){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.x_=re}inputs(){return[this.x_]}run(re){const de=re.get(this.x_);if(de.rank!==2)throw new Error("The rank of x parameter should be 2.");const ot=o.softmax(de);return this.needCheckOutputShape_&&(I.b(ot.shape,de.shape),this.needCheckOutputShape_=!1),ot}}class Ns extends i{constructor(re,de,ot={}){var Ct;super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,I.a(I.j(de)||I.k(de),"The splits parameter is invalid."),this.splits_=de,I.a(ot.axis===void 0||I.j(ot.axis),"The options.axis is invalid."),this.axis_=(Ct=ot.axis)!==null&&Ct!==void 0?Ct:0;const Yt=I.j(de)?de:de.length;for(let on=0;on<Yt;++on)this.outputs.push(new a.e(this))}inputs(){return[this.input_]}computeImpl(re){const de=re.get(this.input_),ot=o.split(de,this.splits_,this.axis_);if(this.needCheckOutputShape_){const Ct=this.axis_>=0?this.axis_:this.axis_+de.rank;let Yt=[];Yt=typeof this.splits_=="number"?new Array(this.splits_).fill(de.shape[Ct]/this.splits_):this.splits_.slice();const on=[];for(const tn of Yt){const bn=de.shape.slice();bn[Ct]=tn,on.push(bn)}for(let tn=0;tn<ot.length;++tn)I.b(ot[tn].shape,on[tn]);this.needCheckOutputShape_=!1}return ot}}class ys extends u{constructor(re,de){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,de!==void 0&&I.a(I.k(de)&&de.length!==0,"The axes parameter is invalid."),this.axes_=de}inputs(){return[this.input_]}run(re){var de;const ot=re.get(this.input_),Ct=o.squeeze(ot,this.axes_);if(this.needCheckOutputShape_){const Yt=(de=this.axes_)!==null&&de!==void 0?de:[...Array(ot.rank).keys()],on=ot.shape.filter((tn,bn)=>!(tn===1&&Yt.indexOf(bn)!==-1));I.b(Ct.shape,on),this.needCheckOutputShape_=!1}return Ct}}class Vs extends u{constructor(re,de){super(re.builder),this.needCheckOutputShape_=!0,I.r(re),this.input_=re,de!==void 0&&I.a(I.k(de)&&de.length!==0,"The permutation parameter is invalid."),this.permutation_=de}inputs(){return[this.input_]}run(re){var de;const ot=re.get(this.input_),Ct=o.transpose(ot,this.permutation_);if(this.needCheckOutputShape_){const Yt=(de=this.permutation_)!==null&&de!==void 0?de:new Array(ot.rank).fill(0).map((tn,bn,On)=>On.length-bn-1),on=new Array(ot.rank).fill(0).map((tn,bn)=>ot.shape[Yt[bn]]);I.b(Ct.shape,on),this.needCheckOutputShape_=!1}return Ct}}(function(jt){jt.nchw="nchw",jt.nhwc="nhwc"})(c||(c={})),function(jt){jt.oihw="oihw",jt.hwio="hwio",jt.ohwi="ohwi",jt.ihwo="ihwo"}(d||(d={})),function(jt){jt.explicit="explicit",jt["same-upper"]="same-upper",jt["same-lower"]="same-lower"}(h||(h={})),function(jt){jt.iohw="iohw",jt.hwoi="hwoi",jt.ohwi="ohwi"}(l||(l={})),function(jt){jt.zrn="zrn",jt.rzn="rzn"}(p||(p={})),function(jt){jt.forward="forward",jt.backward="backward",jt.both="both"}(f||(f={})),function(jt){jt.constant="constant",jt.edge="edge",jt.reflection="reflection",jt.symmetric="symmetric"}(x||(x={})),function(jt){jt.floor="floor",jt.ceil="ceil"}(b||(b={})),function(jt){jt["nearest-neighbor"]="nearest-neighbor",jt.linear="linear"}(m||(m={}));class Us{constructor(re){I.a(re instanceof n.a,"The context paramter is invalid."),this.context_=re}get context(){return this.context_}async build(re){return await r.a.buildAndCompile(re)}buildSync(re){return I.a(typeof window=="undefined"&&typeof importScripts=="function","buildSync() should only be allowed in dedicated worker."),r.a.buildAndCompileSync(re)}input(re,de){return new a.b(re,de,this)}constant(re,de){return typeof re=="number"?(de===void 0&&(de=a.d.float32),a.a.createScalar(re,de,this)):a.a.createTensor(re,de,this)}batchNormalization(re,de,ot,Ct={}){return this.validateOperandBuilder([re,de,ot,Ct.scale,Ct.bias]),new N(re,de,ot,Ct).getFusedOutputs()[0]}clamp(re={},de={}){if(re instanceof a.c){const ot=re;return this.validateOperandBuilder([ot]),new Rn(ot,de).output}return new Rn(void 0,re)}concat(re,de){return this.validateOperandBuilder(re),new ee(re,de).output}conv2d(re,de,ot={}){const Ct=[re,de];return ot.bias&&Ct.push(ot.bias),this.validateOperandBuilder(Ct),new we(re,de,ot).getFusedOutputs()[0]}convTranspose2d(re,de,ot={}){const Ct=[re,de];return ot.bias&&Ct.push(ot.bias),this.validateOperandBuilder(Ct),new pt(re,de,ot).getFusedOutputs()[0]}add(re,de){return this.validateOperandBuilder([re,de]),new D(re,de).output}sub(re,de){return this.validateOperandBuilder([re,de]),new U(re,de).output}mul(re,de){return this.validateOperandBuilder([re,de]),new L(re,de).output}div(re,de){return this.validateOperandBuilder([re,de]),new Y(re,de).output}max(re,de){return this.validateOperandBuilder([re,de]),new V(re,de).output}min(re,de){return this.validateOperandBuilder([re,de]),new P(re,de).output}pow(re,de){return this.validateOperandBuilder([re,de]),new oe(re,de).output}abs(re){return this.validateOperandBuilder([re]),new ye(re).output}ceil(re){return this.validateOperandBuilder([re]),new Ee(re).output}cos(re){return this.validateOperandBuilder([re]),new X(re).output}exp(re){return this.validateOperandBuilder([re]),new je(re).output}floor(re){return this.validateOperandBuilder([re]),new Be(re).output}log(re){return this.validateOperandBuilder([re]),new tt(re).output}neg(re){return this.validateOperandBuilder([re]),new ct(re).output}sin(re){return this.validateOperandBuilder([re]),new Me(re).output}tan(re){return this.validateOperandBuilder([re]),new wt(re).output}hardSwish(re){return re===void 0?new mn(void 0):(this.validateOperandBuilder([re]),new mn(re).output)}relu(re){return re===void 0?new dn(void 0):(this.validateOperandBuilder([re]),new dn(re).output)}sigmoid(re){return re===void 0?new Gt(void 0):(this.validateOperandBuilder([re]),new Gt(re).output)}tanh(re){return re===void 0?new Ht(void 0):(this.validateOperandBuilder([re]),new Ht(re).output)}gemm(re,de,ot={}){return this.validateOperandBuilder([re,de,ot.c]),bt.build(this,re,de,ot)}gru(re,de,ot,Ct,Yt,on={}){return this.validateOperandBuilder([re,de,ot,on.bias,on.recurrentBias,on.initialHiddenState]),new At(re,de,ot,Ct,Yt,on).outputs}gruCell(re,de,ot,Ct,Yt,on={}){return this.validateOperandBuilder([re,de,ot,Ct,on.bias,on.recurrentBias]),new $e(re,de,ot,Ct,Yt,on).output}instanceNormalization(re,de={}){return this.validateOperandBuilder([re,de.bias,de.scale]),new ht(re,de).output}leakyRelu(re={},de={}){if(re instanceof a.c){const ot=re;return this.validateOperandBuilder([ot]),new se(ot,de.alpha).output}return new se(void 0,re.alpha)}matmul(re,de){return this.validateOperandBuilder([re,de]),new ne(re,de).output}pad(re,de,ot={}){return this.validateOperandBuilder([re,de]),new Pt(re,de,ot).output}averagePool2d(re,de={}){return this.validateOperandBuilder([re]),new xn(re,de).output}l2Pool2d(re,de={}){return this.validateOperandBuilder([re]),new pe(re,de).output}maxPool2d(re,de={}){return this.validateOperandBuilder([re]),new Dn(re,de).output}reduceL1(re,de={}){return this.validateOperandBuilder([re]),new ds(re,de).output}reduceL2(re,de={}){return this.validateOperandBuilder([re]),new Ys(re,de).output}reduceLogSumExp(re,de={}){return this.validateOperandBuilder([re]),new Qe(re,de).output}reduceMax(re,de={}){return this.validateOperandBuilder([re]),new Un(re,de).output}reduceMean(re,de={}){return this.validateOperandBuilder([re]),new Ws(re,de).output}reduceMin(re,de={}){return this.validateOperandBuilder([re]),new Gs(re,de).output}reduceProduct(re,de={}){return this.validateOperandBuilder([re]),new As(re,de).output}reduceSum(re,de={}){return this.validateOperandBuilder([re]),new xs(re,de).output}resample2d(re,de={}){return this.validateOperandBuilder([re]),new pn(re,de).output}reshape(re,de){return this.validateOperandBuilder([re]),new Nn(re,de).output}slice(re,de,ot,Ct={}){return this.validateOperandBuilder([re]),new ts(re,de,ot,Ct.axes).output}softmax(re){return this.validateOperandBuilder([re]),new $s(re).output}split(re,de,ot={}){return this.validateOperandBuilder([re]),new Ns(re,de,ot).outputs}squeeze(re,de={}){return this.validateOperandBuilder([re]),new ys(re,de.axes).output}transpose(re,de={}){return this.validateOperandBuilder([re]),new Vs(re,de.permutation).output}validateOperandBuilder(re){I.a(re.every(de=>!de||de instanceof a.c&&de.builder===this),"The operand is not built by this builder.")}}},function(s,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch{typeof window=="object"&&(t=window)}s.exports=t},function(s,e){var t,n,r=s.exports={};function a(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(b){if(t===setTimeout)return setTimeout(b,0);if((t===a||!t)&&setTimeout)return t=setTimeout,setTimeout(b,0);try{return t(b,0)}catch{try{return t.call(null,b,0)}catch{return t.call(this,b,0)}}}(function(){try{t=typeof setTimeout=="function"?setTimeout:a}catch{t=a}try{n=typeof clearTimeout=="function"?clearTimeout:o}catch{n=o}})();var u,c=[],d=!1,h=-1;function l(){d&&u&&(d=!1,u.length?c=u.concat(c):h=-1,c.length&&p())}function p(){if(!d){var b=i(l);d=!0;for(var m=c.length;m;){for(u=c,c=[];++h<m;)u&&u[h].run();h=-1,m=c.length}u=null,d=!1,function(I){if(n===clearTimeout)return clearTimeout(I);if((n===o||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(I);try{n(I)}catch{try{return n.call(null,I)}catch{return n.call(this,I)}}}(b)}}function f(b,m){this.fun=b,this.array=m}function x(){}r.nextTick=function(b){var m=new Array(arguments.length-1);if(arguments.length>1)for(var I=1;I<arguments.length;I++)m[I-1]=arguments[I];c.push(new f(b,m)),c.length!==1||d||i(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=x,r.addListener=x,r.once=x,r.off=x,r.removeListener=x,r.removeAllListeners=x,r.emit=x,r.prependListener=x,r.prependOnceListener=x,r.listeners=function(b){return[]},r.binding=function(b){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(b){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},function(s,e){s.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(s,e){(function(t){s.exports=t}).call(this,{})},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return i}),t.d(e,"b",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c===d?1:0),i=Object(a.a)(n.Equal,o,null,"bool"),u={kernelName:n.Equal,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return i}),t.d(e,"b",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.exp(c)),i=Object(a.b)(n.Exp,o,"float32"),u={kernelName:n.Exp,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c){const d=o.length,h=n.util.sizeFromShape(o),l=n.util.computeStrides(o),p=n.util.computeStrides(c),f=n.util.getTypedArrayFromDType(i,n.util.sizeFromShape(c));for(let x=0;x<h;++x){const b=n.util.indexToLoc(x,d,l),m=new Array(b.length);for(let I=0;I<m.length;I++)m[I]=b[u[I]];f[n.util.locToIndex(m,d,p)]=a[x]}return f}},function(s,e,t){t.d(e,"c",function(){return o}),t.d(e,"a",function(){return i}),t.d(e,"b",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>1/(1+Math.exp(-c))),i=Object(a.a)(n.Sigmoid,c=>1/(1+Math.exp(-c))),u={kernelName:n.Sigmoid,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c,d=!1,h=0){const l=u.length,p=[o[0],a.length/o[0]],f=p[1],x=l>0?c[l-1]+1:0;if(x<0)throw new Error(n.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const b=o.slice();b[0]=x;const m=b.reduce((L,Y)=>L*Y,1),I=n.util.getArrayFromDType(i,m);if(l===0)return x>0&&I.fill(h),[I,b];if(x<=0)throw new Error(n.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let N=0,E=1,D=0,U=c[N];for(;;){let L=0;if(E<l){if(L=c[E],U===L){++E;continue}if(U>=L)throw new Error(n.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(U<0||U>=x)throw new Error(n.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(U,x));U>D&&I.fill(h,D*f,U*f);for(let Y=N;Y<E;++Y){const V=u[Y];if(V<0||V>=p[0])throw new Error(n.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(Y,u[Y],p[0]));for(let P=0;P<f;P++)I[U*f+P]+=a[V*f+P]}if(d)for(let Y=0;Y<f;Y++)I[U*f+Y]/=E-N;if(N=E,++E,D=U+1,U=L,E>l)break}return D<x&&I.fill(h,D*f,x*f),[I,b]}},function(s,e,t){var n=t(112),r=t(113),a=t(114),o=t(115),i=t(116),u=t(117),c=t(118);c.alea=n,c.xor128=r,c.xorwow=a,c.xorshift7=o,c.xor4096=i,c.tychei=u,s.exports=c},function(s,e,t){(function(n){t(3);var r=t(55),a=t(9);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(a.c)();o.registerFlag("DEBUG",()=>!1,i=>{i&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),o.registerFlag("IS_BROWSER",()=>r.isBrowser()),o.registerFlag("IS_NODE",()=>typeof n!="undefined"&&typeof n.versions!="undefined"&&typeof n.versions.node!="undefined"),o.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),o.registerFlag("PROD",()=>!1),o.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>o.getBool("DEBUG")),o.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),o.registerFlag("IS_TEST",()=>!1),o.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),o.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),o.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),o.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1)}).call(this,t(41))},function(s,e,t){t.d(e,"a",function(){return n}),t.d(e,"b",function(){return r});class n{constructor(i,u){this.backend=i,this.dataMover=u,this.data=new WeakMap,this.dataIdsCount=0}get(i){return this.data.has(i)||this.dataMover.moveData(this.backend,i),this.data.get(i)}set(i,u){this.dataIdsCount++,this.data.set(i,u)}has(i){return this.data.has(i)}delete(i){return this.dataIdsCount--,this.data.delete(i)}numDataIds(){return this.dataIdsCount}}class r{refCount(i){return a("refCount")}incRef(i){return a("incRef")}timerAvailable(){return!0}time(i){return a("time")}read(i){return a("read")}readSync(i){return a("readSync")}readToGPU(i,u){return a("readToGPU")}numDataIds(){return a("numDataIds")}disposeData(i,u){return a("disposeData")}write(i,u,c){return a("write")}move(i,u,c,d,h){return a("move")}memory(){return a("memory")}floatPrecision(){return a("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return a("dispose")}}function a(o){throw new Error(`'${o}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},function(s,e,t){t.d(e,"a",function(){return n});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},function(s,e,t){t.d(e,"a",function(){return i}),t(97),t(98),t(99),t(90);var n=t(0),r=t(11),a=t(5);class o{constructor(c,d,h,l){this.constantTenosrs_=c,this.operandRefs_=l,this.allocateInputTensors(d,h),this.outputTensors_=new Map,this.outputOperands_=new Set}allocateInputTensors(c,d){this.inputTensors_=new Map;for(const h in d){const l=d[h],p=c.get(h),f=p.desc,x=l;this.inputTensors_.set(p,{ref:this.operandRefs_.get(p),tensor:a.e(f,x)})}}compute(c){for(const h of c.values())this.outputOperands_.add(h);const d={};for(const h of c.keys())d[h]=this.getTensor(c.get(h));return d}setOutputTensor(c,d){a.a(!this.outputTensors_.has(c),"MLOutput already has tensor."),this.outputTensors_.set(c,{ref:this.operandRefs_.get(c),tensor:d})}releaseTensor(c){let d;if(c instanceof r.b)d=this.inputTensors_;else{if(!(c instanceof r.e)||this.outputOperands_.has(c))return;d=this.outputTensors_}const h=d.get(c);a.a(h!==void 0,"No tensor found for operand."),h.ref--,h.ref===0&&(n.dispose(h.tensor),d.delete(c))}getTensor(c){if(c instanceof r.a)return this.constantTenosrs_.get(c);if(c instanceof r.b)return this.inputTensors_.get(c).tensor;if(c instanceof r.e)return this.outputTensors_.has(c)||(c.operation.compute(this),a.a(this.outputTensors_.has(c),"No output is set.")),this.outputTensors_.get(c).tensor;throw new Error("The operand is invalid.")}}class i{validateInputs(c){for(const d in c){a.a(typeof d=="string"&&this.inputs_.has(d),"The name of the input is invalid.");const h=this.inputs_.get(d),l=c[d],p=h.desc.dimensions;a.a(a.m(l),"Only resource of ArrayBufferView type is supported."),a.u(l,h.desc.type,p)}}validateAndSetOutputOperands(c){a.a(Object.keys(c).length!==0,"The outputs is invalid.");const d=new Map;for(const h in c)a.a(typeof h=="string"&&this.outputs_.has(h),"The name of the output is invalid."),a.a(a.m(c[h]),"Only output of ArrayBufferView type is supported."),d.set(h,this.outputs_.get(h));return d}computeOutputTensors(c,d){if(c)this.validateInputs(c);else{c={};for(const l of this.inputs_.keys()){const p=this.inputs_.get(l),f=new(a.h(p.desc.type))(a.p(p.desc.dimensions));c[l]=f}}let h=this.outputs_;return d&&(h=this.validateAndSetOutputOperands(d)),n.tidy(()=>new o(this.constantTensors_,this.inputs_,c,this.operandRefs_).compute(h))}async compute(c,d){const h=this.computeOutputTensors(c,d);for(const l of Object.keys(h)){const p=h[l],f=a.d(p),x=d[l];a.u(x,f.type,f.dimensions),x.set(await p.data()),n.dispose(p)}return{inputs:c,outputs:d}}computeSync(c,d){const h=this.computeOutputTensors(c,d);for(const l of Object.keys(h)){const p=h[l],f=a.d(p),x=d[l];a.u(x,f.type,f.dimensions),x.set(p.dataSync()),n.dispose(p)}}constructor(c){this.inputs_=new Map,this.outputs_=new Map,this.constants_=new Set,this.operandRefs_=new Map,this.constantTensors_=new Map,a.a(c!==void 0,"Invalid argument");for(const d in c)a.a(typeof d=="string"&&c[d]instanceof r.e,"The outputs parameter is invalid."),this.outputs_.set(d,c[d]);a.a(this.outputs_.size!==0,"The outputs is empty")}static async buildAndCompile(c){const d=new i(c);return d.build(),await d.compile(),d}static buildAndCompileSync(c){const d=new i(c);return d.build(),d.compileSync(),d}build(){const c=new Set;for(const d of this.outputs_.values())this.buildOperation(d.operation,c)}buildOperation(c,d){if(!d.has(c)){d.add(c);for(const h of c.inputs()){if(this.operandRefs_.has(h)){let l=this.operandRefs_.get(h);l++,this.operandRefs_.set(h,l)}else this.operandRefs_.set(h,1);if(h instanceof r.b){if(this.inputs_.has(h.name)){if(this.inputs_.get(h.name)!==h)throw new Error("The name of this input is existed.");continue}this.inputs_.set(h.name,h)}else h instanceof r.a?this.constants_.has(h)||this.constants_.add(h):h instanceof r.e&&this.buildOperation(h.operation,d)}}}async compile(){this.allocateConstants(),await this.computeOnce()}compileSync(){this.allocateConstants(),this.computeOnceSync()}allocateConstants(){for(const c of this.constants_)this.constantTensors_.set(c,a.e(c.desc,c.value))}async computeOnce(){const c=this.computeOutputTensors();for(const d of Object.keys(c)){const h=c[d];await h.data(),n.dispose(h)}}computeOnceSync(){const c=this.computeOutputTensors();for(const d of Object.keys(c)){const h=c[d];h.dataSync(),n.dispose(h)}}dispose(){for(const d of this.constantTensors_.values())n.dispose(d);const c=new Set;for(const d of this.outputs_.values())this.disposeOperation(d.operation,c)}disposeOperation(c,d){if(!d.has(c)){c.dispose(),d.add(c);for(const h of c.inputs())h instanceof r.e&&this.disposeOperation(h.operation,d)}}}},function(s,e){},function(s,e,t){let n;function r(i){n=i}function a(i){if(n!==void 0)return n;if(i||typeof navigator!="undefined"&&navigator!=null){if(i||(i=navigator),i.product==="ReactNative")return!0;const u=i.userAgent||i.vendor||(typeof window!="undefined"?window.opera:"");if(!u){const c=i;return c.userAgentData&&c.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(u)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(u.substr(0,4))}return!1}function o(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}t.r(e),t.d(e,"mockIsMobile",function(){return r}),t.d(e,"isMobile",function(){return a}),t.d(e,"isBrowser",function(){return o})},function(s,e,t){t.d(e,"b",function(){return a}),t.d(e,"a",function(){return o});var n=t(0),r=t(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(i){const u=new Float32Array(i.length);for(let c=0;c<i.length;++c)u[c]=Math.abs(i[c]);return u}const o={kernelName:n.Abs,backendName:"cpu",kernelFunc:i=>{const{x:u}=i.inputs,c=i.backend;Object(r.a)(u,"abs");let d=new Float32Array(n.util.sizeFromShape(u.shape));return d=a(c.data.get(u.dataId).values),c.makeOutput(d,u.shape,u.dtype)}}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.ceil(c)),i=Object(a.b)(n.Ceil,o),u={kernelName:n.Ceil,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u){const c=n.util.getArrayFromDType(i,n.util.sizeFromShape(o));if(u&&i!=="string"){let d=0;a.forEach(h=>{const l=n.util.sizeFromShape(h.shape);c.set(h.vals,d),d+=l})}else{let d=0;a.forEach(h=>{const l=i==="string"?n.backend_util.fromUint8ToStringArray(h.vals):h.vals;let p=0;for(let f=0;f<h.shape[0];++f){const x=f*o[1]+d;for(let b=0;b<h.shape[1];++b)c[x+b]=l[p++]}d+=h.shape[1]})}return c}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.expm1(c)),i=Object(a.b)(n.Expm1,o),u={kernelName:n.Expm1,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.floor(c)),i=Object(a.b)(n.Floor,o),u={kernelName:n.Floor,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c,d,h,l,p){const f=Object(n.buffer)([u,d],i);for(let x=0;x<u;x++){const b=[];let m=0;for(let I=0;I<c;I++){const N=a[x*c+I];m+=N*h[I],b.push(N)}if(m<0||m>=p/d)throw new Error(`Invalid indices: ${b} does not index into ${l}`);for(let I=0;I<d;I++)f.values[x*d+I]=o.get(...o.indexToLoc(m*d+I))}return f}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i){const u=Object(n.buffer)(i,a.dtype);for(let c=0;c<u.size;++c){const d=u.indexToLoc(c).slice(),h=d[0],l=d[2],p=o.locToIndex([h,l]);d[2]=o.values[p];const f=a.locToIndex(d);0<=f&&f<a.values.length&&(u.values[c]=a.values[f])}return u}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c>d?1:0),i=Object(a.a)(n.Greater,o,null,"bool"),u={kernelName:n.Greater,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c>=d?1:0),i=Object(a.a)(n.GreaterEqual,o,null,"bool"),u={kernelName:n.GreaterEqual,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c<d?1:0),i=Object(a.a)(n.Less,o,null,"bool"),u={kernelName:n.Less,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c<=d?1:0),i=Object(a.a)(n.LessEqual,o,null,"bool"),u={kernelName:n.LessEqual,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i){const u=(o-a)/(i-1),c=n.util.makeZerosTypedArray(i,"float32");c[0]=a;for(let d=1;d<c.length;d++)c[d]=c[d-1]+u;return c}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.log(c)),i=Object(a.b)(n.Log,o),u={kernelName:n.Log,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u){const c=n.util.getTypedArrayFromDType(u,n.util.sizeFromShape(i));for(let d=0;d<c.length;++d){const h=d*o;let l=a[h];for(let p=0;p<o;++p){const f=a[h+p];(Number.isNaN(f)||f>l)&&(l=f)}c[d]=l}return c}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>Math.max(c,d)),i=Object(a.a)(n.Maximum,o),u={kernelName:n.Maximum,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>Math.min(c,d)),i=Object(a.a)(n.Minimum,o),u={kernelName:n.Minimum,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return i});var n=t(0),r=t(7),a=t(29);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(u,c,d){const h=n.util.createScalarValue(-1,d);return Object(a.c)([],c,h,u,d)}const i={kernelName:n.Neg,backendName:"cpu",kernelFunc:function(u){const{inputs:c,backend:d}=u,{x:h}=c;Object(r.a)(h,"neg");const l=d.data.get(h.dataId).values,[p,f]=o(l,h.shape,h.dtype);return d.makeTensorInfo(f,h.dtype,p)}}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>c!==d?1:0),i=Object(a.a)(n.NotEqual,o,null,"bool"),u={kernelName:n.NotEqual,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return i});var n=t(0),r=t(7),a=t(16);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o(u,c,d,h){const[l,p]=n.backend_util.computeOutAndReduceShapes(u,h),f=Object(n.upcastType)(c,"int32"),x=n.util.makeZerosTypedArray(n.util.sizeFromShape(l),f),b=n.util.sizeFromShape(p);for(let m=0;m<x.length;++m){const I=m*b;let N=1;for(let E=0;E<b;++E)N*=d[I+E];x[m]=N}return{outVals:x,outShape:l,outDtype:f}}const i={kernelName:n.Prod,backendName:"cpu",kernelFunc:function(u){const{inputs:c,backend:d,attrs:h}=u,{x:l}=c,{axis:p,keepDims:f}=h;Object(r.a)(l,"prod");const x=l.shape.length,b=n.util.parseAxisParam(p,l.shape),m=n.backend_util.getAxesPermutation(b,x);let I=b,N=l;const E=[];m!=null&&(N=Object(a.a)({inputs:{x:l},backend:d,attrs:{perm:m}}),E.push(N),I=n.backend_util.getInnerMostAxes(I.length,x));const D=d.data.get(N.dataId).values,{outVals:U,outShape:L,outDtype:Y}=o(N.shape,N.dtype,D,I);let V=L;return f&&(V=n.backend_util.expandShapeToKeepDim(L,b)),E.forEach(P=>d.disposeIntermediateTensorInfo(P)),d.makeTensorInfo(V,Y,U)}}},function(s,e,t){t.d(e,"a",function(){return u});var n=t(0),r=n.backend_util.RowPartitionType;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a{constructor(d,h,l,p,f,x,b,m,I,N){this.shape=d,this.shapeShape=h,this.values=l,this.valuesShape=p,this.valuesDType=f,this.defaultValue=x,this.defaultValueShape=b,this.rowPartitionValues=m,this.rowPartitionValuesShapes=I,this.rowPartitionTypes=n.backend_util.getRowPartitionTypesHelper(N),this.raggedRank=n.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(d){return this.rowPartitionTypes[0]===r.FIRST_DIM_SIZE?this.rowPartitionTypes[d+1]:this.rowPartitionTypes[d]}getRowPartitionTensor(d){return this.rowPartitionTypes[0]===r.FIRST_DIM_SIZE?this.rowPartitionValues[d+1]:this.rowPartitionValues[d]}getMaxWidth(d){const h=this.getRowPartitionTensor(d-1);switch(this.getRowPartitionTypeByDimension(d-1)){case r.VALUE_ROWIDS:return a.getMaxWidthValueRowID(h);case r.ROW_SPLITS:return a.getMaxWidthRowSplit(h);default:throw new Error(`Cannot handle partition type ${r[this.getRowPartitionTypeByDimension(d-1)]}`)}}static getMaxWidthRowSplit(d){const h=d.length;if(h===0||h===1)return 0;let l=0;for(let p=0;p<h-1;++p){const f=d[p+1]-d[p];f>l&&(l=f)}return l}static getMaxWidthValueRowID(d){const h=d.length;if(h===0)return 0;let l=0,p=d[0],f=0;for(let x=1;x<h;++x){const b=d[x];b!==p&&(p=b,f=Math.max(x-l,f),l=x)}return Math.max(h-l,f)}tensorShapeFromTensor(d,h,l=!0){if(h.length===0){if(d[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return i(d,l)}calculateOutputSize(d){const h=this.valuesShape,l=this.defaultValueShape;n.backend_util.validateDefaultValueShape(l,h);const p=this.tensorShapeFromTensor(this.shape,this.shapeShape),f=n.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,p,h);f[0]<0&&(f[0]=d);for(let x=1;x<=this.raggedRank;++x)f[x]<0&&(f[x]=this.getMaxWidth(x));return f}calculateFirstParentOutputIndex(d,h,l){const p=Math.min(d,l),f=[];let x=0;for(let b=0;b<p;++b,x+=h)f.push(x);for(let b=p;b<d;++b)f.push(-1);return n.util.assert(f.length===d,()=>"Final length of result must be equal to firstDimension."),f}calculateOutputIndexRowSplit(d,h,l,p){const f=d.length,x=[];for(let b=0;b<f-1;++b){const m=d[b+1]-d[b];let I=Math.min(p,m),N=h[b];N===-1&&(I=0);for(let E=0;E<I;++E)x.push(N),N+=l;for(let E=0;E<m-I;++E)x.push(-1)}if(f>0&&x.length!==d[f-1])throw new Error("Invalid row split size.");return x}calculateOutputIndexValueRowID(d,h,l,p){const f=d.length,x=[];if(f===0)return[];let b=0,m=d[0];if(m>=h.length)throw new Error(`Got currentValueRowId=${m}, which is not less than ${h.length}`);let I=h[m];x.push(I);for(let N=1;N<f;++N){const E=d[N];if(E===m)I>=0&&(++b,b<p?I+=l:I=-1);else{if(b=0,m=E,E>=h.length)throw new Error(`Got nextValueRowId=${E} which is not less than ${h.length}`);I=h[E]}x.push(I)}if(x.length!==d.length)throw new Error("Invalid row ids.");return x}calculateOutputIndex(d,h,l,p){const f=this.getRowPartitionTensor(d),x=this.getRowPartitionTypeByDimension(d);switch(x){case r.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(f,h,l,p);case r.ROW_SPLITS:if(f.length-1>h.length)throw new Error(`Row partition size is greater than output size: ${f.length-1} > ${h.length}`);return this.calculateOutputIndexRowSplit(f,h,l,p);default:throw new Error(`Unsupported partition type: ${r[x]}`)}}getFirstDimensionSize(){const d=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const h=this.rowPartitionTypes[0];switch(h){case r.FIRST_DIM_SIZE:return d[0];case r.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case r.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${r[h]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const d=this.getFirstDimensionSize(),h=this.calculateOutputSize(d),l=new Array(this.raggedRank+1);l[l.length-1]=1;for(let x=l.length-2;x>=0;--x)l[x]=l[x+1]*h[x+1];const p=i(h,!1),f=n.util.getArrayFromDType(this.valuesDType,n.util.sizeFromShape(p));if(l[0]*h[0]>0){let x=this.calculateFirstParentOutputIndex(d,l[0],h[0]);for(let b=1;b<=this.raggedRank;++b)x=this.calculateOutputIndex(b-1,x,l[b],h[b]);this.setOutput(this.raggedRank,x,f,p)}return[p,f]}setOutput(d,h,l,p){if(l.length===0)return;const f=this.values,x=l;let b=p.slice();b=b.slice(d+1);const m=n.util.sizeFromShape(b),I=h.length;let N=this.defaultValue;if(N.length!==m&&N.length!==1){const L=this.defaultValueShape;Object(n.tidy)(()=>{const Y=Object(n.reshape)(N,L);N=Object(n.broadcastTo)(Y,b).dataSync()})}let E=0,D=0,U=0;for(let L=0;L<=I;++L){let Y=L<I?h[L]:-1;if(Y!==U){if(D<U){const V=f.subarray(E*m);o(x.subarray(D*m),V,(U-D)*m)}if(L>=I){const V=l.length;Y=Math.floor(V/m)}if(Y>U)if(this.defaultValue.length===1)x.subarray(U*m,Y*m).fill(this.defaultValue[0]),U=Y;else for(;Y>U;)o(x.slice(U*m),N,m),++U;Y<0?(E=L+1,D=U):(E=L,D=U,U=D+1)}else++U}}}function o(c,d,h){for(let l=0;l<h;l++)c[l]=d[l]}function i(c,d){const h=[];for(let l of c){if(l<0){if(!d)throw new Error(`Dimension ${l} must be >= 0`);if(l<-1)throw new Error(`Dimension ${l} must be >= -1`);l=-1}h.push(l)}return h}function u(c,d,h,l,p,f,x,b,m,I){return new a(c,d,h,l,p,f,x,b,m,I).compute()}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u){if(a===o||a<o&&i<0||o<a&&i>1)return n.util.makeZerosTypedArray(0,u);const c=Math.abs(Math.ceil((o-a)/i)),d=n.util.makeZerosTypedArray(c,u);o<a&&i===1&&(i=-1),d[0]=a;for(let h=1;h<d.length;h++)d[h]=d[h-1]+i;return d}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>1/Math.sqrt(c)),i=Object(a.b)(n.Rsqrt,o),u={kernelName:n.Rsqrt,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c,d,h){const l=o[0],p=d[0],f=new Array(p),x=new Array(l),b=o[1];if(p===0){if(l!==0)throw new Error(n.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[n.util.getArrayFromDType(i,0),[0,b],n.util.getArrayFromDType(c,0),f,x]}let m=!0,I=0;const N=new Array(p).fill(0);for(let D=0;D<l;++D){const U=a[D*b];if(U<0)throw new Error(n.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(D,U));if(U>=p)throw new Error(n.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(D,U,p));++N[U],m=m&&U>=I,I=U}let E=!0;for(let D=0;D<p;++D){const U=N[D]===0;f[D]=U,E=E&&!U,N[D]=Math.max(N[D],1),D>0&&(N[D]+=N[D-1])}if(E&&m){const D=a,U=u;for(let L=0;L<l;++L)x[L]=L;return[D,[l,b],U,f,x]}{const D=N[p-1],U=n.util.getArrayFromDType(i,D*b),L=n.util.getArrayFromDType(c,D),Y=new Array(p).fill(0);for(let V=0;V<l;++V){const P=a[V*b],oe=Y[P],ne=(P===0?0:N[P-1])+oe;Y[P]++;for(let ge=0;ge<b;++ge)U[ne*b+ge]=a[V*b+ge];L[ne]=u[V],x[V]=ne}for(let V=0;V<p;++V)if(Y[V]===0){const P=V===0?0:N[V-1];U[P*b+0]=V;for(let oe=1;oe<b;++oe)U[P*b+oe]=0;L[P]=h}return[U,[D,b],L,f,x]}}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u,c){const d=n.util.sizeFromShape(u),h=o[0],l=c.length,p=[];let f=1,x=-1;for(let E=0;E<l;++E){const D=c[E];if(D===-1){if(x!==-1)throw new Error(n.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(x,E));x=E,p.push(1)}else{if(D<0)throw new Error(n.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(E,D));f*=D,p.push(D)}}if(x!==-1){if(f<=0)throw new Error(n.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const E=Math.trunc(d/f);if(f*E!==d)throw new Error(n.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(u,p));p[x]=E}if(n.util.sizeFromShape(p)!==d)throw new Error(n.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(u,p));const b=u.length,m=[];if(b>0){m[b-1]=1;for(let E=b-2;E>=0;--E)m[E]=m[E+1]*u[E+1]}const I=[];if(l>0){I[l-1]=1;for(let E=l-2;E>=0;--E)I[E]=I[E+1]*p[E+1]}const N=n.util.getArrayFromDType(i,h*l);for(let E=0;E<h;++E){let D=0;for(let U=0;U<b;++U)D+=a[E*b+U]*m[U];for(let U=0;U<l;++U)N[E*l+U]=Math.trunc(D/I[U]),D%=I[U]}return[N,[h,l],p]}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(21),a=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)(c=>Math.sqrt(c)),i=Object(a.a)(n.Sqrt,c=>Math.sqrt(c)),u={kernelName:n.Sqrt,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"b",function(){return o}),t.d(e,"a",function(){return u});var n=t(0),r=t(12),a=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o=Object(r.a)((c,d)=>{const h=c-d;return h*h}),i=Object(a.a)(n.SquaredDifference,o),u={kernelName:n.SquaredDifference,backendName:"cpu",kernelFunc:i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u){const c=Object(n.buffer)(a,o.dtype);for(let d=0;d<c.size;d++){const h=c.indexToLoc(d),l=new Array(h.length);for(let p=0;p<l.length;p++)l[p]=h[p]*i[p]+u[p];c.set(o.get(...l),...h)}return c}},function(s,e,t){t.d(e,"a",function(){return a});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r{constructor(i,u,c,d,h,l){this.separator=n.util.encodeString(i),this.nGramWidths=u,this.leftPad=n.util.encodeString(c),this.rightPad=n.util.encodeString(d),this.padWidth=h,this.preserveShort=l}getPadWidth(i){return Math.min(this.padWidth<0?i-1:this.padWidth,i-1)}getNumNGrams(i,u){const c=this.getPadWidth(u);return Math.max(0,i+2*c-u+1)}createNGrams(i,u,c,d,h,l){for(let p=0;p<h;++p){const f=this.getPadWidth(l),x=Math.max(0,f-p),b=Math.max(0,f-(h-(p+1))),m=l-(x+b),I=u+(x>0?0:p-f);let N=0;N+=x*this.leftPad.length;for(let L=0;L<m;++L)N+=i[I+L].length;N+=b*this.rightPad.length,N+=(x+b+m-1)*this.separator.length,c[d+p]=new Uint8Array(N);const E=c[d+p];let D=0;const U=L=>L.forEach(Y=>E[D++]=Y);for(let L=0;L<x;++L)U(this.leftPad),U(this.separator);for(let L=0;L<m-1;++L)U(i[I+L]),U(this.separator);if(m>0){U(i[I+m-1]);for(let L=0;L<b;++L)U(this.separator),U(this.rightPad)}else{for(let L=0;L<b-1;++L)U(this.rightPad),U(this.separator);U(this.rightPad)}}}compute(i,u){const c=i.length,d=u.length;if(d>0){let f=u[0];if(f!==0)throw new Error(`First split value must be 0, got ${f}`);for(let x=1;x<d;++x){let b=u[x]>=f;if(b=b&&u[x]<=c,!b)throw new Error(`Invalid split value ${u[x]}, must be in [${f}, ${c}]`);f=u[x]}if(f!==c)throw new Error(`Last split value must be data size. Expected ${c}, got ${f}`)}const h=d-1,l=n.util.getArrayFromDType("int32",d);if(c===0||d===0){const f=new Array(c);for(let x=0;x<=h;++x)l[x]=0;return[f,l]}l[0]=0;for(let f=1;f<=h;++f){const x=u[f]-u[f-1];let b=0;this.nGramWidths.forEach(m=>{b+=this.getNumNGrams(x,m)}),this.preserveShort&&x>0&&b===0&&(b=1),l[f]=l[f-1]+b}const p=new Array(l[h]);for(let f=0;f<h;++f){const x=u[f];let b=l[f];if(this.nGramWidths.forEach(m=>{const I=u[f+1]-u[f],N=this.getNumNGrams(I,m);this.createNGrams(i,x,p,b,N,m),b+=N}),this.preserveShort&&b===l[f]){const m=u[f+1]-u[f];if(m===0)continue;const I=m+2*this.padWidth,N=1;this.createNGrams(i,x,p,b,N,I)}}return[p,l]}}function a(o,i,u,c,d,h,l,p){return new r(u,c,d,h,l,p).compute(o,i)}},function(s,e,t){t.d(e,"a",function(){return a});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(o,i,u,c){if(!o.length)return;if(i.length===0){for(let h=0;h<o.length;++h)c.push(o.subarray(h,h+1));return}if(i.length===1){const h=i[0];let l=o.indexOf(h);for(;l!==-1;){const p=o.subarray(0,l);u&&p.length===0||c.push(p),l=(o=o.subarray(l+1)).indexOf(h)}return void(u&&o.length===0||c.push(o))}let d=0;for(let h=0;h<o.length+1;h++)if(h===o.length||i.indexOf(o[h])!==-1){const l=o.subarray(d,h);u&&l.length===0||c.push(l),d=h+1}}function a(o,i,u){const c=o.length,d=[];let h=0,l=0;const p=new Array(c);for(let I=0;I<c;++I){const N=d.length;r(o[I],i,u,d);const E=d.length-N;p[I]=E,h+=E,l=Math.max(l,E)}const f=n.util.getArrayFromDType("int32",2*h),x=new Array(h),b=[c,l];let m=0;for(let I=0;I<c;++I)for(let N=0;N<p[I];++N)f[2*m]=I,f[2*m+1]=N,x[m]=d[m],++m;return[f,x,b]}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o){const i=n.util.getArrayFromDType("int32",a.length);for(let u=0;u<a.length;++u)i[u]=n.util.fingerPrint64(a[u]).modulo(o).getLowBitsUnsigned();return i}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o){const i=new Array(a.rank);for(let c=0;c<i.length;c++)i[c]=a.shape[c]*o[c];const u=Object(n.buffer)(i,a.dtype);for(let c=0;c<u.values.length;++c){const d=u.indexToLoc(c),h=new Array(a.rank);for(let p=0;p<h.length;p++)h[p]=d[p]%a.shape[p];const l=a.locToIndex(h);u.values[c]=a.values[l]}return u}},function(s,e,t){t.d(e,"a",function(){return o});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r=(i,u)=>{const c=u.value-i.value;return c===0?i.index-u.index:c};function a(i,u,c=0,d=i.length-1){for(;d>c;){if(d-c>600){const f=d-c+1,x=u-c+1,b=Math.log(f),m=.5*Math.exp(2*b/3),I=.5*Math.sqrt(b*m*(f-m)/f)*Math.sign(x-f/2);a(i,u,Math.max(c,Math.floor(u-x*m/f+I)),Math.min(d,Math.floor(u+(f-x)*m/f+I)))}const h=i[u];let l=c,p=d;for(n.util.swap(i,c,u),r(i[d],h)>0&&n.util.swap(i,c,d);l<p;){for(n.util.swap(i,l,p),l++,p--;r(i[l],h)<0;)l+=1;for(;r(i[p],h)>0;)p-=1}r(i[c],h)===0?n.util.swap(i,c,p):(p+=1,n.util.swap(i,p,d)),p<=u&&(c=p+1),u<=p&&(d=p-1)}}function o(i,u,c,d,h){const l=u[u.length-1],[p,f]=[i.length/l,l],x=n.util.getTypedArrayFromDType(c,p*d),b=n.util.getTypedArrayFromDType("int32",p*d);for(let I=0;I<p;I++){const N=I*f,E=i.subarray(N,N+f);let D=new Array(E.length);E.forEach((V,P)=>D[P]={value:V,index:P}),d<D.length&&(a(D,d),D=D.slice(0,d)),h&&D.sort(r);const U=I*d,L=x.subarray(U,U+d),Y=b.subarray(U,U+d);for(let V=0;V<d;V++)L[V]=D[V].value,Y[V]=D[V].index}const m=u.slice();return m[m.length-1]=d,[Object(n.buffer)(m,c,x),Object(n.buffer)(m,"int32",b)]}},function(s,e,t){t.d(e,"a",function(){return r});var n=t(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,o,i,u){const c=n.util.parseAxisParam(o,i)[0],d=[1,i[0],1];for(let N=0;N<c;N++)d[0]*=i[N];d[1]=i[c];for(let N=c+1;N<i.length;N++)d[2]*=i[N];const h={},l=new Int32Array(i[c]),p=new n.TensorBuffer(d,u,a),f=[],x=d[0]===1&&d[2]===1;for(let N=0;N<i[c];N++){let E;if(x)E=a[N].toString();else{const D=[];for(let U=0;U<d[0];U++)for(let L=0;L<d[2];L++)D.push(p.get(U,N,L));E=D.join(",")}if(h[E]!==void 0)l[N]=h[E];else{const D=Object.keys(h).length;h[E]=D,l[N]=D,f.push(N)}}const b=d.slice();b[1]=Object.keys(h).length;const m=new n.TensorBuffer(b,u);f.forEach((N,E)=>{for(let D=0;D<d[0];D++)for(let U=0;U<d[2];U++)m.set(p.get(D,N,U),D,E,U)});const I=i.slice();return I[c]=b[1],{outputValues:m.values,outputShape:I,indices:l}}},function(s,e,t){t.d(e,"a",function(){return a});var n=t(0),r=t(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a(o,i,u="float32"){if(u==="complex64"){const d=a(o,i,"float32"),h=a(o,i,"float32");return Object(r.a)({inputs:{real:d,imag:h},backend:o})}const c=n.util.makeZerosTypedArray(n.util.sizeFromShape(i),u);return o.makeTensorInfo(i,u,c)}},function(s,e,t){t.d(e,"a",function(){return Sc});var n,r,a=t(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o;(function(Pe){Pe[Pe.float32=0]="float32",Pe[Pe.int32=1]="int32",Pe[Pe.bool=2]="bool",Pe[Pe.string=3]="string",Pe[Pe.complex64=4]="complex64"})(n||(n={})),function(Pe){Pe[Pe.linear=0]="linear",Pe[Pe.relu=1]="relu",Pe[Pe.relu6=2]="relu6",Pe[Pe.prelu=3]="prelu",Pe[Pe.leakyrelu=4]="leakyrelu",Pe[Pe.sigmoid=5]="sigmoid",Pe[Pe.elu=6]="elu"}(r||(r={}));const i={kernelName:a._FusedMatMul,backendName:"wasm",setupFunc:function(Pe){o=Pe.wasm.cwrap(a._FusedMatMul,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{a:Ae,b:rt,bias:xt,preluActivationWeights:Nt}=me;if(Ae.dtype!=="float32"||rt.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:vt,transposeB:St,activation:_t,leakyreluAlpha:en}=st,Kt=He.dataIdMap.get(Ae.dataId).id,Ze=He.dataIdMap.get(rt.dataId).id;let Lt=0;if(xt!=null){const Fs=He.dataIdMap.get(xt.dataId);if(Fs.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${Fs.shape.length}.`);Lt=Fs.id}const Jt=Nt==null?0:He.dataIdMap.get(Nt.dataId).id,un=r[_t];if(un==null)throw new Error(`${_t} activation not yet supported for FusedConv2D in the wasm backend.`);const In=vt?Ae.shape[2]:Ae.shape[1],Xt=St?rt.shape[1]:rt.shape[2],$n=a.broadcast_util.assertAndGetBroadcastShape(Ae.shape.slice(0,-2),rt.shape.slice(0,-2)),Jn=He.makeOutput([...$n,In,Xt],Ae.dtype),Ss=He.dataIdMap.get(Jn.dataId).id,Ms=new Uint8Array(new Int32Array(Ae.shape).buffer),Ps=new Uint8Array(new Int32Array(rt.shape).buffer);return o(Kt,Ms,Ae.shape.length,Ze,Ps,rt.shape.length,vt,St,un,Lt,Jt,en||0,Ss),Jn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u(Pe,me){let He;return{kernelName:Pe,backendName:"wasm",setupFunc:function(st){He=st.wasm.cwrap(Pe,null,["number","number","number"])},kernelFunc:function(st){const{backend:Ae,inputs:{x:rt}}=st,xt=Ae.dataIdMap.get(rt.dataId).id,Nt=Ae.makeOutput(rt.shape,me||rt.dtype),vt=Ae.dataIdMap.get(Nt.dataId).id;return a.util.sizeFromShape(Nt.shape)===0||He(xt,n[rt.dtype],vt),Nt}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c=u(a.Abs);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d(Pe,me,He){let st;return{kernelName:Pe,backendName:"wasm",setupFunc:function(Ae){st=Ae.wasm.cwrap(Pe,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(Ae){const{backend:rt,inputs:xt}=Ae,{a:Nt,b:vt}=xt,St=rt.dataIdMap.get(Nt.dataId).id,_t=rt.dataIdMap.get(vt.dataId).id,en=He!=null?He:Nt.dtype,Kt=a.backend_util.assertAndGetBroadcastShape(Nt.shape,vt.shape),Ze=rt.makeOutput(Kt,en);if(a.util.sizeFromShape(Kt)===0)return Ze;const Lt=new Uint8Array(new Int32Array(Nt.shape).buffer),Jt=new Uint8Array(new Int32Array(vt.shape).buffer),un=rt.dataIdMap.get(Ze.dataId).id;return st(St,Lt,Nt.shape.length,_t,Jt,vt.shape.length,n[Nt.dtype],un),Ze}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h=d(a.Add);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l;const p={kernelName:a.AddN,backendName:"wasm",setupFunc:function(Pe){l=Pe.wasm.cwrap(a.AddN,null,["array","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He}=Pe,st=He.makeOutput(me[0].shape,me[0].dtype);if(a.util.sizeFromShape(st.shape)===0)return st;const Ae=me.map(Nt=>He.dataIdMap.get(Nt.dataId).id),rt=new Uint8Array(new Int32Array(Ae).buffer),xt=He.dataIdMap.get(st.dataId).id;return l(rt,Ae.length,n[st.dtype],xt),st}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f(Pe){const{inputs:{x:me},backend:He}=Pe,st=He.makeOutput(me.shape,me.dtype),Ae=He.typedArrayFromHeap(me);return He.typedArrayFromHeap(st).set(Ae),st}const x={kernelName:a.Identity,backendName:"wasm",kernelFunc:f};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b;function m(Pe){const{inputs:me,backend:He,attrs:st}=Pe,[Ae,rt]=function(Lt,Jt){const un=[],In=[];for(let Xt=0;Xt<Lt.length;++Xt)Lt[Xt]!==1&&un.push(Lt[Xt]),Lt[Jt[Xt]]!==1&&In.push(Jt[Xt]);for(let Xt=0;Xt<In.length;++Xt){let $n=-1;for(let Jn=0;Jn<In.length;++Jn)In[Jn]>=Xt&&($n===-1||In[$n]>In[Jn])&&($n=Jn);In[$n]=Xt}return[un,In]}(me.x.shape,st.perm);let xt=!0;for(let Lt=0;Lt<rt.length;Lt++)rt[Lt]!==Lt&&(xt=!1);const Nt=function(Lt,Jt){const un=new Array(Lt.length);for(let In=0;In<un.length;In++)un[In]=Lt[Jt[In]];return un}(me.x.shape,st.perm),vt={dataId:me.x.dataId,shape:Ae,dtype:me.x.dtype};if(xt){const Lt=f({inputs:me,backend:He});return Lt.shape=Nt,Lt}const St=He.makeOutput(Nt,vt.dtype),_t=He.dataIdMap.get(vt.dataId).id,en=He.dataIdMap.get(St.dataId).id,Kt=new Uint8Array(new Int32Array(rt).buffer),Ze=new Uint8Array(new Int32Array(vt.shape).buffer);return b(_t,Ze,vt.shape.length,n[vt.dtype],en,Kt,rt.length),St}const I={kernelName:a.Transpose,backendName:"wasm",kernelFunc:m,setupFunc:function(Pe){b=Pe.wasm.cwrap(a.Transpose,null,["number","array","number","number","number","array","number"])}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N(Pe,me,He){const st=Pe.shape,Ae=Pe.shape.length,rt=a.util.parseAxisParam(me,st);let xt=rt;const Nt=a.backend_util.getAxesPermutation(xt,Ae);let vt=null,St=!1;if(Nt!=null){const _t=new Array(Ae);for(let Kt=0;Kt<_t.length;Kt++)_t[Kt]=st[Nt[Kt]];xt=a.backend_util.getInnerMostAxes(xt.length,Ae),vt=m({inputs:{x:Pe},attrs:{perm:Nt},backend:He});const en=He.dataIdMap.get(Pe.dataId).id;He.dataIdMap.get(vt.dataId).id!==en&&(St=!0)}return{transposed:vt,originalAxes:rt,axes:xt,inputWasTransposed:St}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E;const D={kernelName:a.All,backendName:"wasm",setupFunc:function(Pe){E=Pe.wasm.cwrap(a.All,null,["number, number, number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He;let Nt=me.dataIdMap.get(xt.dataId).id,vt=xt;const{transposed:St,axes:_t,originalAxes:en,inputWasTransposed:Kt}=N(xt,Ae,me);Kt&&(vt=St,Nt=me.dataIdMap.get(St.dataId).id);const Ze=vt.shape.length;a.backend_util.assertAxesAreInnerMostDims("all",_t,Ze);const[Lt,Jt]=a.backend_util.computeOutAndReduceShapes(vt.shape,_t),un=a.util.sizeFromShape(Jt),In=me.makeOutput(Lt,xt.dtype);if(a.util.sizeFromShape(vt.shape)!==0){const Xt=me.dataIdMap.get(In.dataId).id;E(Nt,un,Xt)}if(Kt&&me.disposeData(St.dataId),rt){const Xt=a.backend_util.expandShapeToKeepDim(In.shape,en);In.shape=Xt}return In}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U;const L={kernelName:a.Any,backendName:"wasm",setupFunc:function(Pe){U=Pe.wasm.cwrap(a.Any,null,["number, number, number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He;let Nt=me.dataIdMap.get(xt.dataId).id,vt=xt;const{transposed:St,axes:_t,originalAxes:en,inputWasTransposed:Kt}=N(xt,Ae,me);Kt&&(vt=St,Nt=me.dataIdMap.get(St.dataId).id);const Ze=vt.shape.length;a.backend_util.assertAxesAreInnerMostDims("any",_t,Ze);const[Lt,Jt]=a.backend_util.computeOutAndReduceShapes(vt.shape,_t),un=a.util.sizeFromShape(Jt),In=me.makeOutput(Lt,xt.dtype);if(a.util.sizeFromShape(vt.shape)!==0){const Xt=me.dataIdMap.get(In.dataId).id;U(Nt,un,Xt)}if(Kt&&me.disposeData(St.dataId),rt){const Xt=a.backend_util.expandShapeToKeepDim(In.shape,en);In.shape=Xt}return In}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Y;const V={kernelName:a.ArgMax,backendName:"wasm",kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae}=st,{x:rt}=He,xt=me.dataIdMap.get(rt.dataId).id;let Nt=xt,vt=rt;const{transposed:St,axes:_t,inputWasTransposed:en}=N(rt,Ae,me);if(en){const In=me.dataIdMap.get(St.dataId).id;In!==xt&&(vt=St,Nt=In)}const Kt=vt.shape.slice(0,-1),Ze=me.makeOutput(Kt,"int32"),Lt=me.dataIdMap.get(Ze.dataId).id,Jt=a.util.sizeFromShape(Ze.shape),un=vt.shape[_t[0]];return Y(Nt,n[vt.dtype],Jt,un,Lt),en&&me.disposeData(St.dataId),Ze},setupFunc:function(Pe){Y=Pe.wasm.cwrap(a.ArgMax,null,["number","number","number","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P;const oe={kernelName:a.AvgPool,backendName:"wasm",setupFunc:function(Pe){P=Pe.wasm.cwrap(a.AvgPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,Ae=me.x,rt=st.dataIdMap.get(Ae.dataId).id,{filterSize:xt,strides:Nt,pad:vt,dimRoundingMode:St}=He,_t=a.backend_util.computePool2DInfo(Ae.shape,xt,Nt,1,vt,St),en=_t.filterHeight,Kt=_t.filterWidth,Ze=_t.padInfo.top,Lt=_t.padInfo.right,Jt=_t.padInfo.bottom,un=_t.padInfo.left,In=_t.strideHeight,Xt=_t.strideWidth,$n=_t.inChannels;if(_t.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${_t.dataFormat}'. Please use 'channelsLast'.`);if(_t.dilationWidth!==1||_t.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${_t.dilationHeight}, ${_t.dilationWidth}].`);const Jn=st.makeOutput(_t.outShape,"float32"),Ss=st.dataIdMap.get(Jn.dataId).id;return P(rt,Ae.shape[0],Ae.shape[1],Ae.shape[2],en,Kt,Ze,Lt,Jt,un,In,Xt,$n,Ss),Jn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ne(Pe){const{inputs:me,attrs:He}=Pe,{x:st}=me,{shape:Ae}=He,rt=a.util.sizeFromShape(st.shape),xt=a.util.inferFromImplicitShape(Ae,rt);return a.util.assert(rt===a.util.sizeFromShape(xt),()=>`new shape: ${xt}, old shape: ${st.shape}. New shape and old shape must have the same number of elements.`),Pe.backend.incRef(st.dataId),{dataId:st.dataId,shape:xt,dtype:st.dtype}}const ge={kernelName:a.Reshape,backendName:"wasm",kernelFunc:ne};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ye;const Ee={kernelName:a.BatchMatMul,backendName:"wasm",setupFunc:function(Pe){ye=Pe.wasm.cwrap(a.BatchMatMul,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{a:Ae,b:rt}=me,{transposeA:xt,transposeB:Nt}=st;if(Ae.dtype!=="float32"||rt.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const vt=Ae.shape.length,St=rt.shape.length,_t=xt?Ae.shape[vt-2]:Ae.shape[vt-1],en=Nt?rt.shape[St-1]:rt.shape[St-2],Kt=xt?Ae.shape[vt-1]:Ae.shape[vt-2],Ze=Nt?rt.shape[St-2]:rt.shape[St-1],Lt=Ae.shape.slice(0,-2),Jt=rt.shape.slice(0,-2),un=a.util.sizeFromShape(Lt),In=a.util.sizeFromShape(Jt),Xt=a.broadcast_util.assertAndGetBroadcastShape(Ae.shape.slice(0,-2),rt.shape.slice(0,-2)).concat([Kt,Ze]);a.util.assert(_t===en,()=>`Error in matMul: inner shapes (${_t}) and (${en}) of Tensors with shapes ${Ae.shape} and ${rt.shape} and transposeA=${xt} and transposeB=${Nt} must match.`);const $n=Nt?[In,Ze,en]:[In,en,Ze],Jn=ne({inputs:{x:Ae},backend:He,attrs:{shape:xt?[un,_t,Kt]:[un,Kt,_t]}}),Ss=ne({inputs:{x:rt},backend:He,attrs:{shape:$n}}),Ms=He.dataIdMap.get(Jn.dataId).id,Ps=He.dataIdMap.get(Ss.dataId).id,Fs=xt?Jn.shape[2]:Jn.shape[1],pr=Nt?Ss.shape[1]:Ss.shape[2],er=Math.max(un,In),fr=He.makeOutput([er,Fs,pr],Jn.dtype),cr=He.dataIdMap.get(fr.dataId).id,jr=new Uint8Array(new Int32Array(Jn.shape).buffer),Ca=new Uint8Array(new Int32Array(Ss.shape).buffer);return ye(Ms,jr,Jn.shape.length,Ps,Ca,Ss.shape.length,xt,Nt,cr),He.disposeData(Jn.dataId),He.disposeData(Ss.dataId),fr.shape=Xt,fr}};var X=t(58),je=t(23),Be=t(76),tt=t(83),ct=t(84),Me=t(85);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(Pe){const{inputs:{x:me},attrs:{begin:He,size:st},backend:Ae}=Pe,[rt,xt]=a.slice_util.parseSliceParams(me,He,st),Nt=a.slice_util.isSliceContinous(me.shape,rt,xt),vt=Ae.readSync(me.dataId),St=Ae.makeOutput(xt,me.dtype),_t=a.util.computeStrides(me.shape),en=Ae.dataIdMap.get(St.dataId);if(Nt){const Lt=a.slice_util.computeFlatOffset(rt,_t);return me.dtype==="string"?en.stringBytes=vt.slice(Lt,Lt+a.util.sizeFromShape(xt)):Ae.typedArrayFromHeap(St).set(vt.subarray(Lt,Lt+a.util.sizeFromShape(xt))),St}if(me.dtype==="string"){const Lt=Object(je.c)(vt,rt,xt,me.shape,me.dtype);return en.stringBytes=Lt,St}const Kt=Ae.typedArrayFromHeap(St),Ze=me.shape.length;if(Ze===2)(function(Lt,Jt,un,In,Xt){let $n=0;const Jn=In[0],Ss=In[1],Ms=Jn+Xt[0];for(let Ps=Jn;Ps<Ms;Ps++){const Fs=Ps*Jt+Ss;un.set(Lt.subarray(Fs,Fs+Xt[1]),$n),$n+=Xt[1]}})(vt,_t[0],Kt,rt,xt);else if(Ze===3)(function(Lt,Jt,un,In,Xt,$n){let Jn=0;const Ss=Xt[0],Ms=Xt[1],Ps=Xt[2],Fs=Ss+$n[0],pr=Ms+$n[1];for(let er=Ss;er<Fs;er++)for(let fr=Ms;fr<pr;fr++){const cr=er*Jt+fr*un+Ps;In.set(Lt.subarray(cr,cr+$n[2]),Jn),Jn+=$n[2]}})(vt,_t[0],_t[1],Kt,rt,xt);else if(Ze===4)(function(Lt,Jt,un,In,Xt,$n,Jn){let Ss=0;const Ms=$n[0],Ps=$n[1],Fs=$n[2],pr=Ms+Jn[0],er=Ps+Jn[1],fr=Fs+Jn[2],cr=$n[3];for(let jr=Ms;jr<pr;jr++)for(let Ca=Ps;Ca<er;Ca++)for(let yo=Fs;yo<fr;yo++){const Ao=jr*Jt+Ca*un+yo*In+cr;Xt.set(Lt.subarray(Ao,Ao+Jn[3]),Ss),Ss+=Jn[3]}})(vt,_t[0],_t[1],_t[2],Kt,rt,xt);else{const Lt=Object(je.c)(vt,rt,xt,me.shape,me.dtype);Kt.set(Lt)}return St}const at={kernelName:a.Slice,backendName:"wasm",kernelFunc:wt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gt={kernelName:a.BatchToSpaceND,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{blockShape:rt,crops:xt}=st,Nt=rt.reduce((un,In)=>un*In),vt=a.backend_util.getReshaped(Ae.shape,rt,Nt),St=a.backend_util.getPermuted(vt.length,rt.length),_t=a.backend_util.getReshapedPermuted(Ae.shape,rt,Nt),en=a.backend_util.getSliceBeginCoords(xt,rt.length),Kt=a.backend_util.getSliceSize(_t,xt,rt.length),Ze=ne({inputs:{x:Ae},backend:He,attrs:{shape:vt}}),Lt=m({inputs:{x:Ze},backend:He,attrs:{perm:St}}),Jt=wt({inputs:{x:ne({inputs:{x:Lt},backend:He,attrs:{shape:_t}})},backend:He,attrs:{begin:en,size:Kt}});return He.disposeData(Ze.dataId),He.disposeData(Lt.dataId),He.disposeData(Ze.dataId),Jt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(Pe){const{inputs:{x:me},attrs:{dtype:He},backend:st}=Pe,Ae=st.makeOutput(me.shape,He),rt=st.typedArrayFromHeap(me);return st.typedArrayFromHeap(Ae).set(rt),Ae}const dn={kernelName:a.Cast,backendName:"wasm",kernelFunc:Ht},mn=u(a.Ceil);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rn;const ee={kernelName:a.ClipByValue,backendName:"wasm",setupFunc:function(Pe){Rn=Pe.wasm.cwrap(a.ClipByValue,null,["number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{clipValueMin:rt,clipValueMax:xt}=st,Nt=He.dataIdMap.get(Ae.dataId).id,vt=He.makeOutput(Ae.shape,Ae.dtype),St=He.dataIdMap.get(vt.dataId).id;return Rn(Nt,rt,xt,St),vt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function se(Pe){const{inputs:me,backend:He}=Pe,st=a.util.parseAxisParam(Pe.attrs.axis,me[0].shape)[0];let Ae=a.backend_util.computeOutShape(me.map(Ze=>Ze.shape),st);const rt=me.filter(Ze=>a.util.sizeFromShape(Ze.shape)>0);if(rt.length===1)return f({inputs:{x:rt[0]},backend:He});const xt=He.makeOutput(Ae,me[0].dtype);if(a.util.sizeFromShape(Ae)===0)return xt;const Nt=rt.map(Ze=>Ze.shape);if(a.backend_util.assertParamsConsistent(Nt,st),rt[0].dtype==="string"){const Ze=rt.map(Xt=>{const $n=a.util.sizeFromShape(Xt.shape.slice(st));return ne({inputs:{x:Xt},backend:He,attrs:{shape:[-1,$n]}})}),Lt=Ze.map(Xt=>({vals:He.readSync(Xt.dataId),shape:Xt.shape}));Ae=a.backend_util.computeOutShape(Ze.map(Xt=>Xt.shape),1);const Jt=Ze[0].shape[0]===1,un=Object(X.a)(Lt,Ae,me[0].dtype,Jt),In=a.backend_util.computeOutShape(rt.map(Xt=>Xt.shape),st);return xt.shape=In,He.dataIdMap.get(xt.dataId).stringBytes=a.backend_util.fromStringArrayToUint8(un),Ze.forEach(Xt=>He.disposeData(Xt.dataId)),xt}const vt=a.util.sizeFromShape(rt[0].shape.slice(0,st));let St=0;const _t=rt.map(Ze=>{const Lt=a.util.sizeFromShape(Ze.shape.slice(st));return St+=Lt,Lt}),en=rt.map(Ze=>He.typedArrayFromHeap(Ze)),Kt=He.typedArrayFromHeap(xt);for(let Ze=0;Ze<vt;Ze++){let Lt=Ze*St;for(let Jt=0;Jt<en.length;Jt++){const un=_t[Jt],In=Ze*un,Xt=en[Jt].subarray(In,In+un);Kt.set(Xt,Lt),Lt+=un}}return xt}const we={kernelName:a.Concat,backendName:"wasm",kernelFunc:se};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pt;const bt={kernelName:a.Conv2D,backendName:"wasm",setupFunc:function(Pe){pt=Pe.wasm.cwrap(a.Conv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{x:Ae,filter:rt}=me,xt=st.dataIdMap.get(Ae.dataId).id,Nt=st.dataIdMap.get(rt.dataId).id,{strides:vt,dilations:St,pad:_t,dimRoundingMode:en,dataFormat:Kt}=He,Ze=a.backend_util.convertConv2DDataFormat(Kt),Lt=a.backend_util.computeConv2DInfo(Ae.shape,rt.shape,vt,St,_t,en,!1,Ze),Jt=Lt.filterHeight,un=Lt.filterWidth,In=Lt.padInfo.top,Xt=Lt.padInfo.right,$n=Lt.padInfo.bottom,Jn=Lt.padInfo.left,Ss=Lt.dilationHeight,Ms=Lt.dilationWidth,Ps=Lt.strideHeight,Fs=Lt.strideWidth,pr=Lt.inChannels,er=Lt.outChannels,fr=Lt.padInfo.type==="SAME"?1:0;if(Lt.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${Lt.dataFormat}'. Please use 'channelsLast'.`);const cr=st.makeOutput(Lt.outShape,"float32"),jr=st.dataIdMap.get(cr.dataId).id;return pt(xt,Ae.shape[0],Ae.shape[1],Ae.shape[2],Nt,Jt,un,In,Xt,$n,Jn,fr,Ss,Ms,Ps,Fs,pr,er,jr),cr}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let At;const $e={kernelName:a.Conv2DBackpropInput,backendName:"wasm",setupFunc:function(Pe){At=Pe.wasm.cwrap(a.Conv2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{dy:Ae,filter:rt}=He,{strides:xt,pad:Nt,dataFormat:vt,dimRoundingMode:St,inputShape:_t}=st,en=a.backend_util.convertConv2DDataFormat(vt),Kt=a.backend_util.computeConv2DInfo(_t,rt.shape,xt,1,Nt,St,!1,en),{batchSize:Ze,filterHeight:Lt,filterWidth:Jt,inChannels:un,inHeight:In,inWidth:Xt,outChannels:$n,outHeight:Jn,outWidth:Ss,strideHeight:Ms,strideWidth:Ps}=Kt,Fs=Lt-1-Kt.padInfo.top,pr=Jt-1-Kt.padInfo.left,er=Kt.dataFormat==="channelsLast",fr=a.util.computeStrides(Kt.inShape),cr=a.util.computeStrides(Ae.shape),[jr,Ca,yo]=a.util.computeStrides(rt.shape),Ao=fr[0],Li=er?fr[1]:fr[2],hi=er?fr[2]:1,wo=er?1:fr[1],Ho=cr[0],qo=er?cr[1]:cr[2],Bi=er?cr[2]:1,ca=er?1:cr[1],zi=me.makeOutput(Kt.inShape,"float32"),Zu=me.dataIdMap.get(zi.dataId).id,Wi=me.dataIdMap.get(Ae.dataId).id,Qu=me.dataIdMap.get(rt.dataId).id;return At(Wi,Qu,Ze,Lt,Jt,In,Xt,un,Jn,Ss,$n,Ms,Ps,Fs,pr,jr,Ca,yo,Ao,Li,hi,wo,Ho,qo,Bi,ca,Zu),zi}},ht=u(a.Cos),Pt=u(a.Cosh);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ot;let xn;(function(Pe){Pe[Pe.bilinear=0]="bilinear",Pe[Pe.nearest=1]="nearest"})(Ot||(Ot={}));const Dn={kernelName:a.CropAndResize,backendName:"wasm",setupFunc:function(Pe){xn=Pe.wasm.cwrap(a.CropAndResize,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{method:Ae,extrapolationValue:rt,cropSize:xt}=st,{image:Nt,boxes:vt,boxInd:St}=He,_t=vt.shape[0],[en,Kt]=xt,Ze=[_t,en,Kt,Nt.shape[3]];let Lt,Jt=me.dataIdMap.get(Nt.dataId);Nt.dtype!=="float32"&&(Lt=Ht({backend:me,inputs:{x:Nt},attrs:{dtype:"float32"}}),Jt=me.dataIdMap.get(Lt.dataId));const un=Jt.id,In=me.dataIdMap.get(vt.dataId).id,Xt=me.dataIdMap.get(St.dataId).id,$n=me.makeOutput(Ze,"float32"),Jn=me.dataIdMap.get($n.dataId).id,Ss=new Uint8Array(new Int32Array(Nt.shape).buffer);return xn(un,In,Xt,_t,Ss,en,Kt,Ot[Ae],rt,Jn),Lt!=null&&me.disposeData(Lt.dataId),$n}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pe;const be={kernelName:a.Cumprod,backendName:"wasm",setupFunc:function(Pe){pe=Pe.wasm.cwrap(a.Cumprod,null,["number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{axis:rt,exclusive:xt,reverse:Nt}=st,vt=Ae.shape.length;a.util.assert(Ae.dtype==="float32"||Ae.dtype==="int32",()=>`cumprod does not support ${Ae.dtype} tensors in the WASM backend`);const St=a.backend_util.getAxesPermutation([rt],vt);let _t=Ae;St!==null&&(_t=m({inputs:{x:Ae},attrs:{perm:St},backend:He}));const en=a.backend_util.getInnerMostAxes(1,vt)[0];a.backend_util.assertAxesAreInnerMostDims("cumprod",[en],vt);const Kt=He.makeOutput(_t.shape,_t.dtype),Ze=_t.shape[en],Lt=He.dataIdMap.get(_t.dataId).id,Jt=He.dataIdMap.get(Kt.dataId).id;pe(Lt,xt?1:0,Nt?1:0,Ze,Jt,n[Ae.dtype]);let un=Kt;return St!==null&&(un=m({inputs:{x:Kt},attrs:{perm:a.backend_util.getUndoAxesPermutation(St)},backend:He}),He.disposeData(_t.dataId),He.disposeData(Kt.dataId)),un}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qe;const Un={kernelName:a.Cumsum,backendName:"wasm",setupFunc:function(Pe){Qe=Pe.wasm.cwrap(a.Cumsum,null,["number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{axis:rt,exclusive:xt,reverse:Nt}=st,vt=Ae.shape.length;a.util.assert(Ae.dtype==="float32"||Ae.dtype==="int32",()=>`cumsum does not support ${Ae.dtype} tensors in the WASM backend`);const St=a.backend_util.getAxesPermutation([rt],vt);let _t=Ae;St!==null&&(_t=m({inputs:{x:Ae},attrs:{perm:St},backend:He}));const en=a.backend_util.getInnerMostAxes(1,vt)[0];a.backend_util.assertAxesAreInnerMostDims("cumsum",[en],vt);const Kt=He.makeOutput(_t.shape,_t.dtype),Ze=_t.shape[en],Lt=He.dataIdMap.get(_t.dataId).id,Jt=He.dataIdMap.get(Kt.dataId).id;Qe(Lt,xt?1:0,Nt?1:0,Ze,Jt,n[Ae.dtype]);let un=Kt;return St!==null&&(un=m({inputs:{x:Kt},attrs:{perm:a.backend_util.getUndoAxesPermutation(St)},backend:He}),He.disposeData(_t.dataId),He.disposeData(Kt.dataId)),un}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ws;const Gs={kernelName:a.DepthToSpace,backendName:"wasm",setupFunc:function(Pe){Ws=Pe.wasm.cwrap(a.DepthToSpace,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{x:Ae}=He,{blockSize:rt,dataFormat:xt}=st,Nt=Ae.shape[0],vt=(xt==="NHWC"?Ae.shape[1]:Ae.shape[2])*rt,St=(xt==="NHWC"?Ae.shape[2]:Ae.shape[3])*rt,_t=(xt==="NHWC"?Ae.shape[3]:Ae.shape[1])/(rt*rt),en=xt==="NHWC"?[Nt,vt,St,_t]:[Nt,_t,vt,St],Kt=me.makeOutput(en,"float32"),Ze=me.dataIdMap.get(Ae.dataId).id,Lt=new Uint8Array(new Int32Array(a.util.computeStrides(Ae.shape)).buffer),Jt=new Uint8Array(new Int32Array(en).buffer),un=new Uint8Array(new Int32Array(a.util.computeStrides(en)).buffer),In=me.dataIdMap.get(Kt.dataId).id;return Ws(Ze,rt,xt==="NHWC"?1:0,Lt,Ae.shape.length-1,Jt,un,en.length,In),Kt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let As;const xs={kernelName:a.DepthwiseConv2dNative,backendName:"wasm",setupFunc:function(Pe){As=Pe.wasm.cwrap(a.DepthwiseConv2dNative,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{x:Ae,filter:rt}=me,xt=st.dataIdMap.get(Ae.dataId).id,Nt=st.dataIdMap.get(rt.dataId).id,{strides:vt,dilations:St,pad:_t,dimRoundingMode:en}=He,Kt=St==null?[1,1]:St,Ze=a.backend_util.computeConv2DInfo(Ae.shape,rt.shape,vt,Kt,_t,en,!0),Lt=Ze.filterHeight,Jt=Ze.filterWidth,un=Ze.padInfo.top,In=Ze.padInfo.right,Xt=Ze.padInfo.bottom,$n=Ze.padInfo.left,Jn=Ze.dilationHeight,Ss=Ze.dilationWidth,Ms=Ze.strideHeight,Ps=Ze.strideWidth,Fs=Ze.inChannels,pr=Ze.outChannels,er=Ze.padInfo.type==="SAME"?1:0;if(Ze.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${Ze.dataFormat}'. Please use 'channelsLast'.`);const fr=st.makeOutput(Ze.outShape,"float32"),cr=st.dataIdMap.get(fr.dataId).id;return As(xt,Ae.shape[0],Ae.shape[1],Ae.shape[2],Nt,Lt,Jt,un,In,Xt,$n,er,Jn,Ss,Ms,Ps,Fs,pr,cr),fr}},ds=u(a.Elu),Ys=d(a.Equal,0,"bool"),pn=u(a.Exp,"float32");/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{input:Ae}=me,{dim:rt}=He,xt=Ae.shape.length,Nt=Ae.shape.slice();let vt=rt;return rt<0&&(a.util.assert(-(xt+1)<=rt,()=>`Axis must be in the interval [${-(xt+1)}, ${xt}]`),vt=xt+rt+1),Nt.splice(vt,0,1),ne({inputs:{x:Ae},backend:st,attrs:{shape:Nt}})}const ts={kernelName:a.ExpandDims,backendName:"wasm",kernelFunc:Nn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $s(Pe){const{attrs:{shape:me,value:He,dtype:st},backend:Ae}=Pe,rt=Ae.makeOutput(me,st);return Ae.typedArrayFromHeap(rt).fill(He),rt}const Ns={kernelName:a.Fill,backendName:"wasm",kernelFunc:$s};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ys;const Vs={kernelName:a.FlipLeftRight,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He}=Pe,{image:st}=me,Ae=He.makeOutput(st.shape,st.dtype),rt=He.dataIdMap.get(st.dataId).id,xt=He.dataIdMap.get(Ae.dataId).id,[Nt,vt,St,_t]=st.shape;return ys(rt,Nt,vt,St,_t,xt),Ae},setupFunc:function(Pe){ys=Pe.wasm.cwrap(a.FlipLeftRight,null,["number","number","number","number","number","number"])}},Us=u(a.Floor),jt=d(a.FloorDiv);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let re;const de={kernelName:a.FusedBatchNorm,backendName:"wasm",setupFunc:function(Pe){re=Pe.wasm.cwrap(a.FusedBatchNorm,null,["number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{varianceEpsilon:Ae}=st,{x:rt,mean:xt,variance:Nt,offset:vt,scale:St}=He,_t=me.dataIdMap.get(rt.dataId).id,en=me.dataIdMap.get(xt.dataId).id,Kt=me.dataIdMap.get(Nt.dataId).id,Ze=vt!=null?me.dataIdMap.get(vt.dataId).id:0,Lt=St!=null?me.dataIdMap.get(St.dataId).id:0,Jt=me.makeOutput(rt.shape,rt.dtype);if(a.util.sizeFromShape(rt.shape)===0)return Jt;const un=me.dataIdMap.get(Jt.dataId).id;return re(_t,en,Kt,Ze,Lt,Ae,un),Jt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ot;const Ct={kernelName:a.FusedConv2D,backendName:"wasm",setupFunc:function(Pe){ot=Pe.wasm.cwrap(a.FusedConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{x:Ae,filter:rt,bias:xt,preluActivationWeights:Nt}=me,{strides:vt,pad:St,dilations:_t,dataFormat:en,dimRoundingMode:Kt,activation:Ze,leakyreluAlpha:Lt}=He,Jt=a.backend_util.computeConv2DInfo(Ae.shape,rt.shape,vt,_t,St,Kt),un=r[Ze];if(un==null)throw new Error(`${Ze} activation not yet supported for FusedConv2D in the wasm backend.`);const In=st.dataIdMap.get(Ae.dataId).id,Xt=st.dataIdMap.get(rt.dataId).id,$n=Jt.outChannels;let Jn=0;if(xt!=null){const ca=st.dataIdMap.get(xt.dataId);if(ca.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ca.shape.length}.`);if(ca.shape[0]!==$n)throw new Error(`FusedConv2D bias shape (${ca.shape}) does not match the number of output channels (${$n})`);Jn=ca.id}const Ss=Jt.filterHeight,Ms=Jt.filterWidth,Ps=Jt.padInfo.top,Fs=Jt.padInfo.right,pr=Jt.padInfo.bottom,er=Jt.padInfo.left,fr=Jt.dilationHeight,cr=Jt.dilationWidth,jr=Jt.strideHeight,Ca=Jt.strideWidth,yo=Jt.inChannels,Ao=Jt.padInfo.type==="SAME"?1:0,Li=Jt.batchSize,hi=Jt.inHeight,wo=Jt.inWidth;if(en!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${en}'. Please use 'NHWC'.`);const Ho=st.makeOutput(Jt.outShape,"float32"),qo=st.dataIdMap.get(Ho.dataId).id,Bi=Nt==null?0:st.dataIdMap.get(Nt.dataId).id;return ot(In,Li,hi,wo,Xt,Ss,Ms,Jn,Ps,Fs,pr,er,Ao,fr,cr,jr,Ca,yo,$n,un,Bi,Lt||0,qo),Ho}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yt;const on={kernelName:a.FusedDepthwiseConv2D,backendName:"wasm",setupFunc:function(Pe){Yt=Pe.wasm.cwrap(a.FusedDepthwiseConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{x:Ae,filter:rt,bias:xt,preluActivationWeights:Nt}=me,{strides:vt,pad:St,dilations:_t,dataFormat:en,dimRoundingMode:Kt,activation:Ze,leakyreluAlpha:Lt}=He,Jt=a.backend_util.computeConv2DInfo(Ae.shape,rt.shape,vt,_t,St,Kt,!0),un=r[Ze];if(un==null)throw new Error(`${Ze} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const In=st.dataIdMap.get(Ae.dataId).id,Xt=st.dataIdMap.get(rt.dataId).id,$n=Jt.outChannels;let Jn=0;if(xt!=null){const ca=st.dataIdMap.get(xt.dataId);if(ca.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ca.shape.length}.`);if(ca.shape[0]!==$n)throw new Error(`FusedDepthwiseConv2D bias shape (${ca.shape}) does not match the number of output channels (${$n})`);Jn=ca.id}const Ss=Jt.filterHeight,Ms=Jt.filterWidth,Ps=Jt.padInfo.top,Fs=Jt.padInfo.right,pr=Jt.padInfo.bottom,er=Jt.padInfo.left,fr=Jt.dilationHeight,cr=Jt.dilationWidth,jr=Jt.strideHeight,Ca=Jt.strideWidth,yo=Jt.inChannels,Ao=Jt.padInfo.type==="SAME"?1:0,Li=Jt.batchSize,hi=Jt.inHeight,wo=Jt.inWidth;if(en!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${en}'. Please use 'NHWC'.`);const Ho=st.makeOutput(Jt.outShape,"float32"),qo=st.dataIdMap.get(Ho.dataId).id,Bi=Nt==null?0:st.dataIdMap.get(Nt.dataId).id;return Yt(In,Li,hi,wo,Xt,Ss,Ms,Jn,Ps,Fs,pr,er,Ao,fr,cr,jr,Ca,yo,$n,un,Bi,Lt||0,qo),Ho}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tn;const bn={kernelName:a.GatherNd,backendName:"wasm",setupFunc:function(Pe){tn=Pe.wasm.cwrap(a.GatherNd,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He}=Pe,{params:st,indices:Ae}=He,[rt,xt,Nt,vt]=a.gather_util.prepareAndValidate(st,Ae),St=me.makeOutput(rt,st.dtype);if(xt===0)return St;const _t=Ae.shape,en=_t[_t.length-1],Kt=me.dataIdMap.get(st.dataId).id,Ze=me.dataIdMap.get(Ae.dataId).id,Lt=new Uint8Array(new Int32Array(vt).buffer),Jt=me.dataIdMap.get(St.dataId).id;return tn(Kt,n[st.dtype],Ze,xt,en,Nt,Lt,Jt),St}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let On;const Mn={kernelName:a.GatherV2,backendName:"wasm",setupFunc:function(Pe){On=Pe.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{x:Ae,indices:rt}=He,{axis:xt,batchDims:Nt}=st,vt=a.util.parseAxisParam(xt,Ae.shape)[0],St=me.readSync(rt.dataId),_t=Ae.shape[vt];for(let Ps=0;Ps<St.length;++Ps){const Fs=St[Ps];a.util.assert(Fs<=_t-1&&Fs>=0,()=>`GatherV2: the index value ${Fs} is not in [0, ${_t-1}]`)}const en=a.backend_util.segment_util.collectGatherOpShapeInfo(Ae,rt,vt,Nt),Kt=ne({inputs:{x:Ae},attrs:{shape:[en.batchSize,en.outerSize,en.dimSize,en.sliceSize]},backend:me}),Ze=a.util.sizeFromShape(rt.shape),Lt=ne({inputs:{x:rt},attrs:{shape:[en.batchSize,Ze/en.batchSize]},backend:me}),Jt=[en.batchSize,en.outerSize,Ze/en.batchSize,en.sliceSize],un=me.makeOutput(Jt,Ae.dtype);if(a.util.sizeFromShape(Ae.shape)===0)return un;const In=Kt.shape.length-1,Xt=me.dataIdMap.get(Kt.dataId).id,$n=me.dataIdMap.get(Lt.dataId).id,Jn=me.dataIdMap.get(un.dataId).id,Ss=new Uint8Array(new Int32Array(a.util.computeStrides(Kt.shape)).buffer),Ms=new Uint8Array(new Int32Array(a.util.computeStrides(Jt)).buffer);return On(Xt,n[Ae.dtype],Ss,In,$n,en.batchSize,Ms,Jn),me.disposeData(Kt.dataId),me.disposeData(Lt.dataId),un.shape=en.outputShape,un}},wn=d(a.Greater,0,"bool"),gs=d(a.GreaterEqual,0,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hs;const xr={kernelName:a.LeakyRelu,backendName:"wasm",setupFunc:function(Pe){Hs=Pe.wasm.cwrap(a.LeakyRelu,null,["number","number","number","number"])},kernelFunc:function(Pe){const{inputs:{x:me},attrs:{alpha:He},backend:st}=Pe,Ae=st.dataIdMap.get(me.dataId).id,rt=st.makeOutput(me.shape,"float32");if(a.util.sizeFromShape(me.shape)!==0){const xt=st.dataIdMap.get(rt.dataId).id;Hs(Ae,n[me.dtype],He,xt)}return rt}},Ir=d(a.Less,0,"bool"),qs=d(a.LessEqual,0,"bool"),ta=u(a.Log),pa=d(a.LogicalAnd,0,"bool"),rr=u(a.LogicalNot),eo=d(a.LogicalOr,0,"bool"),Qs=d(a.LogicalXor,0,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mr;const $r={kernelName:a.Max,backendName:"wasm",setupFunc:function(Pe){mr=Pe.wasm.cwrap(a.Max,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{reductionIndices:Ae,keepDims:rt}=st,{x:xt}=He;let Nt=me.dataIdMap.get(xt.dataId).id,vt=xt;const{transposed:St,axes:_t,originalAxes:en,inputWasTransposed:Kt}=N(xt,Ae,me);Kt&&(vt=St,Nt=me.dataIdMap.get(St.dataId).id);const Ze=vt.shape.length;a.backend_util.assertAxesAreInnerMostDims("max",_t,Ze);const[Lt,Jt]=a.backend_util.computeOutAndReduceShapes(vt.shape,_t),un=a.util.sizeFromShape(Jt),In=me.makeOutput(Lt,xt.dtype);if(a.util.sizeFromShape(vt.shape)!==0){const Xt=me.dataIdMap.get(In.dataId).id;mr(Nt,n[xt.dtype],un,Xt)}if(Kt&&me.disposeData(St.dataId),rt){const Xt=a.backend_util.expandShapeToKeepDim(In.shape,en);In.shape=Xt}return In}},ia=d(a.Maximum);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pr;const Cr={kernelName:a.MaxPool,backendName:"wasm",setupFunc:function(Pe){Pr=Pe.wasm.cwrap(a.MaxPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,Ae=me.x,rt=st.dataIdMap.get(Ae.dataId).id;a.util.assert(Ae.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${Ae.dtype}.`);const{filterSize:xt,strides:Nt,pad:vt,dimRoundingMode:St}=He,_t=a.backend_util.computePool2DInfo(Ae.shape,xt,Nt,1,vt,St),en=_t.filterHeight,Kt=_t.filterWidth,Ze=_t.padInfo.top,Lt=_t.padInfo.right,Jt=_t.padInfo.bottom,un=_t.padInfo.left,In=_t.dilationHeight,Xt=_t.dilationWidth,$n=_t.strideHeight,Jn=_t.strideWidth,Ss=_t.inChannels,Ms=_t.outChannels;if(_t.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${_t.dataFormat}'. Please use 'channelsLast'.`);const Ps=st.makeOutput(_t.outShape,"float32"),Fs=st.dataIdMap.get(Ps.dataId).id;return Pr(rt,Ae.shape[0],Ae.shape[1],Ae.shape[2],en,Kt,Ze,Lt,Jt,un,In,Xt,$n,Jn,Ss,Ms,Fs),Ps}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ba;const za={kernelName:a.Mean,backendName:"wasm",setupFunc:function(Pe){Ba=Pe.wasm.cwrap(a.Mean,null,["number, number, number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He,Nt=me.dataIdMap.get(xt.dataId).id;let vt=Nt,St=xt;const{transposed:_t,axes:en,originalAxes:Kt,inputWasTransposed:Ze}=N(xt,Ae,me);let Lt=en;if(Ze){const Jn=me.dataIdMap.get(_t.dataId).id;Jn!==Nt&&(St=_t,vt=Jn,Lt=a.backend_util.getInnerMostAxes(Lt.length,St.shape.length))}a.backend_util.assertAxesAreInnerMostDims("mean",Lt,St.shape.length);const[Jt,un]=a.backend_util.computeOutAndReduceShapes(St.shape,Lt),In=a.util.sizeFromShape(un);let Xt=St;St.dtype!=="float32"&&(Xt=Ht({backend:me,inputs:{x:St},attrs:{dtype:"float32"}}),vt=me.dataIdMap.get(Xt.dataId).id);const $n=me.makeOutput(Jt,"float32");if(a.util.sizeFromShape(St.shape)!==0){const Jn=me.dataIdMap.get($n.dataId).id;Ba(vt,In,Jn)}if(Ze&&me.disposeData(_t.dataId),rt){const Jn=a.backend_util.expandShapeToKeepDim($n.shape,Kt);$n.shape=Jn}return St.dtype!=="float32"&&me.disposeData(Xt.dataId),$n}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let to;const Wo={kernelName:a.Min,backendName:"wasm",setupFunc:function(Pe){to=Pe.wasm.cwrap(a.Min,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He,Nt=me.dataIdMap.get(xt.dataId).id;let vt=Nt,St=xt;const{transposed:_t,axes:en,originalAxes:Kt,inputWasTransposed:Ze}=N(xt,Ae,me);if(Ze){const $n=me.dataIdMap.get(_t.dataId).id;$n!==Nt&&(St=_t,vt=$n)}const Lt=St.shape.length;a.backend_util.assertAxesAreInnerMostDims("min",en,Lt);const[Jt,un]=a.backend_util.computeOutAndReduceShapes(St.shape,en),In=a.util.sizeFromShape(un),Xt=me.makeOutput(Jt,St.dtype);if(a.util.sizeFromShape(St.shape)!==0){const $n=me.dataIdMap.get(Xt.dataId).id;to(vt,n[xt.dtype],In,$n)}if(Ze&&me.disposeData(_t.dataId),rt){const $n=a.backend_util.expandShapeToKeepDim(Xt.shape,Kt);Xt.shape=$n}return Xt}},si=d(a.Minimum);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var fo;let no;(function(Pe){Pe[Pe.reflect=0]="reflect",Pe[Pe.symmetric=1]="symmetric"})(fo||(fo={}));const Ta={kernelName:a.MirrorPad,backendName:"wasm",kernelFunc:function(Pe){const{inputs:{x:me},backend:He,attrs:{paddings:st,mode:Ae}}=Pe,rt=st.map((Lt,Jt)=>Lt[0]+me.shape[Jt]+Lt[1]),xt=He.dataIdMap.get(me.dataId).id,Nt=He.makeOutput(rt,me.dtype),vt=He.dataIdMap.get(Nt.dataId).id,St=new Uint8Array(new Int32Array(me.shape).buffer),_t=st.map(Lt=>Lt[0]),en=st.map(Lt=>Lt[1]),Kt=new Uint8Array(new Int32Array(_t).buffer),Ze=new Uint8Array(new Int32Array(en).buffer);return no(xt,St,me.shape.length,n[me.dtype],Kt,Ze,fo[Ae],vt),Nt},setupFunc:function(Pe){no=Pe.wasm.cwrap(a.MirrorPad,null,["number","array","number","number","array","array","number","number"])}},mo=d(a.Multiply),Ar=u(a.Neg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(Pe,me){const He=new Int32Array(Pe.wasm.HEAPU8.buffer,me,4),st=He[0],Ae=He[1],rt=He[2],xt=He[3];return Pe.wasm._free(me),{pSelectedIndices:st,selectedSize:Ae,pSelectedScores:rt,pValidOutputs:xt}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ea;const Vo={kernelName:a.NonMaxSuppressionV3,backendName:"wasm",setupFunc:function(Pe){Ea=Pe.wasm.cwrap(a.NonMaxSuppressionV3,"number",["number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{iouThreshold:Ae,maxOutputSize:rt,scoreThreshold:xt}=st,{boxes:Nt,scores:vt}=He,St=me.dataIdMap.get(Nt.dataId).id,_t=me.dataIdMap.get(vt.dataId).id,en=Ea(St,_t,rt,Ae,xt),{pSelectedIndices:Kt,selectedSize:Ze,pSelectedScores:Lt,pValidOutputs:Jt}=Na(me,en);return me.wasm._free(Lt),me.wasm._free(Jt),me.makeOutput([Ze],"int32",Kt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let So;const so={kernelName:a.NonMaxSuppressionV4,backendName:"wasm",setupFunc:function(Pe){So=Pe.wasm.cwrap(a.NonMaxSuppressionV4,"number",["number","number","number","number","number","bool"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{iouThreshold:Ae,maxOutputSize:rt,scoreThreshold:xt,padToMaxOutputSize:Nt}=st,{boxes:vt,scores:St}=He,_t=me.dataIdMap.get(vt.dataId).id,en=me.dataIdMap.get(St.dataId).id,Kt=So(_t,en,rt,Ae,xt,Nt),{pSelectedIndices:Ze,selectedSize:Lt,pSelectedScores:Jt,pValidOutputs:un}=Na(me,Kt);return me.wasm._free(Jt),[me.makeOutput([Lt],"int32",Ze),me.makeOutput([],"int32",un)]}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zs;const Kr={kernelName:a.NonMaxSuppressionV5,backendName:"wasm",setupFunc:function(Pe){Zs=Pe.wasm.cwrap(a.NonMaxSuppressionV5,"number",["number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{iouThreshold:Ae,maxOutputSize:rt,scoreThreshold:xt,softNmsSigma:Nt}=st,{boxes:vt,scores:St}=He,_t=me.dataIdMap.get(vt.dataId).id,en=me.dataIdMap.get(St.dataId).id,Kt=Zs(_t,en,rt,Ae,xt,Nt),{pSelectedIndices:Ze,selectedSize:Lt,pSelectedScores:Jt,pValidOutputs:un}=Na(me,Kt);return me.wasm._free(un),[me.makeOutput([Lt],"int32",Ze),me.makeOutput([Lt],"float32",Jt)]}},Ra=d(a.NotEqual,0,"bool");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fa;const na={kernelName:a.OneHot,backendName:"wasm",setupFunc:function(Pe){fa=Pe.wasm.cwrap(a.OneHot,null,["number","number","number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{indices:Ae}=me,{dtype:rt,depth:xt,onValue:Nt,offValue:vt}=st,St=He.makeOutput([...Ae.shape,xt],rt),_t=He.dataIdMap.get(St.dataId).id,en=He.dataIdMap.get(Ae.dataId).id;return fa(en,xt,Nt,vt,_t),St}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $o={kernelName:a.OnesLike,backendName:"wasm",kernelFunc:function(Pe){const{inputs:{x:me},backend:He}=Pe,st=He.makeOutput(me.shape,me.dtype);return He.typedArrayFromHeap(st).fill(1),st}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const We={kernelName:a.Pack,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{axis:Ae}=st;if(me.length===1)return Nn({inputs:{input:me[0]},backend:He,attrs:{dim:Ae}});const rt=me[0].shape,xt=me[0].dtype;me.forEach(St=>{a.util.assertShapesMatch(rt,St.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(xt===St.dtype,()=>"All tensors passed to stack must have matching dtypes")});const Nt=[],vt=se({inputs:me.map(St=>{const _t=Nn({inputs:{input:St},backend:He,attrs:{dim:Ae}});return Nt.push(_t),_t}),backend:He,attrs:{axis:Ae}});return Nt.forEach(St=>He.disposeData(St.dataId)),vt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let It;const Ut={kernelName:a.PadV2,backendName:"wasm",kernelFunc:function(Pe){const{inputs:{x:me},backend:He,attrs:{paddings:st,constantValue:Ae}}=Pe,rt=st.map((Lt,Jt)=>Lt[0]+me.shape[Jt]+Lt[1]);if(a.util.sizeFromShape(me.shape)===0)return $s({backend:He,attrs:{shape:rt,value:Ae,dtype:me.dtype}});const xt=He.dataIdMap.get(me.dataId).id,Nt=He.makeOutput(rt,me.dtype),vt=He.dataIdMap.get(Nt.dataId).id,St=new Uint8Array(new Int32Array(me.shape).buffer),_t=st.map(Lt=>Lt[0]),en=st.map(Lt=>Lt[1]),Kt=new Uint8Array(new Int32Array(_t).buffer),Ze=new Uint8Array(new Int32Array(en).buffer);return It(xt,St,me.shape.length,n[me.dtype],Kt,Ze,Ae,vt),Nt},setupFunc:function(Pe){It=Pe.wasm.cwrap(a.PadV2,null,["number","array","number","number","array","array","number","number"])}},sn=d(a.Pow);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vn;const fn={kernelName:a.Prelu,backendName:"wasm",setupFunc:function(Pe){vn=Pe.wasm.cwrap(a.Prelu,null,["number","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He}=Pe,{x:st,alpha:Ae}=me,rt=He.dataIdMap.get(st.dataId).id,xt=He.dataIdMap.get(Ae.dataId).id;let Nt=rt;const vt=st;let St=vt;vt.dtype!=="float32"&&(St=Ht({backend:He,inputs:{x:st},attrs:{dtype:"float32"}}),Nt=He.dataIdMap.get(St.dataId).id);const _t=He.makeOutput(st.shape,"float32"),en=He.dataIdMap.get(_t.dataId).id;return vn(Nt,xt,en),vt.dtype!=="float32"&&He.disposeData(St.dataId),_t}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vn;const hs={kernelName:a.Prod,backendName:"wasm",setupFunc:function(Pe){Vn=Pe.wasm.cwrap(a.Prod,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He,Nt=me.dataIdMap.get(xt.dataId).id;let vt=Nt,St=xt;const{transposed:_t,axes:en,originalAxes:Kt,inputWasTransposed:Ze}=N(xt,Ae,me);let Lt=en;if(Ze){const $n=me.dataIdMap.get(_t.dataId).id;$n!==Nt&&(St=_t,vt=$n,Lt=a.backend_util.getInnerMostAxes(Lt.length,St.shape.length))}a.backend_util.assertAxesAreInnerMostDims("prod",Lt,St.shape.length);const[Jt,un]=a.backend_util.computeOutAndReduceShapes(St.shape,Lt),In=a.util.sizeFromShape(un),Xt=me.makeOutput(Jt,St.dtype);if(a.util.sizeFromShape(St.shape)!==0){const $n=me.dataIdMap.get(Xt.dataId).id;Vn(vt,In,n[Xt.dtype],$n)}if(Ze&&me.disposeData(_t.dataId),rt){const $n=a.backend_util.expandShapeToKeepDim(Xt.shape,Kt);Xt.shape=$n}return Xt}},Es={kernelName:a.Range,backendName:"wasm",kernelFunc:Pe=>{const{backend:me,attrs:He}=Pe,{start:st,stop:Ae,step:rt,dtype:xt}=He,Nt=Object(Be.a)(st,Ae,rt,xt),vt=me.makeOutput([Nt.length],xt);return me.typedArrayFromHeap(vt).set(Nt),vt}},dr=d(a.RealDiv),Js=u(a.Relu),ga=u(a.Relu6);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ur;const Or={kernelName:a.ResizeBilinear,backendName:"wasm",setupFunc:function(Pe){ur=Pe.wasm.cwrap(a.ResizeBilinear,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{images:Ae}=He,{alignCorners:rt,halfPixelCenters:xt,size:Nt}=st,[vt,St]=Nt,[_t,en,Kt,Ze]=Ae.shape,Lt=[_t,vt,St,Ze];let Jt,un=me.dataIdMap.get(Ae.dataId);un.dtype!=="float32"&&(Jt=Ht({backend:me,inputs:{x:Ae},attrs:{dtype:"float32"}}),un=me.dataIdMap.get(Jt.dataId));const In=un.id,Xt=me.makeOutput(Lt,"float32");if(a.util.sizeFromShape(Ae.shape)===0)return Xt;const $n=me.dataIdMap.get(Xt.dataId).id;return ur(In,_t,en,Kt,Ze,vt,St,rt?1:0,xt?1:0,$n),Jt!=null&&me.disposeData(Jt.dataId),Xt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ro;const Wa={kernelName:a.ResizeNearestNeighbor,backendName:"wasm",setupFunc:function(Pe){ro=Pe.wasm.cwrap(a.ResizeNearestNeighbor,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{images:Ae}=He,{alignCorners:rt,halfPixelCenters:xt,size:Nt}=st,[vt,St]=Nt,[_t,en,Kt,Ze]=Ae.shape,Lt=[_t,vt,St,Ze],Jt=me.makeOutput(Lt,"float32");if(a.util.sizeFromShape(Ae.shape)===0)return Jt;let un,In=me.dataIdMap.get(Ae.dataId);In.dtype!=="float32"&&(un=Ht({backend:me,inputs:{x:Ae},attrs:{dtype:"float32"}}),In=me.dataIdMap.get(un.dataId));const Xt=In.id,$n=me.dataIdMap.get(Jt.dataId).id;return ro(Xt,_t,en,Kt,Ze,vt,St,rt?1:0,xt?1:0,$n),un!=null&&me.disposeData(un.dataId),Jt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Va;const Qi={kernelName:a.Reverse,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{dims:rt}=st,xt=a.util.parseAxisParam(rt,Ae.shape);if(Ae.shape.length===0)return f({inputs:{x:Ae},backend:He});const Nt=He.makeOutput(Ae.shape,Ae.dtype),vt=He.dataIdMap.get(Ae.dataId).id,St=He.dataIdMap.get(Nt.dataId).id,_t=new Uint8Array(new Int32Array(xt).buffer),en=new Uint8Array(new Int32Array(Ae.shape).buffer);Va(vt,_t,xt.length,en,Ae.shape.length,St);const Kt=ne({inputs:{x:Nt},attrs:{shape:Ae.shape},backend:He});return He.disposeData(Nt.dataId),Kt},setupFunc:function(Pe){Va=Pe.wasm.cwrap(a.Reverse,null,["number","array","number","array","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _i;const ri={kernelName:a.RotateWithOffset,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{image:Ae}=me,{radians:rt,fillValue:xt,center:Nt}=st,vt=He.makeOutput(Ae.shape,Ae.dtype),St=He.dataIdMap.get(Ae.dataId).id,_t=He.dataIdMap.get(vt.dataId).id,[en,Kt,Ze,Lt]=Ae.shape,[Jt,un]=a.backend_util.getImageCenter(Nt,Kt,Ze),In=typeof xt=="number"?[xt,xt,xt,xt===0?0:255]:[...xt,255],Xt=new Uint8Array(new Int32Array(In).buffer);return _i(St,en,Kt,Ze,Lt,rt,Jt,un,Xt,In.length,_t),vt},setupFunc:function(Pe){_i=Pe.wasm.cwrap(a.RotateWithOffset,null,["number","number","number","number","number","number","number","number","array","number","number"])}},$u=u(a.Round),go=u(a.Rsqrt);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bo;const Ua={kernelName:a.ScatterNd,backendName:"wasm",setupFunc:function(Pe){bo=Pe.wasm.cwrap(a.ScatterNd,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{indices:Ae,updates:rt}=He,{shape:xt}=st,Nt=me.makeOutput(xt,rt.dtype);if(a.util.sizeFromShape(xt)===0)return Nt;const{sliceRank:vt,numUpdates:St,sliceSize:_t,strides:en,outputSize:Kt}=a.scatter_util.calculateShapes(rt,Ae,xt),Ze=me.dataIdMap.get(Ae.dataId).id,Lt=me.dataIdMap.get(rt.dataId).id,Jt=new Uint8Array(new Int32Array(en).buffer),un=me.dataIdMap.get(Nt.dataId).id;return bo(Ze,Lt,n[rt.dtype],vt,St,_t,Jt,Kt,un),Nt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wr;const Ji={kernelName:a.Select,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He}=Pe,{condition:st,t:Ae,e:rt}=me,xt=He.dataIdMap.get(st.dataId).id,Nt=He.dataIdMap.get(Ae.dataId).id,vt=He.dataIdMap.get(rt.dataId).id,St=He.makeOutput(Ae.shape,Ae.dtype),_t=He.dataIdMap.get(St.dataId).id,en=st.shape.length,Kt=Ae.shape.length,Ze=en===0||en>1||Kt===1?1:a.util.sizeFromShape(Ae.shape.slice(1));return Wr(xt,Nt,vt,Ze,_t),St},setupFunc:function(Pe){Wr=Pe.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xr;const ja={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(Pe){Xr=Pe.wasm.cwrap(a.Sigmoid,null,["number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:{x:He}}=Pe,st=me.dataIdMap.get(He.dataId).id,Ae=me.makeOutput(He.shape,He.dtype),rt=me.dataIdMap.get(Ae.dataId).id;return a.util.sizeFromShape(Ae.shape)===0||Xr(st,rt),Ae}},To=u(a.Sin);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ai;const Tu={kernelName:a.Softmax,backendName:"wasm",setupFunc:function(Pe){ai=Pe.wasm.cwrap(a.Softmax,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:{logits:He},attrs:{dim:st}}=Pe,Ae=me.dataIdMap.get(He.dataId).id,rt=me.makeOutput(He.shape,He.dtype),xt=me.dataIdMap.get(rt.dataId).id,Nt=He.shape[st],vt=a.util.sizeFromShape(He.shape)/Nt;return a.util.sizeFromShape(rt.shape)===0||ai(Ae,xt,Nt,vt),rt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oi={kernelName:a.SpaceToBatchND,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,{blockShape:rt,paddings:xt}=st,Nt=a.util.sizeFromShape(rt),vt=[[0,0]];vt.push(...xt);for(let un=1+rt.length;un<Ae.shape.length;++un)vt.push([0,0]);const St=Ut.kernelFunc({inputs:{x:Ae},backend:He,attrs:{paddings:vt,constantValue:0}}),_t=a.backend_util.getReshaped(St.shape,rt,Nt,!1),en=a.backend_util.getPermuted(_t.length,rt.length,!1),Kt=a.backend_util.getReshapedPermuted(St.shape,rt,Nt,!1),Ze=ne({inputs:{x:St},backend:He,attrs:{shape:_t}}),Lt=m({inputs:{x:Ze},backend:He,attrs:{perm:en}}),Jt=ne({inputs:{x:Lt},backend:He,attrs:{shape:Kt}});return He.disposeData(St.dataId),He.disposeData(Ze.dataId),He.disposeData(Lt.dataId),Jt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Uo;const Nu={kernelName:a.SparseFillEmptyRows,backendName:"wasm",setupFunc:function(Pe){Uo=Pe.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He}=Pe,{indices:st,values:Ae,denseShape:rt,defaultValue:xt}=He,Nt=st.shape[0],vt=st.shape[1],St=me.readSync(rt.dataId)[0],_t=[Nt+St,vt],en=me.dataIdMap.get(st.dataId).id,Kt=me.dataIdMap.get(Ae.dataId).id,Ze=me.dataIdMap.get(xt.dataId).id,Lt=me.makeOutput(_t,st.dtype),Jt=me.dataIdMap.get(Lt.dataId).id,un=me.makeOutput(_t.slice(0,1),Ae.dtype),In=me.dataIdMap.get(un.dataId).id,Xt=me.makeOutput([St],"bool"),$n=me.dataIdMap.get(Xt.dataId).id,Jn=me.makeOutput([Nt],st.dtype),Ss=me.dataIdMap.get(Jn.dataId).id,Ms=me.makeOutput([4],"int32"),Ps=me.dataIdMap.get(Ms.dataId).id,Fs=Uo(en,Kt,n[Ae.dtype],Nt,St,vt,Ze,Jt,In,$n,Ss,Ps),pr=me.readSync(Ms.dataId);let er;switch(pr[0]){case 1:er=a.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(pr[1]);break;case 2:er=a.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(pr[1],pr[2]);break;case 3:er=a.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(pr[1],pr[2],pr[3]);break;default:er=""}if(me.disposeData(Ms.dataId),er)throw me.disposeData(Lt.dataId),me.disposeData(un.dataId),me.disposeData(Xt.dataId),me.disposeData(Jn.dataId),new Error(er);let fr=Lt,cr=un;return Fs!==_t[0]&&(fr=wt({inputs:{x:Lt},attrs:{begin:0,size:[Fs,vt]},backend:me}),cr=wt({inputs:{x:un},attrs:{begin:0,size:Fs},backend:me}),me.disposeData(Lt.dataId),me.disposeData(un.dataId)),[fr,cr,Xt,Jn]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ls;const Lr={kernelName:a.SparseReshape,backendName:"wasm",setupFunc:function(Pe){Ls=Pe.wasm.cwrap(a.SparseReshape,null,["number","number","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He}=Pe,{inputIndices:st,inputShape:Ae,newShape:rt}=He;if(st.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${st.shape}`);if(Ae.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${Ae.shape}`);if(rt.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${rt.shape}`);const xt=me.dataIdMap.get(st.dataId).id,Nt=me.dataIdMap.get(Ae.dataId).id,vt=me.dataIdMap.get(rt.dataId).id,St=st.shape[0],_t=a.util.sizeFromShape(rt.shape),en=me.makeOutput([St,_t],st.dtype),Kt=me.dataIdMap.get(en.dataId).id,Ze=me.makeOutput([_t],rt.dtype),Lt=me.dataIdMap.get(Ze.dataId).id,Jt=me.makeOutput([3],"int32"),un=me.dataIdMap.get(Jt.dataId).id;Ls(xt,Nt,vt,St,Kt,Lt,un);const In=me.readSync(Jt.dataId);let Xt;switch(In[0]){case 0:Xt=a.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(In[1],In[2]);break;case 1:Xt=a.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(In[1],In[2]);break;case 2:Xt=a.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const $n=Array.from(me.readSync(Ae.dataId)),Jn=Array.from(me.readSync(Ze.dataId));Xt=a.backend_util.getSparseReshapeInputOutputMultipleErrorMessage($n,Jn);break}case 4:{const $n=Array.from(me.readSync(Ae.dataId)),Jn=Array.from(me.readSync(Ze.dataId));Xt=a.backend_util.getSparseReshapeInputOutputMismatchErrorMessage($n,Jn);break}default:Xt=""}if(me.disposeData(Jt.dataId),Xt)throw me.disposeData(en.dataId),me.disposeData(Ze.dataId),new Error(Xt);return[en,Ze]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ao;function Si(Pe){ao=Pe.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function eu(Pe,me){const{backend:He,inputs:st}=Pe,{data:Ae,indices:rt,segmentIds:xt}=st,Nt=rt.shape[0],vt=He.readSync(xt.dataId,Nt-1,Nt)[0],St=Nt>0?vt+1:0;if(St<0)throw new Error(a.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const _t=Ae.shape.slice();_t[0]=St;const en=He.dataIdMap.get(Ae.dataId).id,Kt=He.dataIdMap.get(rt.dataId).id,Ze=He.dataIdMap.get(xt.dataId).id,Lt=He.makeOutput(_t,Ae.dtype),Jt=He.dataIdMap.get(Lt.dataId).id,un=He.makeOutput([4],"int32"),In=He.dataIdMap.get(un.dataId).id;ao(en,n[Ae.dtype],Ae.shape[0],Kt,Ze,Jt,In,me,0);const Xt=He.readSync(un.dataId);let $n;switch(Xt[0]){case 0:$n=a.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:$n=a.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:$n=a.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(Xt[1],Xt[2]);break;case 3:$n=a.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(Xt[1],Xt[2],Xt[3]);break;default:$n=""}if(He.disposeData(un.dataId),$n)throw He.disposeData(Lt.dataId),new Error($n);return Lt}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No={kernelName:a.SparseSegmentMean,backendName:"wasm",setupFunc:Si,kernelFunc:function(Pe){return eu(Pe,!0)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $i={kernelName:a.SparseSegmentSum,backendName:"wasm",setupFunc:Si,kernelFunc:function(Pe){return eu(Pe,!1)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ti={kernelName:a.SplitV,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,attrs:He,backend:st}=Pe,{x:Ae}=me,{numOrSizeSplits:rt,axis:xt}=He,Nt=a.util.parseAxisParam(xt,Ae.shape)[0],vt=a.backend_util.prepareSplitSize(Ae,rt,Nt),St=new Array(Ae.shape.length).fill(0),_t=Ae.shape.slice();return vt.map(en=>{const Kt=[..._t];Kt[Nt]=en;const Ze=wt({inputs:{x:Ae},attrs:{begin:St,size:Kt},backend:st});return St[Nt]+=en,Ze})}},ii=u(a.Sqrt),bs=u(a.Square),jn=d(a.SquaredDifference);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hr;const Gn={kernelName:a.Step,backendName:"wasm",setupFunc:function(Pe){hr=Pe.wasm.cwrap(a.Step,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{alpha:Ae}=st,{x:rt}=He,xt=me.dataIdMap.get(rt.dataId).id,Nt=me.makeOutput(rt.shape,rt.dtype),vt=me.dataIdMap.get(Nt.dataId).id;return hr(xt,Ae,n[rt.dtype],vt),Nt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Aa;const Vr={kernelName:a.StridedSlice,backendName:"wasm",setupFunc:function(Pe){Aa=Pe.wasm.cwrap(a.StridedSlice,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{x:Ae}=He,{begin:rt,end:xt,strides:Nt,beginMask:vt,endMask:St,ellipsisMask:_t,newAxisMask:en,shrinkAxisMask:Kt}=st,{finalShapeSparse:Ze,finalShape:Lt,isIdentity:Jt,sliceDim0:un,isSimpleSlice:In,begin:Xt,end:$n,strides:Jn}=a.slice_util.sliceInfo(Ae.shape,rt,xt,Nt,vt,St,_t,en,Kt);let Ss;if(Jt)Ss=ne({inputs:{x:Ae},backend:me,attrs:{shape:Lt}});else if(un||In){a.util.assert(Ae.shape.length>=1,()=>`Input must have rank at least 1, got: ${Ae.shape.length}`);const Ms=a.slice_util.computeOutShape(Xt,$n,Jn),Ps=wt({inputs:{x:Ae},backend:me,attrs:{begin:Xt,size:Ms}});Ss=ne({inputs:{x:Ps},backend:me,attrs:{shape:Lt}}),me.disposeData(Ps.dataId)}else{const Ms=me.makeOutput(Ze,"float32"),Ps=me.dataIdMap.get(Ae.dataId).id,Fs=new Uint8Array(new Int32Array(a.util.computeStrides(Ae.shape)).buffer),pr=new Uint8Array(new Int32Array(Xt).buffer),er=new Uint8Array(new Int32Array($n).buffer),fr=new Uint8Array(new Int32Array(Jn).buffer),cr=new Uint8Array(new Int32Array(Ze).buffer),jr=new Uint8Array(new Int32Array(a.util.computeStrides(Ze)).buffer),Ca=me.dataIdMap.get(Ms.dataId).id;Aa(Ps,Fs,Ae.shape.length,pr,er,fr,cr,jr,Ze.length,Ca),Ss=ne({inputs:{x:Ms},backend:me,attrs:{shape:Lt}}),me.disposeData(Ms.dataId)}return Ss}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua={kernelName:a.StringNGrams,backendName:"wasm",kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{data:Ae,dataSplits:rt}=He,{separator:xt,nGramWidths:Nt,leftPad:vt,rightPad:St,padWidth:_t,preserveShortSequences:en}=st,Kt=me.readSync(Ae.dataId),Ze=me.readSync(rt.dataId),[Lt,Jt]=Object(tt.a)(Kt,Ze,xt,Nt,vt,St,_t,en),un=me.makeOutput([Lt.length],"string");me.dataIdMap.get(un.dataId).stringBytes=Lt;const In=me.makeOutput(rt.shape,"int32");return me.typedArrayFromHeap(In).set(Jt),[un,In]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tu={kernelName:a.StringSplit,backendName:"wasm",kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{input:Ae,delimiter:rt}=He,{skipEmpty:xt}=st,Nt=me.readSync(Ae.dataId),vt=me.readSync(rt.dataId),[St,_t,en]=Object(ct.a)(Nt,vt[0],xt),Kt=_t.length,Ze=me.makeOutput([Kt,2],"int32");me.typedArrayFromHeap(Ze).set(St);const Lt=me.makeOutput([Kt],"string");me.dataIdMap.get(Lt.dataId).stringBytes=_t;const Jt=me.makeOutput([2],"int32");return me.typedArrayFromHeap(Jt).set(en),[Ze,Lt,Jt]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ui={kernelName:a.StringToHashBucketFast,backendName:"wasm",kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{input:Ae}=He,{numBuckets:rt}=st,xt=me.readSync(Ae.dataId),Nt=Object(Me.a)(xt,rt),vt=me.makeOutput(Ae.shape,"int32");return me.typedArrayFromHeap(vt).set(Nt),vt}},jo=d(a.Sub);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ku;const Ur={kernelName:a.Sum,backendName:"wasm",setupFunc:function(Pe){Ku=Pe.wasm.cwrap(a.Sum,null,["number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{axis:Ae,keepDims:rt}=st,{x:xt}=He,Nt=me.dataIdMap.get(xt.dataId).id;let vt=Nt,St=xt;const{transposed:_t,axes:en,originalAxes:Kt,inputWasTransposed:Ze}=N(xt,Ae,me);let Lt=en;if(Ze){const $n=me.dataIdMap.get(_t.dataId).id;$n!==Nt&&(St=_t,vt=$n,Lt=a.backend_util.getInnerMostAxes(Lt.length,St.shape.length))}a.backend_util.assertAxesAreInnerMostDims("sum",Lt,St.shape.length);const[Jt,un]=a.backend_util.computeOutAndReduceShapes(St.shape,Lt),In=a.util.sizeFromShape(un),Xt=me.makeOutput(Jt,St.dtype);if(a.util.sizeFromShape(St.shape)!==0){const $n=me.dataIdMap.get(Xt.dataId).id;Ku(vt,In,n[Xt.dtype],$n)}if(Ze&&me.disposeData(_t.dataId),rt){const $n=a.backend_util.expandShapeToKeepDim(Xt.shape,Kt);Xt.shape=$n}return Xt}},oo=u(a.Tan),Go=u(a.Tanh);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ar;const xo={kernelName:a.Tile,backendName:"wasm",setupFunc:function(Pe){ar=Pe.wasm.cwrap(a.Tile,null,["number","array","number","array","number","number"])},kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{x:Ae}=me,rt=He.dataIdMap.get(Ae.dataId).id,{reps:xt}=st,Nt=new Array(Ae.shape.length);for(let Kt=0;Kt<Nt.length;Kt++)Nt[Kt]=Ae.shape[Kt]*xt[Kt];const vt=new Uint8Array(new Int32Array(Ae.shape).buffer),St=new Uint8Array(new Int32Array(Nt).buffer),_t=He.makeOutput(Nt,Ae.dtype),en=He.dataIdMap.get(_t.dataId).id;return ar(rt,vt,Ae.shape.length,St,Nt.length,n[_t.dtype],en),_t}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ni;const nu={kernelName:a.TopK,backendName:"wasm",setupFunc:function(Pe){Ni=Pe.wasm.cwrap(a.TopK,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:Pe,backend:me,attrs:He})=>{const{x:st}=Pe,{k:Ae,sorted:rt}=He,xt=me.dataIdMap.get(st.dataId).id,Nt=new Uint8Array(new Int32Array(st.shape).buffer),vt=st.shape.slice();vt[vt.length-1]=Ae;const St=me.makeOutput(vt,st.dtype),_t=me.dataIdMap.get(St.dataId).id,en=me.makeOutput(vt,"int32"),Kt=me.dataIdMap.get(en.dataId).id;return Ni(xt,Nt,st.shape.length,n[st.dtype],Ae,rt,_t,Kt),[St,en]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ci;const li={kernelName:a.Transform,backendName:"wasm",setupFunc:function(Pe){ci=Pe.wasm.cwrap(a.Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(Pe){const{backend:me,inputs:He,attrs:st}=Pe,{image:Ae,transforms:rt}=He,{interpolation:xt,fillMode:Nt,fillValue:vt,outputShape:St}=st,[_t,en,Kt,Ze]=Ae.shape,[Lt,Jt]=St!=null?St:[en,Kt],un=[_t,Lt,Jt,Ze],In=new Uint8Array(new Int32Array(a.util.computeStrides(Ae.shape)).buffer),Xt=new Uint8Array(new Int32Array(a.util.computeStrides(un)).buffer),$n=me.makeOutput(un,Ae.dtype),Jn=me.dataIdMap.get($n.dataId).id,Ss=me.dataIdMap.get(Ae.dataId).id,Ms=me.dataIdMap.get(rt.dataId).id,Ps=xt==="nearest"?1:2;let Fs;switch(Nt){case"constant":default:Fs=1;break;case"reflect":Fs=2;break;case"wrap":Fs=3;break;case"nearest":Fs=4}return ci(Ss,Ms,rt.shape[0]>1,_t,Lt,Jt,Ze,Kt,en,In,Ae.shape.length-1,Xt,un.length-1,Ps,Fs,vt,Jn),$n}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Os={kernelName:a.Unpack,backendName:"wasm",kernelFunc:function(Pe){const{inputs:me,backend:He,attrs:st}=Pe,{value:Ae}=me;let{axis:rt}=st;rt<0&&(rt+=Ae.shape.length);const xt=Ae.shape[rt],Nt=Ae.shape.length,vt=new Array(Nt-1);let St=0;for(let Ze=0;Ze<Nt;Ze++)Ze!==rt&&(vt[St++]=Ae.shape[Ze]);const _t=new Array(xt),en=new Array(Nt).fill(0),Kt=Ae.shape.slice();Kt[rt]=1;for(let Ze=0;Ze<_t.length;Ze++)en[rt]=Ze,_t[Ze]=wt({inputs:{x:Ae},attrs:{begin:en,size:Kt},backend:He});return _t.map(({dataId:Ze,dtype:Lt})=>({dataId:Ze,dtype:Lt,shape:vt}))}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ei={kernelName:a.ZerosLike,backendName:"wasm",kernelFunc:function(Pe){const{inputs:{x:me},backend:He}=Pe,st=He.makeOutput(me.shape,me.dtype);return He.typedArrayFromHeap(st).fill(0),st}},Ia=[i,c,h,p,D,L,V,oe,Ee,Gt,dn,mn,ee,we,bt,$e,ht,Pt,Dn,be,Un,Gs,xs,ds,Ys,pn,ts,Ns,Vs,Us,jt,de,Ct,on,bn,Mn,wn,gs,x,xr,Ir,qs,ta,pa,rr,eo,Qs,$r,ia,Cr,za,Wo,si,Ta,mo,Ar,Vo,so,Kr,Ra,na,$o,We,Ut,sn,fn,hs,Es,dr,Js,ga,ge,Or,Wa,Qi,ri,$u,go,Ua,Ji,ja,To,at,Tu,oi,Nu,Lr,No,$i,Ti,ii,bs,jn,Gn,Vr,ua,tu,ui,jo,Ur,oo,Go,xo,nu,li,I,Os,Ei];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const Pe of Ia)Object(a.registerKernel)(Pe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const su=Object(a.env)();su.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))),su.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(su.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var Ri=t(93),Ai=t.n(Ri),ru=t(100),Oi=t(94),Eo=t.n(Oi);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=Ai.a||Ri,Cc=Eo.a||Oi;class Di extends a.KernelBackend{constructor(me){super(),this.wasm=me,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount($c),Yu=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new a.DataStorage(this,Object(a.engine)())}write(me,He,st){const Ae={id:this.dataIdNextNumber++};return this.move(Ae,me,He,st,1),Ae}numDataIds(){return this.dataIdMap.numDataIds()}async time(me){const He=a.util.now();return me(),{kernelMs:a.util.now()-He}}move(me,He,st,Ae,rt){const xt=this.dataIdNextNumber++;if(Ae==="string"){const _t=He;return void this.dataIdMap.set(me,{id:xt,stringBytes:_t,shape:st,dtype:Ae,memoryOffset:null,refCount:rt})}const Nt=a.util.sizeFromShape(st),vt=Nt*a.util.bytesPerElement(Ae),St=this.wasm._malloc(vt);this.dataIdMap.set(me,{id:xt,memoryOffset:St,shape:st,dtype:Ae,refCount:rt}),this.wasm.tfjs.registerTensor(xt,Nt,St),He!=null&&this.wasm.HEAPU8.set(new Uint8Array(He.buffer,He.byteOffset,vt),St)}async read(me){return this.readSync(me)}readSync(me,He,st){const{memoryOffset:Ae,dtype:rt,shape:xt,stringBytes:Nt}=this.dataIdMap.get(me);if(rt==="string")return He!=null&&He!==0||!(st==null||st>=Nt.length)?Nt.slice(He,st):Nt;He=He||0,st=st||a.util.sizeFromShape(xt);const vt=a.util.bytesPerElement(rt);return function(St,_t){switch(_t){case"float32":return new Float32Array(St);case"int32":return new Int32Array(St);case"bool":return new Uint8Array(St);default:throw new Error(`Unknown dtype ${_t}`)}}(this.wasm.HEAPU8.slice(Ae+He*vt,Ae+st*vt).buffer,rt)}disposeData(me,He=!1){if(this.dataIdMap.has(me)){const st=this.dataIdMap.get(me);if(st.refCount--,!He&&st.refCount>0)return!1;this.wasm._free(st.memoryOffset),this.wasm.tfjs.disposeData(st.id),this.dataIdMap.delete(me)}return!0}refCount(me){return this.dataIdMap.has(me)?this.dataIdMap.get(me).refCount:0}incRef(me){const He=this.dataIdMap.get(me);He!=null&&He.refCount++}floatPrecision(){return 32}getMemoryOffset(me){return this.dataIdMap.get(me).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(me,He,st){let Ae;if(st==null)Ae=this.write(null,me,He);else{const rt=this.dataIdNextNumber++;Ae={id:rt},this.dataIdMap.set(Ae,{id:rt,memoryOffset:st,shape:me,dtype:He,refCount:1});const xt=a.util.sizeFromShape(me);this.wasm.tfjs.registerTensor(rt,xt,st)}return{dataId:Ae,shape:me,dtype:He}}typedArrayFromHeap({shape:me,dtype:He,dataId:st}){const Ae=this.wasm.HEAPU8.buffer,{memoryOffset:rt}=this.dataIdMap.get(st),xt=a.util.sizeFromShape(me);switch(He){case"float32":return new Float32Array(Ae,rt,xt);case"int32":return new Int32Array(Ae,rt,xt);case"bool":return new Uint8Array(Ae,rt,xt);default:throw new Error(`Unknown dtype ${He}`)}}}function Ro(Pe,me,He){let st="tfjs-backend-wasm.wasm";return Pe&&me?st="tfjs-backend-wasm-threaded-simd.wasm":Pe&&(st="tfjs-backend-wasm-simd.wasm"),Pi!=null&&Pi[st]!=null?Pi[st]:He+st}async function au(){const[Pe,me]=await Promise.all([Object(a.env)().getAsync("WASM_HAS_SIMD_SUPPORT"),Object(a.env)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((He,st)=>{const Ae={};var rt;Ae.locateFile=(vt,St)=>{if(vt.endsWith(".worker.js")){const _t=ru.wasmWorkerContents.replace(/\n/g,"\\n"),en=new Blob([_t],{type:"application/javascript"});return URL.createObjectURL(en)}return vt.endsWith(".wasm")?Ro(Pe,me,di!=null?di:St):St+vt},Xu&&(Ae.instantiateWasm=(rt=Ro(Pe,me,di!=null?di:""),(vt,St)=>(a.util.fetch(rt,{credentials:"same-origin"}).then(_t=>{_t.ok||vt.env.a(`failed to load wasm binary file at '${rt}'`),_t.arrayBuffer().then(en=>{WebAssembly.instantiate(en,vt).then(Kt=>{St(Kt.instance,Kt.module)})})}),{})));let xt,Nt=!1;Ae.onAbort=()=>{Nt||ou||(ou=!0,st({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},me&&Pe&&_c==null?(Ae.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Fi.toString()],{type:"text/javascript"}),xt=Fi(Ae)):xt=Cc(Ae),xt.then(vt=>{Nt=!0,ou=!1,vt.tfjs={init:vt.cwrap("init",null,[]),initWithThreadsCount:vt.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:vt.cwrap("get_threads_count","number",[]),registerTensor:vt.cwrap("register_tensor",null,["number","number","number"]),disposeData:vt.cwrap("dispose_data",null,["number"]),dispose:vt.cwrap("dispose",null,[])},He({wasm:vt})}).catch(st)})}const Mi=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let _c=null,di=null,Pi={},ou=!1,Xu=!1;function Sc(Pe,me=!1){if(ou)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof Pe=="string")di=Pe;else{Pi=Pe;const He=Mi.filter(st=>Pi[st]==null);if(He.length>0)throw new Error(`There were no entries found for the following binaries: ${He.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Xu=me}let $c=-1,Yu=-1;Object(a.registerBackend)("wasm",async()=>{const{wasm:Pe}=await au();return new Di(Pe)},2)},function(s,e,t){t.d(e,"a",function(){return a});var n=t(37),r=t(5);class a{constructor(){}async createContext(i={}){return new Promise((u,c)=>{let d;try{d=new n.a(i)}catch(h){c(h)}u(d)})}createContextSync(i={}){return r.a(typeof window=="undefined"&&typeof importScripts=="function","createContextSync() should only be allowed in dedicated worker."),new n.a(i)}}},function(s,e){s.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function n(P,oe,ne){this.low=0|P,this.high=0|oe,this.unsigned=!!ne}function r(P){return(P&&P.__isLong__)===!0}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},o={};function i(P,oe){var ne,ge,ye;return oe?(ye=0<=(P>>>=0)&&P<256)&&(ge=o[P])?ge:(ne=c(P,(0|P)<0?-1:0,!0),ye&&(o[P]=ne),ne):(ye=-128<=(P|=0)&&P<128)&&(ge=a[P])?ge:(ne=c(P,P<0?-1:0,!1),ye&&(a[P]=ne),ne)}function u(P,oe){if(isNaN(P))return oe?I:m;if(oe){if(P<0)return I;if(P>=f)return L}else{if(P<=-x)return Y;if(P+1>=x)return U}return P<0?u(-P,oe).neg():c(P%p|0,P/p|0,oe)}function c(P,oe,ne){return new n(P,oe,ne)}n.fromInt=i,n.fromNumber=u,n.fromBits=c;var d=Math.pow;function h(P,oe,ne){if(P.length===0)throw Error("empty string");if(P==="NaN"||P==="Infinity"||P==="+Infinity"||P==="-Infinity")return m;if(typeof oe=="number"?(ne=oe,oe=!1):oe=!!oe,(ne=ne||10)<2||36<ne)throw RangeError("radix");var ge;if((ge=P.indexOf("-"))>0)throw Error("interior hyphen");if(ge===0)return h(P.substring(1),oe,ne).neg();for(var ye=u(d(ne,8)),Ee=m,X=0;X<P.length;X+=8){var je=Math.min(8,P.length-X),Be=parseInt(P.substring(X,X+je),ne);if(je<8){var tt=u(d(ne,je));Ee=Ee.mul(tt).add(u(Be))}else Ee=(Ee=Ee.mul(ye)).add(u(Be))}return Ee.unsigned=oe,Ee}function l(P,oe){return typeof P=="number"?u(P,oe):typeof P=="string"?h(P,oe):c(P.low,P.high,typeof oe=="boolean"?oe:P.unsigned)}n.fromString=h,n.fromValue=l;var p=4294967296,f=p*p,x=f/2,b=i(1<<24),m=i(0);n.ZERO=m;var I=i(0,!0);n.UZERO=I;var N=i(1);n.ONE=N;var E=i(1,!0);n.UONE=E;var D=i(-1);n.NEG_ONE=D;var U=c(-1,2147483647,!1);n.MAX_VALUE=U;var L=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=L;var Y=c(0,-2147483648,!1);n.MIN_VALUE=Y;var V=n.prototype;V.toInt=function(){return this.unsigned?this.low>>>0:this.low},V.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},V.toString=function(P){if((P=P||10)<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Y)){var oe=u(P),ne=this.div(oe),ge=ne.mul(oe).sub(this);return ne.toString(P)+ge.toInt().toString(P)}return"-"+this.neg().toString(P)}for(var ye=u(d(P,6),this.unsigned),Ee=this,X="";;){var je=Ee.div(ye),Be=(Ee.sub(je.mul(ye)).toInt()>>>0).toString(P);if((Ee=je).isZero())return Be+X;for(;Be.length<6;)Be="0"+Be;X=""+Be+X}},V.getHighBits=function(){return this.high},V.getHighBitsUnsigned=function(){return this.high>>>0},V.getLowBits=function(){return this.low},V.getLowBitsUnsigned=function(){return this.low>>>0},V.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Y)?64:this.neg().getNumBitsAbs();for(var P=this.high!=0?this.high:this.low,oe=31;oe>0&&(P&1<<oe)==0;oe--);return this.high!=0?oe+33:oe+1},V.isZero=function(){return this.high===0&&this.low===0},V.eqz=V.isZero,V.isNegative=function(){return!this.unsigned&&this.high<0},V.isPositive=function(){return this.unsigned||this.high>=0},V.isOdd=function(){return(1&this.low)==1},V.isEven=function(){return(1&this.low)==0},V.equals=function(P){return r(P)||(P=l(P)),(this.unsigned===P.unsigned||this.high>>>31!=1||P.high>>>31!=1)&&this.high===P.high&&this.low===P.low},V.eq=V.equals,V.notEquals=function(P){return!this.eq(P)},V.neq=V.notEquals,V.ne=V.notEquals,V.lessThan=function(P){return this.comp(P)<0},V.lt=V.lessThan,V.lessThanOrEqual=function(P){return this.comp(P)<=0},V.lte=V.lessThanOrEqual,V.le=V.lessThanOrEqual,V.greaterThan=function(P){return this.comp(P)>0},V.gt=V.greaterThan,V.greaterThanOrEqual=function(P){return this.comp(P)>=0},V.gte=V.greaterThanOrEqual,V.ge=V.greaterThanOrEqual,V.compare=function(P){if(r(P)||(P=l(P)),this.eq(P))return 0;var oe=this.isNegative(),ne=P.isNegative();return oe&&!ne?-1:!oe&&ne?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},V.comp=V.compare,V.negate=function(){return!this.unsigned&&this.eq(Y)?Y:this.not().add(N)},V.neg=V.negate,V.add=function(P){r(P)||(P=l(P));var oe=this.high>>>16,ne=65535&this.high,ge=this.low>>>16,ye=65535&this.low,Ee=P.high>>>16,X=65535&P.high,je=P.low>>>16,Be=0,tt=0,ct=0,Me=0;return ct+=(Me+=ye+(65535&P.low))>>>16,tt+=(ct+=ge+je)>>>16,Be+=(tt+=ne+X)>>>16,Be+=oe+Ee,c((ct&=65535)<<16|(Me&=65535),(Be&=65535)<<16|(tt&=65535),this.unsigned)},V.subtract=function(P){return r(P)||(P=l(P)),this.add(P.neg())},V.sub=V.subtract,V.multiply=function(P){if(this.isZero())return m;if(r(P)||(P=l(P)),t)return c(t.mul(this.low,this.high,P.low,P.high),t.get_high(),this.unsigned);if(P.isZero())return m;if(this.eq(Y))return P.isOdd()?Y:m;if(P.eq(Y))return this.isOdd()?Y:m;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(b)&&P.lt(b))return u(this.toNumber()*P.toNumber(),this.unsigned);var oe=this.high>>>16,ne=65535&this.high,ge=this.low>>>16,ye=65535&this.low,Ee=P.high>>>16,X=65535&P.high,je=P.low>>>16,Be=65535&P.low,tt=0,ct=0,Me=0,wt=0;return Me+=(wt+=ye*Be)>>>16,ct+=(Me+=ge*Be)>>>16,Me&=65535,ct+=(Me+=ye*je)>>>16,tt+=(ct+=ne*Be)>>>16,ct&=65535,tt+=(ct+=ge*je)>>>16,ct&=65535,tt+=(ct+=ye*X)>>>16,tt+=oe*Be+ne*je+ge*X+ye*Ee,c((Me&=65535)<<16|(wt&=65535),(tt&=65535)<<16|(ct&=65535),this.unsigned)},V.mul=V.multiply,V.divide=function(P){if(r(P)||(P=l(P)),P.isZero())throw Error("division by zero");var oe,ne,ge;if(t)return this.unsigned||this.high!==-2147483648||P.low!==-1||P.high!==-1?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,P.low,P.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?I:m;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return I;if(P.gt(this.shru(1)))return E;ge=I}else{if(this.eq(Y))return P.eq(N)||P.eq(D)?Y:P.eq(Y)?N:(oe=this.shr(1).div(P).shl(1)).eq(m)?P.isNegative()?N:D:(ne=this.sub(P.mul(oe)),ge=oe.add(ne.div(P)));if(P.eq(Y))return this.unsigned?I:m;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();ge=m}for(ne=this;ne.gte(P);){oe=Math.max(1,Math.floor(ne.toNumber()/P.toNumber()));for(var ye=Math.ceil(Math.log(oe)/Math.LN2),Ee=ye<=48?1:d(2,ye-48),X=u(oe),je=X.mul(P);je.isNegative()||je.gt(ne);)je=(X=u(oe-=Ee,this.unsigned)).mul(P);X.isZero()&&(X=N),ge=ge.add(X),ne=ne.sub(je)}return ge},V.div=V.divide,V.modulo=function(P){return r(P)||(P=l(P)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,P.low,P.high),t.get_high(),this.unsigned):this.sub(this.div(P).mul(P))},V.mod=V.modulo,V.rem=V.modulo,V.not=function(){return c(~this.low,~this.high,this.unsigned)},V.and=function(P){return r(P)||(P=l(P)),c(this.low&P.low,this.high&P.high,this.unsigned)},V.or=function(P){return r(P)||(P=l(P)),c(this.low|P.low,this.high|P.high,this.unsigned)},V.xor=function(P){return r(P)||(P=l(P)),c(this.low^P.low,this.high^P.high,this.unsigned)},V.shiftLeft=function(P){return r(P)&&(P=P.toInt()),(P&=63)==0?this:P<32?c(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):c(0,this.low<<P-32,this.unsigned)},V.shl=V.shiftLeft,V.shiftRight=function(P){return r(P)&&(P=P.toInt()),(P&=63)==0?this:P<32?c(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):c(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},V.shr=V.shiftRight,V.shiftRightUnsigned=function(P){if(r(P)&&(P=P.toInt()),(P&=63)===0)return this;var oe=this.high;return P<32?c(this.low>>>P|oe<<32-P,oe>>>P,this.unsigned):c(P===32?oe:oe>>>P-32,0,this.unsigned)},V.shru=V.shiftRightUnsigned,V.shr_u=V.shiftRightUnsigned,V.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},V.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},V.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},V.toBytesLE=function(){var P=this.high,oe=this.low;return[255&oe,oe>>>8&255,oe>>>16&255,oe>>>24,255&P,P>>>8&255,P>>>16&255,P>>>24]},V.toBytesBE=function(){var P=this.high,oe=this.low;return[P>>>24,P>>>16&255,P>>>8&255,255&P,oe>>>24,oe>>>16&255,oe>>>8&255,255&oe]},n.fromBytes=function(P,oe,ne){return ne?n.fromBytesLE(P,oe):n.fromBytesBE(P,oe)},n.fromBytesLE=function(P,oe){return new n(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,oe)},n.fromBytesBE=function(P,oe){return new n(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],oe)}},function(s,e,t){(function(n,r,a,o){var i,u=(i=(i=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0)||n,function(c){function d(){return wt.buffer!=se&&xn(wt.buffer),we}function h(){return wt.buffer!=se&&xn(wt.buffer),pt}function l(){return wt.buffer!=se&&xn(wt.buffer),bt}function p(){return wt.buffer!=se&&xn(wt.buffer),At}var f,x,b,m=typeof(c=c||{})!="undefined"?c:{};m.ready=new Promise(function(We,It){f=We,x=It}),typeof r!="undefined"&&r.listeners&&(b={uncaughtException:r.listeners("uncaughtException"),unhandledRejection:r.listeners("unhandledRejection")});var I,N,E,D,U,L,Y=Object.assign({},m),V=(We,It)=>{throw It},P=typeof window=="object",oe=typeof importScripts=="function",ne=typeof r=="object"&&typeof r.versions=="object"&&typeof r.versions.node=="string",ge=m.ENVIRONMENT_IS_PTHREAD||!1,ye="";function Ee(We){return m.locateFile?m.locateFile(We,ye):ye+We}if(ne){let We;ye=oe?t(54).dirname(ye)+"/":a+"/",L=()=>{U||(D=t(96),U=t(54))},I=function(It,Ut){return L(),It=U.normalize(It),D.readFileSync(It,Ut?void 0:"utf8")},E=It=>{var Ut=I(It,!0);return Ut.buffer||(Ut=new Uint8Array(Ut)),Ut},N=(It,Ut,sn)=>{L(),It=U.normalize(It),D.readFile(It,function(vn,fn){vn?sn(vn):Ut(fn.buffer)})},r.argv.length>1&&r.argv[1].replace(/\\/g,"/"),r.argv.slice(2),r.on("uncaughtException",function(It){if(!(It instanceof fa))throw It}),r.on("unhandledRejection",function(It){throw It}),V=(It,Ut)=>{if(Ws())throw r.exitCode=It,Ut;var sn;(sn=Ut)instanceof fa||ct("exiting due to exception: "+sn),r.exit(It)},m.inspect=function(){return"[Emscripten Module object]"};try{We=t(122)}catch(It){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),It}o.Worker=We.Worker}else(P||oe)&&(oe?ye=self.location.href:typeof document!="undefined"&&document.currentScript&&(ye=document.currentScript.src),typeof i!="undefined"&&i&&(ye=i),ye=ye.indexOf("blob:")!==0?ye.substr(0,ye.replace(/[?#].*/,"").lastIndexOf("/")+1):"",ne||(I=We=>{var It=new XMLHttpRequest;return It.open("GET",We,!1),It.send(null),It.responseText},oe&&(E=We=>{var It=new XMLHttpRequest;return It.open("GET",We,!1),It.responseType="arraybuffer",It.send(null),new Uint8Array(It.response)}),N=(We,It,Ut)=>{var sn=new XMLHttpRequest;sn.open("GET",We,!0),sn.responseType="arraybuffer",sn.onload=()=>{sn.status==200||sn.status==0&&sn.response?It(sn.response):Ut()},sn.onerror=Ut,sn.send(null)}));ne&&typeof performance=="undefined"&&(o.performance=t(123).performance);var X=console.log.bind(console),je=console.warn.bind(console);ne&&(L(),X=We=>D.writeSync(1,We+`
`),je=We=>D.writeSync(2,We+`
`));var Be,tt=m.print||X,ct=m.printErr||je;function Me(We){Me.shown||(Me.shown={}),Me.shown[We]||(Me.shown[We]=1,ct(We))}Object.assign(m,Y),Y=null,m.arguments&&m.arguments,m.thisProgram&&m.thisProgram,m.quit&&(V=m.quit),m.wasmBinary&&(Be=m.wasmBinary);var wt,at,Gt=m.noExitRuntime||!0;typeof WebAssembly!="object"&&Ys("no native wasm support detected");var Ht,dn=!1;function mn(We){return m["_"+We]}function Rn(We,It,Ut,sn,vn){var fn={string:function(ur){var Or=0;if(ur!=null&&ur!==0){var ro=1+(ur.length<<2);Ot(ur,Or=Kr(ro),ro)}return Or},array:function(ur){var Or=Kr(ur.length);return function(ro,Wa){d().set(ro,Wa)}(ur,Or),Or}},Vn=mn(We),hs=[],Es=0;if(sn)for(var dr=0;dr<sn.length;dr++){var Js=fn[Ut[dr]];Js?(Es===0&&(Es=so()),hs[dr]=Js(sn[dr])):hs[dr]=sn[dr]}var ga=Vn.apply(null,hs);return ga=function(ur){return Es!==0&&Zs(Es),function(Or){return It==="string"?Pt(Or):It==="boolean"?Boolean(Or):Or}(ur)}(ga)}function ee(We){var It=new TextDecoder(We);this.decode=Ut=>(Ut.buffer instanceof SharedArrayBuffer&&(Ut=new Uint8Array(Ut)),It.decode.call(It,Ut))}var se,we,pt,bt,At,$e=typeof TextDecoder!="undefined"?new ee("utf8"):void 0;function ht(We,It,Ut){for(var sn=It+Ut,vn=It;We[vn]&&!(vn>=sn);)++vn;if(vn-It>16&&We.subarray&&$e)return $e.decode(We.subarray(It,vn));for(var fn="";It<vn;){var Vn=We[It++];if(128&Vn){var hs=63&We[It++];if((224&Vn)!=192){var Es=63&We[It++];if((Vn=(240&Vn)==224?(15&Vn)<<12|hs<<6|Es:(7&Vn)<<18|hs<<12|Es<<6|63&We[It++])<65536)fn+=String.fromCharCode(Vn);else{var dr=Vn-65536;fn+=String.fromCharCode(55296|dr>>10,56320|1023&dr)}}else fn+=String.fromCharCode((31&Vn)<<6|hs)}else fn+=String.fromCharCode(Vn)}return fn}function Pt(We,It){return We?ht(h(),We,It):""}function Ot(We,It,Ut){return function(sn,vn,fn,Vn){if(!(Vn>0))return 0;for(var hs=fn,Es=fn+Vn-1,dr=0;dr<sn.length;++dr){var Js=sn.charCodeAt(dr);if(Js>=55296&&Js<=57343&&(Js=65536+((1023&Js)<<10)|1023&sn.charCodeAt(++dr)),Js<=127){if(fn>=Es)break;vn[fn++]=Js}else if(Js<=2047){if(fn+1>=Es)break;vn[fn++]=192|Js>>6,vn[fn++]=128|63&Js}else if(Js<=65535){if(fn+2>=Es)break;vn[fn++]=224|Js>>12,vn[fn++]=128|Js>>6&63,vn[fn++]=128|63&Js}else{if(fn+3>=Es)break;vn[fn++]=240|Js>>18,vn[fn++]=128|Js>>12&63,vn[fn++]=128|Js>>6&63,vn[fn++]=128|63&Js}}return vn[fn]=0,fn-hs}(We,h(),It,Ut)}function xn(We){se=We,m.HEAP8=we=new Int8Array(We),m.HEAP16=new Int16Array(We),m.HEAP32=bt=new Int32Array(We),m.HEAPU8=pt=new Uint8Array(We),m.HEAPU16=new Uint16Array(We),m.HEAPU32=new Uint32Array(We),m.HEAPF32=new Float32Array(We),m.HEAPF64=At=new Float64Array(We)}typeof TextDecoder!="undefined"&&new ee("utf-16le"),ge&&(se=m.buffer);var Dn,pe=m.INITIAL_MEMORY||16777216;if(ge)wt=m.wasmMemory,se=m.buffer;else if(m.wasmMemory)wt=m.wasmMemory;else if(!((wt=new WebAssembly.Memory({initial:pe/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw ct("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),ne&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");wt&&(se=wt.buffer),pe=se.byteLength,xn(se);var be=[],Qe=[],Un=[];function Ws(){return Gt||!1}function Gs(){ge||Ns(Qe)}var As,xs=0,ds=null;function Ys(We){ge?postMessage({cmd:"onAbort",arg:We}):m.onAbort&&m.onAbort(We),ct(We="Aborted("+We+")"),dn=!0,Ht=1,We+=". Build with -s ASSERTIONS=1 for more info.";var It=new WebAssembly.RuntimeError(We);throw x(It),It}function pn(We){return We.startsWith("data:application/octet-stream;base64,")}function Nn(We){return We.startsWith("file://")}function ts(We){try{if(We==As&&Be)return new Uint8Array(Be);if(E)return E(We);throw"both async and sync fetching of the wasm failed"}catch(It){Ys(It)}}m.preloadedImages={},m.preloadedAudios={},pn(As="tfjs-backend-wasm-threaded-simd.wasm")||(As=Ee(As));var $s={};function Ns(We){for(;We.length>0;){var It=We.shift();if(typeof It!="function"){var Ut=It.func;typeof Ut=="number"?It.arg===void 0?Ct(Ut)():Ct(Ut)(It.arg):Ut(It.arg===void 0?null:It.arg)}else It(m)}}function ys(We){var It=so(),Ut=We();return Zs(It),Ut}function Vs(We){var It=jt.pthreads[We];if(It){l()[We>>2]=0;var Ut=It.worker;jt.returnWorkerToPool(Ut)}}function Us(We){(function(It,Ut){if(Ht=It,!Ut&&ge)throw re(It),"unwind";var sn;Ws()||ge||jt.terminateAllThreads(),Ht=sn=It,Ws()||(jt.terminateAllThreads(),m.onExit&&m.onExit(sn),dn=!0),V(sn,new fa(sn))})(We)}var jt={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){ge?jt.initWorker():jt.initMainThread()},initMainThread:function(){for(var We=0;We<8;++We)jt.allocateUnusedWorker()},initWorker:function(){Gt=!1},pthreads:{},setExitStatus:function(We){Ht=We},terminateAllThreads:function(){for(var We in jt.pthreads){var It=jt.pthreads[We];It&&It.worker&&jt.returnWorkerToPool(It.worker)}for(var Ut=0;Ut<jt.unusedWorkers.length;++Ut)jt.unusedWorkers[Ut].terminate();jt.unusedWorkers=[]},returnWorkerToPool:function(We){jt.runWithoutMainThreadQueuedCalls(function(){delete jt.pthreads[We.pthread.threadInfoStruct],jt.unusedWorkers.push(We),jt.runningWorkers.splice(jt.runningWorkers.indexOf(We),1),Vo(We.pthread.threadInfoStruct),We.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(We){l()[Ra>>2]=0;try{We()}finally{l()[Ra>>2]=1}},receiveObjectTransfer:function(We){},threadInit:function(){for(var We in jt.tlsInitFunctions)jt.tlsInitFunctions[We]()},loadWasmModuleToWorker:function(We,It){We.onmessage=Ut=>{var sn,vn=Ut.data,fn=vn.cmd;if(We.pthread&&(jt.currentProxiedOperationCallerThread=We.pthread.threadInfoStruct),vn.targetThread&&vn.targetThread!=no()){var Vn=jt.pthreads[vn.targetThread];return Vn?Vn.worker.postMessage(vn,vn.transferList):ct('Internal error! Worker sent a message "'+fn+'" to target pthread '+vn.targetThread+", but that thread no longer exists!"),void(jt.currentProxiedOperationCallerThread=void 0)}fn==="processQueuedMainThreadWork"?Ta():fn==="spawnThread"?on(vn):fn==="cleanupThread"?Vs(vn.thread):fn==="killThread"?function(hs){l()[hs>>2]=0;var Es=jt.pthreads[hs];delete jt.pthreads[hs],Es.worker.terminate(),Vo(hs),jt.runningWorkers.splice(jt.runningWorkers.indexOf(Es.worker),1),Es.worker.pthread=void 0}(vn.thread):fn==="cancelThread"?(sn=vn.thread,jt.pthreads[sn].worker.postMessage({cmd:"cancel"})):fn==="loaded"?(We.loaded=!0,It&&It(We),We.runPthread&&(We.runPthread(),delete We.runPthread)):fn==="print"?tt("Thread "+vn.threadId+": "+vn.text):fn==="printErr"?ct("Thread "+vn.threadId+": "+vn.text):fn==="alert"?alert("Thread "+vn.threadId+": "+vn.text):vn.target==="setimmediate"?We.postMessage(vn):fn==="onAbort"?m.onAbort&&m.onAbort(vn.arg):ct("worker sent an unknown command "+fn),jt.currentProxiedOperationCallerThread=void 0},We.onerror=Ut=>{throw ct("worker sent an error! "+Ut.filename+":"+Ut.lineno+": "+Ut.message),Ut},ne&&(We.on("message",function(Ut){We.onmessage({data:Ut})}),We.on("error",function(Ut){We.onerror(Ut)}),We.on("detachedExit",function(){})),We.postMessage({cmd:"load",urlOrBlob:m.mainScriptUrlOrBlob||i,wasmMemory:wt,wasmModule:at})},allocateUnusedWorker:function(){var We=Ee("tfjs-backend-wasm-threaded-simd.worker.js");jt.unusedWorkers.push(new Worker(We))},getNewWorker:function(){return jt.unusedWorkers.length==0&&(jt.allocateUnusedWorker(),jt.loadWasmModuleToWorker(jt.unusedWorkers[0])),jt.unusedWorkers.pop()}};function re(We){if(ge)return bn(1,0,We);try{Us(We)}catch(It){(function(Ut){if(Ut instanceof fa||Ut=="unwind")return Ht;V(1,Ut)})(It)}}m.establishStackSpace=function(){var We=no(),It=l()[We+44>>2],Ut=l()[We+48>>2];So(It,It-Ut),Zs(It)};var de,ot=[];function Ct(We){var It=ot[We];return It||(We>=ot.length&&(ot.length=We+1),ot[We]=It=Dn.get(We)),It}function Yt(We,It){var Ut,sn;if(We===0)Ut=Date.now();else{if(We!==1&&We!==4)return sn=28,l()[fo()>>2]=sn,-1;Ut=de()}return l()[It>>2]=Ut/1e3|0,l()[It+4>>2]=Ut%1e3*1e3*1e3|0,0}function on(We){var It=jt.getNewWorker();if(!It)return 6;jt.runningWorkers.push(It);var Ut=jt.pthreads[We.pthread_ptr]={worker:It,threadInfoStruct:We.pthread_ptr};It.pthread=Ut;var sn={cmd:"run",start_routine:We.startRoutine,arg:We.arg,threadInfoStruct:We.pthread_ptr};return It.runPthread=()=>{sn.time=performance.now(),It.postMessage(sn,We.transferList)},It.loaded&&(It.runPthread(),delete It.runPthread),0}function tn(){return 2147483648}function bn(We,It){var Ut=arguments.length-2,sn=arguments;return ys(function(){for(var vn=Ut,fn=Kr(8*vn),Vn=fn>>3,hs=0;hs<Ut;hs++){var Es=sn[2+hs];p()[Vn+hs]=Es}return Na(We,vn,fn,It)})}m.invokeEntryPoint=function(We,It){return Ct(We)(It)},de=ne?()=>{var We=r.hrtime();return 1e3*We[0]+We[1]/1e6}:ge?()=>performance.now()-m.__performance_now_clock_drift:()=>performance.now();var On=[];function Mn(We){try{return wt.grow(We-se.byteLength+65535>>>16),xn(wt.buffer),1}catch{}}var wn={inEventHandler:0,removeAllEventListeners:function(){for(var We=wn.eventHandlers.length-1;We>=0;--We)wn._removeHandler(We);wn.eventHandlers=[],wn.deferredCalls=[]},registerRemoveEventListeners:function(){wn.removeEventListenersRegistered||(wn.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(We,It,Ut){function sn(Vn,hs){if(Vn.length!=hs.length)return!1;for(var Es in Vn)if(Vn[Es]!=hs[Es])return!1;return!0}for(var vn in wn.deferredCalls){var fn=wn.deferredCalls[vn];if(fn.targetFunction==We&&sn(fn.argsList,Ut))return}wn.deferredCalls.push({targetFunction:We,precedence:It,argsList:Ut}),wn.deferredCalls.sort(function(Vn,hs){return Vn.precedence<hs.precedence})},removeDeferredCalls:function(We){for(var It=0;It<wn.deferredCalls.length;++It)wn.deferredCalls[It].targetFunction==We&&(wn.deferredCalls.splice(It,1),--It)},canPerformEventHandlerRequests:function(){return wn.inEventHandler&&wn.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(wn.canPerformEventHandlerRequests())for(var We=0;We<wn.deferredCalls.length;++We){var It=wn.deferredCalls[We];wn.deferredCalls.splice(We,1),--We,It.targetFunction.apply(null,It.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(We,It){for(var Ut=0;Ut<wn.eventHandlers.length;++Ut)wn.eventHandlers[Ut].target!=We||It&&It!=wn.eventHandlers[Ut].eventTypeString||wn._removeHandler(Ut--)},_removeHandler:function(We){var It=wn.eventHandlers[We];It.target.removeEventListener(It.eventTypeString,It.eventListenerFunc,It.useCapture),wn.eventHandlers.splice(We,1)},registerOrRemoveHandler:function(We){var It=function(sn){++wn.inEventHandler,wn.currentEventHandler=We,wn.runDeferredCalls(),We.handlerFunc(sn),wn.runDeferredCalls(),--wn.inEventHandler};if(We.callbackfunc)We.eventListenerFunc=It,We.target.addEventListener(We.eventTypeString,It,We.useCapture),wn.eventHandlers.push(We),wn.registerRemoveEventListeners();else for(var Ut=0;Ut<wn.eventHandlers.length;++Ut)wn.eventHandlers[Ut].target==We.target&&wn.eventHandlers[Ut].eventTypeString==We.eventTypeString&&wn._removeHandler(Ut--)},queueEventHandlerOnThread_iiii:function(We,It,Ut,sn,vn){ys(function(){var fn=Kr(12);l()[fn>>2]=Ut,l()[fn+4>>2]=sn,l()[fn+8>>2]=vn,Ea(We,637534208,It,sn,fn)})},getTargetThreadForEventCallback:function(We){switch(We){case 1:return 0;case 2:return jt.currentProxiedOperationCallerThread;default:return We}},getNodeNameForTarget:function(We){return We?We==window?"#window":We==screen?"#screen":We&&We.nodeName?We.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function gs(We,It,Ut,sn){ys(function(){var vn,fn,Vn,hs=Kr(12),Es=0;It&&(fn=function(dr){for(var Js=0,ga=0;ga<dr.length;++ga){var ur=dr.charCodeAt(ga);ur>=55296&&ur<=57343&&(ur=65536+((1023&ur)<<10)|1023&dr.charCodeAt(++ga)),ur<=127?++Js:Js+=ur<=2047?2:ur<=65535?3:4}return Js}(vn=It)+1,Vn=Wo(fn),Ot(vn,Vn,fn),Es=Vn),l()[hs>>2]=Es,l()[hs+4>>2]=Ut,l()[hs+8>>2]=sn,Ea(We,657457152,0,Es,hs)})}var Hs=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function xr(We){var It;return We=(It=We)>2?Pt(It):It,Hs[We]||(typeof document!="undefined"?document.querySelector(We):void 0)}function Ir(We){return xr(We)}function qs(We,It,Ut){var sn=Ir(We);if(!sn)return-4;if(sn.canvasSharedPtr&&(l()[sn.canvasSharedPtr>>2]=It,l()[sn.canvasSharedPtr+4>>2]=Ut),!sn.offscreenCanvas&&sn.controlTransferredOffscreen)return sn.canvasSharedPtr?(function(Vn,hs,Es,dr){gs(Vn,hs=hs?Pt(hs):"",Es,dr)}(l()[sn.canvasSharedPtr+8>>2],We,It,Ut),1):-4;sn.offscreenCanvas&&(sn=sn.offscreenCanvas);var vn=!1;if(sn.GLctxObject&&sn.GLctxObject.GLctx){var fn=sn.GLctxObject.GLctx.getParameter(2978);vn=fn[0]===0&&fn[1]===0&&fn[2]===sn.width&&fn[3]===sn.height}return sn.width=It,sn.height=Ut,vn&&sn.GLctxObject.GLctx.viewport(0,0,It,Ut),0}function ta(We,It,Ut){return ge?bn(2,1,We,It,Ut):qs(We,It,Ut)}var pa,rr={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(We){rr.lastError||(rr.lastError=We)},getNewId:function(We){for(var It=rr.counter++,Ut=We.length;Ut<It;Ut++)We[Ut]=null;return It},getSource:function(We,It,Ut,sn){for(var vn="",fn=0;fn<It;++fn){var Vn=sn?l()[sn+4*fn>>2]:-1;vn+=Pt(l()[Ut+4*fn>>2],Vn<0?void 0:Vn)}return vn},createContext:function(We,It){We.getContextSafariWebGL2Fixed||(We.getContextSafariWebGL2Fixed=We.getContext,We.getContext=function(sn,vn){var fn=We.getContextSafariWebGL2Fixed(sn,vn);return sn=="webgl"==fn instanceof WebGLRenderingContext?fn:null});var Ut=We.getContext("webgl",It);return Ut?rr.registerContext(Ut,It):0},registerContext:function(We,It){var Ut=Wo(8);l()[Ut+4>>2]=no();var sn={handle:Ut,attributes:It,version:It.majorVersion,GLctx:We};return We.canvas&&(We.canvas.GLctxObject=sn),rr.contexts[Ut]=sn,(typeof It.enableExtensionsByDefault=="undefined"||It.enableExtensionsByDefault)&&rr.initExtensions(sn),Ut},makeContextCurrent:function(We){return rr.currentContext=rr.contexts[We],m.ctx=pa=rr.currentContext&&rr.currentContext.GLctx,!(We&&!pa)},getContext:function(We){return rr.contexts[We]},deleteContext:function(We){rr.currentContext===rr.contexts[We]&&(rr.currentContext=null),typeof wn=="object"&&wn.removeAllHandlersOnTarget(rr.contexts[We].GLctx.canvas),rr.contexts[We]&&rr.contexts[We].GLctx.canvas&&(rr.contexts[We].GLctx.canvas.GLctxObject=void 0),si(rr.contexts[We].handle),rr.contexts[We]=null},initExtensions:function(We){if(We||(We=rr.currentContext),!We.initExtensionsDone){We.initExtensionsDone=!0;var It,Ut=We.GLctx;(function(sn){var vn=sn.getExtension("ANGLE_instanced_arrays");vn&&(sn.vertexAttribDivisor=function(fn,Vn){vn.vertexAttribDivisorANGLE(fn,Vn)},sn.drawArraysInstanced=function(fn,Vn,hs,Es){vn.drawArraysInstancedANGLE(fn,Vn,hs,Es)},sn.drawElementsInstanced=function(fn,Vn,hs,Es,dr){vn.drawElementsInstancedANGLE(fn,Vn,hs,Es,dr)})})(Ut),function(sn){var vn=sn.getExtension("OES_vertex_array_object");vn&&(sn.createVertexArray=function(){return vn.createVertexArrayOES()},sn.deleteVertexArray=function(fn){vn.deleteVertexArrayOES(fn)},sn.bindVertexArray=function(fn){vn.bindVertexArrayOES(fn)},sn.isVertexArray=function(fn){return vn.isVertexArrayOES(fn)})}(Ut),function(sn){var vn=sn.getExtension("WEBGL_draw_buffers");vn&&(sn.drawBuffers=function(fn,Vn){vn.drawBuffersWEBGL(fn,Vn)})}(Ut),Ut.disjointTimerQueryExt=Ut.getExtension("EXT_disjoint_timer_query"),(It=Ut).multiDrawWebgl=It.getExtension("WEBGL_multi_draw"),(Ut.getSupportedExtensions()||[]).forEach(function(sn){sn.includes("lose_context")||sn.includes("debug")||Ut.getExtension(sn)})}}},eo=["default","low-power","high-performance"],Qs={mappings:{},buffers:[null,[],[]],printChar:function(We,It){var Ut=Qs.buffers[We];It===0||It===10?((We===1?tt:ct)(ht(Ut,0)),Ut.length=0):Ut.push(It)},varargs:void 0,get:function(){return Qs.varargs+=4,l()[Qs.varargs-4>>2]},getStr:function(We){return Pt(We)},get64:function(We,It){return We}};function mr(We){return ge?bn(3,1,We):0}function $r(We,It,Ut,sn,vn){if(ge)return bn(4,1,We,It,Ut,sn,vn)}function ia(We,It,Ut,sn){if(ge)return bn(5,1,We,It,Ut,sn);for(var vn=0,fn=0;fn<Ut;fn++){var Vn=l()[It>>2],hs=l()[It+4>>2];It+=8;for(var Es=0;Es<hs;Es++)Qs.printChar(We,h()[Vn+Es]);vn+=hs}return l()[sn>>2]=vn,0}jt.init();var Pr,Cr,Ba,za=[null,re,ta,mr,$r,ia],to={__clock_gettime:function(We,It){return Yt(We,It)},__emscripten_init_main_thread_js:function(We){mo(We,!oe,1,!P),jt.threadInit()},__emscripten_thread_cleanup:function(We){ge?postMessage({cmd:"cleanupThread",thread:We}):Vs(We)},__pthread_create_js:function(We,It,Ut,sn){if(typeof SharedArrayBuffer=="undefined")return ct("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var vn=[];if(ge&&vn.length===0)return Ar(687865856,We,It,Ut,sn);var fn={startRoutine:Ut,pthread_ptr:We,arg:sn,transferList:vn};return ge?(fn.cmd="spawnThread",postMessage(fn,vn),0):on(fn)},_emscripten_default_pthread_stack_size:function(){return 2097152},_emscripten_notify_thread_queue:function(We,It){if(We==It)postMessage({cmd:"processQueuedMainThreadWork"});else if(ge)postMessage({targetThread:We,cmd:"processThreadQueue"});else{var Ut=jt.pthreads[We],sn=Ut&&Ut.worker;if(!sn)return;sn.postMessage({cmd:"processThreadQueue"})}return 1},abort:function(){Ys("")},emscripten_check_blocking_allowed:function(){ne||oe||Me("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_get_heap_max:tn,emscripten_get_now:de,emscripten_memcpy_big:function(We,It,Ut){h().copyWithin(We,It,It+Ut)},emscripten_num_logical_cores:function(){return ne?t(124).cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(We,It,Ut){On.length=It;for(var sn=Ut>>3,vn=0;vn<It;vn++)On[vn]=p()[sn+vn];return(We<0?$s[-We-1]:za[We]).apply(null,On)},emscripten_resize_heap:function(We){var It=h().length;if((We>>>=0)<=It)return!1;var Ut,sn,vn=2147483648;if(We>vn)return!1;for(var fn=1;fn<=4;fn*=2){var Vn=It*(1+.2/fn);if(Vn=Math.min(Vn,We+100663296),Mn(Math.min(vn,((Ut=Math.max(We,Vn))%(sn=65536)>0&&(Ut+=sn-Ut%sn),Ut))))return!0}return!1},emscripten_set_canvas_element_size:function(We,It,Ut){return Ir(We)?qs(We,It,Ut):ta(We,It,Ut)},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},emscripten_webgl_create_context:function(We,It){return Ut=We,sn=It>>2,vn=l()[sn+6],fn={alpha:!!l()[sn+0],depth:!!l()[sn+1],stencil:!!l()[sn+2],antialias:!!l()[sn+3],premultipliedAlpha:!!l()[sn+4],preserveDrawingBuffer:!!l()[sn+5],powerPreference:eo[vn],failIfMajorPerformanceCaveat:!!l()[sn+7],majorVersion:l()[sn+8],minorVersion:l()[sn+9],enableExtensionsByDefault:l()[sn+10],explicitSwapControl:l()[sn+11],proxyContextToMainThread:l()[sn+12],renderViaOffscreenBackBuffer:l()[sn+13]},(Vn=Ir(Ut))?fn.explicitSwapControl?0:rr.createContext(Vn,fn):0;var Ut,sn,vn,fn,Vn},exit:Us,fd_close:mr,fd_seek:$r,fd_write:ia,memory:wt||m.wasmMemory,setTempRet0:function(We){}},Wo=(function(){var We={env:to,wasi_snapshot_preview1:to};function It(vn,fn){var Vn,hs,Es=vn.exports;if(m.asm=Es,Vn=m.asm.emscripten_tls_init,jt.tlsInitFunctions.push(Vn),Dn=m.asm.__indirect_function_table,hs=m.asm.__wasm_call_ctors,Qe.unshift(hs),at=fn,!ge){var dr=jt.unusedWorkers.length;jt.unusedWorkers.forEach(function(Js){jt.loadWasmModuleToWorker(Js,function(){--dr||function(ga){if(xs--,m.monitorRunDependencies&&m.monitorRunDependencies(xs),xs==0&&ds){var ur=ds;ds=null,ur()}}()})})}}function Ut(vn){It(vn.instance,vn.module)}function sn(vn){return function(){if(!Be&&(P||oe)){if(typeof fetch=="function"&&!Nn(As))return fetch(As,{credentials:"same-origin"}).then(function(fn){if(!fn.ok)throw"failed to load wasm binary file at '"+As+"'";return fn.arrayBuffer()}).catch(function(){return ts(As)});if(N)return new Promise(function(fn,Vn){N(As,function(hs){fn(new Uint8Array(hs))},Vn)})}return Promise.resolve().then(function(){return ts(As)})}().then(function(fn){return WebAssembly.instantiate(fn,We)}).then(function(fn){return fn}).then(vn,function(fn){ct("failed to asynchronously prepare wasm: "+fn),Ys(fn)})}if(ge||(xs++,m.monitorRunDependencies&&m.monitorRunDependencies(xs)),m.instantiateWasm)try{return m.instantiateWasm(We,It)}catch(vn){return ct("Module.instantiateWasm callback failed with error: "+vn),!1}(Be||typeof WebAssembly.instantiateStreaming!="function"||pn(As)||Nn(As)||typeof fetch!="function"?sn(Ut):fetch(As,{credentials:"same-origin"}).then(function(vn){return WebAssembly.instantiateStreaming(vn,We).then(Ut,function(fn){return ct("wasm streaming compile failed: "+fn),ct("falling back to ArrayBuffer instantiation"),sn(Ut)})})).catch(x)}(),m.___wasm_call_ctors=function(){return(m.___wasm_call_ctors=m.asm.__wasm_call_ctors).apply(null,arguments)},m._init=function(){return(m._init=m.asm.init).apply(null,arguments)},m._init_with_threads_count=function(){return(m._init_with_threads_count=m.asm.init_with_threads_count).apply(null,arguments)},m._get_threads_count=function(){return(m._get_threads_count=m.asm.get_threads_count).apply(null,arguments)},m._register_tensor=function(){return(m._register_tensor=m.asm.register_tensor).apply(null,arguments)},m._dispose_data=function(){return(m._dispose_data=m.asm.dispose_data).apply(null,arguments)},m._dispose=function(){return(m._dispose=m.asm.dispose).apply(null,arguments)},m._Abs=function(){return(m._Abs=m.asm.Abs).apply(null,arguments)},m._Add=function(){return(m._Add=m.asm.Add).apply(null,arguments)},m._AddN=function(){return(m._AddN=m.asm.AddN).apply(null,arguments)},m._All=function(){return(m._All=m.asm.All).apply(null,arguments)},m._Any=function(){return(m._Any=m.asm.Any).apply(null,arguments)},m._ArgMax=function(){return(m._ArgMax=m.asm.ArgMax).apply(null,arguments)},m._AvgPool=function(){return(m._AvgPool=m.asm.AvgPool).apply(null,arguments)},m._BatchMatMul=function(){return(m._BatchMatMul=m.asm.BatchMatMul).apply(null,arguments)},m._Ceil=function(){return(m._Ceil=m.asm.Ceil).apply(null,arguments)},m._ClipByValue=function(){return(m._ClipByValue=m.asm.ClipByValue).apply(null,arguments)},m._Conv2D=function(){return(m._Conv2D=m.asm.Conv2D).apply(null,arguments)},m._Conv2DBackpropInput=function(){return(m._Conv2DBackpropInput=m.asm.Conv2DBackpropInput).apply(null,arguments)},m._Cos=function(){return(m._Cos=m.asm.Cos).apply(null,arguments)},m._Cosh=function(){return(m._Cosh=m.asm.Cosh).apply(null,arguments)},m._CropAndResize=function(){return(m._CropAndResize=m.asm.CropAndResize).apply(null,arguments)},m._Cumprod=function(){return(m._Cumprod=m.asm.Cumprod).apply(null,arguments)},m._Cumsum=function(){return(m._Cumsum=m.asm.Cumsum).apply(null,arguments)},m._DepthToSpace=function(){return(m._DepthToSpace=m.asm.DepthToSpace).apply(null,arguments)},m._DepthwiseConv2dNative=function(){return(m._DepthwiseConv2dNative=m.asm.DepthwiseConv2dNative).apply(null,arguments)},m._Elu=function(){return(m._Elu=m.asm.Elu).apply(null,arguments)},m._Equal=function(){return(m._Equal=m.asm.Equal).apply(null,arguments)},m._Exp=function(){return(m._Exp=m.asm.Exp).apply(null,arguments)},m._FlipLeftRight=function(){return(m._FlipLeftRight=m.asm.FlipLeftRight).apply(null,arguments)},m._Floor=function(){return(m._Floor=m.asm.Floor).apply(null,arguments)},m._FloorDiv=function(){return(m._FloorDiv=m.asm.FloorDiv).apply(null,arguments)},m._FusedBatchNorm=function(){return(m._FusedBatchNorm=m.asm.FusedBatchNorm).apply(null,arguments)},m._FusedConv2D=function(){return(m._FusedConv2D=m.asm.FusedConv2D).apply(null,arguments)},m._FusedDepthwiseConv2D=function(){return(m._FusedDepthwiseConv2D=m.asm.FusedDepthwiseConv2D).apply(null,arguments)},m._Gather=function(){return(m._Gather=m.asm.Gather).apply(null,arguments)},m._GatherNd=function(){return(m._GatherNd=m.asm.GatherNd).apply(null,arguments)},m._Greater=function(){return(m._Greater=m.asm.Greater).apply(null,arguments)},m._GreaterEqual=function(){return(m._GreaterEqual=m.asm.GreaterEqual).apply(null,arguments)},m._LeakyRelu=function(){return(m._LeakyRelu=m.asm.LeakyRelu).apply(null,arguments)},m._Less=function(){return(m._Less=m.asm.Less).apply(null,arguments)},m._LessEqual=function(){return(m._LessEqual=m.asm.LessEqual).apply(null,arguments)},m._Log=function(){return(m._Log=m.asm.Log).apply(null,arguments)},m._LogicalAnd=function(){return(m._LogicalAnd=m.asm.LogicalAnd).apply(null,arguments)},m._LogicalNot=function(){return(m._LogicalNot=m.asm.LogicalNot).apply(null,arguments)},m._LogicalOr=function(){return(m._LogicalOr=m.asm.LogicalOr).apply(null,arguments)},m._LogicalXor=function(){return(m._LogicalXor=m.asm.LogicalXor).apply(null,arguments)},m._Max=function(){return(m._Max=m.asm.Max).apply(null,arguments)},m._MaxPool=function(){return(m._MaxPool=m.asm.MaxPool).apply(null,arguments)},m._Maximum=function(){return(m._Maximum=m.asm.Maximum).apply(null,arguments)},m._Mean=function(){return(m._Mean=m.asm.Mean).apply(null,arguments)},m._Min=function(){return(m._Min=m.asm.Min).apply(null,arguments)},m._Minimum=function(){return(m._Minimum=m.asm.Minimum).apply(null,arguments)},m._MirrorPad=function(){return(m._MirrorPad=m.asm.MirrorPad).apply(null,arguments)},m._Multiply=function(){return(m._Multiply=m.asm.Multiply).apply(null,arguments)},m._Neg=function(){return(m._Neg=m.asm.Neg).apply(null,arguments)},m._NonMaxSuppressionV3=function(){return(m._NonMaxSuppressionV3=m.asm.NonMaxSuppressionV3).apply(null,arguments)},m._NonMaxSuppressionV4=function(){return(m._NonMaxSuppressionV4=m.asm.NonMaxSuppressionV4).apply(null,arguments)},m._NonMaxSuppressionV5=function(){return(m._NonMaxSuppressionV5=m.asm.NonMaxSuppressionV5).apply(null,arguments)},m._NotEqual=function(){return(m._NotEqual=m.asm.NotEqual).apply(null,arguments)},m._OneHot=function(){return(m._OneHot=m.asm.OneHot).apply(null,arguments)},m._PadV2=function(){return(m._PadV2=m.asm.PadV2).apply(null,arguments)},m._Pow=function(){return(m._Pow=m.asm.Pow).apply(null,arguments)},m._Prelu=function(){return(m._Prelu=m.asm.Prelu).apply(null,arguments)},m._Prod=function(){return(m._Prod=m.asm.Prod).apply(null,arguments)},m._RealDiv=function(){return(m._RealDiv=m.asm.RealDiv).apply(null,arguments)},m._Relu=function(){return(m._Relu=m.asm.Relu).apply(null,arguments)},m._Relu6=function(){return(m._Relu6=m.asm.Relu6).apply(null,arguments)},m._ResizeBilinear=function(){return(m._ResizeBilinear=m.asm.ResizeBilinear).apply(null,arguments)},m._ResizeNearestNeighbor=function(){return(m._ResizeNearestNeighbor=m.asm.ResizeNearestNeighbor).apply(null,arguments)},m._Reverse=function(){return(m._Reverse=m.asm.Reverse).apply(null,arguments)},m._RotateWithOffset=function(){return(m._RotateWithOffset=m.asm.RotateWithOffset).apply(null,arguments)},m._Round=function(){return(m._Round=m.asm.Round).apply(null,arguments)},m._Rsqrt=function(){return(m._Rsqrt=m.asm.Rsqrt).apply(null,arguments)},m._ScatterNd=function(){return(m._ScatterNd=m.asm.ScatterNd).apply(null,arguments)},m._SelectV2=function(){return(m._SelectV2=m.asm.SelectV2).apply(null,arguments)},m._Sigmoid=function(){return(m._Sigmoid=m.asm.Sigmoid).apply(null,arguments)},m._Sin=function(){return(m._Sin=m.asm.Sin).apply(null,arguments)},m._Softmax=function(){return(m._Softmax=m.asm.Softmax).apply(null,arguments)},m._SparseFillEmptyRows=function(){return(m._SparseFillEmptyRows=m.asm.SparseFillEmptyRows).apply(null,arguments)},m._SparseReshape=function(){return(m._SparseReshape=m.asm.SparseReshape).apply(null,arguments)},m._SparseSegmentReduction=function(){return(m._SparseSegmentReduction=m.asm.SparseSegmentReduction).apply(null,arguments)},m._Sqrt=function(){return(m._Sqrt=m.asm.Sqrt).apply(null,arguments)},m._Square=function(){return(m._Square=m.asm.Square).apply(null,arguments)},m._SquaredDifference=function(){return(m._SquaredDifference=m.asm.SquaredDifference).apply(null,arguments)},m._Step=function(){return(m._Step=m.asm.Step).apply(null,arguments)},m._StridedSlice=function(){return(m._StridedSlice=m.asm.StridedSlice).apply(null,arguments)},m._Sub=function(){return(m._Sub=m.asm.Sub).apply(null,arguments)},m._Sum=function(){return(m._Sum=m.asm.Sum).apply(null,arguments)},m._Tan=function(){return(m._Tan=m.asm.Tan).apply(null,arguments)},m._Tanh=function(){return(m._Tanh=m.asm.Tanh).apply(null,arguments)},m._Tile=function(){return(m._Tile=m.asm.Tile).apply(null,arguments)},m._TopK=function(){return(m._TopK=m.asm.TopK).apply(null,arguments)},m._Transform=function(){return(m._Transform=m.asm.Transform).apply(null,arguments)},m._Transpose=function(){return(m._Transpose=m.asm.Transpose).apply(null,arguments)},m.__FusedMatMul=function(){return(m.__FusedMatMul=m.asm._FusedMatMul).apply(null,arguments)},m._malloc=function(){return(Wo=m._malloc=m.asm.malloc).apply(null,arguments)}),si=m._free=function(){return(si=m._free=m.asm.free).apply(null,arguments)},fo=(m._emscripten_tls_init=function(){return(m._emscripten_tls_init=m.asm.emscripten_tls_init).apply(null,arguments)},m.___errno_location=function(){return(fo=m.___errno_location=m.asm.__errno_location).apply(null,arguments)}),no=m._pthread_self=function(){return(no=m._pthread_self=m.asm.pthread_self).apply(null,arguments)},Ta=m._emscripten_main_thread_process_queued_calls=function(){return(Ta=m._emscripten_main_thread_process_queued_calls=m.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},mo=(m.__emscripten_thread_crashed=function(){return(m.__emscripten_thread_crashed=m.asm._emscripten_thread_crashed).apply(null,arguments)},m.__emscripten_thread_init=function(){return(mo=m.__emscripten_thread_init=m.asm._emscripten_thread_init).apply(null,arguments)}),Ar=(m._emscripten_current_thread_process_queued_calls=function(){return(m._emscripten_current_thread_process_queued_calls=m.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},m._emscripten_main_browser_thread_id=function(){return(m._emscripten_main_browser_thread_id=m.asm.emscripten_main_browser_thread_id).apply(null,arguments)},m._emscripten_sync_run_in_main_thread_2=function(){return(m._emscripten_sync_run_in_main_thread_2=m.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},m._emscripten_sync_run_in_main_thread_4=function(){return(Ar=m._emscripten_sync_run_in_main_thread_4=m.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)}),Na=m._emscripten_run_in_main_runtime_thread_js=function(){return(Na=m._emscripten_run_in_main_runtime_thread_js=m.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},Ea=m._emscripten_dispatch_to_thread_=function(){return(Ea=m._emscripten_dispatch_to_thread_=m.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},Vo=m.__emscripten_thread_free_data=function(){return(Vo=m.__emscripten_thread_free_data=m.asm._emscripten_thread_free_data).apply(null,arguments)},So=(m.__emscripten_thread_exit=function(){return(m.__emscripten_thread_exit=m.asm._emscripten_thread_exit).apply(null,arguments)},m._memalign=function(){return(m._memalign=m.asm.memalign).apply(null,arguments)},m._emscripten_stack_set_limits=function(){return(So=m._emscripten_stack_set_limits=m.asm.emscripten_stack_set_limits).apply(null,arguments)}),so=m.stackSave=function(){return(so=m.stackSave=m.asm.stackSave).apply(null,arguments)},Zs=m.stackRestore=function(){return(Zs=m.stackRestore=m.asm.stackRestore).apply(null,arguments)},Kr=m.stackAlloc=function(){return(Kr=m.stackAlloc=m.asm.stackAlloc).apply(null,arguments)},Ra=(m.dynCall_iijjiiii=function(){return(m.dynCall_iijjiiii=m.asm.dynCall_iijjiiii).apply(null,arguments)},m.dynCall_jiji=function(){return(m.dynCall_jiji=m.asm.dynCall_jiji).apply(null,arguments)},m.__emscripten_allow_main_runtime_queued_calls=21672);function fa(We){this.name="ExitStatus",this.message="Program terminated with exit("+We+")",this.status=We}function na(We){if(!(xs>0)){if(ge)return f(m),Gs(),void postMessage({cmd:"loaded"});(function(){if(m.preRun)for(typeof m.preRun=="function"&&(m.preRun=[m.preRun]);m.preRun.length;)Ut=m.preRun.shift(),be.unshift(Ut);var Ut;Ns(be)})(),xs>0||(m.setStatus?(m.setStatus("Running..."),setTimeout(function(){setTimeout(function(){m.setStatus("")},1),It()},1)):It())}function It(){Pr||(Pr=!0,m.calledRun=!0,dn||(Gs(),f(m),m.onRuntimeInitialized&&m.onRuntimeInitialized(),function(){if(!ge){if(m.postRun)for(typeof m.postRun=="function"&&(m.postRun=[m.postRun]);m.postRun.length;)Ut=m.postRun.shift(),Un.unshift(Ut);var Ut;Ns(Un)}}()))}}if(m.cwrap=function(We,It,Ut,sn){var vn=(Ut=Ut||[]).every(function(fn){return fn==="number"});return It!=="string"&&vn&&!sn?mn(We):function(){return Rn(We,It,Ut,arguments)}},m.keepRuntimeAlive=Ws,m.PThread=jt,m.PThread=jt,m.wasmMemory=wt,m.ExitStatus=fa,ds=function We(){Pr||na(),Pr||(ds=We)},m.run=na,m.preInit)for(typeof m.preInit=="function"&&(m.preInit=[m.preInit]);m.preInit.length>0;)m.preInit.pop()();if(na(),b&&(Cr={uncaughtException:r.listeners("uncaughtException").filter(function(We){return!b.uncaughtException.indexOf(We)>-1}),unhandledRejection:r.listeners("unhandledRejection").filter(function(We){return!b.unhandledRejection.indexOf(We)>-1})}),typeof WasmBackendModule!="undefined")Ba=WasmBackendModule;else{if(typeof c=="undefined")throw new Error("Could not find wasm module in post.js");Ba=c}if(Cr){var $o=Ba._dispose;Ba._dispose=function(){$o(),Cr.uncaughtException.forEach(function(We){r.removeListener("uncaughtException",We)}),Cr.unhandledRejection.forEach(function(We){r.removeListener("unhandledRejection",We)})}}return c.ready});s.exports=u}).call(this,"/index.js",t(41),"/",t(40))},function(s,e,t){(function(n,r,a){var o,i=(o=(o=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0)||n,function(u){var c,d,h,l=typeof(u=u||{})!="undefined"?u:{};l.ready=new Promise(function(pn,Nn){c=pn,d=Nn}),typeof r!="undefined"&&r.listeners&&(h={uncaughtException:r.listeners("uncaughtException"),unhandledRejection:r.listeners("unhandledRejection")});var p,f,x,b,m,I,N=Object.assign({},l),E=typeof window=="object",D=typeof importScripts=="function",U=typeof r=="object"&&typeof r.versions=="object"&&typeof r.versions.node=="string",L="";U?(L=D?t(54).dirname(L)+"/":a+"/",I=()=>{m||(b=t(96),m=t(54))},p=function(pn,Nn){return I(),pn=m.normalize(pn),b.readFileSync(pn,Nn?void 0:"utf8")},x=pn=>{var Nn=p(pn,!0);return Nn.buffer||(Nn=new Uint8Array(Nn)),Nn},f=(pn,Nn,ts)=>{I(),pn=m.normalize(pn),b.readFile(pn,function($s,Ns){$s?ts($s):Nn(Ns.buffer)})},r.argv.length>1&&r.argv[1].replace(/\\/g,"/"),r.argv.slice(2),r.on("uncaughtException",function(pn){if(!(pn instanceof xs))throw pn}),r.on("unhandledRejection",function(pn){throw pn}),l.inspect=function(){return"[Emscripten Module object]"}):(E||D)&&(D?L=self.location.href:typeof document!="undefined"&&document.currentScript&&(L=document.currentScript.src),o&&(L=o),L=L.indexOf("blob:")!==0?L.substr(0,L.replace(/[?#].*/,"").lastIndexOf("/")+1):"",p=pn=>{var Nn=new XMLHttpRequest;return Nn.open("GET",pn,!1),Nn.send(null),Nn.responseText},D&&(x=pn=>{var Nn=new XMLHttpRequest;return Nn.open("GET",pn,!1),Nn.responseType="arraybuffer",Nn.send(null),new Uint8Array(Nn.response)}),f=(pn,Nn,ts)=>{var $s=new XMLHttpRequest;$s.open("GET",pn,!0),$s.responseType="arraybuffer",$s.onload=()=>{$s.status==200||$s.status==0&&$s.response?Nn($s.response):ts()},$s.onerror=ts,$s.send(null)});var Y,V=l.print||console.log.bind(console),P=l.printErr||console.warn.bind(console);Object.assign(l,N),N=null,l.arguments&&l.arguments,l.thisProgram&&l.thisProgram,l.quit&&l.quit,l.wasmBinary&&(Y=l.wasmBinary);var oe;l.noExitRuntime,typeof WebAssembly!="object"&&we("no native wasm support detected");var ne=!1;function ge(pn){return l["_"+pn]}function ye(pn,Nn,ts,$s,Ns){var ys={string:function(Ct){var Yt=0;if(Ct!=null&&Ct!==0){var on=1+(Ct.length<<2);(function(tn,bn,On){(function(Mn,wn,gs,Hs){if(!(Hs>0))return 0;for(var xr=gs+Hs-1,Ir=0;Ir<Mn.length;++Ir){var qs=Mn.charCodeAt(Ir);if(qs>=55296&&qs<=57343&&(qs=65536+((1023&qs)<<10)|1023&Mn.charCodeAt(++Ir)),qs<=127){if(gs>=xr)break;wn[gs++]=qs}else if(qs<=2047){if(gs+1>=xr)break;wn[gs++]=192|qs>>6,wn[gs++]=128|63&qs}else if(qs<=65535){if(gs+2>=xr)break;wn[gs++]=224|qs>>12,wn[gs++]=128|qs>>6&63,wn[gs++]=128|63&qs}else{if(gs+3>=xr)break;wn[gs++]=240|qs>>18,wn[gs++]=128|qs>>12&63,wn[gs++]=128|qs>>6&63,wn[gs++]=128|63&qs}}wn[gs]=0})(tn,je,bn,On)})(Ct,Yt=As(on),on)}return Yt},array:function(Ct){var Yt=As(Ct.length);return function(on,tn){X.set(on,tn)}(Ct,Yt),Yt}},Vs=ge(pn),Us=[],jt=0;if($s)for(var re=0;re<$s.length;re++){var de=ys[ts[re]];de?(jt===0&&(jt=Ws()),Us[re]=de($s[re])):Us[re]=$s[re]}var ot=Vs.apply(null,Us);return ot=function(Ct){return jt!==0&&Gs(jt),function(Yt){return Nn==="string"?Me(Yt):Nn==="boolean"?Boolean(Yt):Yt}(Ct)}(ot)}var Ee,X,je,Be,tt=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function ct(pn,Nn,ts){for(var $s=Nn+ts,Ns=Nn;pn[Ns]&&!(Ns>=$s);)++Ns;if(Ns-Nn>16&&pn.subarray&&tt)return tt.decode(pn.subarray(Nn,Ns));for(var ys="";Nn<Ns;){var Vs=pn[Nn++];if(128&Vs){var Us=63&pn[Nn++];if((224&Vs)!=192){var jt=63&pn[Nn++];if((Vs=(240&Vs)==224?(15&Vs)<<12|Us<<6|jt:(7&Vs)<<18|Us<<12|jt<<6|63&pn[Nn++])<65536)ys+=String.fromCharCode(Vs);else{var re=Vs-65536;ys+=String.fromCharCode(55296|re>>10,56320|1023&re)}}else ys+=String.fromCharCode((31&Vs)<<6|Us)}else ys+=String.fromCharCode(Vs)}return ys}function Me(pn,Nn){return pn?ct(je,pn,Nn):""}function wt(pn){Ee=pn,l.HEAP8=X=new Int8Array(pn),l.HEAP16=new Int16Array(pn),l.HEAP32=Be=new Int32Array(pn),l.HEAPU8=je=new Uint8Array(pn),l.HEAPU16=new Uint16Array(pn),l.HEAPU32=new Uint32Array(pn),l.HEAPF32=new Float32Array(pn),l.HEAPF64=new Float64Array(pn)}typeof TextDecoder!="undefined"&&new TextDecoder("utf-16le"),l.INITIAL_MEMORY;var at,Gt=[],Ht=[],dn=[],mn,Rn,ee=0,se=null;function we(pn){l.onAbort&&l.onAbort(pn),P(pn="Aborted("+pn+")"),ne=!0,pn+=". Build with -s ASSERTIONS=1 for more info.";var Nn=new WebAssembly.RuntimeError(pn);throw d(Nn),Nn}function pt(pn){return pn.startsWith("data:application/octet-stream;base64,")}function bt(pn){return pn.startsWith("file://")}function At(pn){try{if(pn==mn&&Y)return new Uint8Array(Y);if(x)return x(pn);throw"both async and sync fetching of the wasm failed"}catch(Nn){we(Nn)}}function $e(pn){for(;pn.length>0;){var Nn=pn.shift();if(typeof Nn!="function"){var ts=Nn.func;typeof ts=="number"?Nn.arg===void 0?Pt(ts)():Pt(ts)(Nn.arg):ts(Nn.arg===void 0?null:Nn.arg)}else Nn(l)}}l.preloadedImages={},l.preloadedAudios={},pt(mn="tfjs-backend-wasm.wasm")||(Rn=mn,mn=l.locateFile?l.locateFile(Rn,L):L+Rn);var ht=[];function Pt(pn){var Nn=ht[pn];return Nn||(pn>=ht.length&&(ht.length=pn+1),ht[pn]=Nn=at.get(pn)),Nn}function Ot(){return 2147483648}function xn(pn){try{return oe.grow(pn-Ee.byteLength+65535>>>16),wt(oe.buffer),1}catch{}}var Dn,pe,be,Qe={mappings:{},buffers:[null,[],[]],printChar:function(pn,Nn){var ts=Qe.buffers[pn];Nn===0||Nn===10?((pn===1?V:P)(ct(ts,0)),ts.length=0):ts.push(Nn)},varargs:void 0,get:function(){return Qe.varargs+=4,Be[Qe.varargs-4>>2]},getStr:function(pn){return Me(pn)},get64:function(pn,Nn){return pn}},Un={abort:function(){we("")},emscripten_get_heap_max:Ot,emscripten_memcpy_big:function(pn,Nn,ts){je.copyWithin(pn,Nn,Nn+ts)},emscripten_resize_heap:function(pn){var Nn,ts,$s=je.length,Ns=2147483648;if((pn>>>=0)>Ns)return!1;for(var ys=1;ys<=4;ys*=2){var Vs=$s*(1+.2/ys);if(Vs=Math.min(Vs,pn+100663296),xn(Math.min(Ns,((Nn=Math.max(pn,Vs))%(ts=65536)>0&&(Nn+=ts-Nn%ts),Nn))))return!0}return!1},fd_close:function(pn){return 0},fd_seek:function(pn,Nn,ts,$s,Ns){},fd_write:function(pn,Nn,ts,$s){for(var Ns=0,ys=0;ys<ts;ys++){var Vs=Be[Nn>>2],Us=Be[Nn+4>>2];Nn+=8;for(var jt=0;jt<Us;jt++)Qe.printChar(pn,je[Vs+jt]);Ns+=Us}return Be[$s>>2]=Ns,0},setTempRet0:function(pn){}},Ws=(function(){var pn={env:Un,wasi_snapshot_preview1:Un};function Nn(Ns,ys){var Vs,Us=Ns.exports;l.asm=Us,wt((oe=l.asm.memory).buffer),at=l.asm.__indirect_function_table,Vs=l.asm.__wasm_call_ctors,Ht.unshift(Vs),function(jt){if(ee--,l.monitorRunDependencies&&l.monitorRunDependencies(ee),ee==0&&se){var re=se;se=null,re()}}()}function ts(Ns){Nn(Ns.instance)}function $s(Ns){return function(){if(!Y&&(E||D)){if(typeof fetch=="function"&&!bt(mn))return fetch(mn,{credentials:"same-origin"}).then(function(ys){if(!ys.ok)throw"failed to load wasm binary file at '"+mn+"'";return ys.arrayBuffer()}).catch(function(){return At(mn)});if(f)return new Promise(function(ys,Vs){f(mn,function(Us){ys(new Uint8Array(Us))},Vs)})}return Promise.resolve().then(function(){return At(mn)})}().then(function(ys){return WebAssembly.instantiate(ys,pn)}).then(function(ys){return ys}).then(Ns,function(ys){P("failed to asynchronously prepare wasm: "+ys),we(ys)})}if(ee++,l.monitorRunDependencies&&l.monitorRunDependencies(ee),l.instantiateWasm)try{return l.instantiateWasm(pn,Nn)}catch(Ns){return P("Module.instantiateWasm callback failed with error: "+Ns),!1}(Y||typeof WebAssembly.instantiateStreaming!="function"||pt(mn)||bt(mn)||typeof fetch!="function"?$s(ts):fetch(mn,{credentials:"same-origin"}).then(function(Ns){return WebAssembly.instantiateStreaming(Ns,pn).then(ts,function(ys){return P("wasm streaming compile failed: "+ys),P("falling back to ArrayBuffer instantiation"),$s(ts)})})).catch(d)}(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},l._init=function(){return(l._init=l.asm.init).apply(null,arguments)},l._init_with_threads_count=function(){return(l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},l._get_threads_count=function(){return(l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},l._register_tensor=function(){return(l._register_tensor=l.asm.register_tensor).apply(null,arguments)},l._dispose_data=function(){return(l._dispose_data=l.asm.dispose_data).apply(null,arguments)},l._dispose=function(){return(l._dispose=l.asm.dispose).apply(null,arguments)},l._Abs=function(){return(l._Abs=l.asm.Abs).apply(null,arguments)},l._Add=function(){return(l._Add=l.asm.Add).apply(null,arguments)},l._AddN=function(){return(l._AddN=l.asm.AddN).apply(null,arguments)},l._All=function(){return(l._All=l.asm.All).apply(null,arguments)},l._Any=function(){return(l._Any=l.asm.Any).apply(null,arguments)},l._ArgMax=function(){return(l._ArgMax=l.asm.ArgMax).apply(null,arguments)},l._AvgPool=function(){return(l._AvgPool=l.asm.AvgPool).apply(null,arguments)},l._BatchMatMul=function(){return(l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},l._Ceil=function(){return(l._Ceil=l.asm.Ceil).apply(null,arguments)},l._ClipByValue=function(){return(l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},l._Conv2D=function(){return(l._Conv2D=l.asm.Conv2D).apply(null,arguments)},l._Conv2DBackpropInput=function(){return(l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},l._Cos=function(){return(l._Cos=l.asm.Cos).apply(null,arguments)},l._Cosh=function(){return(l._Cosh=l.asm.Cosh).apply(null,arguments)},l._CropAndResize=function(){return(l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},l._Cumprod=function(){return(l._Cumprod=l.asm.Cumprod).apply(null,arguments)},l._Cumsum=function(){return(l._Cumsum=l.asm.Cumsum).apply(null,arguments)},l._DepthToSpace=function(){return(l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},l._DepthwiseConv2dNative=function(){return(l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},l._Elu=function(){return(l._Elu=l.asm.Elu).apply(null,arguments)},l._Equal=function(){return(l._Equal=l.asm.Equal).apply(null,arguments)},l._Exp=function(){return(l._Exp=l.asm.Exp).apply(null,arguments)},l._FlipLeftRight=function(){return(l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},l._Floor=function(){return(l._Floor=l.asm.Floor).apply(null,arguments)},l._FloorDiv=function(){return(l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},l._FusedBatchNorm=function(){return(l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},l._FusedConv2D=function(){return(l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},l._FusedDepthwiseConv2D=function(){return(l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},l._Gather=function(){return(l._Gather=l.asm.Gather).apply(null,arguments)},l._GatherNd=function(){return(l._GatherNd=l.asm.GatherNd).apply(null,arguments)},l._Greater=function(){return(l._Greater=l.asm.Greater).apply(null,arguments)},l._GreaterEqual=function(){return(l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},l._LeakyRelu=function(){return(l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},l._Less=function(){return(l._Less=l.asm.Less).apply(null,arguments)},l._LessEqual=function(){return(l._LessEqual=l.asm.LessEqual).apply(null,arguments)},l._Log=function(){return(l._Log=l.asm.Log).apply(null,arguments)},l._LogicalAnd=function(){return(l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},l._LogicalNot=function(){return(l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},l._LogicalOr=function(){return(l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},l._LogicalXor=function(){return(l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},l._Max=function(){return(l._Max=l.asm.Max).apply(null,arguments)},l._MaxPool=function(){return(l._MaxPool=l.asm.MaxPool).apply(null,arguments)},l._Maximum=function(){return(l._Maximum=l.asm.Maximum).apply(null,arguments)},l._Mean=function(){return(l._Mean=l.asm.Mean).apply(null,arguments)},l._Min=function(){return(l._Min=l.asm.Min).apply(null,arguments)},l._Minimum=function(){return(l._Minimum=l.asm.Minimum).apply(null,arguments)},l._MirrorPad=function(){return(l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},l._Multiply=function(){return(l._Multiply=l.asm.Multiply).apply(null,arguments)},l._Neg=function(){return(l._Neg=l.asm.Neg).apply(null,arguments)},l._NonMaxSuppressionV3=function(){return(l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},l._NonMaxSuppressionV4=function(){return(l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},l._NonMaxSuppressionV5=function(){return(l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},l._NotEqual=function(){return(l._NotEqual=l.asm.NotEqual).apply(null,arguments)},l._OneHot=function(){return(l._OneHot=l.asm.OneHot).apply(null,arguments)},l._PadV2=function(){return(l._PadV2=l.asm.PadV2).apply(null,arguments)},l._Pow=function(){return(l._Pow=l.asm.Pow).apply(null,arguments)},l._Prelu=function(){return(l._Prelu=l.asm.Prelu).apply(null,arguments)},l._Prod=function(){return(l._Prod=l.asm.Prod).apply(null,arguments)},l._RealDiv=function(){return(l._RealDiv=l.asm.RealDiv).apply(null,arguments)},l._Relu=function(){return(l._Relu=l.asm.Relu).apply(null,arguments)},l._Relu6=function(){return(l._Relu6=l.asm.Relu6).apply(null,arguments)},l._ResizeBilinear=function(){return(l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},l._ResizeNearestNeighbor=function(){return(l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},l._Reverse=function(){return(l._Reverse=l.asm.Reverse).apply(null,arguments)},l._RotateWithOffset=function(){return(l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},l._Round=function(){return(l._Round=l.asm.Round).apply(null,arguments)},l._Rsqrt=function(){return(l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},l._ScatterNd=function(){return(l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},l._SelectV2=function(){return(l._SelectV2=l.asm.SelectV2).apply(null,arguments)},l._Sigmoid=function(){return(l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},l._Sin=function(){return(l._Sin=l.asm.Sin).apply(null,arguments)},l._Softmax=function(){return(l._Softmax=l.asm.Softmax).apply(null,arguments)},l._SparseFillEmptyRows=function(){return(l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},l._SparseReshape=function(){return(l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},l._SparseSegmentReduction=function(){return(l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},l._Sqrt=function(){return(l._Sqrt=l.asm.Sqrt).apply(null,arguments)},l._Square=function(){return(l._Square=l.asm.Square).apply(null,arguments)},l._SquaredDifference=function(){return(l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},l._Step=function(){return(l._Step=l.asm.Step).apply(null,arguments)},l._StridedSlice=function(){return(l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},l._Sub=function(){return(l._Sub=l.asm.Sub).apply(null,arguments)},l._Sum=function(){return(l._Sum=l.asm.Sum).apply(null,arguments)},l._Tan=function(){return(l._Tan=l.asm.Tan).apply(null,arguments)},l._Tanh=function(){return(l._Tanh=l.asm.Tanh).apply(null,arguments)},l._Tile=function(){return(l._Tile=l.asm.Tile).apply(null,arguments)},l._TopK=function(){return(l._TopK=l.asm.TopK).apply(null,arguments)},l._Transform=function(){return(l._Transform=l.asm.Transform).apply(null,arguments)},l._Transpose=function(){return(l._Transpose=l.asm.Transpose).apply(null,arguments)},l.__FusedMatMul=function(){return(l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},l._malloc=function(){return(l._malloc=l.asm.malloc).apply(null,arguments)},l._free=function(){return(l._free=l.asm.free).apply(null,arguments)},l.___errno_location=function(){return(l.___errno_location=l.asm.__errno_location).apply(null,arguments)},l._emscripten_main_thread_process_queued_calls=function(){return(l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},l.stackSave=function(){return(Ws=l.stackSave=l.asm.stackSave).apply(null,arguments)}),Gs=l.stackRestore=function(){return(Gs=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},As=l.stackAlloc=function(){return(As=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)};function xs(pn){this.name="ExitStatus",this.message="Program terminated with exit("+pn+")",this.status=pn}function ds(pn){function Nn(){Dn||(Dn=!0,l.calledRun=!0,ne||($e(Ht),c(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),function(){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)ts=l.postRun.shift(),dn.unshift(ts);var ts;$e(dn)}()))}ee>0||(function(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)ts=l.preRun.shift(),Gt.unshift(ts);var ts;$e(Gt)}(),ee>0||(l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),Nn()},1)):Nn()))}if(l.dynCall_iijjiiii=function(){return(l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},l.dynCall_jiji=function(){return(l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},l.cwrap=function(pn,Nn,ts,$s){var Ns=(ts=ts||[]).every(function(ys){return ys==="number"});return Nn!=="string"&&Ns&&!$s?ge(pn):function(){return ye(pn,Nn,ts,arguments)}},se=function pn(){Dn||ds(),Dn||(se=pn)},l.run=ds,l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();if(ds(),h&&(pe={uncaughtException:r.listeners("uncaughtException").filter(function(pn){return!h.uncaughtException.indexOf(pn)>-1}),unhandledRejection:r.listeners("unhandledRejection").filter(function(pn){return!h.unhandledRejection.indexOf(pn)>-1})}),typeof u!="undefined")be=u;else{if(typeof WasmBackendModuleThreadedSimd=="undefined")throw new Error("Could not find wasm module in post.js");be=WasmBackendModuleThreadedSimd}if(pe){var Ys=be._dispose;be._dispose=function(){Ys(),pe.uncaughtException.forEach(function(pn){r.removeListener("uncaughtException",pn)}),pe.unhandledRejection.forEach(function(pn){r.removeListener("unhandledRejection",pn)})}}return u.ready});s.exports=i}).call(this,"/index.js",t(41),"/")},function(s,e,t){(function(n){t.d(e,"a",function(){return a});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r=typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof n!="undefined"?n:o=>o();function a(){return new Promise(o=>r(()=>o()))}}).call(this,t(120).setImmediate)},function(s,e){},function(s,e,t){var n=t(0);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r={},a={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function o(F,y){if(!(F in r)||y!=null){const S=function(_,T){if(_!==1&&_!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const O=T==null?function(B){if(typeof OffscreenCanvas!="undefined"&&B===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(_):T;return O.addEventListener("webglcontextlost",B=>{B.preventDefault(),delete r[_]},!1),Object(n.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(a.failIfMajorPerformanceCaveat=!1),_===1?O.getContext("webgl",a)||O.getContext("experimental-webgl",a):O.getContext("webgl2",a)}(F,y);if(S===null)return console.log("Could not get context for WebGL version",F),null;r[F]=S}const k=r[F];return k==null||k.isContextLost()?(delete r[F],o(F)):(k.disable(k.DEPTH_TEST),k.disable(k.STENCIL_TEST),k.disable(k.BLEND),k.disable(k.DITHER),k.disable(k.POLYGON_OFFSET_FILL),k.disable(k.SAMPLE_COVERAGE),k.enable(k.SCISSOR_TEST),k.enable(k.CULL_FACE),k.cullFace(k.BACK),r[F])}var i,u,c;function d(F,y){return[y,F]}function h(F){const y=n.util.sizeFromShape(F),k=Math.ceil(y/4);return n.util.sizeToSquarishShape(k)}function l(F,y){return[Math.max(1,Math.ceil(y/2)),Math.max(1,Math.ceil(F/2))]}function p(F,y){const k=F;let S,_,T,O,B,z,K,Q,ue,ae;return Object(n.env)().getNumber("WEBGL_VERSION")===2?(S=k.R32F,_=k.R16F,T=k.RGBA16F,O=k.RGBA32F,B=k.RED,K=4,Q=1,ue=k.HALF_FLOAT,ae=k.FLOAT,z=k.RGBA8):(S=F.RGBA,_=F.RGBA,T=F.RGBA,O=k.RGBA,B=F.RGBA,K=4,Q=4,ue=y!=null?y.HALF_FLOAT_OES:null,ae=F.FLOAT,z=F.RGBA),{internalFormatFloat:S,internalFormatHalfFloat:_,internalFormatPackedHalfFloat:T,internalFormatPackedFloat:O,textureFormatFloat:B,downloadTextureFormat:z,downloadUnpackNumChannels:K,defaultNumChannels:Q,textureTypeHalfFloat:ue,textureTypeFloat:ae}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f(F,y){const k=y();return Object(n.env)().getBool("DEBUG")&&function(S){const _=S.getError();if(_!==S.NO_ERROR)throw new Error("WebGL Error: "+function(T,O){switch(O){case T.NO_ERROR:return"NO_ERROR";case T.INVALID_ENUM:return"INVALID_ENUM";case T.INVALID_VALUE:return"INVALID_VALUE";case T.INVALID_OPERATION:return"INVALID_OPERATION";case T.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case T.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case T.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${O}`}}(S,_))}(F),k}(function(F){F[F.DENSE=0]="DENSE",F[F.SHARED_BATCH=1]="SHARED_BATCH"})(i||(i={})),function(F){F[F.RENDER=0]="RENDER",F[F.UPLOAD=1]="UPLOAD",F[F.PIXELS=2]="PIXELS",F[F.DOWNLOAD=3]="DOWNLOAD"}(u||(u={})),function(F){F[F.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",F[F.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",F[F.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",F[F.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",F[F.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(c||(c={}));function x(F){return!!(Object(n.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||F===0||596e-10<Math.abs(F)&&Math.abs(F)<65504)}function b(F,y){return V(F,()=>F.getExtension(y),'Extension "'+y+'" not supported on this browser.')}const m=/ERROR: [0-9]+:([0-9]+):/g;function I(F,y){const k=m.exec(y);if(k==null)return console.log(`Couldn't parse line number in error: ${y}`),void console.log(F);const S=+k[1],_=F.split(`
`),T=_.length.toString().length+2,O=_.map((ue,ae)=>n.util.rightPad((ae+1).toString(),T)+ue);let B=0;for(let ue=0;ue<O.length;ue++)B=Math.max(O[ue].length,B);const z=O.slice(0,S-1),K=O.slice(S-1,S),Q=O.slice(S);console.log(z.join(`
`)),console.log(y.split(`
`)[0]),console.log(`%c ${n.util.rightPad(K[0],B)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(Q.join(`
`))}function N(F,y){if(f(F,()=>F.validateProgram(y)),F.getProgramParameter(y,F.VALIDATE_STATUS)===!1)throw console.log(F.getProgramInfoLog(y)),new Error("Shader program validation failed.")}function E(F,y,k,S,_,T,O){const B=F.getAttribLocation(y,k);return B!==-1&&(f(F,()=>F.bindBuffer(F.ARRAY_BUFFER,S)),f(F,()=>F.vertexAttribPointer(B,_,F.FLOAT,!1,T,O)),f(F,()=>F.enableVertexAttribArray(B)),!0)}function D(F,y,k,S){f(F,()=>function(_,T,O){P(_,O),f(_,()=>_.activeTexture(_.TEXTURE0+O)),f(_,()=>_.bindTexture(_.TEXTURE_2D,T))}(F,y,S)),f(F,()=>F.uniform1i(k,S))}function U(F,y,k){f(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,k)),f(F,()=>F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,y,0))}function L(F,y){f(F,()=>F.bindFramebuffer(F.FRAMEBUFFER,y)),f(F,()=>F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,null,0))}function Y(F){const y=F.checkFramebufferStatus(F.FRAMEBUFFER);if(y!==F.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(k,S){switch(S){case k.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case k.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case k.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case k.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${S}`}}(F,y))}function V(F,y,k){const S=f(F,()=>y());if(S==null)throw new Error(k);return S}function P(F,y){const k=F.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,S=y+F.TEXTURE0;if(S<F.TEXTURE0||S>k)throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${k}]`}.`)}function oe(F,y=2){return n.util.sizeFromShape(F.slice(0,F.length-y))}function ne(F){if(F.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[F.length>1?F[F.length-2]:1,F[F.length-1]]}function ge(F){let y=[1,1,1];return F.length===0||F.length===1&&F[0]===1||(y=[oe(F),...ne(F)]),y}function ye(F){return F%2==0}function Ee(F,y){if(F=F.slice(-2),y=y.slice(-2),n.util.arraysEqual(F,y)||!F.length||!y.length||F[0]===0||F[1]===0||y[0]===0||y[1]===0)return!0;if(F.length!==y.length){const k=F.slice(-1)[0],S=y.slice(-1)[0];if(k===S||ye(k)&&ye(S)&&(F[0]===1||y[0]===1))return!0}return F[1]===y[1]&&ye(F[0])&&ye(y[0])}let X,je;function Be(F,y){return F.getExtension(y)!=null}function tt(F){try{if(o(F)!=null)return!0}catch(y){return console.log("Error when getting WebGL context: ",y),!1}return!1}function ct(F){if(F===0)return!1;const y=o(F);if(F!==1){if(Be(y,"EXT_color_buffer_float"))return Me(y);const k="EXT_color_buffer_half_float";if(Be(y,k)){const S=y.getExtension(k);return function(_,T){const O=p(_,T),B=_.createTexture();_.bindTexture(_.TEXTURE_2D,B);const z=1,K=1;_.texImage2D(_.TEXTURE_2D,0,O.internalFormatHalfFloat,z,K,0,O.textureFormatFloat,O.textureTypeHalfFloat,null);const Q=_.createFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,Q),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,B,0);const ue=_.checkFramebufferStatus(_.FRAMEBUFFER)===_.FRAMEBUFFER_COMPLETE;return _.bindTexture(_.TEXTURE_2D,null),_.bindFramebuffer(_.FRAMEBUFFER,null),_.deleteTexture(B),_.deleteFramebuffer(Q),ue}(y,S)}return!1}return!Be(y,"OES_texture_float")||!Be(y,"WEBGL_color_buffer_float")?!1:Me(y)}function Me(F){const y=p(F),k=F.createTexture();F.bindTexture(F.TEXTURE_2D,k),F.texImage2D(F.TEXTURE_2D,0,y.internalFormatFloat,1,1,0,y.textureFormatFloat,y.textureTypeFloat,null);const S=F.createFramebuffer();F.bindFramebuffer(F.FRAMEBUFFER,S),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,k,0);const _=F.checkFramebufferStatus(F.FRAMEBUFFER)===F.FRAMEBUFFER_COMPLETE;return F.bindTexture(F.TEXTURE_2D,null),F.bindFramebuffer(F.FRAMEBUFFER,null),F.deleteTexture(k),F.deleteFramebuffer(S),_}function wt(F,y){Array.isArray(F)||(F=[F]),F.forEach(k=>{k!=null&&n.util.assert(k.dtype!=="complex64",()=>`${y} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at=Object(n.env)();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(){let F,y,k,S,_,T,O,B,z,K;return Object(n.env)().getNumber("WEBGL_VERSION")===2?(F="#version 300 es",y="in",k="out",S="in",_="texture",T="outputColor",O="out vec4 outputColor;",B=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,z="",K=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(F="",y="attribute",k="varying",S="varying",_="texture2D",T="gl_FragColor",O="",B=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,z=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,K=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:F,attribute:y,varyingVs:k,varyingFs:S,texture2D:_,output:T,defineOutput:O,defineSpecialNaN:B,defineSpecialInf:z,defineRound:K}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(F,y,k="index"){const S=n.util.computeStrides(y);return S.map((_,T)=>`${`int ${F[T]} = ${k} / ${_}`}; ${T===S.length-1?`int ${F[T+1]} = ${k} - ${F[T]} * ${_}`:`index -= ${F[T]} * ${_}`};`).join("")}function dn(F,y,k="index"){const S=n.util.computeStrides(y);return S.map((_,T)=>`${`int ${F[T]} = ${k} / outShapeStrides[${T}]`}; ${T===S.length-1?`int ${F[T+1]} = ${k} - ${F[T]} * outShapeStrides[${T}]`:`index -= ${F[T]} * outShapeStrides[${T}]`};`).join("")}function mn(F,y,k="index"){const S=function(_,T){const O=_.length,B=_.map(K=>`${T}[${K}]`),z=new Array(O-1);z[O-2]=B[O-1];for(let K=O-3;K>=0;--K)z[K]=`(${z[K+1]} * ${B[K+1]})`;return z}(F.map((_,T)=>T),y);return S.map((_,T)=>`${`int ${F[T]} = ${k} / ${S[T]}`}; ${T===S.length-1?`int ${F[T+1]} = ${k} - ${F[T]} * ${S[T]}`:`index -= ${F[T]} * ${S[T]}`};`).join("")}function Rn(F){const y=n.util.computeStrides(F).map(k=>k.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${y[0]} + coords.y * ${y[1]} + coords.z;
  }
`}at.registerFlag("HAS_WEBGL",()=>at.getNumber("WEBGL_VERSION")>0),at.registerFlag("WEBGL_VERSION",()=>tt(2)?2:tt(1)?1:0),at.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),at.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>at.get("WEBGL_VERSION")===2),at.registerFlag("WEBGL_CPU_FORWARD",()=>!0),at.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),at.registerFlag("WEBGL_PACK",()=>at.getBool("HAS_WEBGL")),at.registerFlag("WEBGL_PACK_NORMALIZATION",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_CLIP",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_PACK_REDUCE",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_LAZILY_UNPACK",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_CONV_IM2COL",()=>at.getBool("WEBGL_PACK")),at.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(F){if(X==null){const y=o(F);X=y.getParameter(y.MAX_TEXTURE_SIZE)}return X}(at.getNumber("WEBGL_VERSION"))),at.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(F){if(je==null){const y=o(F);je=y.getParameter(y.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,je)}(at.getNumber("WEBGL_VERSION"))),at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const F=at.getNumber("WEBGL_VERSION");return F===0?0:function(y){if(y===0)return 0;let k;const S=o(y);return k=Be(S,"EXT_disjoint_timer_query_webgl2")&&y===2?2:Be(S,"EXT_disjoint_timer_query")?1:0,k}(F)}),at.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>at.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!n.device_util.isMobile()),at.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(F){if(F===0)return!1;const y=o(F);if(F===1){if(!Be(y,"OES_texture_float"))return!1}else if(!Be(y,"EXT_color_buffer_float"))return!1;return Me(y)}(at.getNumber("WEBGL_VERSION"))),at.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!at.getBool("WEBGL_FORCE_F16_TEXTURES")&&at.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),at.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ct(at.getNumber("WEBGL_VERSION"))),at.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return(F=at.getNumber("WEBGL_VERSION"))===2&&o(F).fenceSync!=null;var F}),at.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>at.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),at.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,F=>{if(F<0&&F!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${F}.`)}),at.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>n.device_util.isMobile()?1:-1,F=>{if(F<0&&F!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${F}.`)}),at.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),at.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),at.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),at.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),at.registerFlag("WEBGL_EXP_CONV",()=>!1),at.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>at.getBool("IS_TEST"));const ee=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:se}=n.backend_util;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(F,y,k){const S=[];if(F.forEach(ae=>{const Re=n.util.sizeFromShape(ae.shapeInfo.logicalShape);if(ae.shapeInfo.isUniform?S.push(`uniform float ${ae.name}${Re>1?`[${Re}]`:""};`):(S.push(`uniform sampler2D ${ae.name};`),S.push(`uniform int offset${ae.name};`)),k.enableShapeUniforms){const{uniformShape:ke}=be(k.packedInputs,ae.shapeInfo.logicalShape,ae.shapeInfo.texShape);switch(ke.length){case 1:S.push(`uniform int ${ae.name}Shape;`);break;case 2:S.push(`uniform ivec2 ${ae.name}Shape;`);break;case 3:S.push(`uniform ivec3 ${ae.name}Shape;`);break;case 4:S.push(`uniform ivec4 ${ae.name}Shape;`)}S.push(`uniform ivec2 ${ae.name}TexShape;`)}}),k.enableShapeUniforms){switch(y.logicalShape.length){case 1:S.push("uniform int outShape;");break;case 2:S.push("uniform ivec2 outShape;"),S.push("uniform int outShapeStrides;");break;case 3:S.push("uniform ivec3 outShape;"),S.push("uniform ivec2 outShapeStrides;");break;case 4:S.push("uniform ivec4 outShape;"),S.push("uniform ivec3 outShapeStrides;")}S.push("uniform ivec2 outTexShape;")}k.customUniforms&&k.customUniforms.forEach(ae=>{S.push(`uniform ${ae.type} ${ae.name}${ae.arrayIndex?`[${ae.arrayIndex}]`:""};`)});const _=S.join(`
`),T=F.map(ae=>function(Re,ke,Ge=!1,qe){let Ne="";Ne+=Ge?bt(Re,qe):pt(Re,qe);const Ke=Re.shapeInfo.logicalShape,an=ke.logicalShape;return Ke.length<=an.length&&(Ne+=Ge?function(kn,Pn){const Xn=kn.name,Hn=Xn.charAt(0).toUpperCase()+Xn.slice(1),Qn="get"+Hn+"AtOutCoords",Wn=kn.shapeInfo.logicalShape.length,vs=Pn.logicalShape.length,fs=se(kn.shapeInfo.logicalShape,Pn.logicalShape),w=pe(vs),g=vs-Wn;let v;const C=["x","y","z","w","u","v"];v=Wn===0?"":vs<2&&fs.length>=1?"coords = 0;":fs.map(le=>`coords.${C[le+g]} = 0;`).join(`
`);let $="";$=vs<2&&Wn>0?"coords":kn.shapeInfo.logicalShape.map((le,ve)=>`coords.${C[ve+g]}`).join(", ");let M="return outputValue;";const W=n.util.sizeFromShape(kn.shapeInfo.logicalShape)===1,J=n.util.sizeFromShape(Pn.logicalShape)===1;if(Wn!==1||W||J){if(W&&!J)M=vs===1?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(fs.length){const le=Wn-2,ve=Wn-1;fs.indexOf(le)>-1&&fs.indexOf(ve)>-1?M="return vec4(outputValue.x);":fs.indexOf(le)>-1?M="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":fs.indexOf(ve)>-1&&(M="return vec4(outputValue.xx, outputValue.zz);")}}else M=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${Qn}() {
      ${w} coords = getOutputCoords();
      ${v}
      vec4 outputValue = get${Hn}(${$});
      ${M}
    }
  `}(Re,ke):function(kn,Pn){const Xn=kn.name,Hn=Xn.charAt(0).toUpperCase()+Xn.slice(1),Qn="get"+Hn+"AtOutCoords",Wn=Pn.texShape,vs=kn.shapeInfo.texShape,fs=kn.shapeInfo.logicalShape.length,w=Pn.logicalShape.length;if(!kn.shapeInfo.isUniform&&fs===w&&kn.shapeInfo.flatOffset==null&&n.util.arraysEqual(vs,Wn))return`
      float ${Qn}() {
        return sampleTexture(${Xn}, resultUV);
      }
    `;const g=pe(w),v=se(kn.shapeInfo.logicalShape,Pn.logicalShape),C=w-fs;let $;const M=["x","y","z","w","u","v"];$=fs===0?"":w<2&&v.length>=1?"coords = 0;":v.map(J=>`coords.${M[J+C]} = 0;`).join(`
`);let W="";return W=w<2&&fs>0?"coords":kn.shapeInfo.logicalShape.map((J,le)=>`coords.${M[le+C]}`).join(", "),`
    float ${Qn}() {
      ${g} coords = getOutputCoords();
      ${$}
      return get${Hn}(${W});
    }
  `}(Re,ke)),Ne}(ae,y,k.packedInputs,k.enableShapeUniforms)).join(`
`),O=y.texShape,B=Gt(),z=function(ae){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${ae.texture2D}(textureSampler, uv).r;
    }
  `}(B);let K,Q,ue=function(ae){return`${ae.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${ae.varyingFs} vec2 resultUV;
    ${ae.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${ae.defineSpecialNaN}
    ${ae.defineSpecialInf}
    ${ae.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${At}
    ${$e}
    ${ht}
  `}(B);return y.isPacked?(K=function(ae,Re,ke){switch(ae.length){case 0:return Ot();case 1:return function(Ge,qe,Ne){const Ke=[Math.ceil(qe[0]/2),Math.ceil(qe[1]/2)];return Ke[0]===1?Ne?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${Ke[1]}.0);
      }
    `:Ke[1]===1?Ne?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${Ke[0]}.0);
      }
    `:Ne?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Ke[0]}, ${Ke[1]}));
      return 2 * (resTexRC.x * ${Ke[1]} + resTexRC.y);
    }
  `}(0,Re,ke);case 2:return function(Ge,qe,Ne){const Ke=[Math.ceil(qe[0]/2),Math.ceil(qe[1]/2)];if(n.util.arraysEqual(Ge,qe))return Ne?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${Ke[0]}, ${Ke[1]}));
      }
    `;const an=Math.ceil(Ge[1]/2);return Ne?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Ke[0]}, ${Ke[1]}));

      int index = resTexRC.x * ${Ke[1]} + resTexRC.y;
      int r = 2 * (index / ${an});
      int c = imod(index, ${an}) * 2;

      return ivec2(r, c);
    }
  `}(ae,Re,ke);case 3:return function(Ge,qe,Ne){if(Ne)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const Ke=[Math.ceil(qe[0]/2),Math.ceil(qe[1]/2)],an=Math.ceil(Ge[2]/2),kn=an*Math.ceil(Ge[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Ke[0]}, ${Ke[1]}));
      int index = resTexRC.x * ${Ke[1]} + resTexRC.y;

      int b = index / ${kn};
      index -= b * ${kn};

      int r = 2 * (index / ${an});
      int c = imod(index, ${an}) * 2;

      return ivec3(b, r, c);
    }
  `}(ae,Re,ke);default:return function(Ge,qe,Ne){if(Ne)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const Ke=[Math.ceil(qe[0]/2),Math.ceil(qe[1]/2)],an=Math.ceil(Ge[Ge.length-1]/2),kn=an*Math.ceil(Ge[Ge.length-2]/2);let Pn=kn,Xn="",Hn="b, r, c";for(let Qn=2;Qn<Ge.length-1;Qn++)Pn*=Ge[Ge.length-Qn-1],Xn=`
      int b${Qn} = index / ${Pn};
      index -= b${Qn} * ${Pn};
    `+Xn,Hn=`b${Qn}, `+Hn;return`
    ivec${Ge.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Ke[0]}, ${Ke[1]}));
      int index = resTexRC.x * ${Ke[1]} + resTexRC.y;

      ${Xn}

      int b = index / ${kn};
      index -= b * ${kn};

      int r = 2 * (index / ${an});
      int c = imod(index, ${an}) * 2;

      return ivec${Ge.length}(${Hn});
    }
  `}(ae,Re,ke)}}(y.logicalShape,O,k.enableShapeUniforms),Q=function(ae){return`
    void setOutput(vec4 val) {
      ${ae.output} = val;
    }
  `}(B)):(K=function(ae,Re,ke){switch(ae.length){case 0:return Ot();case 1:return function(Ge,qe,Ne){return qe[0]===1?Ne?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${qe[1]}.0);
      }
    `:qe[1]===1?Ne?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${qe[0]}.0);
      }
    `:Ne?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${qe[0]}, ${qe[1]}));
      return resTexRC.x * ${qe[1]} + resTexRC.y;
    }
  `}(0,Re,ke);case 2:return function(Ge,qe,Ne){return n.util.arraysEqual(Ge,qe)?Ne?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${qe[0]}, ${qe[1]}));
      }
    `:Ge[1]===1?Ne?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${qe[0]}, ${qe[1]}));
        int index = resTexRC.x * ${qe[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:Ge[0]===1?Ne?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${qe[0]}, ${qe[1]}));
        int index = resTexRC.x * ${qe[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:Ne?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${qe[0]}, ${qe[1]}));
      int index = resTexRC.x * ${qe[1]} + resTexRC.y;
      int r = index / ${Ge[1]};
      int c = index - r * ${Ge[1]};
      return ivec2(r, c);
    }
  `}(ae,Re,ke);case 3:return function(Ge,qe,Ne){if(Ne)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${dn(["r","c","d"],Ge)}
    return ivec3(r, c, d);
  }
`;const Ke=Ht(["r","c","d"],Ge);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${qe[0]}, ${qe[1]}));
      int index = resTexRC.x * ${qe[1]} + resTexRC.y;
      ${Ke}
      return ivec3(r, c, d);
    }
  `}(ae,Re,ke);case 4:return function(Ge,qe,Ne){if(Ne)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${dn(["r","c","d","d2"],Ge)}
      return ivec4(r, c, d, d2);
    }
  `;const Ke=Ht(["r","c","d","d2"],Ge);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${qe[0]}, ${qe[1]}));
      int index = resTexRC.x * ${qe[1]} + resTexRC.y;
      ${Ke}
      return ivec4(r, c, d, d2);
    }
  `}(ae,Re,ke);case 5:return function(Ge,qe){const Ne=Ht(["r","c","d","d2","d3"],Ge);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${qe[0]},
                             ${qe[1]}));

      int index = resTexRC.x * ${qe[1]} + resTexRC.y;

      ${Ne}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}(ae,Re);case 6:return function(Ge,qe){const Ne=Ht(["r","c","d","d2","d3","d4"],Ge);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${qe[0]}, ${qe[1]}));
      int index = resTexRC.x * ${qe[1]} + resTexRC.y;

      ${Ne}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}(ae,Re);default:throw new Error(`${ae.length}-D output sampling is not yet supported`)}}(y.logicalShape,O,k.enableShapeUniforms),Q=function(ae){return`
    void setOutput(float val) {
      ${ae.output} = vec4(val, 0, 0, 0);
    }
  `}(B)),k.packedInputs&&(ue+=Pt),[ue,z,Q,_,K,T,k.userCode].join(`
`)}function pt(F,y=!1){const k=F.shapeInfo.logicalShape;switch(k.length){case 0:return function(S,_){const T=S.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1);if(S.shapeInfo.isUniform)return`float ${O}() {return ${T};}`;const[B,z]=S.shapeInfo.texShape;if(B===1&&z===1)return`
      float ${O}() {
        return sampleTexture(${T}, halfCR);
      }
    `;const K=xn(T);if(_)return`
    float ${O}() {
      vec2 uv = uvFromFlat(${T}TexShape[0], ${T}TexShape[1], ${K});
      return sampleTexture(${T}, uv);
    }
  `;const[Q,ue]=S.shapeInfo.texShape;return`
    float ${O}() {
      vec2 uv = uvFromFlat(${Q}, ${ue}, ${K});
      return sampleTexture(${T}, uv);
    }
  `}(F,y);case 1:return function(S,_){const T=S.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1);if(S.shapeInfo.isUniform)return`
      float ${O}(int index) {
        ${Dn(S)}
      }
    `;const B=S.shapeInfo.texShape,z=B[0],K=B[1];if(K===1&&z===1)return`
      float ${O}(int index) {
        return sampleTexture(${T}, halfCR);
      }
    `;const Q=xn(T);return K===1?_?`
      float ${O}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${Q}) + 0.5) / float(${T}TexShape[0]));
        return sampleTexture(${T}, uv);
      }
    `:`
      float ${O}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${Q}) + 0.5) / ${z}.0);
        return sampleTexture(${T}, uv);
      }
    `:z===1?_?`
      float ${O}(int index) {
        vec2 uv = vec2((float(index + ${Q}) + 0.5) / float(${T}TexShape[1]), 0.5);
        return sampleTexture(${T}, uv);
      }
    `:`
      float ${O}(int index) {
        vec2 uv = vec2((float(index + ${Q}) + 0.5) / ${K}.0, 0.5);
        return sampleTexture(${T}, uv);
      }
    `:_?`
    float ${O}(int index) {
      vec2 uv = uvFromFlat(${T}TexShape[0], ${T}TexShape[1], index + ${Q});
      return sampleTexture(${T}, uv);
    }
  `:`
    float ${O}(int index) {
      vec2 uv = uvFromFlat(${z}, ${K}, index + ${Q});
      return sampleTexture(${T}, uv);
    }
  `}(F,y);case 2:return function(S,_){const T=S.shapeInfo.logicalShape,O=S.name,B="get"+O.charAt(0).toUpperCase()+O.slice(1),z=S.shapeInfo.texShape;if(z!=null&&n.util.arraysEqual(T,z)){if(_)return`
      float ${B}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${O}TexShape[1], ${O}TexShape[0]);
        return sampleTexture(${O}, uv);
      }
    `;const Ge=z[0];return`
    float ${B}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${z[1]}.0, ${Ge}.0);
      return sampleTexture(${O}, uv);
    }
  `}const{newShape:K,keptDims:Q}=n.util.squeezeShape(T),ue=K;if(ue.length<T.length){const Ge=["row","col"];return`
      ${pt(Qe(S,ue),_)}
      float ${B}(int row, int col) {
        return ${B}(${Un(Ge,Q)});
      }
    `}if(S.shapeInfo.isUniform)return`
      float ${B}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${T[1]}, 1)));
        ${Dn(S)}
      }
    `;const ae=z[0],Re=z[1],ke=xn(O);return Re===1?_?`
      float ${B}(int row, int col) {
        float index = dot(vec3(row, col, ${ke}), vec3(${O}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${O}TexShape[0]));
        return sampleTexture(${O}, uv);
      }
    `:`
    float ${B}(int row, int col) {
      float index = dot(vec3(row, col, ${ke}), vec3(${T[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${ae}.0);
      return sampleTexture(${O}, uv);
    }
  `:ae===1?_?`
      float ${B}(int row, int col) {
        float index = dot(vec3(row, col, ${ke}), vec3(${O}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${O}TexShape[1]), 0.5);
        return sampleTexture(${O}, uv);
      }
    `:`
    float ${B}(int row, int col) {
      float index = dot(vec3(row, col, ${ke}), vec3(${T[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${Re}.0, 0.5);
      return sampleTexture(${O}, uv);
    }
  `:_?`
      float ${B}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${O}Shape[1] + col + ${ke};
        vec2 uv = uvFromFlat(${O}TexShape[0], ${O}TexShape[1], index);
        return sampleTexture(${O}, uv);
      }
    `:`
  float ${B}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${T[1]} + col + ${ke};
    vec2 uv = uvFromFlat(${ae}, ${Re}, index);
    return sampleTexture(${O}, uv);
  }
`}(F,y);case 3:return function(S,_){const T=S.shapeInfo.logicalShape,O=S.name,B="get"+O.charAt(0).toUpperCase()+O.slice(1),z=T[1]*T[2],K=T[2],{newShape:Q,keptDims:ue}=n.util.squeezeShape(T),ae=Q;if(ae.length<T.length){const Ke=["row","col","depth"];return`
        ${pt(Qe(S,ae),_)}
        float ${B}(int row, int col, int depth) {
          return ${B}(${Un(Ke,ue)});
        }
      `}if(S.shapeInfo.isUniform)return`
      float ${B}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${z}, ${K}, 1)));
        ${Dn(S)}
      }
    `;const Re=S.shapeInfo.texShape,ke=Re[0],Ge=Re[1],qe=S.shapeInfo.flatOffset;if(Ge===z&&qe==null)return _?`
      float ${B}(int row, int col, int depth) {
        int stride1 = ${O}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${O}TexShape[1], ${O}TexShape[0]);
        return sampleTexture(${O}, uv);
      }
    `:`
        float ${B}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${K}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${Ge}.0, ${ke}.0);
          return sampleTexture(${O}, uv);
        }
      `;if(Ge===K&&qe==null)return _?`
      float ${B}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${O}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${O}TexShape[1], ${O}TexShape[0]);
        return sampleTexture(${O}, uv);
      }
    `:`
    float ${B}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${T[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Ge}.0, ${ke}.0);
      return sampleTexture(${O}, uv);
    }
  `;const Ne=xn(O);return _?`
    float ${B}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${O}Shape[1] * ${O}Shape[2];
      int stride1 = ${O}Shape[2];
      int index = row * ${z} + col * ${K} + depth + ${Ne};
      vec2 uv = uvFromFlat(${O}TexShape[0], ${O}TexShape[1], index);
      return sampleTexture(${O}, uv);
    }
    `:`
      float ${B}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${z} + col * ${K} + depth + ${Ne};
        vec2 uv = uvFromFlat(${ke}, ${Ge}, index);
        return sampleTexture(${O}, uv);
      }
  `}(F,y);case 4:return function(S,_){const T=S.shapeInfo.logicalShape,O=S.name,B="get"+O.charAt(0).toUpperCase()+O.slice(1),z=T[3],K=T[2]*z,Q=T[1]*K,{newShape:ue,keptDims:ae}=n.util.squeezeShape(T);if(ue.length<T.length){const Pn=["row","col","depth","depth2"];return`
      ${pt(Qe(S,ue),_)}
      float ${B}(int row, int col, int depth, int depth2) {
        return ${B}(${Un(Pn,ae)});
      }
    `}if(S.shapeInfo.isUniform)return`
      float ${B}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${Q}, ${K}, ${z}, 1)));
        ${Dn(S)}
      }
    `;const Re=S.shapeInfo.flatOffset,ke=S.shapeInfo.texShape,Ge=ke[0],qe=ke[1],Ne=`int stride2 = ${O}Shape[3];`,Ke=`int stride1 = ${O}Shape[2] * stride2;`,an=`int stride0 = ${O}Shape[1] * stride1;`;if(qe===Q&&Re==null)return _?`
      float ${B}(int row, int col, int depth, int depth2) {
        ${Ne}
        ${Ke}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${O}TexShape[1], ${O}TexShape[0]);
        return sampleTexture(${O}, uv);
      }
    `:`
      float ${B}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${K}, ${z}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${qe}.0, ${Ge}.0);
        return sampleTexture(${O}, uv);
      }
    `;if(qe===z&&Re==null)return _?`
      float ${B}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${O}Shape[1] * ${O}Shape[2], ${O}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${O}TexShape[1], ${O}TexShape[0]);
        return sampleTexture(${O}, uv);
      }
    `:`
      float ${B}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${T[1]*T[2]}, ${T[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${qe}.0, ${Ge}.0);
        return sampleTexture(${O}, uv);
      }
    `;const kn=xn(O);return _?`
    float ${B}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${Ne}
      ${Ke}
      ${an}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${O}TexShape[0], ${O}TexShape[1], index + ${kn});
      return sampleTexture(${O}, uv);
    }
  `:`
    float ${B}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${Q} + col * ${K} +
          depth * ${z} + depth2;
      vec2 uv = uvFromFlat(${Ge}, ${qe}, index + ${kn});
      return sampleTexture(${O}, uv);
    }
  `}(F,y);case 5:return function(S){const _=S.shapeInfo.logicalShape,T=S.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1),B=_[4],z=_[3]*B,K=_[2]*z,Q=_[1]*K,{newShape:ue,keptDims:ae}=n.util.squeezeShape(_);if(ue.length<_.length){const Ke=["row","col","depth","depth2","depth3"];return`
      ${pt(Qe(S,ue))}
      float ${O}(int row, int col, int depth, int depth2, int depth3) {
        return ${O}(${Un(Ke,ae)});
      }
    `}if(S.shapeInfo.isUniform)return`
      float ${O}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${Q}, ${K}, ${z}, ${B})) +
          depth3;
        ${Dn(S)}
      }
    `;const Re=S.shapeInfo.flatOffset,ke=S.shapeInfo.texShape,Ge=ke[0],qe=ke[1];if(qe===Q&&Re==null)return`
      float ${O}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${K}, ${z}, ${B}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${qe}.0, ${Ge}.0);
        return sampleTexture(${T}, uv);
      }
    `;if(qe===B&&Re==null)return`
      float ${O}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${_[1]*_[2]*_[3]},
               ${_[2]*_[3]}, ${_[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${qe}.0, ${Ge}.0);
        return sampleTexture(${T}, uv);
      }
    `;const Ne=xn(T);return`
    float ${O}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${Q} + col * ${K} + depth * ${z} +
          depth2 * ${B} + depth3 + ${Ne};
      vec2 uv = uvFromFlat(${Ge}, ${qe}, index);
      return sampleTexture(${T}, uv);
    }
  `}(F);case 6:return function(S){const _=S.shapeInfo.logicalShape,T=S.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1),{newShape:B,keptDims:z}=n.util.squeezeShape(_);if(B.length<_.length){const an=["row","col","depth","depth2","depth3","depth4"];return`
      ${pt(Qe(S,B))}
      float ${O}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${O}(${Un(an,z)});
      }
    `}const K=_[5],Q=_[4]*K,ue=_[3]*Q,ae=_[2]*ue,Re=_[1]*ae;if(S.shapeInfo.isUniform)return`
      float ${O}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${Re}, ${ae}, ${ue}, ${Q})) +
          dot(
            vec2(depth3, depth4),
            vec2(${K}, 1)));
        ${Dn(S)}
      }
    `;const ke=S.shapeInfo.flatOffset,Ge=S.shapeInfo.texShape,qe=Ge[0],Ne=Ge[1];if(Ne===Re&&ke==null)return`
      float ${O}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${ae}, ${ue}, ${Q}, ${K})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Ne}.0, ${qe}.0);
        return sampleTexture(${T}, uv);
      }
    `;if(Ne===K&&ke==null)return`
      float ${O}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${_[1]*_[2]*_[3]*_[4]},
               ${_[2]*_[3]*_[4]},
               ${_[3]*_[4]},
               ${_[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Ne}.0, ${qe}.0);
        return sampleTexture(${T}, uv);
      }
    `;const Ke=xn(T);return`
    float ${O}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${Re} + col * ${ae} + depth * ${ue} +
          depth2 * ${Q} + depth3 * ${K} + depth4 + ${Ke};
      vec2 uv = uvFromFlat(${qe}, ${Ne}, index);
      return sampleTexture(${T}, uv);
    }
  `}(F);default:throw new Error(`${k.length}-D input sampling is not yet supported`)}}function bt(F,y){switch(F.shapeInfo.logicalShape.length){case 0:return function(k){const S=k.name,_="get"+S.charAt(0).toUpperCase()+S.slice(1),T=Gt();return`
    vec4 ${_}() {
      return ${T.texture2D}(${S}, halfCR);
    }
  `}(F);case 1:return function(k,S){const _=k.name,T="get"+_.charAt(0).toUpperCase()+_.slice(1),O=k.shapeInfo.texShape,B=Gt();if(S)return`
    vec4 ${T}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${_}TexShape[0]) / 2.0), ceil(float(${_}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${B.texture2D}(${_}, uv);
    }
  `;const z=[Math.ceil(O[0]/2),Math.ceil(O[1]/2)];return`
    vec4 ${T}(int index) {
      vec2 uv = packedUVfrom1D(
        ${z[0]}, ${z[1]}, index);
      return ${B.texture2D}(${_}, uv);
    }
  `}(F,y);case 2:return function(k,S){const _=k.shapeInfo.logicalShape,T=k.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1),B=k.shapeInfo.texShape,z=B[0],K=B[1],Q=Gt();if(B!=null&&n.util.arraysEqual(_,B))return S?`
      vec4 ${O}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${T}TexShape[1], ${T}TexShape[0]);

        return ${Q.texture2D}(${T}, uv);
      }
    `:`
      vec4 ${O}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${K}.0, ${z}.0);

        return ${Q.texture2D}(${T}, uv);
      }
    `;if(S)return`
    vec4 ${O}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${T}TexShape[0]) / 2.0), ceil(float(${T}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${T}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${Q.texture2D}(${T}, uv);
    }
  `;const ue=[Math.ceil(B[0]/2),Math.ceil(B[1]/2)],ae=Math.ceil(_[1]/2);return`
    vec4 ${O}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ae}, ${ue[0]}, ${ue[1]}, row, col);
      return ${Q.texture2D}(${T}, uv);
    }
  `}(F,y);case 3:return function(k,S){const _=k.shapeInfo.logicalShape,T=k.name,O="get"+T.charAt(0).toUpperCase()+T.slice(1),B=k.shapeInfo.texShape,z=[Math.ceil(B[0]/2),Math.ceil(B[1]/2)];if(_[0]===1){const ke=[1,2],Ge=["b","row","col"];return`
        ${bt(Qe(k,_.slice(1)),S)}
        vec4 ${O}(int b, int row, int col) {
          return ${O}(${Un(Ge,ke)});
        }
      `}const K=Gt();if(S)return`
    vec4 ${O}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${T}TexShape[0]) / 2.0), ceil(float(${T}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${T}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${T}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${K.texture2D}(${T}, uv);
    }
  `;const Q=z[0],ue=z[1],ae=Math.ceil(_[2]/2),Re=ae*Math.ceil(_[1]/2);return`
    vec4 ${O}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${Q}, ${ue}, ${Re}, ${ae}, b, row, col);
      return ${K.texture2D}(${T}, uv);
    }
  `}(F,y);default:return function(k,S){const _=k.name,T="get"+_.charAt(0).toUpperCase()+_.slice(1),O=Gt();if(S)return`
    vec4 ${T}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${_}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${_}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${_}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${_}TexShape[0]) / 2.0), ceil(float(${_}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${O.texture2D}(${_}, uv);
    }
  `;const B=k.shapeInfo.logicalShape,z=B.length,K=k.shapeInfo.texShape,Q=[Math.ceil(K[0]/2),Math.ceil(K[1]/2)],ue=Q[0],ae=Q[1],Re=Math.ceil(B[z-1]/2);let ke=Re*Math.ceil(B[z-2]/2),Ge="int b, int row, int col",qe=`b * ${ke} + (row / 2) * ${Re} + (col / 2)`;for(let Ne=2;Ne<z-1;Ne++)Ge=`int b${Ne}, `+Ge,ke*=B[z-Ne-1],qe=`b${Ne} * ${ke} + `+qe;return`
    vec4 ${T}(${Ge}) {
      int index = ${qe};
      int texR = index / ${ae};
      int texC = index - texR * ${ae};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${ae}, ${ue});
      return ${O.texture2D}(${_}, uv);
    }
  `}(F,y)}}const At=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ht=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Pt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Ot(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function xn(F){return`offset${F}`}function Dn(F){const y=F.name,k=n.util.sizeFromShape(F.shapeInfo.logicalShape);return k<2?`return ${y};`:`
    for (int i = 0; i < ${k}; i++) {
      if (i == index) {
        return ${y}[i];
      }
    }
  `}function pe(F){if(F<=1)return"int";if(F===2)return"ivec2";if(F===3)return"ivec3";if(F===4)return"ivec4";if(F===5)return"ivec5";if(F===6)return"ivec6";throw Error(`GPU for rank ${F} is not yet supported`)}function be(F,y,k){const{newShape:S,keptDims:_}=n.util.squeezeShape(y),T=y.length,O=F&&T===3&&y[0]===1,B=O?y.slice(1):S,z=!F&&T>1&&!n.util.arraysEqual(y,k)&&S.length<T||O;return{useSqueezeShape:z,uniformShape:z?B:y,keptDims:_}}function Qe(F,y){const k=JSON.parse(JSON.stringify(F));return k.shapeInfo.logicalShape=y,k}function Un(F,y){return y.map(k=>F[k]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ws(F,y,k,S){const _=k.map((Q,ue)=>{const ae={logicalShape:Q.shape,texShape:Q.isUniform?null:Q.texData.texShape,isUniform:Q.isUniform,isPacked:!Q.isUniform&&Q.texData.isPacked,flatOffset:null};return Q.texData!=null&&Q.texData.slice!=null&&Q.texData.slice.flatOffset>0&&(ae.flatOffset=Q.texData.slice.flatOffset),{name:y.variableNames[ue],shapeInfo:ae}}),T=_.map(Q=>Q.shapeInfo),O={logicalShape:S.shape,texShape:S.texData.texShape,isUniform:!1,isPacked:S.texData.isPacked,flatOffset:null},B=we(_,O,y),z=function(Q,ue){const ae=V(Q,()=>Q.createShader(Q.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(f(Q,()=>Q.shaderSource(ae,ue)),f(Q,()=>Q.compileShader(ae)),Object(n.env)().get("ENGINE_COMPILE_ONLY"))return ae;if(Q.getShaderParameter(ae,Q.COMPILE_STATUS)===!1)throw I(ue,Q.getShaderInfoLog(ae)),new Error("Failed to compile fragment shader.");return ae}(F.gl,B),K=F.createProgram(z);return Object(n.env)().get("ENGINE_COMPILE_ONLY")?{program:y,fragmentShader:z,source:B,webGLProgram:K,inShapeInfos:T,outShapeInfo:O,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:y,fragmentShader:z,source:B,webGLProgram:K,inShapeInfos:T,outShapeInfo:O},Gs(F,y,K))}function Gs(F,y,k){const S={},_={},T={},O=[];let B,z,K,Q=null,ue=null;ue=F.getUniformLocation(k,"NAN",!1),Object(n.env)().getNumber("WEBGL_VERSION")===1&&(Q=F.getUniformLocation(k,"INFINITY",!1));const ae=!1;for(let Re=0;Re<y.variableNames.length;Re++){const ke=y.variableNames[Re];S[ke]=F.getUniformLocation(k,ke,ae),S[`offset${ke}`]=F.getUniformLocation(k,`offset${ke}`,ae),y.enableShapeUniforms&&(_[`${ke}Shape`]=F.getUniformLocation(k,`${ke}Shape`,ae),T[`${ke}TexShape`]=F.getUniformLocation(k,`${ke}TexShape`,ae))}return y.enableShapeUniforms&&(B=F.getUniformLocation(k,"outShape",ae),K=F.getUniformLocation(k,"outShapeStrides",ae),z=F.getUniformLocation(k,"outTexShape",ae)),y.customUniforms&&y.customUniforms.forEach((Re,ke)=>{O[ke]=F.getUniformLocation(k,Re.name,ae)}),{uniformLocations:S,customUniformLocations:O,infLoc:Q,nanLoc:ue,inShapesLocations:_,inTexShapesLocations:T,outShapeLocation:B,outShapeStridesLocation:K,outTexShapeLocation:z}}function As(F,y){if(F.length!==y.length)throw Error(`Binary was compiled with ${F.length} inputs, but was executed with ${y.length} inputs`);F.forEach((k,S)=>{const _=k.logicalShape,T=y[S],O=T.shape;if(!n.util.arraysEqual(_,O))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${_} and ${O} must match`);if(k.isUniform&&T.isUniform)return;const B=k.texShape,z=T.isUniform?null:T.texData.texShape;if(!n.util.arraysEqual(B,z))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${B} and ${z} must match`)})}function xs(F){return Object(n.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&F<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ds{constructor(y){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=i.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const k=Gt();this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?dn(["r","c","d"],y):Ht(["r","c","d"],y)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${k.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ys{constructor(y){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=i.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const k=Gt();this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?dn(["r","c","d"],y):Ht(["r","c","d"],y)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${k.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pn{constructor(y){this.variableNames=["A"],this.outTexUsage=u.DOWNLOAD;const k=Gt();this.outputShape=y,this.userCode=`
      ${ee}

      void main() {
        float x = getAAtOutCoords();
        ${k.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nn{constructor(y){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=u.DOWNLOAD;const k=Gt();this.outputShape=y,this.userCode=`
      ${ee}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${k.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ts{constructor(y,k=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const S=Gt();this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length);let _="result";k&&(_="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:Rn(y)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${S.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${S.output} = vec4(${_}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $s{constructor(y,k=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const S=Gt();this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length);let _="",T="result";k&&(T="floor(result * 255. + 0.5)");for(let O=0;O<=1;O++)for(let B=0;B<=1;B++){const z=2*O+B;_+=`
          localCoords = coords;
          if(localCoords[2] + ${B} < ${this.enableShapeUniforms?"outShape[2]":`${y[2]}`}) {
          localCoords[2] += ${B};
          if (localCoords[1] + ${O} < ${this.enableShapeUniforms?"outShape[1]":`${y[1]}`}) {
            localCoords[1] += ${O};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${S.texture2D}(A, uv);

            if (offset == 0) {
              result[${z}] = values[0];
            } else if (offset == 1) {
              result[${z}] = values[1];
            } else if (offset == 2) {
              result[${z}] = values[2];
            } else {
              result[${z}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:Rn(y)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${_}

          ${S.output} = ${T};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ns(F){const y=Gt();return function(k,S){const _=V(k,()=>k.createShader(k.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(f(k,()=>k.shaderSource(_,S)),f(k,()=>k.compileShader(_)),k.getShaderParameter(_,k.COMPILE_STATUS)===!1)throw console.log(k.getShaderInfoLog(_)),new Error("Failed to compile vertex shader.");return _}(F,`${y.version}
    precision highp float;
    ${y.attribute} vec3 clipSpacePos;
    ${y.attribute} vec2 uv;
    ${y.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function ys(F){return function(y,k){const S=V(y,()=>y.createBuffer(),"Unable to create WebGLBuffer");return f(y,()=>y.bindBuffer(y.ARRAY_BUFFER,S)),f(y,()=>y.bufferData(y.ARRAY_BUFFER,k,y.STATIC_DRAW)),S}(F,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Vs(F){return function(y,k){const S=V(y,()=>y.createBuffer(),"Unable to create WebGLBuffer");return f(y,()=>y.bindBuffer(y.ELEMENT_ARRAY_BUFFER,S)),f(y,()=>y.bufferData(y.ELEMENT_ARRAY_BUFFER,k,y.STATIC_DRAW)),S}(F,new Uint16Array([0,1,2,2,1,3]))}function Us(F,y,k,S,_,T){(function(z,K){const Q=Object(n.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(z<=0||K<=0)throw new Error(`Requested texture size [${z}x${K}] is invalid.`);if(z>Q||K>Q)throw new Error(`Requested texture size [${z}x${K}] greater than WebGL maximum on this browser / GPU [${Q}x${Q}].`)})(y,k);const O=function(z){return V(z,()=>z.createTexture(),"Unable to create WebGLTexture.")}(F),B=F.TEXTURE_2D;return f(F,()=>F.bindTexture(B,O)),f(F,()=>F.texParameteri(B,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE)),f(F,()=>F.texParameteri(B,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE)),f(F,()=>F.texParameteri(B,F.TEXTURE_MIN_FILTER,F.NEAREST)),f(F,()=>F.texParameteri(B,F.TEXTURE_MAG_FILTER,F.NEAREST)),Object(n.env)().getNumber("WEBGL_VERSION")===1?f(F,()=>F.texImage2D(B,0,S,y,k,0,_,T,null)):f(F,()=>F.texStorage2D(B,1,S,y,k)),f(F,()=>F.bindTexture(F.TEXTURE_2D,null)),{texture:O,texShape:[k,y]}}function jt(F){return F.internalFormatFloat}function re(F){return F.internalFormatHalfFloat}function de(F){return F.downloadTextureFormat}function ot(F){return F.internalFormatPackedFloat}function Ct(F){return F.internalFormatPackedHalfFloat}function Yt(F,y,k,S,_,T,O,B){const z=F,K=new Float32Array(function(Q,ue){const[ae,Re]=l(Q,ue);return ae*Re*4}(T,O));return z.bindBuffer(z.PIXEL_PACK_BUFFER,y),z.getBufferSubData(z.PIXEL_PACK_BUFFER,0,K),z.bindBuffer(z.PIXEL_PACK_BUFFER,null),K}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class on{constructor(y){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const k=Object(n.env)().getNumber("WEBGL_VERSION");y!=null?(this.gl=y,function(T,O){r[T]=O}(k,y)):this.gl=o(k);let S="WEBGL_color_buffer_float";const _="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Object(n.env)().getNumber("WEBGL_VERSION")===1){const T="OES_texture_float",O="OES_texture_half_float";if(this.textureFloatExtension=b(this.gl,T),Be(this.gl,O))this.textureHalfFloatExtension=b(this.gl,O);else if(Object(n.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(S),Be(this.gl,_))this.colorBufferHalfFloatExtension=b(this.gl,_);else if(Object(n.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(S="EXT_color_buffer_float",Be(this.gl,S))this.colorBufferFloatExtension=this.gl.getExtension(S);else{if(!Be(this.gl,_))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(_)}this.vertexBuffer=ys(this.gl),this.indexBuffer=Vs(this.gl),this.framebuffer=function(T){return V(T,()=>T.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=p(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(n.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const y=this.gl;f(y,()=>y.finish()),f(y,()=>y.bindFramebuffer(y.FRAMEBUFFER,null)),f(y,()=>y.deleteFramebuffer(this.framebuffer)),f(y,()=>y.bindBuffer(y.ARRAY_BUFFER,null)),f(y,()=>y.bindBuffer(y.ELEMENT_ARRAY_BUFFER,null)),f(y,()=>y.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(y,k){return this.throwIfDisposed(),function(S,_,T,O){const[B,z]=d(_,T);return Us(S,B,z,jt(O),O.textureFormatFloat,S.FLOAT)}(this.gl,y,k,this.textureConfig)}createFloat16MatrixTexture(y,k){return this.throwIfDisposed(),function(S,_,T,O){const[B,z]=d(_,T);return Us(S,B,z,re(O),O.textureFormatFloat,O.textureTypeHalfFloat)}(this.gl,y,k,this.textureConfig)}createUnsignedBytesMatrixTexture(y,k){return this.throwIfDisposed(),function(S,_,T,O){const[B,z]=d(_,T);return Us(S,B,z,de(O),S.RGBA,S.UNSIGNED_BYTE)}(this.gl,y,k,this.textureConfig)}uploadPixelDataToTexture(y,k){this.throwIfDisposed(),function(S,_,T){f(S,()=>S.bindTexture(S.TEXTURE_2D,_)),T.data instanceof Uint8Array?Object(n.env)().getNumber("WEBGL_VERSION")===2?f(S,()=>S.texSubImage2D(S.TEXTURE_2D,0,0,0,T.width,T.height,S.RGBA,S.UNSIGNED_BYTE,T.data)):f(S,()=>S.texImage2D(S.TEXTURE_2D,0,S.RGBA,T.width,T.height,0,S.RGBA,S.UNSIGNED_BYTE,T.data)):Object(n.env)().getNumber("WEBGL_VERSION")===2?f(S,()=>S.texSubImage2D(S.TEXTURE_2D,0,0,0,S.RGBA,S.UNSIGNED_BYTE,T)):f(S,()=>S.texImage2D(S.TEXTURE_2D,0,S.RGBA,S.RGBA,S.UNSIGNED_BYTE,T)),f(S,()=>S.bindTexture(S.TEXTURE_2D,null))}(this.gl,y,k)}uploadDenseMatrixToTexture(y,k,S,_){this.throwIfDisposed(),function(T,O,B,z,K,Q){let ue,ae,Re;f(T,()=>T.bindTexture(T.TEXTURE_2D,O)),K instanceof Uint8Array?(ue=new Uint8Array(B*z*4),ae=T.UNSIGNED_BYTE,Re=T.RGBA):(ue=new Float32Array(B*z*4),ae=T.FLOAT,Re=Q.internalFormatPackedFloat),ue.set(K),Object(n.env)().getNumber("WEBGL_VERSION")===2?f(T,()=>T.texSubImage2D(T.TEXTURE_2D,0,0,0,B,z,T.RGBA,ae,ue)):f(T,()=>T.texImage2D(T.TEXTURE_2D,0,Re,B,z,0,T.RGBA,ae,ue)),f(T,()=>T.bindTexture(T.TEXTURE_2D,null))}(this.gl,y,k,S,_,this.textureConfig)}createFloat16PackedMatrixTexture(y,k){return this.throwIfDisposed(),function(S,_,T,O){const[B,z]=l(_,T);return Us(S,B,z,Ct(O),S.RGBA,O.textureTypeHalfFloat)}(this.gl,y,k,this.textureConfig)}createPackedMatrixTexture(y,k){return this.throwIfDisposed(),function(S,_,T,O){const[B,z]=l(_,T);return Us(S,B,z,ot(O),S.RGBA,S.FLOAT)}(this.gl,y,k,this.textureConfig)}deleteMatrixTexture(y){this.throwIfDisposed(),this.outputTexture===y&&(L(this.gl,this.framebuffer),this.outputTexture=null),f(this.gl,()=>this.gl.deleteTexture(y))}downloadByteEncodedFloatMatrixFromOutputTexture(y,k,S){return this.downloadMatrixDriver(y,()=>function(_,T,O,B){const[z,K]=d(T,O),Q=new Uint8Array(T*O*4);return f(_,()=>_.readPixels(0,0,z,K,B.downloadTextureFormat,_.UNSIGNED_BYTE,Q)),new Float32Array(Q.buffer)}(this.gl,k,S,this.textureConfig))}downloadPackedMatrixFromBuffer(y,k,S,_,T,O){return Yt(this.gl,y,0,0,0,T,O,this.textureConfig)}downloadFloat32MatrixFromBuffer(y,k){return function(S,_,T){const O=S,B=new Float32Array(T);return O.bindBuffer(O.PIXEL_PACK_BUFFER,_),O.getBufferSubData(O.PIXEL_PACK_BUFFER,0,B),O.bindBuffer(O.PIXEL_PACK_BUFFER,null),B}(this.gl,y,k)}createBufferFromTexture(y,k,S){this.bindTextureToFrameBuffer(y);const _=function(T,O,B,z){const K=T.createBuffer();f(T,()=>T.bindBuffer(T.PIXEL_PACK_BUFFER,K));const Q=16*O*B;return f(T,()=>T.bufferData(T.PIXEL_PACK_BUFFER,Q,T.STREAM_READ)),f(T,()=>T.readPixels(0,0,B,O,T.RGBA,T.FLOAT,0)),f(T,()=>T.bindBuffer(T.PIXEL_PACK_BUFFER,null)),K}(this.gl,k,S,this.textureConfig);return this.unbindTextureToFrameBuffer(),_}createAndWaitForFence(){const y=this.createFence(this.gl);return this.pollFence(y)}createFence(y){let k,S;if(Object(n.env)().getBool("WEBGL_FENCE_API_ENABLED")){const _=y,T=_.fenceSync(_.SYNC_GPU_COMMANDS_COMPLETE,0);y.flush(),S=()=>{const O=_.clientWaitSync(T,0,0);return O===_.ALREADY_SIGNALED||O===_.CONDITION_SATISFIED},k=T}else Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(k=this.beginQuery(),this.endQuery(),S=()=>this.isQueryAvailable(k,Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):S=()=>!0;return{query:k,isFencePassed:S}}downloadMatrixFromPackedTexture(y,k,S){return this.downloadMatrixDriver(y,()=>function(_,T,O){const B=new Float32Array(T*O*4);return f(_,()=>_.readPixels(0,0,O,T,_.RGBA,_.FLOAT,B)),B}(this.gl,k,S))}createProgram(y){this.throwIfDisposed();const k=this.gl;this.vertexShader==null&&(this.vertexShader=Ns(k));const S=function(_){return V(_,()=>_.createProgram(),"Unable to create WebGLProgram.")}(k);return f(k,()=>k.attachShader(S,this.vertexShader)),f(k,()=>k.attachShader(S,y)),function(_,T){if(f(_,()=>_.linkProgram(T)),!Object(n.env)().get("ENGINE_COMPILE_ONLY")&&_.getProgramParameter(T,_.LINK_STATUS)===!1)throw console.log(_.getProgramInfoLog(T)),new Error("Failed to link vertex and fragment shaders.")}(k,S),this.debug&&N(k,S),this.vertexAttrsAreBound||(this.setProgram(S),this.vertexAttrsAreBound=function(_,T,O){return f(_,()=>_.bindBuffer(_.ARRAY_BUFFER,O)),E(_,T,"clipSpacePos",O,3,20,0)&&E(_,T,"uv",O,2,20,12)}(k,this.program,this.vertexBuffer)),S}deleteProgram(y){this.throwIfDisposed(),y===this.program&&(this.program=null),y!=null&&f(this.gl,()=>this.gl.deleteProgram(y))}setProgram(y){this.throwIfDisposed(),this.program=y,this.program!=null&&this.debug&&N(this.gl,this.program),f(this.gl,()=>this.gl.useProgram(y))}getUniformLocation(y,k,S=!0){return this.throwIfDisposed(),S?function(_,T,O){return V(_,()=>_.getUniformLocation(T,O),'uniform "'+O+'" not present in program.')}(this.gl,y,k):function(_,T,O){return _.getUniformLocation(T,O)}(this.gl,y,k)}getAttributeLocation(y,k){return this.throwIfDisposed(),f(this.gl,()=>this.gl.getAttribLocation(y,k))}getUniformLocationNoThrow(y,k){return this.throwIfDisposed(),this.gl.getUniformLocation(y,k)}setInputMatrixTexture(y,k,S){this.throwIfDisposed(),this.throwIfNoProgram(),D(this.gl,y,k,S)}setOutputMatrixTexture(y,k,S){this.setOutputMatrixTextureDriver(y,S,k)}setOutputPackedMatrixTexture(y,k,S){this.throwIfDisposed();const[_,T]=l(k,S);this.setOutputMatrixTextureDriver(y,_,T)}setOutputMatrixWriteRegion(y,k,S,_){this.setOutputMatrixWriteRegionDriver(S,y,_,k)}setOutputPackedMatrixWriteRegion(y,k,S,_){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&N(this.gl,this.program),Y(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const y=this.gl;this.debug&&this.debugValidate(),f(y,()=>y.drawElements(y.TRIANGLES,6,y.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),f(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=b(this.gl,Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const S=this.gl,_=this.getQueryTimerExtensionWebGL2(),T=S.createQuery();return S.beginQuery(_.TIME_ELAPSED_EXT,T),T}const y=this.getQueryTimerExtensionWebGL1(),k=y.createQueryEXT();return y.beginQueryEXT(y.TIME_ELAPSED_EXT,k),k}endQuery(){if(Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const k=this.gl,S=this.getQueryTimerExtensionWebGL2();return void k.endQuery(S.TIME_ELAPSED_EXT)}const y=this.getQueryTimerExtensionWebGL1();y.endQueryEXT(y.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(y){return await n.util.repeatedTry(()=>this.disposed||this.isQueryAvailable(y,Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(y,Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(y,k){if(k===0)return null;if(k===2){const S=this.gl;return S.getQueryParameter(y,S.QUERY_RESULT)/1e6}{const S=this.getQueryTimerExtensionWebGL1();return S.getQueryObjectEXT(y,S.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(y,k){if(k===0)return!0;if(k===2){const S=this.gl,_=this.getQueryTimerExtensionWebGL2(),T=S.getQueryParameter(y,S.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(_.GPU_DISJOINT_EXT)),T&&!this.disjoint}{const S=this.getQueryTimerExtensionWebGL1(),_=S.getQueryObjectEXT(y,S.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(S.GPU_DISJOINT_EXT)),_&&!this.disjoint}}pollFence(y){return new Promise(k=>{this.addItemToPoll(()=>y.isFencePassed(),()=>k())})}pollItems(){const y=function(k){let S=0;for(;S<k.length&&k[S]();++S);return S-1}(this.itemsToPoll.map(k=>k.isDoneFn));for(let k=0;k<=y;++k){const{resolveFn:S}=this.itemsToPoll[k];S()}this.itemsToPoll=this.itemsToPoll.slice(y+1)}addItemToPoll(y,k){this.itemsToPoll.push({isDoneFn:y,resolveFn:k}),this.itemsToPoll.length>1||n.util.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(y){this.throwIfDisposed(),U(this.gl,y,this.framebuffer),this.debug&&Y(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(U(this.gl,this.outputTexture,this.framebuffer),this.debug&&Y(this.gl)):L(this.gl,this.framebuffer)}downloadMatrixDriver(y,k){this.bindTextureToFrameBuffer(y);const S=k();return this.unbindTextureToFrameBuffer(),S}setOutputMatrixTextureDriver(y,k,S){this.throwIfDisposed();const _=this.gl;U(_,y,this.framebuffer),this.debug&&Y(_),this.outputTexture=y,f(_,()=>_.viewport(0,0,k,S)),f(_,()=>_.scissor(0,0,k,S))}setOutputMatrixWriteRegionDriver(y,k,S,_){this.throwIfDisposed(),f(this.gl,()=>this.gl.scissor(y,k,S,_))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}var tn=t(28);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:bn,bincountImpl:On,bincountReduceImpl:Mn,castImpl:wn,ceilImpl:gs,concatImpl:Hs,equalImpl:xr,expImpl:Ir,expm1Impl:qs,floorImpl:ta,gatherNdImpl:pa,gatherV2Impl:rr,greaterImpl:eo,greaterEqualImpl:Qs,lessImpl:mr,lessEqualImpl:$r,linSpaceImpl:ia,logImpl:Pr,maxImpl:Cr,maximumImpl:Ba,minimumImpl:za,multiplyImpl:to,negImpl:Wo,notEqualImpl:si,prodImpl:fo,raggedTensorToTensorImpl:no,rangeImpl:Ta,rsqrtImpl:mo,scatterImpl:Ar,sigmoidImpl:Na,simpleAbsImpl:Ea,sliceImpl:Vo,sparseFillEmptyRowsImpl:So,sparseReshapeImpl:so,sparseSegmentReductionImpl:Zs,sqrtImpl:Kr,stridedSliceImpl:Ra,stringNGramsImpl:fa,stringSplitImpl:na,stringToHashBucketFastImpl:$o,subImpl:We,tileImpl:It,topKImpl:Ut,transposeImpl:sn,uniqueImpl:vn}=tn;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(F,y){return["x","y","z","w","u","v"].slice(0,y).map(k=>`${F}.${k}`)}function Vn(F,y){return y===1?[F]:fn(F,y)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hs{constructor(y){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=y,this.rank=y.length,this.enableShapeUniforms=xs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const k=Vn("rc",this.rank),S=pe(this.rank),_=this.getOutOfBoundsCondition(k),T=this.getSetup(k),O=this.getOutput(k);this.userCode=`
        void main() {
          ${S} rc = getOutputCoords();

          if(${_}) {
            setOutput(vec4(0));
          } else {
            ${T}

            setOutput(vec4(${O}));
          }
        }
      `}}getSourceCoordsArr(y){const k=[];for(let S=0;S<=1;S++)for(let _=0;_<=1;_++){let T=`${S===0?"r":"rp1"}, ${_===0?"c":"cp1"}`;for(let O=2;O<this.rank;O++)T=`${y[y.length-1-O]},`+T;k.push(T)}return k}getOutOfBoundsCondition(y){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let k="";for(let S=this.rank-2;S<this.rank;S++)k+=`${y[S]} >= ${this.enableShapeUniforms?`outShape[${S}]`:this.outputShape[S]}`,S<this.rank-1&&(k+="||");return k}getSetup(y){if(this.rank===1)return"";const k=y.slice(-2),S=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],_=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${k[0]};
      int c = ${k[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${S};
      bool rEdge = rp1 >= ${_};
    `}getOutput(y){const k=this.getSourceCoordsArr(y);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${k[0]}),
            cEdge ? 0. : getA(${k[1]}),
            rEdge ? 0. : getA(${k[2]}),
            rEdge || cEdge ? 0. : getA(${k[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Es{constructor(y,k){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length);let S="";for(let O=0;O<4;O++){let B="thisRC = rc;";O%2==1&&(B+="thisRC.z += 1;"),O>1&&(B+="thisRC.y += 1;"),S+=`
        ${B}
        ${O>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${O}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${O>0?"}":""}
      `}var _,T;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */this.userCode=`
      ${_=k,T=this.enableShapeUniforms,`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${T?mn(["r","c","d"],"inputShape"):Ht(["r","c","d"],_)}
      return ivec3(r, c, d);
    }
  `}
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:Rn(y)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":y[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":y[2]};

        ${S}

        setOutput(result);
      }
    `}}class dr{constructor(y){this.gpgpu=y,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(y,k,S){const _=ga(k,S),T=ur(y,_,S);T in this.freeTextures||(this.freeTextures[T]=[]),T in this.usedTextures||(this.usedTextures[T]=[]);const O=Js(y,_,this.gpgpu.gl,this.gpgpu.textureConfig,S);if(this.freeTextures[T].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=O,this.log();const z=this.freeTextures[T].shift();return this.usedTextures[T].push(z),z}let B;return _===c.PACKED_2X2_FLOAT32?B=this.gpgpu.createPackedMatrixTexture(y[0],y[1]):_===c.PACKED_2X2_FLOAT16?B=this.gpgpu.createFloat16PackedMatrixTexture(y[0],y[1]):_===c.UNPACKED_FLOAT32?B=this.gpgpu.createFloat32MatrixTexture(y[0],y[1]):_===c.UNPACKED_FLOAT16?B=this.gpgpu.createFloat16MatrixTexture(y[0],y[1]):_===c.PACKED_4X1_UNSIGNED_BYTE&&(B=this.gpgpu.createUnsignedBytesMatrixTexture(y[0],y[1])),this.usedTextures[T].push(B),this.numUsedTextures++,this._numBytesAllocated+=O,this.log(),B}releaseTexture(y,k,S,_){if(this.freeTextures==null)return;const T=ga(S,_),O=ur(k,T,_);O in this.freeTextures||(this.freeTextures[O]=[]);const B=Js(k,T,this.gpgpu.gl,this.gpgpu.textureConfig,_),z=Object(n.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");z!==-1&&this._numBytesAllocated>z?(this.gpgpu.deleteMatrixTexture(y.texture),this._numBytesAllocated-=B):(this.freeTextures[O].push(y),this.numFreeTextures++,this._numBytesFree+=B),this.numUsedTextures--;const K=this.usedTextures[O],Q=K.indexOf(y);if(Q<0)throw new Error("Cannot release a texture that was never provided by this texture manager");K.splice(Q,1),this.log()}log(){if(!this.logEnabled)return;const y=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${y})`);const k=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*k)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const y in this.freeTextures)this.freeTextures[y].forEach(k=>{this.gpgpu.deleteMatrixTexture(k.texture)});for(const y in this.usedTextures)this.usedTextures[y].forEach(k=>{this.gpgpu.deleteMatrixTexture(k.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Js(F,y,k,S,_){const T=function(z,K){switch(z){case c.PACKED_2X2_FLOAT32:return ot(K);case c.PACKED_2X2_FLOAT16:return Ct(K);case c.UNPACKED_FLOAT32:return jt(K);case c.UNPACKED_FLOAT16:return re(K);case c.PACKED_4X1_UNSIGNED_BYTE:return de(K);default:throw new Error(`Unknown physical texture type ${z}`)}}(y,S);let O;if(_){const[z,K]=l(F[0],F[1]);O=z*K}else{const[z,K]=d(F[0],F[1]);O=z*K}const B=function(z,K){const Q=z;if(K===Q.R32F)return 4;if(K===Q.R16F)return 2;if(K===Q.RGBA32F||K===z.RGBA)return 16;if(K===Q.RGBA16F)return 8;if(K===Q.RGBA8)return 4;throw new Error(`Unknown internal format ${K}`)}(k,T);return O*B}function ga(F,y){if(F===u.UPLOAD)return c.PACKED_2X2_FLOAT32;if(F===u.RENDER||F==null)return function(k){return Object(n.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?k?c.PACKED_2X2_FLOAT32:c.UNPACKED_FLOAT32:k?c.PACKED_2X2_FLOAT16:c.UNPACKED_FLOAT16}(y);if(F===u.DOWNLOAD||F===u.PIXELS)return c.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${F}`)}function ur(F,y,k){return`${F[0]}_${F[1]}_${y}_${k}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Or{constructor(y,k){this.variableNames=["A"],this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${k}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ro="return abs(x);",Wa="return x;";class Va{constructor(y,k){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${k}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qi{constructor(y){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length);const k=y.length,S=Vn("rc",k),_=pe(k),T=function(z,K){if(z===1)return"rc";let Q="";for(let ue=0;ue<z;ue++)Q+=K[ue],ue<z-1&&(Q+=",");return Q}(k,S),O=S.slice(-2),B=k<=1?"rc":`vec2(${O.join(",")})`;this.userCode=`
      void main() {
        ${_} rc = getOutputCoords();
        vec4 packedInput = getA(${T});

        setOutput(getChannel(packedInput, ${B}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _i=n.kernel_impls.whereImpl,ri={},$u=Object(n.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class go extends n.KernelBackend{constructor(y){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(n.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let k;if(y!=null){if(y instanceof on)k=y;else{const _=o(Object(n.env)().getNumber("WEBGL_VERSION"),y);k=new on(_)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const _=o(Object(n.env)().getNumber("WEBGL_VERSION"));k=new on(_),this.binaryCache=((S=Object(n.env)().getNumber("WEBGL_VERSION"))in ri||(ri[S]={}),ri[S]),this.gpgpuCreatedLocally=!0}var S;this.gpgpu=k,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new dr(this.gpgpu),this.numMBBeforeWarning=Object(n.env)().global.screen==null?1024:Object(n.env)().global.screen.height*Object(n.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new n.DataStorage(this,Object(n.engine)())}nextDataId(){return go.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(y,k,S){if((Object(n.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(n.env)().getBool("DEBUG"))&&this.checkNumericalProblems(y),S==="complex64"&&y!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const _={id:this.nextDataId()};return this.texData.set(_,{shape:k,dtype:S,values:y,usage:u.UPLOAD,refCount:1}),_}refCount(y){return this.texData.has(y)?this.texData.get(y).refCount:0}incRef(y){this.texData.get(y).refCount++}decRef(y){this.texData.has(y)&&this.texData.get(y).refCount--}move(y,k,S,_,T){if(Object(n.env)().getBool("DEBUG")&&this.checkNumericalProblems(k),_==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(y,{shape:S,dtype:_,values:k,usage:u.UPLOAD,refCount:T})}disposeIntermediateTensorInfo(y){this.disposeData(y.dataId)}readSync(y){const k=this.texData.get(y),{values:S,dtype:_,complexTensorInfos:T,slice:O,shape:B,isPacked:z}=k;if(O!=null){let ae;ae=z?new Va(B,Wa):new Or(B,Wa);const Re=this.runWebGLProgram(ae,[{dataId:y,shape:B,dtype:_}],_),ke=this.readSync(Re.dataId);return this.disposeIntermediateTensorInfo(Re),ke}if(S!=null)return this.convertAndCacheOnCPU(y);if(_==="string")return S;const K=this.activeTimers!=null;let Q,ue;if(K&&(Q=n.util.now()),_==="complex64"){const ae=this.readSync(T.real.dataId),Re=this.readSync(T.imag.dataId);ue=n.backend_util.mergeRealAndImagArrays(ae,Re)}else ue=this.getValuesFromTexture(y);return K&&(this.downloadWaitMs+=n.util.now()-Q),this.convertAndCacheOnCPU(y,ue)}async read(y){if(this.pendingRead.has(y)){const ke=this.pendingRead.get(y);return new Promise(Ge=>ke.push(Ge))}const k=this.texData.get(y),{values:S,shape:_,slice:T,dtype:O,complexTensorInfos:B,isPacked:z}=k;if(T!=null){let ke;ke=z?new Va(_,Wa):new Or(_,Wa);const Ge=this.runWebGLProgram(ke,[{dataId:y,shape:_,dtype:O}],O),qe=this.read(Ge.dataId);return this.disposeIntermediateTensorInfo(Ge),qe}if(S!=null)return this.convertAndCacheOnCPU(y);if(Object(n.env)().getBool("DEBUG")&&!Object(n.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Object(n.env)().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let K,Q,ue=null;if(O!=="complex64"&&Object(n.env)().get("WEBGL_BUFFER_SUPPORTED")){K=this.decode(y);const ke=this.texData.get(K.dataId);ue=this.gpgpu.createBufferFromTexture(ke.texture.texture,...h(_))}if(this.pendingRead.set(y,[]),O!=="complex64"&&await this.gpgpu.createAndWaitForFence(),O==="complex64"){const ke=await Promise.all([this.read(B.real.dataId),this.read(B.imag.dataId)]),Ge=ke[0],qe=ke[1];Q=n.backend_util.mergeRealAndImagArrays(Ge,qe)}else if(ue==null)Q=this.getValuesFromTexture(y);else{const ke=n.util.sizeFromShape(_);Q=this.gpgpu.downloadFloat32MatrixFromBuffer(ue,ke)}if(K!=null&&this.disposeIntermediateTensorInfo(K),ue!=null){const ke=this.gpgpu.gl;f(ke,()=>ke.deleteBuffer(ue))}const ae=this.convertAndCacheOnCPU(y,Q),Re=this.pendingRead.get(y);return this.pendingRead.delete(y),Re.forEach(ke=>ke(ae)),this.pendingDisposal.has(y)&&(this.pendingDisposal.delete(y),this.disposeData(y)&&Object(n.engine)().removeDataId(y,this),this.pendingDeletes--),ae}readToGPU(y,k={}){const S=this.texData.get(y),{values:_,shape:T,slice:O,dtype:B,isPacked:z,texture:K}=S;if(B==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(O!=null){let Re;Re=z?new Va(T,Wa):new Or(T,Wa);const ke=this.runWebGLProgram(Re,[{dataId:y,shape:T,dtype:B}],B),Ge=this.readToGPU(ke,k);return this.disposeIntermediateTensorInfo(ke),Ge}if(K==null)throw _!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const Q=this.decode(y,k.customTexShape),ue=Object(n.engine)().makeTensorFromTensorInfo(Q),ae=this.texData.get(Q.dataId);return Object.assign({tensorRef:ue},ae.texture)}bufferSync(y){const k=this.readSync(y.dataId);if(y.dtype==="string")try{const S=k.map(_=>n.util.decodeString(_));return Object(n.buffer)(y.shape,y.dtype,S)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(n.buffer)(y.shape,y.dtype,k)}checkNumericalProblems(y){if(y!=null)for(let k=0;k<y.length;k++){const S=y[k];if(!x(S))throw Object(n.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${S} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${S} cannot be represented on this device.`)}}getValuesFromTexture(y){const{shape:k,dtype:S,isPacked:_}=this.texData.get(y),T=n.util.sizeFromShape(k);if(Object(n.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const ae=this.decode(y),Re=this.texData.get(ae.dataId),ke=this.gpgpu.downloadMatrixFromPackedTexture(Re.texture.texture,...h(k)).subarray(0,T);return this.disposeIntermediateTensorInfo(ae),ke}const O=Object(n.env)().getBool("WEBGL_PACK")&&_===!0,B=O?ge(k):k,z=O?new Nn(B):new pn(B),K=this.runWebGLProgram(z,[{shape:B,dtype:S,dataId:y}],"float32"),Q=this.texData.get(K.dataId),ue=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(Q.texture.texture,Q.texShape[0],Q.texShape[1]).subarray(0,T);return this.disposeIntermediateTensorInfo(K),ue}timerAvailable(){return Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(y){const k=this.activeTimers,S=[];let _=!1;this.programTimersStack==null?(this.programTimersStack=S,_=!0):this.activeTimers.push(S),this.activeTimers=S,y();const T=n.util.flatten(this.activeTimers.map(z=>z.query)).filter(z=>z!=null),O=n.util.flatten(this.activeTimers.map(z=>z.name)).filter(z=>z!=null);this.activeTimers=k,_&&(this.programTimersStack=null);const B={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const z=await Promise.all(T);B.kernelMs=n.util.sum(z),B.getExtraProfileInfo=()=>z.map((K,Q)=>({name:O[Q],ms:K})).map(K=>`${K.name}: ${K.ms}`).join(", ")}else B.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,B})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:n.util.now(),endMs:null}}endTimer(y){return Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),y):(y.endMs=n.util.now(),y)}async getQueryTime(y){if(Object(n.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(y);const k=y;return k.endMs-k.startMs}disposeData(y,k=!1){if(this.pendingDisposal.has(y))return!1;if(!this.texData.has(y))return!0;if(k?this.texData.get(y).refCount=0:this.texData.get(y).refCount--,!k&&this.texData.get(y).refCount>0)return!1;if(this.pendingRead.has(y))return this.pendingDisposal.add(y),this.pendingDeletes++,!1;this.releaseGPUData(y);const{complexTensorInfos:S}=this.texData.get(y);return S!=null&&(this.disposeData(S.real.dataId,k),this.disposeData(S.imag.dataId,k)),this.texData.delete(y),!0}releaseGPUData(y){const{texture:k,dtype:S,texShape:_,usage:T,isPacked:O,slice:B}=this.texData.get(y),z=B&&B.origDataId||y,K=this.dataRefCount.get(z);K>1?this.dataRefCount.set(z,K-1):(this.dataRefCount.delete(z),k!=null&&(this.numBytesInGPU-=this.computeBytes(_,S),this.textureManager.releaseTexture(k,_,T,O)));const Q=this.texData.get(y);Q.texture=null,Q.texShape=null,Q.isPacked=!1,Q.slice=null}getTexture(y){return this.uploadToGPU(y),this.texData.get(y).texture.texture}getDataInfo(y){return this.texData.get(y)}shouldExecuteOnCPU(y,k=$u){return Object(n.env)().getBool("WEBGL_CPU_FORWARD")&&y.every(S=>this.texData.get(S.dataId).texture==null&&n.util.sizeFromShape(S.shape)<k)}getGPGPUContext(){return this.gpgpu}where(y){n.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const k=y.dataSync();return _i(y.shape,k)}packedUnaryOp(y,k,S){const _=new Va(y.shape,k),T=this.compileAndRun(_,[y],S);return Object(n.engine)().makeTensorFromTensorInfo(T)}abs(y){if(this.shouldExecuteOnCPU([y])&&y.dtype!=="complex64"){const _=Ea(this.texData.get(y.dataId).values);return this.makeOutput(y.shape,y.dtype,_)}if(Object(n.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(y,ro,y.dtype);const k=new Or(y.shape,ro),S=this.compileAndRun(k,[y]);return Object(n.engine)().makeTensorFromTensorInfo(S)}makeTensorInfo(y,k,S){let _;if(k==="string"&&S!=null&&S.length>0&&n.util.isString(S[0])){const T=S.map(O=>n.util.encodeString(O));_=this.write(T,y,k)}else _=this.write(S,y,k);return this.texData.get(_).usage=null,{dataId:_,shape:y,dtype:k}}makeOutput(y,k,S){return Object(n.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(y,k,S),this)}unpackTensor(y){const k=new Qi(y.shape);return this.runWebGLProgram(k,[y],y.dtype)}packTensor(y){const k=new hs(y.shape);return this.runWebGLProgram(k,[y],y.dtype,null,!0)}packedReshape(y,k){const S=[oe(y.shape),...ne(y.shape)],_={dtype:y.dtype,shape:S,dataId:y.dataId},T=[oe(k),...ne(k)],O=new Es(T,S),B=[S],z=this.runWebGLProgram(O,[_],y.dtype,B,!0);return{dataId:z.dataId,shape:k,dtype:z.dtype}}decode(y,k){const S=this.texData.get(y),{isPacked:_,shape:T,dtype:O}=S;if(k!=null){const Q=n.util.sizeFromShape(T),ue=k[0]*k[1]*4;n.util.assert(Q<=ue,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const B=ge(T);let z;z=_?new Ys(B):new ds(B);const K=[k!=null?k:h(B)];return{dtype:O,shape:T,dataId:this.runWebGLProgram(z,[{shape:B,dtype:O,dataId:y}],O,K,!0,k).dataId}}runWebGLProgram(y,k,S,_,T=!1,O){const B=this.makeTensorInfo(y.outputShape,S),z=this.texData.get(B.dataId);if(y.packedOutput&&(z.isPacked=!0),y.outPackingScheme===i.DENSE){const Ne=O!=null?O:h(y.outputShape);z.texShape=Ne.map(Ke=>2*Ke)}if(y.outTexUsage!=null&&(z.usage=y.outTexUsage),n.util.sizeFromShape(B.shape)===0)return z.values=n.util.getTypedArrayFromDType(B.dtype,0),B;const K=[],Q=k.map(Ne=>{if(Ne.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Ke=this.texData.get(Ne.dataId);if(Ke.texture==null){if(!y.packedInputs&&n.util.sizeFromShape(Ne.shape)<=Object(n.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:Ne.shape,texData:null,isUniform:!0,uniformValues:Ke.values};y.packedInputs&&(Ke.isPacked=!0,Ke.shape=Ne.shape)}if(this.uploadToGPU(Ne.dataId),!!Ke.isPacked!=!!y.packedInputs)Ne=Ke.isPacked?this.unpackTensor(Ne):this.packTensor(Ne),K.push(Ne),Ke=this.texData.get(Ne.dataId);else if(Ke.isPacked&&!Ee(Ke.shape,Ne.shape)){const an=Ne,kn=Ne.shape;Ne.shape=Ke.shape,Ne=this.packedReshape(Ne,kn),K.push(Ne),Ke=this.texData.get(Ne.dataId),an.shape=kn}return{shape:Ne.shape,texData:Ke,isUniform:!1}});this.uploadToGPU(B.dataId);const ue={shape:B.shape,texData:z,isUniform:!1},ae=function(Ne,Ke,an){let kn="";Ke.concat(an).forEach(Hn=>{const Qn=Hn.texData!=null&&Hn.texData.slice!=null&&Hn.texData.slice.flatOffset>0;if(Ne.enableShapeUniforms&&!Hn.isUniform){const Wn=Hn.texData.texShape,{useSqueezeShape:vs,uniformShape:fs,keptDims:w}=be(Ne.packedInputs,Hn.shape,Wn);let g="",v="",C="";if(fs.length===1&&Ne.packedInputs){const Xe=[Math.ceil(Wn[0]/2),Math.ceil(Wn[1]/2)];g=`${Xe[0]>1}_${Xe[1]>1}`}else if(fs.length!==2||Ne.packedInputs){if(fs.length>2&&!Ne.packedInputs){const Xe=n.util.computeStrides(fs);C=`${Xe[0]===Wn[1]}_${Xe[Xe.length-1]===Wn[1]}`}}else v=`${fs[0]>1}_${fs[1]>1}`;const $=Hn.shape.length,M=fs.length===2&&n.util.arraysEqual(Hn.shape,Wn),W=n.util.sizeFromShape(Hn.shape)===1,J=n.backend_util.getBroadcastDims(Hn.shape,an.shape),le=!Ne.packedInputs&&$===an.shape.length&&n.util.arraysEqual(Wn,an.texData.texShape),ve=Ne.packedInputs||fs.length>2?"":`${Wn[0]>1}_${Wn[1]>1}`;kn+=`${$}_${le}_${vs?w:""}_${fs.length}_${W}_${J}_${M}_${g}_${v}_${C}_${ve}_${Qn}`}else{const Wn=Hn.isUniform?"uniform":Hn.texData.texShape;kn+=`${Hn.shape}_${Wn}_${Qn}`}});const Pn=Ne.userCode;let Xn=Ne.constructor.name;return Xn+="_"+kn+"_"+Pn+`${Object(n.env)().getNumber("WEBGL_VERSION")}`,Xn}(y,Q,ue),Re=this.getAndSaveBinary(ae,()=>Ws(this.gpgpu,y,Q,ue)),ke=this.activeTimers!=null;let Ge;ke&&(Ge=this.startTimer()),Object(n.env)().get("ENGINE_COMPILE_ONLY")||function(Ne,Ke,an,kn,Pn){Ke.program.enableShapeUniforms||(As(Ke.inShapeInfos,an),As([Ke.outShapeInfo],[kn]));const Xn=kn.texData.texture,Hn=kn.texData.texShape;kn.texData.isPacked?Ne.setOutputPackedMatrixTexture(Xn.texture,Hn[0],Hn[1]):Ne.setOutputMatrixTexture(Xn.texture,Hn[0],Hn[1]),Ne.setProgram(Ke.webGLProgram),Object(n.env)().getNumber("WEBGL_VERSION")===1&&Ke.infLoc!==null&&Ne.gl.uniform1f(Ke.infLoc,1/0),Ke.nanLoc!==null&&Ne.gl.uniform1f(Ke.nanLoc,NaN),an.forEach((Wn,vs)=>{const fs=Ke.program.variableNames[vs],w=Ke.uniformLocations[fs],g=Ke.uniformLocations[`offset${fs}`],v=Ke.inShapesLocations[`${fs}Shape`],C=Ke.inTexShapesLocations[`${fs}TexShape`];if(v){const{uniformShape:$}=be(Ke.program.packedInputs,Wn.shape,Wn.texData.texShape);switch($.length){case 1:Ne.gl.uniform1iv(v,new Int32Array($));break;case 2:Ne.gl.uniform2iv(v,new Int32Array($));break;case 3:Ne.gl.uniform3iv(v,new Int32Array($));break;case 4:Ne.gl.uniform4iv(v,new Int32Array($))}}if(C&&Ne.gl.uniform2i(C,Wn.texData.texShape[0],Wn.texData.texShape[1]),w!=null)if(Wn.isUniform)if(n.util.sizeFromShape(Wn.shape)<2)Ne.gl.uniform1f(w,Wn.uniformValues[0]);else{let $=Wn.uniformValues;$ instanceof Float32Array||($=new Float32Array($)),Ne.gl.uniform1fv(w,$)}else Wn.texData.slice!=null&&g!=null&&Ne.gl.uniform1i(g,Wn.texData.slice.flatOffset),Ne.setInputMatrixTexture(Wn.texData.texture.texture,w,vs)});const Qn=Ke.outShapeLocation;if(Qn)switch(kn.shape.length){case 1:Ne.gl.uniform1iv(Qn,new Int32Array(kn.shape));break;case 2:Ne.gl.uniform2iv(Qn,new Int32Array(kn.shape));break;case 3:Ne.gl.uniform3iv(Qn,new Int32Array(kn.shape));break;case 4:Ne.gl.uniform4iv(Qn,new Int32Array(kn.shape))}if(Ke.outShapeStridesLocation){const Wn=n.util.computeStrides(kn.shape);switch(kn.shape.length){case 2:Ne.gl.uniform1iv(Ke.outShapeStridesLocation,new Int32Array(Wn));break;case 3:Ne.gl.uniform2iv(Ke.outShapeStridesLocation,new Int32Array(Wn));break;case 4:Ne.gl.uniform3iv(Ke.outShapeStridesLocation,new Int32Array(Wn))}}Ke.outTexShapeLocation&&Ne.gl.uniform2i(Ke.outTexShapeLocation,kn.texData.texShape[0],kn.texData.texShape[1]),Ke.program.customUniforms&&Pn&&Ke.program.customUniforms.forEach((Wn,vs)=>{const fs=Ke.customUniformLocations[vs],w=Pn[vs];if(Wn.type==="float")Ne.gl.uniform1fv(fs,w);else if(Wn.type==="vec2")Ne.gl.uniform2fv(fs,w);else if(Wn.type==="vec3")Ne.gl.uniform3fv(fs,w);else if(Wn.type==="vec4")Ne.gl.uniform4fv(fs,w);else if(Wn.type==="int")Ne.gl.uniform1iv(fs,w);else if(Wn.type==="ivec2")Ne.gl.uniform2iv(fs,w);else if(Wn.type==="ivec3")Ne.gl.uniform3iv(fs,w);else{if(Wn.type!=="ivec4")throw Error(`uniform type ${Wn.type} is not supported yet.`);Ne.gl.uniform4iv(fs,w)}}),Ne.executeProgram()}(this.gpgpu,Re,Q,ue,_),K.forEach(Ne=>this.disposeIntermediateTensorInfo(Ne)),ke&&(Ge=this.endTimer(Ge),this.activeTimers.push({name:y.constructor.name,query:this.getQueryTime(Ge)}));const qe=Object(n.env)().get("WEBGL_FLUSH_THRESHOLD");if(qe>0){const Ne=n.util.now();Ne-this.lastGlFlushTime>qe&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=Ne)}if(!Object(n.env)().getBool("WEBGL_LAZILY_UNPACK")&&z.isPacked&&T===!1){const Ne=this.unpackTensor(B);return this.disposeIntermediateTensorInfo(B),Ne}return B}compileAndRun(y,k,S,_,T=!1){return S=S||k[0].dtype,this.runWebGLProgram(y,k,S,_,T)}getAndSaveBinary(y,k){return y in this.binaryCache||(this.binaryCache[y]=k()),this.binaryCache[y]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Object(n.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(y=>{this.gpgpu.deleteProgram(this.binaryCache[y].webGLProgram),delete this.binaryCache[y]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Object(n.tidy)(()=>{if(!Object(n.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const y=Object(n.env)().getBool("DEBUG");Object(n.env)().set("DEBUG",!1);const k=this.abs(Object(n.scalar)(1e-8)).dataSync()[0];if(Object(n.env)().set("DEBUG",y),k>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}uploadToGPU(y){const k=this.texData.get(y),{shape:S,dtype:_,values:T,texture:O,usage:B,isPacked:z}=k;if(O!=null)return;const K=this.activeTimers!=null;let Q;K&&(Q=n.util.now());let ue=k.texShape;if(ue==null&&(ue=function(ae,Re=!1){let ke=Object(n.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");Re&&(ke*=2,(ae=ae.map((qe,Ne)=>Ne>=ae.length-2?n.util.nearestLargerEven(ae[Ne]):ae[Ne])).length===1&&(ae=[2,ae[0]])),ae.length!==2&&(ae=n.util.squeezeShape(ae).newShape);let Ge=n.util.sizeFromShape(ae);if(ae.length<=1&&Ge<=ke)return[1,Ge];if(ae.length===2&&ae[0]<=ke&&ae[1]<=ke)return ae;if(ae.length===3&&ae[0]*ae[1]<=ke&&ae[2]<=ke)return[ae[0]*ae[1],ae[2]];if(ae.length===3&&ae[0]<=ke&&ae[1]*ae[2]<=ke)return[ae[0],ae[1]*ae[2]];if(ae.length===4&&ae[0]*ae[1]*ae[2]<=ke&&ae[3]<=ke)return[ae[0]*ae[1]*ae[2],ae[3]];if(ae.length===4&&ae[0]<=ke&&ae[1]*ae[2]*ae[3]<=ke)return[ae[0],ae[1]*ae[2]*ae[3]];if(Re){const qe=oe(ae);let Ne=2,Ke=2;return ae.length&&([Ne,Ke]=ne(ae)),Ge=qe*(Ne/2)*(Ke/2),n.util.sizeToSquarishShape(Ge).map(an=>2*an)}return n.util.sizeToSquarishShape(Ge)}(S,z),k.texShape=ue),T!=null){const ae=ge(S);let Re,ke=ue[1],Ge=ue[0];const qe=T instanceof Uint8Array||T instanceof Uint8ClampedArray;!z&&qe||([ke,Ge]=l(ue[0],ue[1])),Re=z?new $s(ae,qe):new ts(ae,qe);const Ne=qe?[Ge,ke]:ue,Ke=this.makeTensorInfo(Ne,_),an=this.texData.get(Ke.dataId);an.usage=qe?u.PIXELS:u.UPLOAD,an.texShape=Ne,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Ke.dataId),ke,Ge,T);const kn=[[Ge,ke]],Pn=!0,Xn=this.runWebGLProgram(Re,[Ke],_,kn,Pn),Hn=this.texData.get(Xn.dataId);k.texShape=Hn.texShape,k.isPacked=Hn.isPacked,k.usage=Hn.usage,Object(n.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(Xn.dataId):(k.texture=Hn.texture,k.values=null,this.texData.delete(Xn.dataId)),this.disposeIntermediateTensorInfo(Ke),K&&(this.uploadWaitMs+=n.util.now()-Q)}else{const ae=this.acquireTexture(ue,B,_,z);k.texture=ae}}convertAndCacheOnCPU(y,k){const S=this.texData.get(y),{dtype:_}=S;return this.releaseGPUData(y),k!=null&&(S.values=function(T,O){if(O==="float32"||O==="complex64")return T;if(O==="int32"||O==="bool"){const B=O==="int32"?new Int32Array(T.length):new Uint8Array(T.length);for(let z=0;z<B.length;++z)B[z]=Math.round(T[z]);return B}throw new Error(`Unknown dtype ${O}`)}(k,_)),S.values}acquireTexture(y,k,S,_){if(this.numBytesInGPU+=this.computeBytes(y,S),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const T=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${T} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(y,k,_)}computeBytes(y,k){return y[0]*y[1]*n.util.bytesPerElement(k)}checkCompileCompletion(){for(const[,y]of Object.entries(this.binaryCache))this.checkCompletion_(y)}async checkCompileCompletionAsync(){const y=[];if(this.gpgpu.parallelCompilationExtension){for(const[,k]of Object.entries(this.binaryCache))y.push(this.checkCompletionAsync_(k));return Promise.all(y)}for(const[,k]of Object.entries(this.binaryCache)){const S=new Promise(_=>{try{this.checkCompletion_(k),_(!0)}catch(T){throw T}});y.push(S)}return Promise.all(y)}async checkCompletionAsync_(y){return this.gpgpu.gl.getProgramParameter(y.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(y):(await Object(n.nextFrame)(),this.checkCompletionAsync_(y))}checkCompletion_(y){if(this.gpgpu.gl.getProgramParameter(y.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(y.webGLProgram)),this.gpgpu.gl.getShaderParameter(y.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(I(y.source,this.gpgpu.gl.getShaderInfoLog(y.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,y]of Object.entries(this.binaryCache)){const{uniformLocations:k,customUniformLocations:S,infLoc:_,nanLoc:T,inShapesLocations:O,inTexShapesLocations:B,outShapeLocation:z,outShapeStridesLocation:K,outTexShapeLocation:Q}=Gs(this.gpgpu,y.program,y.webGLProgram);y.uniformLocations=k,y.customUniformLocations=S,y.infLoc=_,y.nanLoc=T,y.inShapesLocations=O,y.inTexShapesLocations=B,y.outShapeLocation=z,y.outShapeStridesLocation=K,y.outTexShapeLocation=Q}}}go.nextDataId=0,n.device_util.isBrowser()&&Object(n.registerBackend)("webgl",()=>new go,2);class bo{constructor(y,k,S){this.variableNames=["A","B"],this.outputShape=n.backend_util.assertAndGetBroadcastShape(k,S),this.enableShapeUniforms=xs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${y}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ua{constructor(y,k,S,_=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.backend_util.assertAndGetBroadcastShape(k,S);const T=this.outputShape.length;this.enableShapeUniforms=xs(T);let O="";if(_)if(T===0||n.util.sizeFromShape(this.outputShape)===1)O=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(O=`
          ${pe(T)} coords = getOutputCoords();
        `,T===1)this.enableShapeUniforms?O+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:O+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const B=Vn("coords",T);this.enableShapeUniforms?O+=`
            bool nextRowOutOfBounds =
              (${B[T-2]} + 1) >= outShape[${T} - 2];
            bool nextColOutOfBounds =
              (${B[T-1]} + 1) >= outShape[${T} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:O+=`
            bool nextRowOutOfBounds =
              (${B[T-2]} + 1) >= ${this.outputShape[T-2]};
            bool nextColOutOfBounds =
              (${B[T-1]} + 1) >= ${this.outputShape[T-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${y}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${O}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wr(F){const{inputs:y,backend:k}=F,{x:S}=y;return k.incRef(S.dataId),{dataId:S.dataId,shape:S.shape,dtype:S.dtype}}const Ji={kernelName:n.Identity,backendName:"webgl",kernelFunc:Wr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xr(F){const{inputs:y,backend:k}=F,{real:S,imag:_}=y,T=k.makeTensorInfo(S.shape,"complex64"),O=k.texData.get(T.dataId),B=Wr({inputs:{x:S},backend:k}),z=Wr({inputs:{x:_},backend:k});return O.complexTensorInfos={real:B,imag:z},T}const ja={kernelName:n.Complex,backendName:"webgl",kernelFunc:Xr},To="return (a < 0.) ? b * a : a;",ai=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu={kernelName:n.LeakyRelu,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{alpha:T}=S,O=k.makeTensorInfo([],"float32",n.util.createScalarValue(T,"float32")),B=Object(n.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(ai,_.shape,O.shape):new bo(To,_.shape,O.shape),z=k.runWebGLProgram(B,[_,O],"float32");return k.disposeIntermediateTensorInfo(O),z}},oi="return (a < 0.) ? b * a : a;",Uo=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu={kernelName:n.Prelu,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{x:S,alpha:_}=y,T=Object(n.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(Uo,S.shape,_.shape):new bo(oi,S.shape,_.shape);return k.runWebGLProgram(T,[S,_],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ls({opSnippet:F,packedOpSnippet:y,cpuKernelImpl:k,dtype:S}){return({inputs:_,backend:T})=>{const{x:O}=_,B=T,z=S||O.dtype;if(B.shouldExecuteOnCPU([O])&&k!=null){const Q=B.texData.get(O.dataId),ue=k(Q.values,z);return B.makeTensorInfo(O.shape,z,ue)}let K;return K=Object(n.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&y!=null?new Va(O.shape,y):new Or(O.shape,F),B.runWebGLProgram(K,[O],z)}}function Lr({opSnippet:F,packedOpSnippet:y,checkOutOfBounds:k=!1,supportsComplex:S=!1,cpuKernelImpl:_,dtype:T}){return({inputs:O,backend:B})=>{const{a:z,b:K}=O,Q=B;if(S&&z.dtype==="complex64"){const Re=Q.texData.get(z.dataId),ke=Q.texData.get(K.dataId),[Ge,qe]=[[Re.complexTensorInfos.real,ke.complexTensorInfos.real],[Re.complexTensorInfos.imag,ke.complexTensorInfos.imag]].map(Ke=>{const[an,kn]=Ke,Pn={dataId:an.dataId,dtype:an.dtype,shape:z.shape},Xn={dataId:kn.dataId,dtype:kn.dtype,shape:K.shape},Hn=new bo(F,z.shape,K.shape);return Q.runWebGLProgram(Hn,[Pn,Xn],Object(n.upcastType)(an.dtype,kn.dtype))}),Ne=Xr({inputs:{real:Ge,imag:qe},backend:Q});return Q.disposeIntermediateTensorInfo(Ge),Q.disposeIntermediateTensorInfo(qe),Ne}const ue=T||Object(n.upcastType)(z.dtype,K.dtype);if((z.dtype==="string"||K.dtype==="string"||Q.shouldExecuteOnCPU([z,K]))&&_!=null){const Re=Q.texData.get(z.dataId).values,ke=Q.texData.get(K.dataId).values,Ge=z.dtype==="string"?n.backend_util.fromUint8ToStringArray(Re):Re,qe=z.dtype==="string"?n.backend_util.fromUint8ToStringArray(ke):ke,[Ne,Ke]=_(z.shape,K.shape,Ge,qe,ue),an=Q.makeTensorInfo(Ke,ue);return Q.texData.get(an.dataId).values=Ne,an}let ae;return ae=Object(n.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&y!=null?new Ua(y,z.shape,K.shape,k):new bo(F,z.shape,K.shape),Q.runWebGLProgram(ae,[z,K],ue)}}function ao(F,y=!1){if(F==="linear")return"return x;";if(F==="relu")return y?`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : x;
`;if(F==="elu")return y?`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if(F==="relu6")return y?`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;if(F==="prelu")return y?Uo:oi;if(F==="leakyrelu")return y?ai:To;if(F==="sigmoid")return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${F} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Si{constructor(y,k,S,_=!1,T=!1,O=!1,B=null,z=!1,K=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S,this.enableShapeUniforms=xs(this.outputShape.length);const Q=_?y[1]:y[2],ue=Math.ceil(Q/2),ae=_?"i * 2, rc.y":"rc.y, i * 2",Re=T?"rc.z, i * 2":"i * 2, rc.z",ke=_?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Ge=T?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let qe="",Ne="";B&&(qe=z?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${B}
        }`:K?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${B}
        }`:`vec4 activation(vec4 x) {
          ${B}
        }`,Ne="result = activation(result);");const Ke=O?"result += getBiasAtOutCoords();":"";O&&this.variableNames.push("bias"),z&&this.variableNames.push("preluActivationWeights"),K&&this.variableNames.push("leakyreluAlpha");let an="rc.x",kn="rc.x";y[0]<k[0]?an=`int(min(float(rc.x), ${y[0]-1}.))`:k[0]<y[0]&&(kn=`int(min(float(rc.x), ${k[0]-1}.))`),this.userCode=`
      ${qe}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${ue}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${ue}; i++) {
          int batchA = ${an};
          int batchB = ${kn};
          vec4 a = getMatrixA(batchA, ${ae});
          vec4 b = getMatrixB(batchB, ${Re});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${ke[0]} * ${Ge[0]});
          result += (${ke[1]} * ${Ge[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${Ke}

        ${Ne}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu="return areal * breal - aimag * bimag;",No="return areal * bimag + aimag * breal;";class $i{constructor(y,k,S){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=n.backend_util.assertAndGetBroadcastShape(k,S),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${y}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ti="return a * b;";function ii(F){const{inputs:y,backend:k}=F,{a:S,b:_}=y,T=n.backend_util.upcastType(S.dtype,_.dtype);if(S.dtype==="complex64"){const B=k.texData.get(S.dataId),z=k.texData.get(_.dataId),K=new $i(eu,S.shape,_.shape),Q=new $i(No,S.shape,_.shape),ue=[{dataId:B.complexTensorInfos.real.dataId,dtype:B.complexTensorInfos.real.dtype,shape:S.shape},{dataId:B.complexTensorInfos.imag.dataId,dtype:B.complexTensorInfos.imag.dtype,shape:S.shape},{dataId:z.complexTensorInfos.real.dataId,dtype:z.complexTensorInfos.real.dtype,shape:_.shape},{dataId:z.complexTensorInfos.imag.dataId,dtype:z.complexTensorInfos.imag.dtype,shape:_.shape}],ae=k.runWebGLProgram(K,ue,"float32"),Re=k.runWebGLProgram(Q,ue,"float32"),ke=Xr({inputs:{real:ae,imag:Re},backend:k});return k.disposeIntermediateTensorInfo(ae),k.disposeIntermediateTensorInfo(Re),ke}if(k.shouldExecuteOnCPU([S,_])){const B=k.texData.get(S.dataId),z=k.texData.get(_.dataId),[K,Q]=to(S.shape,_.shape,B.values,z.values,T),ue=k.makeTensorInfo(Q,T);return k.texData.get(ue.dataId).values=K,ue}let O;return O=Object(n.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(Ti,S.shape,_.shape):new bo(Ti,S.shape,_.shape),k.runWebGLProgram(O,[S,_],T)}const bs={kernelName:n.Multiply,backendName:"webgl",kernelFunc:ii};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{shape:T}=S,O=k,B=n.util.sizeFromShape(_.shape),z=n.util.inferFromImplicitShape(T,B),K=n.util.sizeFromShape(z);n.util.assert(B===K,()=>`The new shape (${z}) has ${K} elements and the old shape (${_.shape}) has ${B} elements. The new shape and old shape must have the same number of elements.`);const Q=O.texData.get(_.dataId);return!Q.isPacked||Ee(_.shape,z)||Q.texture!==null&&Ee(Q.shape,z)?(O.incRef(_.dataId),{dataId:_.dataId,shape:z,dtype:_.dtype}):function(ue,ae,Re){const ke=[oe(ue.shape),...ne(ue.shape)],Ge={dtype:ue.dtype,shape:ke,dataId:ue.dataId},qe=[oe(ae),...ne(ae)],Ne=new Es(qe,ke),Ke=[ke],an=Re.runWebGLProgram(Ne,[Ge],ue.dtype,Ke,!0);return{dataId:an.dataId,shape:ae,dtype:an.dtype}}(_,z,O)}const hr={kernelName:n.Reshape,backendName:"webgl",kernelFunc:jn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gn{constructor(y,k){this.variableNames=["x"];const{windowSize:S,batchSize:_,inSize:T,outSize:O}=y;this.outputShape=[_,O];const B=4*Math.floor(S/4),z=S%4;let K="sumValue += dot(values, ones);";if(k!=null){const ue=1/k;K=`sumValue += dot(values * ${n.util.isInt(ue)?ue.toPrecision(2):ue}, ones);`}let Q="";T%S>0&&(Q=`
        if (inIdx < 0 || inIdx >= ${T}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${Q}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${S};

        float sumValue = 0.0;

        for (int i = 0; i < ${B}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${K}
        }

        int inIdx = inOffset + ${B};
        if (${z===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${K}
        } else if (${z===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${K}
        } else if (${z===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${K}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aa{constructor(y,k){this.variableNames=["x"];const{windowSize:S,batchSize:_,inSize:T,outSize:O}=y;this.outputShape=[_,O];let B="0.0",z="";k==="prod"?B="1.0":k==="min"?(B="1.0 / 1e-20",z="min"):k==="max"&&(B="-1.0 / 1e-20",z="max");let K=`${k}(${k}(${k}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;k==="sum"?K="sumValue":k==="prod"?K="prodValue":k==="all"?K="allValue":k==="any"&&(K="anyValue");const Q=4*Math.floor(S/4),ue=S%4;let ae=`
      if (${k==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${k==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${z}(values, minMaxValue);
        if (${k==="min"} || ${k==="max"}) {
          minMaxValue = ${z}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,Re="vec4";k==="all"?(B="1.0",ae=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,Re="bvec4"):k==="any"&&(B="0.0",ae=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,Re="bvec4");let ke="";T%S>0&&(ke=`
        if (inIdx < 0 || inIdx >= ${T}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${B};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${ke}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${S};

        vec4 minMaxValue = vec4(${B});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${Q}; i += 4) {
          int inIdx = inOffset + i;
          ${Re} values = ${Re}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${ae}
        }

        int inIdx = inOffset + ${Q};
        if (${ue===1}) {
          ${Re} values = ${Re}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${ae}
        } else if (${ue===2}) {
          ${Re} values = ${Re}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${ae}
        } else if (${ue===3}) {
          ${Re} values = ${Re}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${ae}
        }
        setOutput(${K});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vr(F,y,k,S){const _=function(O){const B=[];for(;B.length===0||B[B.length-1].outSize!==1;){const z=B.length?B[B.length-1].outSize:O[1],K=n.backend_util.computeOptimalWindowSize(z);B.push({inSize:z,windowSize:K,outSize:Math.ceil(z/K)})}return B}(F.shape);let T=F;for(let O=0;O<_.length;O++){const{inSize:B,windowSize:z,outSize:K}=_[O];let Q,ue;Q=k==="mean"?O===0?new Gn({windowSize:z,inSize:B,batchSize:F.shape[0],outSize:K},B):new Gn({windowSize:z,inSize:B,batchSize:F.shape[0],outSize:K}):new Aa({windowSize:z,inSize:B,batchSize:F.shape[0],outSize:K},k),ue=T,T=S.runWebGLProgram(Q,[T],y),ue.dataId!==F.dataId&&S.disposeIntermediateTensorInfo(ue)}return T}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ua{constructor(y,k){this.variableNames=["A"];const S=new Array(y.length);for(let O=0;O<S.length;O++)S[O]=y[k[O]];this.outputShape=S,this.rank=S.length;const _=pe(this.rank),T=function(O){const B=O.length;if(B>6)throw Error(`Transpose for rank ${B} is not yet supported`);const z=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],K=new Array(B);for(let Q=0;Q<O.length;Q++)K[O[Q]]=z[Q];return K.join()}(k);this.userCode=`
    void main() {
      ${_} resRC = getOutputCoords();
      setOutput(getA(${T}));
    }
    `}}class tu{constructor(y,k){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const S=new Array(y.length);for(let Q=0;Q<S.length;Q++)S[Q]=y[k[Q]];if(this.outputShape=S,this.rank=S.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const _=pe(this.rank),T=fn("rc",this.rank),O=new Array(this.rank);for(let Q=0;Q<k.length;Q++)O[k[Q]]=T[Q];const B=`vec2(${O.slice(-2).join()})`,z=`++${T[this.rank-1]} < ${S[this.rank-1]}`,K=`getChannel(getA(${O.join()}), ${B})`;this.userCode=`
    void main() {
      ${_} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${K};
      if(${z}) {
        result[1] = ${K};
      }
      --${T[this.rank-1]};
      if(++${T[this.rank-2]} < ${S[this.rank-2]}) {
        result[2] = ${K};
        if(${z}) {
          result[3] = ${K};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ui(F,y,k){const S=Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tu(F.shape,y):new ua(F.shape,y);return k.runWebGLProgram(S,[F],F.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jo(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,keepDims:O}=S;return function(B,z,K,Q){const ue=z,ae=B.shape.length,Re=n.util.parseAxisParam(ue,B.shape);let ke=Re;const Ge=n.backend_util.getAxesPermutation(ke,ae),qe=Ge!=null;let Ne=B;qe&&(Ne=ui(B,Ge,Q),ke=n.backend_util.getInnerMostAxes(ke.length,ae)),n.backend_util.assertAxesAreInnerMostDims("sum",ke,ae);const[Ke,an]=n.backend_util.computeOutAndReduceShapes(Ne.shape,ke);let kn=Ke;K&&(kn=n.backend_util.expandShapeToKeepDim(Ke,Re));const Pn=n.util.sizeFromShape(an),Xn=jn({inputs:{x:Ne},attrs:{shape:[n.util.sizeFromShape(B.shape)/Pn,Pn]},backend:Q}),Hn=Vr(Xn,Object(n.sumOutType)(B.dtype),"sum",Q),Qn=jn({inputs:{x:Hn},attrs:{shape:kn},backend:Q});return Q.disposeIntermediateTensorInfo(Xn),Q.disposeIntermediateTensorInfo(Hn),qe&&Q.disposeIntermediateTensorInfo(Ne),Qn}(_,T,O,k)}const Ku={kernelName:n.Sum,backendName:"webgl",kernelFunc:jo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{perm:T}=S,O=k,B=_.shape.length,z=new Array(B);for(let Q=0;Q<z.length;Q++)z[Q]=_.shape[T[Q]];let K;if(O.shouldExecuteOnCPU([_])){const Q=O.texData.get(_.dataId).values,ue=sn(Q,_.shape,_.dtype,T,z);K=O.makeTensorInfo(z,_.dtype),O.texData.get(K.dataId).values=ue}else K=ui(_,T,O);return K}const oo={kernelName:n.Transpose,backendName:"webgl",kernelFunc:Ur};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Go({a:F,b:y,transposeA:k,transposeB:S,backend:_,bias:T=null,preluActivationWeights:O=null,leakyreluAlpha:B=0,activation:z=null}){const K=F.shape.length,Q=y.shape.length,ue=k?F.shape[K-2]:F.shape[K-1],ae=S?y.shape[Q-1]:y.shape[Q-2],Re=k?F.shape[K-1]:F.shape[K-2],ke=S?y.shape[Q-2]:y.shape[Q-1],Ge=F.shape.slice(0,-2),qe=y.shape.slice(0,-2),Ne=n.util.sizeFromShape(Ge),Ke=n.util.sizeFromShape(qe),an=n.broadcast_util.assertAndGetBroadcastShape(F.shape.slice(0,-2),y.shape.slice(0,-2)).concat([Re,ke]);n.util.assert(ue===ae,()=>`Error in matMul: inner shapes (${ue}) and (${ae}) of Tensors with shapes ${F.shape} and ${y.shape} and transposeA=${k} and transposeB=${S} must match.`);const kn=k?[Ne,ue,Re]:[Ne,Re,ue],Pn=S?[Ke,ke,ae]:[Ke,ae,ke],Xn=jn({inputs:{x:F},backend:_,attrs:{shape:kn}}),Hn=jn({inputs:{x:y},backend:_,attrs:{shape:Pn}}),Qn=[Xn,Hn],Wn=Math.max(Ne,Ke),vs=k?Xn.shape[1]:Xn.shape[2],fs=T!=null,w=O!=null,g=z==="leakyrelu",v=z!=null?ao(z,!0):null;let C;if((Re===1||ke===1)&&vs>1e3&&(fs||w||g||v!=null)===!1){let M=Xn,W=Hn;k&&(M=Ur({inputs:{x:Xn},backend:_,attrs:{perm:[0,2,1]}}),Qn.push(M)),S&&(W=Ur({inputs:{x:Hn},backend:_,attrs:{perm:[0,2,1]}}),Qn.push(W));const J=ke===1;let le=M;ke!==1&&(le=jn({inputs:{x:M},backend:_,attrs:{shape:[Wn,vs,1]}}),Qn.push(le));const ve=ke===1?2:1;let Xe=W;J&&(Xe=jn({inputs:{x:W},backend:_,attrs:{shape:[Wn,1,vs]}}),Qn.push(Xe));const Ve=ii({inputs:{a:le,b:Xe},backend:_});C=jo({inputs:{x:Ve},backend:_,attrs:{axis:ve,keepDims:!0}}),Qn.push(Ve)}else{const M=Object(n.upcastType)(F.dtype,y.dtype),W=new Si(kn,Pn,[Wn,Re,ke],k,S,fs,v,w,g),J=[Xn,Hn];if(T!=null&&J.push(T),w&&J.push(O),g){const le=_.makeTensorInfo([],"float32",n.util.createScalarValue(B,"float32"));J.push(le),Qn.push(le)}C=_.runWebGLProgram(W,J,M)}const $=jn({inputs:{x:C},backend:_,attrs:{shape:an}});Qn.push(C);for(const M of Qn)_.disposeIntermediateTensorInfo(M);return $}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ar={kernelName:n._FusedMatMul,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{a:_,b:T,bias:O,preluActivationWeights:B}=y,{transposeA:z,transposeB:K,activation:Q,leakyreluAlpha:ue}=S;return Go({a:_,b:T,transposeA:z,transposeB:K,backend:k,bias:O,preluActivationWeights:B,leakyreluAlpha:ue,activation:Q})}},xo="return abs(x);";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni={kernelName:n.Abs,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{x:S}=y;if(k.shouldExecuteOnCPU([S])&&S.dtype!=="complex64"){const T=k.texData.get(S.dataId),O=Ea(T.values);return k.makeTensorInfo(S.shape,S.dtype,O)}let _;return _=Object(n.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Va(S.shape,xo):new Or(S.shape,xo),k.runWebGLProgram(_,[S],S.dtype)}},nu=Ls({opSnippet:`if (isnan(x)) return x;
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),ci={kernelName:n.Acos,backendName:"webgl",kernelFunc:nu},li=Ls({opSnippet:`if (isnan(x)) return x;
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),Os={kernelName:n.Acosh,backendName:"webgl",kernelFunc:li},Ei="return a + b;",Ia=Lr({opSnippet:Ei,packedOpSnippet:Ei,supportsComplex:!0,cpuKernelImpl:bn}),su={kernelName:n.Add,backendName:"webgl",kernelFunc:Ia};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ri{constructor(y,k){this.outputShape=[],this.outputShape=y,this.variableNames=k.map((T,O)=>`T${O}`);const S=[];this.variableNames.forEach(T=>{S.push(`float v${T} = get${T}AtOutCoords();`)});const _=this.variableNames.map(T=>`v${T}`).join(" + ");this.userCode=`
      void main() {
        ${S.join(`
        `)}

        float result = ${_};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai{constructor(y,k){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=y,this.variableNames=k.map((T,O)=>`T${O}`);const S=[];this.variableNames.forEach(T=>{S.push(`vec4 v${T} = get${T}AtOutCoords();`)});const _=this.variableNames.map(T=>`v${T}`).join(" + ");this.userCode=`
      void main() {
        ${S.join(`
        `)}

        vec4 result = ${_};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ru={kernelName:n.AddN,backendName:"webgl",kernelFunc:function F(y){const{inputs:k,backend:S}=y,_=k;if(_.length===1)return Wr({inputs:{x:_[0]},backend:S});if(_.length>Object(n.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const z=Math.floor(_.length/2),K=F({inputs:_.slice(0,z),backend:S}),Q=F({inputs:_.slice(z),backend:S});return F({inputs:[K,Q],backend:S})}const T=_.map(z=>z.dtype).reduce((z,K)=>Object(n.upcastType)(z,K)),O=_.map(z=>z.shape),B=Object(n.env)().getBool("WEBGL_PACK")?new Ai(_[0].shape,O):new Ri(_[0].shape,O);return S.runWebGLProgram(B,_,T)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oi={kernelName:n.All,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,keepDims:O}=S,B=_.shape.length,z=n.util.parseAxisParam(T,_.shape);let K=z;const Q=n.backend_util.getAxesPermutation(K,B);let ue=_;Q!=null&&(ue=Ur({inputs:{x:_},backend:k,attrs:{perm:Q}}),K=n.backend_util.getInnerMostAxes(K.length,B)),n.backend_util.assertAxesAreInnerMostDims("all",K,B);const[ae,Re]=n.backend_util.computeOutAndReduceShapes(ue.shape,K),ke=jn({inputs:{x:ue},backend:k,attrs:{shape:[-1,n.util.sizeFromShape(Re)]}}),Ge=Vr(ke,ke.dtype,"all",k);let qe;return O?qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:n.backend_util.expandShapeToKeepDim(ae,z)}}):qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:ae}}),k.disposeIntermediateTensorInfo(ke),k.disposeIntermediateTensorInfo(Ge),Q!=null&&k.disposeIntermediateTensorInfo(ue),qe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo={kernelName:n.Any,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,keepDims:O}=S,B=_.shape.length,z=n.util.parseAxisParam(T,_.shape);let K=z;const Q=n.backend_util.getAxesPermutation(K,B);let ue=_;Q!=null&&(ue=Ur({inputs:{x:_},backend:k,attrs:{perm:Q}}),K=n.backend_util.getInnerMostAxes(K.length,B)),n.backend_util.assertAxesAreInnerMostDims("any",K,B);const[ae,Re]=n.backend_util.computeOutAndReduceShapes(ue.shape,K),ke=jn({inputs:{x:ue},backend:k,attrs:{shape:[-1,n.util.sizeFromShape(Re)]}}),Ge=Vr(ke,ke.dtype,"any",k);let qe;return O?qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:n.backend_util.expandShapeToKeepDim(ae,z)}}):qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:ae}}),k.disposeIntermediateTensorInfo(ke),k.disposeIntermediateTensorInfo(Ge),Q!=null&&k.disposeIntermediateTensorInfo(ue),qe}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fi{constructor(y,k,S){this.variableNames=["A"];const{windowSize:_,batchSize:T,outSize:O}=y;S||this.variableNames.push("bestIndicesA"),this.outputShape=[T,O];const B=k==="max"?">":"<",z=S?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${_};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${_}; i++) {
          int inIdx = ${z};
          float candidate = getA(batch, inIdx);
          if (candidate ${B} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cc{constructor(y,k,S,_){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,n.util.assert(y.length>2,()=>`Packed arg${S.charAt(0).toUpperCase()+S.slice(1)} supports only inputs with rank above 2.`);const T=y[y.length-1],O=Math.ceil(T/k);this.outputShape=y.slice(0,-1),O>1&&this.outputShape.push(O),_||this.variableNames.push("bestIndicesA");const B=this.outputShape,z=B.length,K=pe(z),Q=Vn("coords",z);let ue,ae;if(O===1){ae=z+1;const Qn=pe(ae);ue=`
        ${Qn} sourceLocR = ${Qn}(${Q.join()}, 0);
        ++${Q[z-1]};
        ${Qn} sourceLocG = ${Qn}(${Q.join()}, 0);
        ++${Q[z-2]};
        ${Qn} sourceLocA = ${Qn}(${Q.join()}, 0);
        --${Q[z-1]};
        ${Qn} sourceLocB = ${Qn}(${Q.join()}, 0);
        --${Q[z-2]};`}else ae=z,ue=`
        ${K} sourceLocR = coords;
        ++${Q[z-1]};
        ${K} sourceLocG = coords;
        ++${Q[z-2]};
        ${K} sourceLocA = coords;
        --${Q[z-1]};
        ${K} sourceLocB = coords;
        --${Q[z-2]};`;const Re=["x","y","z","w","u","v"].slice(0,ae),ke="."+Re[ae-1],Ge=Re.map(Qn=>"int "+Qn),qe=Vn("sourceLocR",ae-1).concat("inIdx.r"),Ne=Vn("sourceLocG",ae-1).concat("inIdx.g"),Ke=Vn("sourceLocB",ae-1).concat("inIdx.b"),an=Vn("sourceLocA",ae-1).concat("inIdx.a"),kn=S==="max"?"greaterThan":"lessThan",Pn=_?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${qe.join()}),
                             getBestIndicesAChannel(${Ne.join()}),
                             getBestIndicesAChannel(${Ke.join()}),
                             getBestIndicesAChannel(${an.join()})));`,Xn=`vec4(
            getAChannel(${qe.join()}),
            hasNextCol ? getAChannel(${Ne.join()}) : 0.,
            hasNextRow ? getAChannel(${Ke.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${an.join()}) : 0.)`,Hn=_?"":`
      float getBestIndicesAChannel(${Ge.join()}) {
        return getChannel(getBestIndicesA(${Re.join()}),
                                          vec2(${Re.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${Ge.join()}) {
        return getChannel(getA(${Re.join()}),
                               vec2(${Re.slice(-2).join()}));
      }
      ${Hn}
      void main() {
        ${K} coords = getOutputCoords();
        bool hasNextCol = ${Q[z-1]} < ${B[z-1]-1};
        bool hasNextRow = ${Q[z-2]} < ${B[z-2]-1};
        ${ue}
        ivec4 srcIdx = ivec4(sourceLocR${ke}, sourceLocG${ke},
          sourceLocB${ke}, sourceLocA${ke}) * ${k};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${Xn};

        for (int i = 0; i < ${k}; i++) {
          inIdx = srcIdx;
          ${Pn}
          vec4 candidate = ${Xn};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${kn}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(F,y,k,S=null){let _=y.shape[0],T=y.shape[1];S!=null&&(_=S.shape[0],T=S.shape[1]);const O=n.backend_util.computeOptimalWindowSize(T),B={windowSize:O,inSize:T,batchSize:_,outSize:Math.ceil(T/O)},z=new Fi(B,k,S==null),K=[y];S!=null&&K.push(S);const Q=F.runWebGLProgram(z,K,"int32");if(Q.shape[1]===1)return Q;const ue=Di(F,y,k,Q);return F.disposeIntermediateTensorInfo(Q),ue}function Ro(F,y,k,S=null){const _=S!=null?S.shape:y.shape,T=_[_.length-1],O=n.backend_util.computeOptimalWindowSize(T),B=new Cc(_,O,k,S==null),z=S==null?[y]:[y,S],K=F.runWebGLProgram(B,z,"int32");if(K.shape.length===y.shape.length){const Q=Ro(F,y,k,K);return F.disposeIntermediateTensorInfo(K),Q}return K}function au(F,y,k,S){const _=[k];if(n.backend_util.assertAxesAreInnerMostDims("arg"+S.charAt(0).toUpperCase()+S.slice(1),_,y.shape.length),!Object(n.env)().getBool("WEBGL_PACK_REDUCE")||y.shape.length<=2){const T=[],O=F.texData.get(y.dataId);let B=y;O!==null&&O.isPacked&&(B=F.unpackTensor(y),T.push(B));const[z,K]=n.backend_util.computeOutAndReduceShapes(B.shape,_),Q=n.util.sizeFromShape(K),ue=jn({inputs:{x:B},backend:F,attrs:{shape:[-1,Q]}});T.push(ue);const ae=Di(F,ue,S);T.push(ae);const Re=jn({inputs:{x:ae},backend:F,attrs:{shape:z}});return T.forEach(ke=>F.disposeIntermediateTensorInfo(ke)),Re}return Ro(F,y,S)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mi={kernelName:n.ArgMax,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T}=S;let O=n.util.parseAxisParam(T,_.shape);const B=n.backend_util.getAxesPermutation(O,_.shape.length);let z=_;const K=[];B!=null&&(z=Ur({inputs:{x:_},backend:k,attrs:{perm:B}}),K.push(z),O=n.backend_util.getInnerMostAxes(O.length,z.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMax",[O[0]],z.shape.length);const Q=au(k,z,O[0],"max");return K.forEach(ue=>k.disposeIntermediateTensorInfo(ue)),Q}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _c={kernelName:n.ArgMin,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T}=S;let O=n.util.parseAxisParam(T,_.shape);const B=n.backend_util.getAxesPermutation(O,_.shape.length);let z=_;const K=[];B!=null&&(z=Ur({inputs:{x:_},backend:k,attrs:{perm:B}}),K.push(z),O=n.backend_util.getInnerMostAxes(O.length,z.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMin",[O[0]],z.shape.length);const Q=au(k,z,O[0],"min");return K.forEach(ue=>k.disposeIntermediateTensorInfo(ue)),Q}},di=Ls({opSnippet:`if (isnan(x)) return x;
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),Pi={kernelName:n.Asin,backendName:"webgl",kernelFunc:di},ou=Ls({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Xu={kernelName:n.Asinh,backendName:"webgl",kernelFunc:ou},Sc=Ls({opSnippet:`if (isnan(x)) return x;
  return atan(x);
`}),$c={kernelName:n.Atan,backendName:"webgl",kernelFunc:Sc},Yu=Lr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),Pe={kernelName:n.Atan2,backendName:"webgl",kernelFunc:Yu},me=Ls({opSnippet:`if (isnan(x)) return x;
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`}),He={kernelName:n.Atanh,backendName:"webgl",kernelFunc:me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class st{constructor(y,k,S,_=!1,T=!1){if(this.variableNames=["x"],k==="avg"&&S)throw new Error("Cannot compute positions for average pool.");const O=y.filterWidth,B=y.strideHeight,z=y.strideWidth,K=y.dilationHeight,Q=y.dilationWidth,ue=y.effectiveFilterHeight,ae=y.effectiveFilterWidth,Re=y.padInfo.top,ke=y.padInfo.left;this.outputShape=y.outShape;const Ge=k==="avg",qe=`((batch  * ${y.inHeight} + xR) * ${y.inWidth} + xC) * ${y.inChannels} + d`,Ne=`(xR * ${y.inWidth} + xC) * ${y.inChannels} + d`;let Ke="0.0";if(Ge||(Ke="-1.0 / 1e-20"),S){const Hn=">=";return void(this.userCode=`
        const ivec2 strides = ivec2(${B}, ${z});
        const ivec2 pads = ivec2(${Re}, ${ke});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${ue};
              wR += ${K}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${y.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${ae};
                wC += ${Q}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${y.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${Hn} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${_?T?qe:Ne:`wR * ${ae} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let an=`${k}(${k}(${k}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;k==="avg"&&(an="avgValue / count");const kn=4*Math.floor(O/4),Pn=O%4,Xn=`
      if (${Ge}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${B}, ${z});
      const ivec2 pads = ivec2(${Re}, ${ke});
      const float initializationValue = ${Ke};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${y.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${Ke});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${ue};
            wR += ${K}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${y.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${kn}; wC += 4) {
            int xC = xCCorner + wC * ${Q};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Q}, d),
              getValue(batch, xR, xC + 2 * ${Q}, d),
              getValue(batch, xR, xC + 3 * ${Q}, d)
            );

            ${Xn}
          }

          int xC = xCCorner + ${kn};
          if (${Pn===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${Xn}
          } else if (${Pn===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Q}, d),
              initializationValue,
              initializationValue
            );

            ${Xn}
          } else if (${Pn===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${Q}, d),
              getValue(batch, xR, xC + 2 * ${Q}, d),
              initializationValue
            );

            ${Xn}
          }
        }
        setOutput(${an});
      }
    `}}class Ae{constructor(y,k,S,_=!1,T=!1){if(this.variableNames=["x"],k==="avg"&&S)throw new Error("Cannot compute positions for average pool.");const O=y.filterWidth,B=y.strideDepth,z=y.strideHeight,K=y.strideWidth,Q=y.dilationDepth,ue=y.dilationHeight,ae=y.dilationWidth,Re=y.effectiveFilterDepth,ke=y.effectiveFilterHeight,Ge=y.effectiveFilterWidth,qe=y.padInfo.front,Ne=y.padInfo.top,Ke=y.padInfo.left;this.outputShape=y.outShape;const an=k==="avg";let kn="0.0";if(an||(kn="-1.0 / 1e-20"),S){const Wn=">=";return void(this.userCode=`
        const ivec3 strides =
            ivec3(${B}, ${z}, ${K});
        const ivec3 pads = ivec3(${qe}, ${Ne}, ${Ke});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${Re};
              wD += ${Q}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${y.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${ke};
                wR += ${ue}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${y.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${Ge};
                  wC += ${ae}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${y.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${Wn} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${_?T?`(((batch * ${y.inDepth} + xD) * ${y.inHeight} + xR) * ${y.inWidth} + xC) * ${y.inChannels} + ch`:`((xD * ${y.inHeight} + xR) * ${y.inWidth} + xC) * ${y.inChannels} + ch`:`wD * ${ke} * ${Ge} +
                      wR * ${Ge} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let Pn=`${k}(${k}(${k}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;k==="avg"&&(Pn="avgValue / count");const Xn=4*Math.floor(O/4),Hn=O%4,Qn=`
      if (${an}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${B}, ${z}, ${K});
      const ivec3 pads = ivec3(${qe}, ${Ne}, ${Ke});
      const float initializationValue = ${kn};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${y.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${kn});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${Re};
            wD += ${Q}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${y.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${ke};
            wR += ${ue}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${y.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Xn}; wC += 4) {
              int xC = xCCorner + wC * ${ae};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ae}, ch),
                getValue(batch, xD, xR, xC + 2 * ${ae}, ch),
                getValue(batch, xD, xR, xC + 3 * ${ae}, ch)
              );

              ${Qn}
            }

            int xC = xCCorner + ${Xn};
            if (${Hn===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${Qn}
            } else if (${Hn===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ae}, ch),
                initializationValue,
                initializationValue
              );

              ${Qn}
            } else if (${Hn===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${ae}, ch),
                getValue(batch, xD, xR, xC + 2 * ${ae}, ch),
                initializationValue
              );

              ${Qn}
            }
          }
          setOutput(${Pn});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rt={kernelName:n.AvgPool,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y;wt(_,"avgPool");const{filterSize:T,strides:O,pad:B,dimRoundingMode:z}=S;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(O,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${O} and dilations '1'`);const K=n.backend_util.computePool2DInfo(_.shape,T,O,1,B,z);if(K.filterWidth===1&&K.filterHeight===1&&n.util.arraysEqual(K.inShape,K.outShape))return Wr({inputs:{x:_},backend:k});const Q=new st(K,"avg",!1);return k.runWebGLProgram(Q,[_],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt={kernelName:n.AvgPool3D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{filterSize:T,strides:O,pad:B,dimRoundingMode:z,dataFormat:K}=S,Q=n.backend_util.computePool3DInfo(_.shape,T,O,[1,1,1],B,z,K),ue=new Ae(Q,"avg",!1);return k.runWebGLProgram(ue,[_],"float32")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nt{constructor(y){this.variableNames=["dy"],this.outputShape=y.inShape;const k=y.filterHeight,S=y.filterWidth,_=y.strideHeight,T=y.strideWidth,O=y.dilationHeight,B=y.dilationWidth,z=y.effectiveFilterHeight,K=y.effectiveFilterWidth,Q=z-1-y.padInfo.top,ue=K-1-y.padInfo.left,ae=1/(k*S);this.userCode=`
      const ivec2 pads = ivec2(${Q}, ${ue});
      const float avgMultiplier = float(${ae});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${z};
            wR += ${O}) {
          float dyR = float(dyRCorner + wR) / ${_}.0;

          if (dyR < 0.0 || dyR >= ${y.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${K};
            wC+= ${B}) {
            float dyC = float(dyCCorner + wC) / ${T}.0;

            if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class vt{constructor(y){this.variableNames=["dy"],this.outputShape=y.inShape;const k=y.filterDepth,S=y.filterHeight,_=y.filterWidth,T=y.strideDepth,O=y.strideHeight,B=y.strideWidth,z=y.dilationDepth,K=y.dilationHeight,Q=y.dilationWidth,ue=y.effectiveFilterDepth,ae=y.effectiveFilterHeight,Re=y.effectiveFilterWidth,ke=ue-1-y.padInfo.front,Ge=ae-1-y.padInfo.top,qe=Re-1-y.padInfo.left,Ne=1/(k*S*_);this.userCode=`
      const ivec3 pads = ivec3(${ke}, ${Ge}, ${qe});
      const float avgMultiplier = float(${Ne});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${ue};
            wD += ${z}) {
          float dyD = float(dyDCorner + wD) / ${T}.0;

          if (dyD < 0.0 || dyD >= ${y.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${ae};
              wR += ${K}) {
            float dyR = float(dyRCorner + wR) / ${O}.0;

            if (dyR < 0.0 || dyR >= ${y.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${Re};
                wC += ${Q}) {
              float dyC = float(dyCCorner + wC) / ${B}.0;

              if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const St={kernelName:n.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,input:T}=y,O=T,{filterSize:B,strides:z,pad:K,dimRoundingMode:Q}=S,ue=n.backend_util.computePool3DInfo(O.shape,B,z,[1,1,1],K,Q),ae=new vt(ue);return k.runWebGLProgram(ae,[_],O.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _t={kernelName:n.AvgPoolGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,input:T}=y,O=T;wt([_,T],"avgPoolGrad");const{filterSize:B,strides:z,pad:K}=S,Q=n.backend_util.computePool2DInfo(O.shape,B,z,1,K),ue=new Nt(Q);return k.runWebGLProgram(ue,[_],O.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const en={kernelName:n.BatchMatMul,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{a:_,b:T}=y,{transposeA:O,transposeB:B}=S;return Go({a:_,b:T,transposeA:O,transposeB:B,backend:k})}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kt{constructor(y,k,S,_,T,O){this.outputShape=[],this.variableNames=["x","mean","variance"],n.backend_util.assertAndGetBroadcastShape(y,k),n.backend_util.assertAndGetBroadcastShape(y,S);let B="0.0";_!=null&&(n.backend_util.assertAndGetBroadcastShape(y,_),this.variableNames.push("offset"),B="getOffsetAtOutCoords()");let z="1.0";T!=null&&(n.backend_util.assertAndGetBroadcastShape(y,T),this.variableNames.push("scale"),z="getScaleAtOutCoords()"),this.outputShape=y,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${B};
        float scale = ${z};
        float inv = scale * inversesqrt(variance + float(${O}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ze{constructor(y,k,S,_,T,O){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],n.backend_util.assertAndGetBroadcastShape(y,k),n.backend_util.assertAndGetBroadcastShape(y,S);let B="vec4(0.0)";_!=null&&(n.backend_util.assertAndGetBroadcastShape(y,_),this.variableNames.push("offset"),B="getOffsetAtOutCoords()");let z="vec4(1.0)";T!=null&&(n.backend_util.assertAndGetBroadcastShape(y,T),this.variableNames.push("scale"),z="getScaleAtOutCoords()"),this.outputShape=y,this.userCode=`
      void main() {
        vec4 offset = ${B};
        vec4 scale = ${z};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${O}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt={kernelName:n.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:F,backend:y,attrs:k})=>{const{x:S,mean:_,variance:T,offset:O,scale:B}=F;n.util.assert(_.shape.length===T.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),n.util.assert(O==null||_.shape.length===O.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),n.util.assert(B==null||_.shape.length===B.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:z}=k;z==null&&(z=.001);const K=[S,_,T];let Q=null;O!=null&&(Q=O.shape,K.push(O));let ue=null;B!=null&&(ue=B.shape,K.push(B));const ae=Object(n.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Ze(S.shape,_.shape,T.shape,Q,ue,z):new Kt(S.shape,_.shape,T.shape,Q,ue,z);return y.runWebGLProgram(ae,K,K[0].dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jt{constructor(y){this.variableNames=["source"],this.outputShape=y,this.rank=y.length;const k=pe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const S=function(T){if(T===1)return"sourceLoc";if(T<=6)return un.slice(0,T).map(O=>"sourceLoc."+O).join(",");throw Error(`Slicing for rank ${T} is not yet supported`)}(this.rank);let _;_=`
        ${k} sourceLoc;
        ${k} coords = getOutputCoords();
        ${y.map((T,O)=>`sourceLoc.${un[O]} = start[${O}] + coords.${un[O]};`).join(`
`)}
      `,this.userCode=`
      void main() {
        ${_}
        setOutput(getSource(${S}));
      }
    `}}const un=["x","y","z","w","u","v"];class In{constructor(y){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=y,this.rank=y.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const k=pe(this.rank),S=Vn("coords",this.rank),_=Vn("sourceLoc",this.rank),T=this.rank===1?"sourceLoc":`vec2(${_.slice(-2).join()})`,O=`getChannel(getSource(${_.join()}), ${T})`,B=`
      result.x = ${O};
      if (++${S[this.rank-1]} < ${y[this.rank-1]}) {
        ++${_[this.rank-1]};
        result.y = ${O};
        --${_[this.rank-1]};
      }
    `,z=this.rank===1?"":`
      --${S[this.rank-1]};
      if (++${S[this.rank-2]} < ${y[this.rank-2]}) {
        ++${_[this.rank-2]};
        result.z = ${O};
        if (++${S[this.rank-1]} < ${y[this.rank-1]}) {
          ++${_[this.rank-1]};
          result.w = ${O};
        }
      }
    `,K=this.rank<=4?`sourceLoc = coords +
            ${k}(${y.map((Q,ue)=>`start[${ue}]`).join()});`:y.map((Q,ue)=>`${_[ue]} = ${S[ue]} + start[${ue}];`).join(`
`);this.userCode=`
      void main() {
        ${k} coords = getOutputCoords();
        ${k} sourceLoc;
        ${K}
        vec4 result = vec4(0.);
        ${B}
        ${z}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{begin:T,size:O}=S,[B,z]=n.slice_util.parseSliceParams(_,T,O);if(n.slice_util.assertParamsValid(_,B,z),n.util.sizeFromShape(z)===0)return k.makeTensorInfo(z,_.dtype,[]);if(k.shouldExecuteOnCPU([_])||_.dtype==="string"){const ue=k.texData.get(_.dataId),ae=Vo(ue.values,B,z,_.shape,_.dtype);return k.makeTensorInfo(z,_.dtype,ae)}const{isPacked:K}=k.texData.get(_.dataId),Q=n.slice_util.isSliceContinous(_.shape,B,z);if(K||!Q){const ue=Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new In(z):new Jt(z),ae=[B];return k.runWebGLProgram(ue,[_],_.dtype,ae)}return k.uploadToGPU(_.dataId),function(ue,ae,Re,ke){const Ge=ke.texData.get(ue.dataId),qe=ke.makeTensorInfo(Re,ue.dtype),Ne=ke.texData.get(qe.dataId);Object.assign(Ne,Ge),Ne.refCount=1,Ne.shape=Re,Ne.dtype=ue.dtype;let Ke=n.slice_util.computeFlatOffset(ae,n.util.computeStrides(ue.shape));Ge.slice&&(Ke+=Ge.slice.flatOffset),Ne.slice={flatOffset:Ke,origDataId:Ge.slice&&Ge.slice.origDataId||ue.dataId};const an=ke.dataRefCount.get(Ne.slice.origDataId)||1;return ke.dataRefCount.set(Ne.slice.origDataId,an+1),qe}(_,B,z,k)}const $n={kernelName:n.Slice,backendName:"webgl",kernelFunc:Xt},Jn={kernelName:n.BatchToSpaceND,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{blockShape:T,crops:O}=S;n.util.assert(_.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const B=T.reduce((Ke,an)=>Ke*an),z=n.backend_util.getReshaped(_.shape,T,B),K=n.backend_util.getPermuted(z.length,T.length),Q=n.backend_util.getReshapedPermuted(_.shape,T,B),ue=n.backend_util.getSliceBeginCoords(O,T.length),ae=n.backend_util.getSliceSize(Q,O,T.length),Re=[],ke=jn({inputs:{x:_},backend:k,attrs:{shape:z}}),Ge=Ur({inputs:{x:ke},backend:k,attrs:{perm:K}}),qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:Q}}),Ne=Xt({inputs:{x:qe},backend:k,attrs:{begin:ue,size:ae}});return Re.push(ke),Re.push(Ge),Re.push(qe),Re.forEach(Ke=>k.disposeIntermediateTensorInfo(Ke)),Ne}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ss={kernelName:n.Bincount,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,weights:T}=y,{size:O}=S,B=k.readSync(_.dataId),z=k.readSync(T.dataId),K=On(B,z,T.dtype,T.shape,O);return k.makeTensorInfo([O],T.dtype,K)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ms={kernelName:n.BroadcastArgs,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{s0:S,s1:_}=y,T=k.readSync(S.dataId),O=k.readSync(_.dataId),B=n.backend_util.assertAndGetBroadcastShape(Array.from(T),Array.from(O));return k.makeTensorInfo([B.length],"int32",Int32Array.from(B))}},Ps=Lr({opSnippet:"return float(a != b);",cpuKernelImpl:si,dtype:"bool"}),Fs={kernelName:n.NotEqual,backendName:"webgl",kernelFunc:Ps};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr(F){const{inputs:y,backend:k}=F,{input:S}=y;return Wr({inputs:{x:k.texData.get(S.dataId).complexTensorInfos.real},backend:k})}const er={kernelName:n.Real,backendName:"webgl",kernelFunc:pr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fr={kernelName:n.Cast,backendName:"webgl",kernelFunc:function F(y){const{inputs:k,backend:S,attrs:_}=y,{x:T}=k,{dtype:O}=_;if(O==="complex64"){if(T.dtype==="complex64")return Wr({inputs:{x:T},backend:S});const B=n.zeros(T.shape),z=F({inputs:{x:T},backend:S,attrs:{dtype:"float32"}}),K=Xr({inputs:{real:z,imag:B},backend:S});return B.dispose(),S.disposeIntermediateTensorInfo(z),K}if(T.dtype==="complex64"){const B=pr({inputs:{input:T},backend:S}),z=F({inputs:{x:B},backend:S,attrs:{dtype:O}});return S.disposeIntermediateTensorInfo(B),z}if(!n.util.hasEncodingLoss(T.dtype,O)){const B=Wr({inputs:{x:T},backend:S});return{dataId:B.dataId,shape:B.shape,dtype:O}}if(S.shouldExecuteOnCPU([T])){const B=S.texData.get(T.dataId).values,[z,K,Q]=wn(B,T.shape,T.dtype,O);return S.makeTensorInfo(z,K,Q)}if(O==="int32")return function(B,z){const K=new Or(B.shape,"return float(int(x));"),Q=z.runWebGLProgram(K,[B],"int32");return{dataId:Q.dataId,shape:Q.shape,dtype:Q.dtype}}(T,S);if(O==="bool"){const B=S.makeTensorInfo([],"bool",n.util.getTypedArrayFromDType("bool",1)),z=Ps({inputs:{a:T,b:B},backend:S});return S.disposeIntermediateTensorInfo(B),z}throw new Error(`Error in Cast: failed to cast ${T.dtype} to ${O}`)}},cr="return ceil(x);",jr=Ls({opSnippet:cr,packedOpSnippet:cr,cpuKernelImpl:gs}),Ca={kernelName:n.Ceil,backendName:"webgl",kernelFunc:jr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yo{constructor(y){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=y,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ao{constructor(y){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=y,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Li={kernelName:n.ClipByValue,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{clipValueMin:T,clipValueMax:O}=S;let B;B=Object(n.env)().getBool("WEBGL_PACK_CLIP")?new Ao(_.shape):new yo(_.shape);const z=[[T],[O]];return k.runWebGLProgram(B,[_],_.dtype,z)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hi{constructor(y){this.variableNames=["real","imag"],this.outputShape=y,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(F,y){return{dataId:y.dataId,dtype:y.dtype,shape:F.shape}}const Ho={kernelName:n.ComplexAbs,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{x:S}=y,_=k.texData.get(S.dataId),T=new hi(S.shape),O=[wo(S,_.complexTensorInfos.real),wo(S,_.complexTensorInfos.imag)];return k.runWebGLProgram(T,O,O[0].dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qo{constructor(y){this.outputShape=[],this.outputShape=n.backend_util.computeOutShape(y,1),this.variableNames=y.map((O,B)=>`T${B}`);const k=new Array(y.length-1);k[0]=y[0][1];for(let O=1;O<k.length;O++)k[O]=k[O-1]+y[O][1];const S=[`if (yC < ${k[0]}) setOutput(getT0(yR, yC));`];for(let O=1;O<k.length;O++){const B=k[O-1];S.push(`else if (yC < ${k[O]}) setOutput(getT${O}(yR, yC-${B}));`)}const _=k.length,T=k[k.length-1];S.push(`else setOutput(getT${_}(yR, yC-${T}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${S.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bi{constructor(y,k){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=n.backend_util.computeOutShape(y,k);const S=this.outputShape,_=S.length,T=pe(_),O=Vn("coords",_),B=["x","y","z","w","u","v"].slice(0,_);this.variableNames=y.map((Ge,qe)=>`T${qe}`);const z=new Array(y.length-1);z[0]=y[0][k];for(let Ge=1;Ge<z.length;Ge++)z[Ge]=z[Ge-1]+y[Ge][k];const K=B[k],Q=B.slice(-2),ue=B.join();let ae=`if (${K} < ${z[0]}) {
        return getChannel(
            getT0(${ue}), vec2(${Q.join()}));
        }`;for(let Ge=1;Ge<z.length;Ge++){const qe=z[Ge-1];ae+=`
        if (${K} < ${z[Ge]}  && ${K} >= ${z[Ge-1]}) {
          return getChannel(
            getT${Ge}(${ca(B,K,qe)}),
            vec2(${ca(Q,K,qe)}));
        }`}const Re=z.length,ke=z[z.length-1];ae+=`
        return getChannel(
          getT${Re}(${ca(B,K,ke)}),
          vec2(${ca(Q,K,ke)}));`,this.userCode=`
      float getValue(${B.map(Ge=>"int "+Ge)}) {
        ${ae}
      }

      void main() {
        ${T} coords = getOutputCoords();
        vec4 result = vec4(getValue(${O}), 0., 0., 0.);

        ${O[_-1]} = ${O[_-1]} + 1;
        if (${O[_-1]} < ${S[_-1]}) {
          result.g = getValue(${O});
        }

        ${O[_-2]} = ${O[_-2]} + 1;
        if (${O[_-2]} < ${S[_-2]}) {
          result.a = getValue(${O});
        }

        ${O[_-1]} = ${O[_-1]} - 1;
        if (${O[_-2]} < ${S[_-2]} &&
            ${O[_-1]} < ${S[_-1]}) {
          result.b = getValue(${O});
        }
        setOutput(result);
      }
    `}}function ca(F,y,k){const S=F.indexOf(y);return F.map((_,T)=>T===S?`${_} - ${k}`:_).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(F){const{inputs:y,backend:k}=F,{input:S}=y;return Wr({inputs:{x:k.texData.get(S.dataId).complexTensorInfos.imag},backend:k})}const Zu={kernelName:n.Imag,backendName:"webgl",kernelFunc:zi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wi(F,y,k){const S=F[0].dtype;if(S==="complex64"){const ue=F.map(qe=>pr({inputs:{input:qe},backend:k})),ae=F.map(qe=>zi({inputs:{input:qe},backend:k})),Re=Wi(ue,y,k),ke=Wi(ae,y,k),Ge=Xr({inputs:{real:Re,imag:ke},backend:k});return ue.forEach(qe=>k.disposeIntermediateTensorInfo(qe)),ae.forEach(qe=>k.disposeIntermediateTensorInfo(qe)),k.disposeIntermediateTensorInfo(Re),k.disposeIntermediateTensorInfo(ke),Ge}let _=k.shouldExecuteOnCPU(F);if(S==="string"&&(_=!0),_){const ue=F.map(Ke=>{const an=n.util.sizeFromShape(Ke.shape.slice(y));return jn({inputs:{x:Ke},backend:k,attrs:{shape:[-1,an]}})}),ae=ue.map(Ke=>({vals:k.readSync(Ke.dataId),shape:Ke.shape})),Re=n.backend_util.computeOutShape(ue.map(Ke=>Ke.shape),1),ke=ue[0].shape[0]===1,Ge=Hs(ae,Re,S,ke),qe=n.backend_util.computeOutShape(F.map(Ke=>Ke.shape),y),Ne=k.makeTensorInfo(qe,S,Ge);return ue.forEach(Ke=>k.disposeIntermediateTensorInfo(Ke)),Ne}const T=Object(n.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(F.length>T){const ue=[];for(let Re=0;Re<F.length;Re+=T){const ke=F.slice(Re,Re+T);ue.push(Wi(ke,y,k))}const ae=Wi(ue,y,k);for(const Re of ue)k.disposeIntermediateTensorInfo(Re);return ae}if(Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&F[0].shape.length>1){const ue=new Bi(F.map(ae=>ae.shape),y);return k.runWebGLProgram(ue,F,S)}const{tensors2D:O,outShape:B}=function(ue,ae,Re){const ke=n.backend_util.computeOutShape(ue.map(Ge=>Ge.shape),ae);return{tensors2D:ue.map(Ge=>jn({inputs:{x:Ge},attrs:{shape:[-1,n.util.sizeFromShape(Ge.shape.slice(ae))]},backend:Re})),outShape:ke}}(F,y,k),z=new qo(O.map(ue=>ue.shape)),K=k.runWebGLProgram(z,O,S);O.forEach(ue=>k.disposeIntermediateTensorInfo(ue));const Q=jn({inputs:{x:K},attrs:{shape:B},backend:k});return k.disposeIntermediateTensorInfo(K),Q}function Qu(F){const{inputs:y,backend:k,attrs:S}=F,{axis:_}=S,T=n.util.parseAxisParam(_,y[0].shape)[0],O=n.backend_util.computeOutShape(y.map(K=>K.shape),T);if(n.util.sizeFromShape(O)===0)return k.makeTensorInfo(O,y[0].dtype,[]);const B=y.filter(K=>n.util.sizeFromShape(K.shape)>0);if(B.length===1)return Wr({inputs:{x:B[0]},backend:k});const z=B.map(K=>K.shape);return n.backend_util.assertParamsConsistent(z,T),Wi(B,T,k)}const Ol={kernelName:n.Concat,backendName:"webgl",kernelFunc:Qu};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kc{constructor(y,k=!1,S=null,_=!1,T=!1){this.variableNames=["x","W"],this.outputShape=y.outShape;const O=y.padInfo.top,B=y.padInfo.left,z=y.strideHeight,K=y.strideWidth,Q=y.dilationHeight,ue=y.dilationWidth,ae=y.filterHeight,Re=y.filterWidth,ke=4*Math.floor(y.inChannels/4),Ge=y.inChannels%4,qe=y.dataFormat==="channelsLast",Ne=qe?1:2,Ke=qe?2:3,an=qe?3:1;let kn="",Pn="";S&&(kn=_?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${S}
        }`:T?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${S}
        }`:`
          float activation(float x) {
            ${S}
          }
        `,Pn="result = activation(result);");const Xn=k?"result += getBiasAtOutCoords();":"";k&&this.variableNames.push("bias"),_&&this.variableNames.push("preluActivationWeights"),T&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${kn}

      const ivec2 strides = ivec2(${z}, ${K});
      const ivec2 pads = ivec2(${O}, ${B});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${an}];

        ivec2 xRCCorner =
            ivec2(coords[${Ne}], coords[${Ke}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${ae}; wR++) {
          int xR = xRCorner + wR * ${Q};

          if (xR < 0 || xR >= ${y.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${Re}; wC++) {
            int xC = xCCorner + wC * ${ue};

            if (xC < 0 || xC >= ${y.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${ke}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${qe}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${Ge===1}) {

              if (${qe}) {
                dotProd +=
                    getX(batch, xR, xC, ${ke}) *
                    getW(wR, wC, ${ke}, d2);
              } else {
                dotProd +=
                    getX(batch, ${ke}, xR, xC) *
                    getW(wR, wC, ${ke}, d2);
              }

            } else if (${Ge===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${ke}, d2),
                getW(wR, wC, ${ke} + 1, d2)
              );

              if (${qe}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${ke}),
                  getX(batch, xR, xC, ${ke} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${ke}, xR, xC),
                  getX(batch, ${ke} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${Ge===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${ke}, d2),
                getW(wR, wC, ${ke} + 1, d2),
                getW(wR, wC, ${ke} + 2, d2)
              );

              if (${qe}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${ke}),
                  getX(batch, xR, xC, ${ke} + 1),
                  getX(batch, xR, xC, ${ke} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${ke}, xR, xC),
                  getX(batch, ${ke} + 1, xR, xC),
                  getX(batch, ${ke} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${Xn}
        ${Pn}
        setOutput(result);
      }
    `}}class Fl{constructor(y){this.variableNames=["x","W"],this.outputShape=y.outShape;const k=y.padInfo.front,S=y.padInfo.top,_=y.padInfo.left,T=y.strideDepth,O=y.strideHeight,B=y.strideWidth,z=y.dilationDepth,K=y.dilationHeight,Q=y.dilationWidth,ue=y.filterDepth,ae=y.filterHeight,Re=y.filterWidth,ke=4*Math.floor(y.inChannels/4),Ge=y.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${T}, ${O}, ${B});
      const ivec3 pads = ivec3(${k}, ${S}, ${_});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${ue}; wF++) {
          int xF = xFCorner + wF * ${z};

          if (xF < 0 || xF >= ${y.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${ae}; wR++) {
            int xR = xRCorner + wR * ${K};

            if (xR < 0 || xR >= ${y.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Re}; wC++) {
              int xC = xCCorner + wC * ${Q};

              if (xC < 0 || xC >= ${y.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${ke}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${Ge===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${ke}) *
                  getW(wF, wR, wC, ${ke}, d2);
              } else if (${Ge===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${ke}),
                  getX(batch, xF, xR, xC, ${ke} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${ke}, d2),
                  getW(wF, wR, wC, ${ke} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${Ge===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${ke}),
                  getX(batch, xF, xR, xC, ${ke} + 1),
                  getX(batch, xF, xR, xC, ${ke} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${ke}, d2),
                  getW(wF, wR, wC, ${ke} + 1, d2),
                  getW(wF, wR, wC, ${ke} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xc{constructor(y,k=!1,S=null,_=!1,T=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=y.outShape,this.enableShapeUniforms=xs(this.outputShape.length);const O=y.padInfo.left,B=y.strideWidth,z=y.dilationWidth,K=y.filterHeight,Q=y.filterWidth,ue=Q;let ae=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let qe=0;qe<Q;qe++)ae+=`
           vec4 xTexelC${2*qe};
           int xTexelC${2*qe}Ready;
           vec4 xTexelC${2*qe+1};
           int xTexelC${2*qe+1}Ready;
           vec4 xC${qe};`;ae+=`
     for (int r = 0; r < ${K}; r++) {
      for (int d1 = 0; d1 < ${y.inChannels}; d1 += 2) {
       `;for(let qe=0;qe<Q;qe++)ae+=`
           xTexelC${2*qe} = vec4(0.0);
           xTexelC${2*qe}Ready = 0;
           xTexelC${2*qe+1} = vec4(0.0);
           xTexelC${2*qe+1}Ready = 0;
           xC${qe} = vec4(0.0);`;ae+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let qe=0;qe<(ue+1)/2;qe++){const Ne=2*qe;if(ae+=`
           xC = xCCorner + ${Ne*z};
           `,B===1){if(Ne<Q&&(O%2==1?(ae+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ne}Ready == 0) {
                   xTexelC${Ne} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Ne}.zw = vec2(0.0);
                   }
                   xTexelC${Ne}Ready = 1;
                 }
               `,ae+=z===1&&Ne>0?`
                 xC${Ne} = vec4(xTexelC${Ne-2}.zw, xTexelC${Ne}.xy);
                 `:`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${Ne} = vec4(previous.zw, xTexelC${Ne}.xy);
                   } else {
                     xC${Ne} = vec4(0.0, 0.0, xTexelC${Ne}.xy);
                   }
                   `):ae+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${Ne}Ready == 0) {
                   xTexelC${Ne} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${Ne}.zw = vec2(0.0);
                   }
                   xTexelC${Ne}Ready = 1;
                 }

                 xC${Ne} = xTexelC${Ne};
                 `,Ne+1<Q)){const Ke=O%2==0?n.util.nearestLargerEven(z):z;z%2==0&&O%2==1||z%2!=0&&O%2!=1?(ae+=`
                   xCOffset = xC + imod(pads[1], 2) + ${Ke};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ne+1}Ready == 0) {
                     xTexelC${Ne+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${Ne+1}.zw = vec2(0.0);
                     }
                     xTexelC${Ne+1}Ready = 1;
                   }
                   `,ae+=z>1?`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${Ne+1} = vec4(previous.zw, xTexelC${Ne+1}.xy);
                     } else {
                      xC${Ne+1} = vec4(0.0, 0.0, xTexelC${Ne+1}.xy);
                     }
                     `:`
                     xC${Ne+1} = vec4(xTexelC${Ne}.zw, xTexelC${Ne+1}.xy);
                     `):ae+=Ke===1?`
                     xC${Ne+1} = xTexelC${Ne};
                     `:`
                     xCOffset = xC + ${Ke};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ne+1}Ready == 0) {
                       xTexelC${Ne+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${Ne+1}.zw = vec2(0.0);
                       }
                       xTexelC${Ne+1}Ready = 1;
                     }

                     xC${Ne+1} = xTexelC${Ne+1};
                     `}}else Ne<Q&&(O%2==1?(ae+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ne}Ready == 0) {
                   xTexelC${Ne} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Ne}.zw = vec2(0.0);
                   }
                   xTexelC${Ne}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Ne+1}Ready == 0) {
                   xTexelC${Ne+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${Ne+1}.zw = vec2(0.0);
                   }
                   xTexelC${Ne+1}Ready = 1;
                 }

                 xC${Ne} = vec4(xTexelC${Ne}.zw, xTexelC${Ne+1}.zw);
               `,Ne+1<Q&&(ae+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${Ne+1} = vec4(xTexelC${Ne+1}.xy, final.xy);
                 `)):(ae+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${Ne}Ready == 0) {
                   xTexelC${Ne} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${Ne}.zw = vec2(0.0);
                   }
                   xTexelC${Ne}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ne+1}Ready == 0) {
                   xTexelC${Ne+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${Ne+1}.zw = vec2(0.);
                   }
                   xTexelC${Ne+1}Ready = 1;
                 }

                 xC${Ne} = vec4(
                   xTexelC${Ne}.xy, xTexelC${Ne+1}.xy);
               `,Ne+1<Q&&(ae+=`
                   xC${Ne+1} = vec4(xTexelC${Ne}.zw, xTexelC${Ne+1}.zw);
                 `)));Ne<Q&&(ae+=`
             wTexel = getW(r, ${Ne}, d1, d2);
             dotProd += xC${Ne}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${y.inChannels}) {
               dotProd += xC${Ne}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,Ne+1<Q&&(ae+=`
               wTexel = getW(r, ${Ne+1}, d1, d2);
               dotProd += xC${Ne+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${y.inChannels}) {
                 dotProd += xC${Ne+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}ae+=`
     }
   `,ae+=`
     }
   `,ae+=`
     }
   `;let Re="",ke="";S&&(Re=_?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${S}
         }`:T?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${S}
         }`:`vec4 activation(vec4 x) {
           ${S}
         }`,ke="result = activation(result);");const Ge=k?"result += getBiasAtOutCoords();":"";k&&this.variableNames.push("bias"),_&&this.variableNames.push("preluActivationWeights"),T&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${Re}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${ae}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${Ge}
         ${ke}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tc{constructor(y,k){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=y,this.enableShapeUniforms=xs(this.outputShape.length);const{dataFormat:S}=k,_=Gt(),T=S==="channelsLast",O=T?1:2,B=T?2:3,z=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${y[2]} && pos < ${y[1]}) {`;let K="";for(let Q=0;Q<=1;Q++)for(let ue=0;ue<=1;ue++)K+=`
          blockIndex = rc.z + ${ue};
          pos = rc.y + ${Q};

          ${z}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${O}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${B}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${T}) {
                  innerDims = vec2(d1, ch);
                  result[${2*Q+ue}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*Q+ue}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${K}

        ${_.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(F,y){const k=F.length;return k>=3?y?[...F.slice(0,-3),F[k-3]*F[k-2],F[k-1]]:[...F.slice(0,-3),F[k-3],F[k-2]*F[k-1]]:!y&&k===1&&F[0]>1?[F[0],1]:null}function Yc({x:F,filter:y,convInfo:k,backend:S,bias:_=null,preluActivationWeights:T=null,leakyreluAlpha:O=0,activation:B=null}){const z=F.shape,K=S.texData.get(F.dataId),Q=k.inChannels,ue=z[0]*z[1]*z[2],ae=k.outChannels,Re=k.dataFormat==="channelsLast";let ke;const Ge=[];if(T!=null){const qe=Ju(T.shape,Re);qe!=null&&(T=jn({inputs:{x:T},backend:S,attrs:{shape:qe}}),Ge.push(T))}if(_!=null){const qe=Ju(_.shape,Re);qe!=null&&(_=jn({inputs:{x:_},backend:S,attrs:{shape:qe}}),Ge.push(_))}if(!((ue===1||ae===1)&&Q>1e3)&&K.isPacked&&Re&&K.texture!=null&&z[2]%2!=0&&n.util.arraysEqual(K.shape.slice(-3),z.slice(-3))){const qe=z[0]*z[1]*(z[2]+1),Ne={dataId:F.dataId,shape:[1,qe,k.inChannels],dtype:F.dtype},Ke=K.shape;K.shape=K.shape.slice(),K.shape[K.shape.length-2]++,n.util.assert(Ee(K.shape,Ne.shape),()=>`packed reshape ${K.shape} to ${Ne.shape} isn't free`);const an=jn({inputs:{x:y},backend:S,attrs:{shape:[1,k.inChannels,k.outChannels]}});Ge.push(an);const kn=Go({a:Ne,b:an,backend:S,transposeA:!1,transposeB:!1,bias:_,activation:B,preluActivationWeights:T,leakyreluAlpha:O}),Pn=S.texData.get(kn.dataId);n.util.assert(Pn.isPacked,()=>"batchMatMul result is expected to be packed"),K.shape=Ke,Pn.shape=k.outShape,ke=Wr({inputs:{x:kn},backend:S}),ke.shape=k.outShape,Ge.push(kn)}else{const qe=k.outHeight*k.outWidth,Ne=jn({inputs:{x:F},backend:S,attrs:{shape:Re?[k.batchSize,qe,k.inChannels]:[k.batchSize,k.inChannels,qe]}}),Ke=jn({inputs:{x:y},backend:S,attrs:{shape:[1,k.inChannels,k.outChannels]}}),an=Go({a:Re?Ne:Ke,b:Re?Ke:Ne,transposeA:!Re,transposeB:!1,backend:S,bias:_,activation:B,preluActivationWeights:T,leakyreluAlpha:O});ke=jn({inputs:{x:an},backend:S,attrs:{shape:k.outShape}}),Ge.push(Ne),Ge.push(Ke),Ge.push(an)}for(const qe of Ge)S.disposeIntermediateTensorInfo(qe);return ke}function Nc({x:F,filter:y,convInfo:k,backend:S,bias:_=null,preluActivationWeights:T=null,leakyreluAlpha:O=0,activation:B=null}){const{filterWidth:z,filterHeight:K,inChannels:Q,outWidth:ue,outHeight:ae,dataFormat:Re}=k,ke=Re==="channelsLast",Ge=z*K*Q,qe=ae*ue,Ne=[k.batchSize,Ge,qe],Ke=[];if(T!=null){const $=Ju(T.shape,ke);$!=null&&(T=jn({inputs:{x:T},backend:S,attrs:{shape:$}}),Ke.push(T))}if(_!=null){const $=Ju(_.shape,ke);$!=null&&(_=jn({inputs:{x:_},backend:S,attrs:{shape:$}}),Ke.push(_))}const an=jn({inputs:{x:y},backend:S,attrs:{shape:[1,Ge,n.util.sizeFromShape(y.shape)/Ge]}});Ke.push(an);const kn=new Tc(Ne,k),Pn=[F.shape,[k.padInfo.top,k.padInfo.left],[k.strideHeight,k.strideWidth],[k.dilationHeight,k.dilationWidth],[k.inChannels],[k.filterWidth*k.inChannels],[k.outWidth]],Xn=S.runWebGLProgram(kn,[F],"float32",Pn),Hn=jn({inputs:{x:Xn},backend:S,attrs:{shape:Ne}});Ke.push(Xn),Ke.push(Hn);const Qn=_!=null,Wn=T!=null,vs=B==="leakyrelu",fs=B?ao(B,!0):null,w=new Si(ke?Hn.shape:an.shape,ke?an.shape:Hn.shape,ke?[k.batchSize,qe,k.outChannels]:[k.batchSize,k.outChannels,qe],!0,!1,Qn,fs,Wn,vs),g=ke?[Hn,an]:[an,Hn];if(_&&g.push(_),Wn&&g.push(T),vs){const $=S.makeTensorInfo([],"float32",n.util.createScalarValue(O,"float32"));g.push($),Ke.push($)}const v=S.runWebGLProgram(w,g,"float32"),C=jn({inputs:{x:v},backend:S,attrs:{shape:k.outShape}});Ke.push(v);for(const $ of Ke)S.disposeIntermediateTensorInfo($);return C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iu={kernelName:n.Conv2D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T}=y,{strides:O,pad:B,dataFormat:z,dilations:K,dimRoundingMode:Q}=S,ue=n.backend_util.convertConv2DDataFormat(z),ae=n.backend_util.computeConv2DInfo(_.shape,T.shape,O,K,B,Q,!1,ue);let Re;if(ae.filterHeight!==1||ae.filterWidth!==1||ae.dilationHeight!==1||ae.dilationWidth!==1||ae.strideHeight!==1||ae.strideWidth!==1||ae.padInfo.type!=="SAME"&&ae.padInfo.type!=="VALID")if(ae.strideWidth<=2&&ue==="channelsLast"&&Object(n.env)().getBool("WEBGL_EXP_CONV")){const Ge=new Xc(ae),qe=[[ae.padInfo.top,ae.padInfo.left],[ae.strideHeight,ae.strideWidth],[ae.dilationHeight,ae.dilationWidth],[ae.inHeight,ae.inWidth]];Re=k.runWebGLProgram(Ge,[_,T],"float32",qe)}else if(Object(n.env)().getBool("WEBGL_CONV_IM2COL"))Re=Nc({x:_,filter:T,convInfo:ae,backend:k});else{const Ge=new Kc(ae);Re=k.runWebGLProgram(Ge,[_,T],"float32")}else Re=Yc({x:_,filter:T,convInfo:ae,backend:k});const ke=jn({inputs:{x:Re},backend:k,attrs:{shape:ae.outShape}});return k.disposeIntermediateTensorInfo(Re),ke}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dl{constructor(y){this.variableNames=["x","dy"],this.outputShape=y.filterShape;const k=y.strideHeight,S=y.strideWidth,_=y.padInfo.top,T=y.padInfo.left,O=y.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${y.batchSize}; b++) {
          for (int yR = 0; yR < ${y.outHeight}; yR++) {
            int xR = wR + yR * ${k} - ${_};

            if (xR < 0 || xR >= ${y.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${y.outWidth}; yC++) {
              int xC = wC + yC * ${S} - ${T};

              if (xC < 0 || xC >= ${y.inWidth}) {
                continue;
              }

              if (${O}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ml{constructor(y){this.variableNames=["dy","W"],this.outputShape=y.inShape;const k=y.filterHeight,S=y.filterWidth,_=y.strideHeight,T=y.strideWidth,O=y.dataFormat==="channelsLast",B=k-1-y.padInfo.top,z=S-1-y.padInfo.left,K=O?1:2,Q=O?2:3,ue=O?3:1;this.userCode=`
      const ivec2 pads = ivec2(${B}, ${z});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${ue}];

        ivec2 dyCorner = ivec2(coords[${K}], coords[${Q}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${k}; wR++) {
          float dyR = float(dyRCorner + wR) / ${_}.0;

          if (dyR < 0.0 || dyR >= ${y.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${k} - 1 - wR;

          for (int wC = 0; wC < ${S}; wC++) {
            float dyC = float(dyCCorner + wC) / ${T}.0;

            if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${S} - 1 - wC;

            for (int d2 = 0; d2 < ${y.outChannels}; d2++) {

              if (${O}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Pl{constructor(y){this.variableNames=["x","dy"],this.outputShape=y.filterShape;const k=y.strideDepth,S=y.strideHeight,_=y.strideWidth,T=y.padInfo.front,O=y.padInfo.top,B=y.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${y.batchSize}; b++) {
          for (int yF = 0; yF < ${y.outDepth}; yF++) {
            int xF = wF + yF * ${k} - ${T};

            if (xF < 0 || xF >= ${y.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${y.outHeight}; yR++) {
              int xR = wR + yR * ${S} - ${O};

              if (xR < 0 || xR >= ${y.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${y.outWidth}; yC++) {
                int xC = wC + yC * ${_} - ${B};

                if (xC < 0 || xC >= ${y.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Zc{constructor(y){this.variableNames=["dy","W"],this.outputShape=y.inShape;const k=y.filterDepth,S=y.filterHeight,_=y.filterWidth,T=y.strideDepth,O=y.strideHeight,B=y.strideWidth,z=k-1-y.padInfo.front,K=S-1-y.padInfo.top,Q=_-1-y.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${z}, ${K}, ${Q});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${k}; wF++) {
          float dyF = float(dyFCorner + wF) / ${T}.0;

          if (dyF < 0.0 || dyF >= ${y.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${k} - 1 - wF;

          for (int wR = 0; wR < ${S}; wR++) {
            float dyR = float(dyRCorner + wR) / ${O}.0;

            if (dyR < 0.0 || dyR >= ${y.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${S} - 1 - wR;

            for (int wC = 0; wC < ${_}; wC++) {
              float dyC = float(dyCCorner + wC) / ${B}.0;

              if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${_} - 1 - wC;

              for (int d2 = 0; d2 < ${y.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ec={kernelName:n.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,dy:T}=y,{strides:O,pad:B,dataFormat:z,dimRoundingMode:K,filterShape:Q}=S,ue=n.backend_util.convertConv2DDataFormat(z),ae=n.backend_util.computeConv2DInfo(_.shape,Q,O,1,B,K,!1,ue),Re=new Dl(ae);return k.runWebGLProgram(Re,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ec={kernelName:n.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,filter:T}=y,{inputShape:O,strides:B,pad:z,dataFormat:K,dimRoundingMode:Q}=S,ue=n.backend_util.convertConv2DDataFormat(K),ae=n.backend_util.computeConv2DInfo(O,T.shape,B,1,z,Q,!1,ue),Re=new Ml(ae);return k.runWebGLProgram(Re,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc={kernelName:n.Conv3D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T}=y,{strides:O,pad:B,dilations:z}=S,K=n.backend_util.computeConv3DInfo(_.shape,T.shape,O,z,B),Q=new Fl(K);return k.runWebGLProgram(Q,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ll={kernelName:n.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,dy:T}=y,{strides:O,pad:B,filterShape:z}=S,K=n.backend_util.computeConv3DInfo(_.shape,z,O,1,B),Q=new Pl(K);return k.runWebGLProgram(Q,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eu={kernelName:n.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,filter:T}=y,{pad:O,strides:B,inputShape:z}=S,K=n.backend_util.computeConv3DInfo(z,T.shape,B,1,O),Q=new Zc(K);return k.runWebGLProgram(Q,[_,T],"float32")}},Bl=Ls({opSnippet:`if (isnan(x)) return x;
  return cos(x);
`}),zl={kernelName:n.Cos,backendName:"webgl",kernelFunc:Bl},Jc=Ls({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),Ru={kernelName:n.Cosh,backendName:"webgl",kernelFunc:Jc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uu{constructor(y,k,S,_,T){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[O,B,z,K]=y,[Q]=k,[ue,ae]=S;this.outputShape=[Q,ue,ae,K];const Re=_==="bilinear"?1:0,[ke,Ge]=[B-1+".0",z-1+".0"],[qe,Ne,Ke]=ue>1?[""+(B-1)/(ue-1),"(y2-y1) * height_ratio",`y1*${ke} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${ke}`],[an,kn,Pn]=ae>1?[""+(z-1)/(ae-1),"(x2-x1) * width_ratio",`x1*${Ge} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Ge}`];this.userCode=`
      const float height_ratio = float(${qe});
      const float width_ratio = float(${an});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${O}) {
          return;
        }

        float height_scale = ${Ne};
        float width_scale = ${kn};

        float in_y = ${Ke};
        if( in_y < 0.0 || in_y > ${ke} ) {
          setOutput(float(${T}));
          return;
        }
        float in_x = ${Pn};
        if( in_x < 0.0 || in_x > ${Ge} ) {
          setOutput(float(${T}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${Re} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tc={kernelName:n.CropAndResize,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{image:_,boxes:T,boxInd:O}=y,{cropSize:B,method:z,extrapolationValue:K}=S,Q=new uu(_.shape,T.shape,B,z,K);return k.runWebGLProgram(Q,[_,T,O],"float32")}};var gr;(function(F){F.Prod="*",F.Sum="+"})(gr||(gr={}));class Rc{constructor(y,k,S,_){this.op=y,this.outputShape=k,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const T=this.outputShape.length,O=this.op===gr.Prod?"1.0":"0.0",B=S?O:`getX(${Au(T,"coords",this.op)})`,z=this.outputShape[this.outputShape.length-1];let K="",Q="";S?(K=_?"end != "+(z-1):"end != 0",Q=_?"end + 1":"end - 1"):(K=_?`end + pow2 < ${z}`:"end >= pow2",Q=_?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${pe(T)} coords = getOutputCoords();
        int end = ${el(T,"coords",this.op)};
        float val = ${B};
        int pow2 = int(pow(2.0, index));
        if (${K}) {
          int idx = ${Q};
          ${el(T,"coords",this.op)} = idx;
          val ${this.op}= getX(${Au(T,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Au(F,y,k){if(F===1)return`${y}`;if(F===2)return`${y}.x, ${y}.y`;if(F===3)return`${y}.x, ${y}.y, ${y}.z`;if(F===4)return`${y}.x, ${y}.y, ${y}.z, ${y}.w`;throw new Error(`Cumulative ${k} for rank ${F} is not yet supported`)}function el(F,y,k){if(F===1)return`${y}`;if(F===2)return`${y}.y`;if(F===3)return`${y}.z`;if(F===4)return`${y}.w`;throw new Error(`Cumulative ${k} for rank ${F} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(F,y,k,S,_,T){const O=y.shape.length,B=n.backend_util.getAxesPermutation([S],O);let z=y;B!=null&&(z=Ur({inputs:{x:y},backend:k,attrs:{perm:B}}));const K=n.backend_util.getInnerMostAxes(1,O)[0];if(K!==O-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${y.shape.length-1} but got axis=${S}`);const Q=z.shape[K];let ue=Wr({inputs:{x:z},backend:k});for(let ae=0;ae<=Math.ceil(Math.log2(Q))-1;ae++){const Re=new Rc(F,z.shape,!1,T),ke=[[ae]],Ge=ue;ue=k.runWebGLProgram(Re,[ue],ue.dtype,ke),k.disposeIntermediateTensorInfo(Ge)}if(_){const ae=new Rc(F,z.shape,_,T),Re=ue;ue=k.runWebGLProgram(ae,[ue],ue.dtype),k.disposeIntermediateTensorInfo(Re)}if(B!=null){const ae=Ur({inputs:{x:ue},backend:k,attrs:{perm:n.backend_util.getUndoAxesPermutation(B)}});return k.disposeIntermediateTensorInfo(ue),k.disposeIntermediateTensorInfo(z),ae}return ue}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Se={kernelName:n.Cumprod,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,exclusive:O,reverse:B}=S;return Ko(gr.Prod,_,k,T,O,B)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe={kernelName:n.Cumsum,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,exclusive:O,reverse:B}=S;return Ko(gr.Sum,_,k,T,O,B)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z={kernelName:n.DenseBincount,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,weights:T}=y,{size:O,binaryOutput:B}=S;if(_.shape.length===1){const z=k.readSync(_.dataId),K=k.readSync(T.dataId),Q=On(z,K,T.dtype,T.shape,O);return k.makeTensorInfo([O],T.dtype,Q)}if(_.shape.length===2){const z=k.bufferSync(_),K=k.bufferSync(T),Q=Mn(z,K,O,B);return k.makeTensorInfo(Q.shape,T.dtype,Q.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${_.shape.length}.`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fe{constructor(y,k,S){this.variableNames=["x"],this.outputShape=[],this.outputShape=y,this.blockSize=k,this.dataFormat=S,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${k};
      int offset_h = imod(h, ${k});
      int in_w = w / ${k};
      int offset_w = imod(w, ${k});
      int offset_d = (offset_h * ${k} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H={kernelName:n.DepthToSpace,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{blockSize:T,dataFormat:O}=S,B=_.shape[0],z=(O==="NHWC"?_.shape[1]:_.shape[2])*T,K=(O==="NHWC"?_.shape[2]:_.shape[3])*T,Q=(O==="NHWC"?_.shape[3]:_.shape[1])/(T*T),ue=new fe(O==="NHWC"?[B,z,K,Q]:[B,Q,z,K],T,O);return k.runWebGLProgram(ue,[_],_.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ce{constructor(y,k=!1,S=null,_=!1,T=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=y.outShape,this.enableShapeUniforms=xs(this.outputShape.length);const O=y.filterHeight,B=y.filterWidth,z=y.outChannels/y.inChannels;let K="",Q="";S&&(K=_?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${S}
        }`:T?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${S}
        }`:`
          float activation(float x) {
            ${S}
          }
        `,Q="result = activation(result);");const ue=k?"result += getBiasAtOutCoords();":"";k&&this.variableNames.push("bias"),_&&this.variableNames.push("preluActivationWeights"),T&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${K}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${z};
        int q = d2 - d1 * ${z};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${O}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${B}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${ue}
        ${Q}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ce{constructor(y,k=!1,S=null,_=!1,T=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=y.outShape,this.enableShapeUniforms=xs(this.outputShape.length);const O=y.outChannels/y.inChannels,B=y.padInfo.left,z=y.strideWidth,K=y.dilationWidth,Q=y.filterHeight,ue=y.filterWidth,ae=ue;let Re=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let Ne=0;Ne<ue;Ne++)Re+=`
          vec4 xTexelC${2*Ne};
          int xTexelC${2*Ne}Ready;
          vec4 xTexelC${2*Ne+1};
          int xTexelC${2*Ne+1}Ready;
          vec4 xC${Ne};`;Re+=`
    for (int r = 0; r < ${Q}; r++) {
      `;for(let Ne=0;Ne<ue;Ne++)Re+=`
          xTexelC${2*Ne} = vec4(0.0);
          xTexelC${2*Ne}Ready = 0;
          xTexelC${2*Ne+1} = vec4(0.0);
          xTexelC${2*Ne+1}Ready = 0;
          xC${Ne} = vec4(0.0);`;Re+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let Ne=0;Ne<(ae+1)/2;Ne++){const Ke=2*Ne;if(Re+=`
          xC = xCCorner + ${Ke*K};
          `,z===1){if(Ke<ue&&(B%2==1?(Re+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ke}Ready == 0) {
                  xTexelC${Ke} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ke}.zw = vec2(0.0);
                  }
                  xTexelC${Ke}Ready = 1;
                }
              `,Re+=K===1&&Ke>0?`
                xC${Ke} = vec4(xTexelC${Ke-2}.zw, xTexelC${Ke}.xy);
                `:`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${Ke} = vec4(previous.zw, xTexelC${Ke}.xy);
                  } else {
                    xC${Ke} = vec4(0.0, 0.0, xTexelC${Ke}.xy);
                  }
                  `):Re+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${Ke}Ready == 0) {
                  xTexelC${Ke} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Ke}.zw = vec2(0.0);
                  }
                  xTexelC${Ke}Ready = 1;
                }

                xC${Ke} = xTexelC${Ke};
                `,Ke+1<ue)){const an=B%2==0?n.util.nearestLargerEven(K):K;K%2==0&&B%2==1||K%2!=0&&B%2!=1?(Re+=`
                  xCOffset = xC + imod(pads[1], 2) + ${an};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ke+1}Ready == 0) {
                    xTexelC${Ke+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${Ke+1}.zw = vec2(0.0);
                    }
                    xTexelC${Ke+1}Ready = 1;
                  }
                  `,Re+=K>1?`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${Ke+1} = vec4(previous.zw, xTexelC${Ke+1}.xy);
                    } else {
                     xC${Ke+1} = vec4(0.0, 0.0, xTexelC${Ke+1}.xy);
                    }
                    `:`
                    xC${Ke+1} = vec4(xTexelC${Ke}.zw, xTexelC${Ke+1}.xy);
                    `):Re+=an===1?`
                    xC${Ke+1} = xTexelC${Ke};
                    `:`
                    xCOffset = xC + ${an};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ke+1}Ready == 0) {
                      xTexelC${Ke+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${Ke+1}.zw = vec2(0.0);
                      }
                      xTexelC${Ke+1}Ready = 1;
                    }

                    xC${Ke+1} = xTexelC${Ke+1};
                    `}}else Ke<ue&&(B%2==1?(Re+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ke}Ready == 0) {
                  xTexelC${Ke} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ke}.zw = vec2(0.0);
                  }
                  xTexelC${Ke}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${Ke+1}Ready == 0) {
                  xTexelC${Ke+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${Ke+1}.zw = vec2(0.0);
                  }
                  xTexelC${Ke+1}Ready = 1;
                }

                xC${Ke} = vec4(xTexelC${Ke}.zw, xTexelC${Ke+1}.zw);
              `,Ke+1<ue&&(Re+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${Ke+1} = vec4(xTexelC${Ke+1}.xy, final.xy);
                `)):(Re+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${Ke}Ready == 0) {
                  xTexelC${Ke} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${Ke}.zw = vec2(0.0);
                  }
                  xTexelC${Ke}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${Ke+1}Ready == 0) {
                  xTexelC${Ke+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${Ke+1}.zw = vec2(0.);
                  }
                  xTexelC${Ke+1}Ready = 1;
                }

                xC${Ke} = vec4(
                  xTexelC${Ke}.xy, xTexelC${Ke+1}.xy);
              `,Ke+1<ue&&(Re+=`
                  xC${Ke+1} = vec4(xTexelC${Ke}.zw, xTexelC${Ke+1}.zw);
                `)));Ke<ue&&(Re+=`
            wTexel = getW(r, ${Ke}, d1, q);
            dotProd += xC${Ke} * vec4(wTexel.xz, wTexel.xz);
          `,Ke+1<ue&&(Re+=`
              wTexel = getW(r, ${Ke+1}, d1, q);
              dotProd += xC${Ke+1} * vec4(wTexel.xz, wTexel.xz);
            `))}Re+=`
    }
  `,Re+=`
      }
    `;let ke="",Ge="";S&&(ke=_?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${S}
        }`:T?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${S}
        }`:`vec4 activation(vec4 x) {
          ${S}
        }`,Ge="result = activation(result);");const qe=k?"result += getBiasAtOutCoords();":"";k&&this.variableNames.push("bias"),_&&this.variableNames.push("preluActivationWeights"),T&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${ke}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${O};
        int q = d2 - d1 * ${O};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${Re}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${qe}
        ${Ge}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const De={kernelName:n.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T}=y,{strides:O,pad:B,dilations:z,dimRoundingMode:K}=S;let Q=z;Q==null&&(Q=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(O,Q),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${O} and dilations '${Q}'`);const ue=n.backend_util.computeConv2DInfo(_.shape,T.shape,O,Q,B,K,!0);let ae;ae=Object(n.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&ue.strideWidth<=2&&ue.outChannels/ue.inChannels==1?new Ce(ue):new ce(ue);const Re=[[ue.padInfo.top,ue.padInfo.left],[ue.strideHeight,ue.strideWidth],[ue.dilationHeight,ue.dilationWidth],[ue.inHeight,ue.inWidth]];return k.runWebGLProgram(ae,[_,T],"float32",Re)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fe{constructor(y){this.variableNames=["x","dy"],this.outputShape=y.filterShape;const k=y.strideHeight,S=y.strideWidth,_=y.padInfo.top,T=y.padInfo.left,O=y.outChannels/y.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${O} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${y.batchSize}; b++) {
          for (int yR = 0; yR < ${y.outHeight}; yR++) {
            int xR = wR + yR * ${k} - ${_};

            if (xR < 0 || xR >= ${y.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${y.outWidth}; yC++) {
              int xC = wC + yC * ${S} - ${T};

              if (xC < 0 || xC >= ${y.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Ie{constructor(y){this.variableNames=["dy","W"],this.outputShape=y.inShape;const k=y.filterHeight,S=y.filterWidth,_=y.strideHeight,T=y.strideWidth,O=k-1-y.padInfo.top,B=S-1-y.padInfo.left,z=y.outChannels/y.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${O}, ${B});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${k}; wR++) {
          float dyR = float(dyRCorner + wR) / ${_}.0;

          if (dyR < 0.0 || dyR >= ${y.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${k} - 1 - wR;

          for (int wC = 0; wC < ${S}; wC++) {
            float dyC = float(dyCCorner + wC) / ${T}.0;

            if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${S} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${z}; dm++) {
              int d2 = d1 * ${z} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Te={kernelName:n.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,dy:T}=y,{strides:O,dilations:B,pad:z,dimRoundingMode:K,filterShape:Q}=S,ue=n.backend_util.computeConv2DInfo(_.shape,Q,O,B,z,K,!0),ae=new Fe(ue);return k.runWebGLProgram(ae,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ye={kernelName:n.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,filter:T}=y,{strides:O,dilations:B,pad:z,dimRoundingMode:K,inputShape:Q}=S,ue=n.backend_util.computeConv2DInfo(Q,T.shape,O,B,z,K,!0),ae=new Ie(ue);return k.runWebGLProgram(ae,[_,T],"float32")}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Le{constructor(y){this.variableNames=["X"],this.outputShape=[y,y],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je={kernelName:n.Diag,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{x:S}=y,_=[...S.shape,...S.shape],T=n.util.sizeFromShape(S.shape),O=jn({inputs:{x:S},backend:k,attrs:{shape:[T]}}),B=new Le(T),z=k.runWebGLProgram(B,[O],O.dtype),K=jn({inputs:{x:z},backend:k,attrs:{shape:_}});return k.disposeIntermediateTensorInfo(O),k.disposeIntermediateTensorInfo(z),K}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gt{constructor(y){this.variableNames=["x","W"],this.outputShape=y.outShape;const{inHeight:k,inWidth:S,padInfo:_,strideHeight:T,strideWidth:O,filterHeight:B,filterWidth:z,dilationHeight:K,dilationWidth:Q}=y,{top:ue,left:ae}=_;this.userCode=`
      const ivec2 strides = ivec2(${T}, ${O});
      const ivec2 pads = ivec2(${ue}, ${ae});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${B}; h++) {
          int hIn = hBeg + h * ${K};

          if (hIn >= 0 && hIn < ${k}) {
            for (int w = 0; w < ${z}; w++) {
              int wIn = wBeg + w * ${Q};

              if (wIn >= 0 && wIn < ${S}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lt={kernelName:n.Dilation2D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T}=y,{strides:O,pad:B,dilations:z}=S,K=n.backend_util.computeDilation2DInfo(_.shape,T.shape,O,B,"NHWC",z);let Q;const ue=new gt(K);Q=k.runWebGLProgram(ue,[_,T],"float32");const ae=jn({inputs:{x:Q},backend:k,attrs:{shape:K.outShape}});return k.disposeIntermediateTensorInfo(Q),ae}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ft={kernelName:n.Einsum,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{equation:_}=S,T=y,{allDims:O,summedDims:B,idDims:z}=n.backend_util.decodeEinsumEquation(_,T.length);n.backend_util.checkEinsumDimSizes(O.length,z,T);const{path:K,steps:Q}=n.backend_util.getEinsumComputePath(B,z),ue=Q.length;let ae=null,Re=O.length;const ke=[];for(let Ge=0;Ge<ue;++Ge){for(const qe of Q[Ge]){const{permutationIndices:Ne,expandDims:Ke}=n.backend_util.getEinsumPermutation(Re,z[qe]);let an;n.backend_util.isIdentityPermutation(Ne)?an=T[qe]:(an=Ur({inputs:{x:T[qe]},backend:k,attrs:{perm:Ne}}),ke.push(an));const kn=an.shape.slice();for(let Pn=0;Pn<Ke.length;++Pn)kn.splice(Ke[Pn],0,1);n.util.arraysEqual(an.shape,kn)||(an=jn({inputs:{x:an},backend:k,attrs:{shape:kn}}),ke.push(an)),ae===null?ae=an:(ae=ii({inputs:{a:an,b:ae},backend:k}),ke.push(ae))}Ge<ue-1&&(K[Ge]>=0&&(ae=jo({inputs:{x:ae},backend:k,attrs:{axis:K[Ge]-(O.length-Re),keepDims:!1}}),ke.push(ae)),Re--)}for(const Ge of ke)Ge!==ae&&k.disposeIntermediateTensorInfo(Ge);return ae}},yt=Ls({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),$t={kernelName:n.Elu,backendName:"webgl",kernelFunc:yt},Bt={kernelName:n.EluGrad,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k}=F,{dy:S,y:_}=y,T=Object(n.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,S.shape,_.shape):new bo("return (b >= 1.0) ? a : a * (b + 1.0);",S.shape,_.shape);return k.runWebGLProgram(T,[S,_],S.dtype)}},G=Lr({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:xr}),A={kernelName:n.Equal,backendName:"webgl",kernelFunc:G},R=Ls({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${n.backend_util.ERF_P};
  float a1 = ${n.backend_util.ERF_A1};
  float a2 = ${n.backend_util.ERF_A2};
  float a3 = ${n.backend_util.ERF_A3};
  float a4 = ${n.backend_util.ERF_A4};
  float a5 = ${n.backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),q={kernelName:n.Erf,backendName:"webgl",kernelFunc:R},j=Ls({opSnippet:`if (isnan(x)) return x;
  return exp(x);
`,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Ir,dtype:"float32"}),te={kernelName:n.Exp,backendName:"webgl",kernelFunc:j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ie(F){const{inputs:y,attrs:k,backend:S}=F,{dim:_}=k,{input:T}=y,O=T.shape.length,B=T.shape.slice();let z=_;return _<0&&(n.util.assert(-(O+1)<=_,()=>`Axis must be in the interval [${-(O+1)}, ${O}]`),z=O+_+1),B.splice(z,0,1),jn({inputs:{x:T},backend:S,attrs:{shape:B}})}const he={kernelName:n.ExpandDims,backendName:"webgl",kernelFunc:ie},xe="return exp(x) - 1.0;",_e=Ls({opSnippet:xe,packedOpSnippet:xe,cpuKernelImpl:qs}),Ue={kernelName:n.Expm1,backendName:"webgl",kernelFunc:_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nt{constructor(y,k,S){this.variableNames=["real","imag"];const _=k[1];this.outputShape=k;const T=S?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,O=S?`${_}.0`:"1.0";let B;if(y==="real")B="return real * expR - imag * expI;";else{if(y!=="imag")throw new Error(`FFT component must be either "real" or "imag", got ${y}.`);B="return real * expI + imag * expR;"}this.userCode=`
      const float exponentMultiplier = ${T};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${B}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${_});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${_}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${O};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function it(F,y,k){const S=k.texData.get(F.dataId),_=n.util.sizeFromShape(F.shape),T=F.shape[F.shape.length-1],O=jn({inputs:{x:F},backend:k,attrs:{shape:[_/T,T]}}),B=O.shape,z=new nt("real",B,y),K=new nt("imag",B,y),Q=[{dataId:S.complexTensorInfos.real.dataId,dtype:S.complexTensorInfos.real.dtype,shape:B},{dataId:S.complexTensorInfos.imag.dataId,dtype:S.complexTensorInfos.imag.dtype,shape:B}],ue=k.runWebGLProgram(z,Q,"float32"),ae=k.runWebGLProgram(K,Q,"float32"),Re=Xr({inputs:{real:ue,imag:ae},backend:k});k.disposeIntermediateTensorInfo(ue),k.disposeIntermediateTensorInfo(ae);const ke=jn({inputs:{x:Re},backend:k,attrs:{shape:F.shape}});return k.disposeIntermediateTensorInfo(O),k.disposeIntermediateTensorInfo(Re),ke}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const et={kernelName:n.FFT,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{input:S}=y;return it(S,!1,k)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dt{constructor(y,k){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=y,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ut(F){const{backend:y,attrs:k}=F,{shape:S,value:_}=k;let{dtype:T}=k;if(T=T||n.util.inferDtype(_),T==="string"){const O=n.util.getArrayFromDType(T,n.util.sizeFromShape(S));return O.fill(_),y.makeTensorInfo(S,T,O)}{const O=new dt(S,_),B=[[_]];return y.runWebGLProgram(O,[],T,B)}}const Et={kernelName:n.Fill,backendName:"webgl",kernelFunc:ut};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tt{constructor(y){this.variableNames=["Image"],this.outputShape=[];const k=y[2];this.outputShape=y,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${k} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${k}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dt={kernelName:n.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:F,backend:y})=>{const{image:k}=F,S=y,_=new Tt(k.shape);return S.runWebGLProgram(_,[k],k.dtype)}},Wt="return floor(x);",qt=Ls({opSnippet:Wt,packedOpSnippet:Wt,cpuKernelImpl:ta}),cn={kernelName:n.Floor,backendName:"webgl",kernelFunc:qt},rn=Lr({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),yn={kernelName:n.FloorDiv,backendName:"webgl",kernelFunc:rn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fn{constructor(y){this.variableNames=["A"];const k=Gt(),[S,_]=y;this.outputShape=y,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${_}.0, ${S}.0);

        vec4 values = ${k.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _n{constructor(y){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const k=Gt(),[S,_]=y;this.outputShape=y,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${_}.0, ${S}.0);
            vec4 values = ${k.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${k.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ss={kernelName:n.FromPixels,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F;let{pixels:_}=y;const{numChannels:T}=S,O=typeof HTMLVideoElement!="undefined"&&_ instanceof HTMLVideoElement,B=typeof HTMLImageElement!="undefined"&&_ instanceof HTMLImageElement,[z,K]=O?[_.videoWidth,_.videoHeight]:[_.width,_.height],Q=[K,z],ue=[K,z,T];if(B||O){const Ge=Object(n.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");zn!=null&&Ge===Kn||(Kn=Ge,zn=document.createElement("canvas").getContext("2d",{willReadFrequently:Kn})),zn.canvas.width=z,zn.canvas.height=K,zn.drawImage(_,0,0,z,K),_=zn.canvas}const ae=k.makeTensorInfo(Q,"int32");k.texData.get(ae.dataId).usage=u.PIXELS,k.gpgpu.uploadPixelDataToTexture(k.getTexture(ae.dataId),_);const Re=Object(n.env)().getBool("WEBGL_PACK")?new _n(ue):new Fn(ue),ke=k.runWebGLProgram(Re,[ae],"int32");return k.disposeData(ae.dataId),ke}};let zn,Kn=Object(n.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const us={kernelName:n.FusedConv2D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T,bias:O,preluActivationWeights:B}=y,{strides:z,pad:K,dataFormat:Q,dilations:ue,dimRoundingMode:ae,activation:Re,leakyreluAlpha:ke}=S,Ge=n.backend_util.convertConv2DDataFormat(Q),qe=n.backend_util.computeConv2DInfo(_.shape,T.shape,z,ue,K,ae,!1,Ge);let Ne;const Ke=[],an=O!=null,kn=B!=null,Pn=Re==="leakyrelu",Xn=()=>{const Qn=[_,T],Wn=(vs,fs)=>{if(fs==="NCHW"&&vs.shape.length===1&&vs.shape[0]!==1){const w=jn({inputs:{x:vs},backend:k,attrs:{shape:[vs.shape[0],1,1]}});return Ke.push(w),w}return vs};if(an&&Qn.push(Wn(O,Q)),kn&&Qn.push(Wn(B,Q)),Pn){const vs=k.makeTensorInfo([],"float32",n.util.createScalarValue(ke,"float32"));Qn.push(vs),Ke.push(vs)}return Qn};if(qe.filterHeight!==1||qe.filterWidth!==1||qe.dilationHeight!==1||qe.dilationWidth!==1||qe.strideHeight!==1||qe.strideWidth!==1||qe.padInfo.type!=="SAME"&&qe.padInfo.type!=="VALID")if(qe.strideWidth<=2&&Ge==="channelsLast"&&Object(n.env)().getBool("WEBGL_EXP_CONV")){const Qn=Re?ao(Re,!0):null,Wn=new Xc(qe,an,Qn,kn,Pn),vs=[[qe.padInfo.top,qe.padInfo.left],[qe.strideHeight,qe.strideWidth],[qe.dilationHeight,qe.dilationWidth],[qe.inHeight,qe.inWidth]],fs=Xn();Ne=k.runWebGLProgram(Wn,fs,"float32",vs)}else if(Object(n.env)().getBool("WEBGL_CONV_IM2COL"))Ne=Nc({x:_,filter:T,convInfo:qe,backend:k,bias:O,activation:Re,preluActivationWeights:B,leakyreluAlpha:ke});else{const Qn=Re?ao(Re,!1):null,Wn=new Kc(qe,an,Qn,kn,Pn),vs=Xn();Ne=k.runWebGLProgram(Wn,vs,"float32")}else Ne=Yc({x:_,filter:T,convInfo:qe,backend:k,bias:O,activation:Re,preluActivationWeights:B,leakyreluAlpha:ke});const Hn=jn({inputs:{x:Ne},backend:k,attrs:{shape:qe.outShape}});return Ke.push(Ne),Ke.forEach(Qn=>k.disposeIntermediateTensorInfo(Qn)),Hn}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ps={kernelName:n.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,filter:T,bias:O,preluActivationWeights:B}=y,{strides:z,pad:K,dilations:Q,dimRoundingMode:ue,activation:ae,leakyreluAlpha:Re}=S,ke=[];let Ge=Q;Ge==null&&(Ge=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(z,Ge),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${z} and dilations '${Ge}'`);const qe=n.backend_util.computeConv2DInfo(_.shape,T.shape,z,Ge,K,ue,!0),Ne=Object(n.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&qe.strideWidth<=2&&qe.outChannels/qe.inChannels==1,Ke=ae?ao(ae,Ne):null,an=[_,T],kn=O!=null,Pn=B!=null,Xn=ae==="leakyrelu";if(kn&&an.push(O),Pn&&an.push(B),Xn){const vs=k.makeTensorInfo([],"float32",n.util.createScalarValue(Re,"float32"));an.push(vs),ke.push(vs)}let Hn;Hn=Ne?new Ce(qe,kn,Ke,Pn,Xn):new ce(qe,kn,Ke,Pn,Xn);const Qn=[[qe.padInfo.top,qe.padInfo.left],[qe.strideHeight,qe.strideWidth],[qe.dilationHeight,qe.dilationWidth],[qe.inHeight,qe.inWidth]],Wn=k.runWebGLProgram(Hn,an,"float32",Qn);return ke.forEach(vs=>k.disposeIntermediateTensorInfo(vs)),Wn}};class es{constructor(y,k,S,_){this.sliceDim=y,this.strides=k,this.paramsShape=_,this.variableNames=["x","indices"],this.outputShape=S;const T=pe(k.length),O=pe(S.length),B=this.sliceDim>1?"strides[j]":"strides",z=pe(_.length),K=_.length>1?"paramsShape[j]":"paramsShape";this.userCode=`
        ${T} strides = ${T}(${this.strides});
        ${z} paramsShape = ${z}(${this.paramsShape});
         void main() {
          ${O} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            out_of_bounds = out_of_bounds || index < 0;
            out_of_bounds = out_of_bounds || index >= ${K};
            flattenIndex += index * ${B};
          }
          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ks={kernelName:n.GatherNd,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{params:S,indices:_}=y,T=_.shape,O=T[T.length-1],B=n.util.sizeFromShape(S.shape),[z,K,Q,ue]=n.backend_util.prepareAndValidate(S,_),ae=jn({inputs:{x:_},backend:k,attrs:{shape:[K,O]}}),Re=jn({inputs:{x:S},backend:k,attrs:{shape:[n.util.sizeFromShape(S.shape)/Q,Q]}});if(k.shouldExecuteOnCPU([S,_])||S.dtype==="string"){const Ne=k.readSync(_.dataId),Ke=k.bufferSync(S),an=pa(Ne,Ke,S.dtype,K,O,Q,ue,S.shape,B);return k.makeTensorInfo(z,S.dtype,an.values)}const ke=new es(O,ue,[K,Q],S.shape),Ge=k.runWebGLProgram(ke,[Re,ae],Re.dtype),qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:z}});return k.disposeIntermediateTensorInfo(ae),k.disposeIntermediateTensorInfo(Re),k.disposeIntermediateTensorInfo(Ge),qe}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ks{constructor(y,k){this.variableNames=["A","indices"],this.outputShape=k,this.rank=k.length;const S=pe(this.rank),_=function(T,O){const B=["resRC.x","resRC.y","resRC.z","resRC.w"],z=[];for(let K=0;K<T.length;K++)K===2?z.push("index"):z.push(`${B[K]}`);return z.join()}(y);this.userCode=`
      void main() {
        ${S} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${y[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${_}));
      }
    `}}function sa(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,indices:T}=y,{axis:O,batchDims:B}=S,z=n.util.parseAxisParam(O,_.shape)[0];if(Object(n.env)().get("DEBUG")){const Ke=k.readSync(T.dataId),an=_.shape[z];for(let kn=0;kn<Ke.length;++kn){const Pn=Ke[kn];n.util.assert(Pn<=an-1&&Pn>=0,()=>`GatherV2: the index value ${Pn} is not in [0, ${an-1}]`)}}const K=n.backend_util.segment_util.collectGatherOpShapeInfo(_,T,z,B),Q=n.util.sizeFromShape(T.shape),ue=[],ae=jn({inputs:{x:_},backend:k,attrs:{shape:[K.batchSize,K.outerSize,K.dimSize,K.sliceSize]}}),Re=jn({inputs:{x:T},backend:k,attrs:{shape:[K.batchSize,Q/K.batchSize]}});ue.push(ae),ue.push(Re);const ke=[K.batchSize,K.outerSize,Q/K.batchSize,K.sliceSize];if(k.shouldExecuteOnCPU([_,T])||_.dtype==="string"){const Ke=k.bufferSync(Re),an=k.bufferSync(ae),kn=rr(an,Ke,ke);return ue.forEach(Pn=>k.disposeIntermediateTensorInfo(Pn)),k.makeTensorInfo(K.outputShape,kn.dtype,kn.values)}const Ge=new Ks(ae.shape,ke),qe=k.runWebGLProgram(Ge,[ae,Re],ae.dtype);ue.push(qe);const Ne=jn({inputs:{x:qe},backend:k,attrs:{shape:K.outputShape}});return ue.forEach(Ke=>k.disposeIntermediateTensorInfo(Ke)),Ne}const or={kernelName:n.GatherV2,backendName:"webgl",kernelFunc:sa},_r=Lr({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:eo,dtype:"bool"}),yr={kernelName:n.Greater,backendName:"webgl",kernelFunc:_r},Ga=Lr({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:Qs}),ma={kernelName:n.GreaterEqual,backendName:"webgl",kernelFunc:Ga};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ha={kernelName:n.IFFT,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{input:S}=y;return it(S,!0,k)}},vo=Ls({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),pi={kernelName:n.IsFinite,backendName:"webgl",kernelFunc:vo},fi=Ls({opSnippet:"return float(isinf(x));",dtype:"bool"}),Ac={kernelName:n.IsInf,backendName:"webgl",kernelFunc:fi},tl=Ls({opSnippet:"return float(isnan(x));",dtype:"bool"}),nl={kernelName:n.IsNan,backendName:"webgl",kernelFunc:tl},Pd=Lr({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:mr,dtype:"bool"}),mi={kernelName:n.Less,backendName:"webgl",kernelFunc:Pd},Bb=Lr({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:$r,dtype:"bool"}),zb={kernelName:n.LessEqual,backendName:"webgl",kernelFunc:Bb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wb={kernelName:n.LinSpace,backendName:"webgl",kernelFunc:function(F){const{backend:y,attrs:k}=F,{start:S,stop:_,num:T}=k,O=ia(S,_,T);return y.makeTensorInfo([O.length],"float32",O)}},Vb=Ls({opSnippet:`if (isnan(x)) return x;
  return x < 0.0 ? 0./0. : log(x);
`,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:Pr}),Pf={kernelName:n.Log,backendName:"webgl",kernelFunc:Vb},Ub=Ls({opSnippet:`if (isnan(x)) return x;
  return log(1.0 + x);
`}),jb={kernelName:n.Log1p,backendName:"webgl",kernelFunc:Ub},Gb=Lr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),Hb={kernelName:n.LogicalAnd,backendName:"webgl",kernelFunc:Gb},qb=Ls({opSnippet:"return float(!(x >= 1.0));"}),Kb={kernelName:n.LogicalNot,backendName:"webgl",kernelFunc:qb},Xb=Lr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),Yb={kernelName:n.LogicalOr,backendName:"webgl",kernelFunc:Xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zb{constructor(y,k,S,_,T){this.variableNames=["x"],this.outputShape=[];const O=k,B=y[3]-1;let z;this.outputShape=y;const K=`float(${S}) + float(${_}) * sum`;z=T===.5?`inversesqrt(${K})`:T===1?`1.0/(${K})`:`exp(log(${K}) * float(-${T}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${O}; j <= ${O}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${B}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${z};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qb{constructor(y,k,S,_,T){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const O=k,B=y[3]-1;let z;this.outputShape=y;const K=`float(${S}) + float(${_}) * sum`;z=T===.5?`inversesqrt(${K})`:T===1?`1.0/(${K})`:`exp(log(${K}) * float(-${T}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${O};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${O}; j <= ${O}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${B}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${z};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jb={kernelName:n.LRN,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{depthRadius:T,bias:O,alpha:B,beta:z}=S,K=Object(n.env)().getBool("WEBGL_PACK_NORMALIZATION")?new Qb(_.shape,T,O,B,z):new Zb(_.shape,T,O,B,z);return k.runWebGLProgram(K,[_],_.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ex{constructor(y,k,S,_,T){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=y,this.depth=y[3],this.depthRadius=k,this.bias=S,this.alpha=_,this.beta=T,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${k})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${k} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${_}) * norm + float(${S});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${_})
                * float(${T})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${T});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oh={kernelName:n.LRNGrad,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{x:_,y:T,dy:O}=y,{depthRadius:B,bias:z,alpha:K,beta:Q}=S,ue=new ex(_.shape,B,z,K,Q);return k.runWebGLProgram(ue,[_,T,O],_.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wl(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{reductionIndices:T,keepDims:O}=S,B=_.shape.length,z=n.util.parseAxisParam(T,_.shape);let K=z;const Q=n.backend_util.getAxesPermutation(K,B),ue=Q!=null,ae=k.shouldExecuteOnCPU([_]);let Re=_;if(ue){if(ae){const Ke=k.texData.get(Re.dataId).values,an=new Array(B);for(let Pn=0;Pn<an.length;Pn++)an[Pn]=_.shape[Q[Pn]];const kn=sn(Ke,_.shape,_.dtype,Q,an);Re=k.makeTensorInfo(an,_.dtype),k.texData.get(Re.dataId).values=kn}else Re=ui(_,Q,k);K=n.backend_util.getInnerMostAxes(K.length,B)}n.backend_util.assertAxesAreInnerMostDims("max",K,B);const[ke,Ge]=n.backend_util.computeOutAndReduceShapes(Re.shape,K);let qe,Ne=ke;if(O&&(Ne=n.backend_util.expandShapeToKeepDim(ke,z)),ae){const Ke=k.texData.get(Re.dataId).values,an=Cr(Ke,n.util.sizeFromShape(Ge),Ne,_.dtype);qe=k.makeTensorInfo(Ne,_.dtype),k.texData.get(qe.dataId).values=an}else qe=function(Ke,an,kn,Pn){const Xn=n.util.sizeFromShape(an),Hn=jn({inputs:{x:Ke},attrs:{shape:[n.util.sizeFromShape(Ke.shape)/Xn,Xn]},backend:Pn}),Qn=Vr(Hn,Ke.dtype,"max",Pn),Wn=jn({inputs:{x:Qn},attrs:{shape:kn},backend:Pn});return Pn.disposeIntermediateTensorInfo(Hn),Pn.disposeIntermediateTensorInfo(Qn),Wn}(Re,Ge,Ne,k);return ue&&k.disposeIntermediateTensorInfo(Re),qe}const Lf={kernelName:n.Max,backendName:"webgl",kernelFunc:Wl},Vl=Lr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,cpuKernelImpl:Ba}),Fh={kernelName:n.Maximum,backendName:"webgl",kernelFunc:Vl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bf={kernelName:n.MaxPool,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y;wt(_,"maxPool");const{filterSize:T,strides:O,pad:B,dimRoundingMode:z}=S;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(O,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${O} and dilations '1'`);const K=n.backend_util.computePool2DInfo(_.shape,T,O,1,B,z);if(K.filterWidth===1&&K.filterHeight===1&&n.util.arraysEqual(K.inShape,K.outShape))return Wr({inputs:{x:_},backend:k});const Q=new st(K,"max",!1);return k.runWebGLProgram(Q,[_],_.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dh={kernelName:n.MaxPool3D,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{filterSize:T,strides:O,pad:B,dataFormat:z,dimRoundingMode:K}=S,Q=n.backend_util.computePool3DInfo(_.shape,T,O,[1,1,1],B,K,z),ue=new Ae(Q,"max",!1);return k.runWebGLProgram(ue,[_],_.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ul{constructor(y){this.variableNames=["dy","maxPos"],this.outputShape=y.inShape;const k=y.strideHeight,S=y.strideWidth,_=y.dilationHeight,T=y.effectiveFilterHeight,O=y.effectiveFilterWidth,B=T-1-y.padInfo.top,z=O-1-y.padInfo.left,K=T*O-1;this.userCode=`
      const ivec2 pads = ivec2(${B}, ${z});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${T};
          wR += ${_}) {
          float dyR = float(dyRCorner + wR) / ${k}.0;

          if (dyR < 0.0 || dyR >= ${y.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${O}; wC++) {
            float dyC = float(dyCCorner + wC) / ${S}.0;

            if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${K} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${O} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class zf{constructor(y){this.variableNames=["dy","maxPos"],this.outputShape=y.inShape;const k=y.strideDepth,S=y.strideHeight,_=y.strideWidth,T=y.dilationDepth,O=y.dilationHeight,B=y.dilationWidth,z=y.effectiveFilterDepth,K=y.effectiveFilterHeight,Q=y.effectiveFilterWidth,ue=z-1-y.padInfo.front,ae=K-1-y.padInfo.top,Re=Q-1-y.padInfo.left,ke=z*K*Q-1;this.userCode=`
      const ivec3 pads = ivec3(${ue}, ${ae}, ${Re});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${z};
           wD += ${T}) {
          float dyD = float(dyDCorner + wD) / ${k}.0;

          if (dyD < 0.0 || dyD >= ${y.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${K};
              wR += ${O}) {
            float dyR = float(dyRCorner + wR) / ${S}.0;

            if (dyR < 0.0 || dyR >= ${y.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${Q};
                wC += ${B}) {
              float dyC = float(dyCCorner + wC) / ${_}.0;

              if (dyC < 0.0 || dyC >= ${y.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${ke} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${K} * ${Q} +
                  wR * ${Q} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tx={kernelName:n.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,input:T}=y,O=T,{filterSize:B,strides:z,pad:K,dimRoundingMode:Q}=S,ue=n.backend_util.computePool3DInfo(O.shape,B,z,[1,1,1],K,Q),ae=new Ae(ue,"max",!0),Re=k.runWebGLProgram(ae,[O],O.dtype),ke=new zf(ue),Ge=k.runWebGLProgram(ke,[_,Re],O.dtype);return k.disposeIntermediateTensorInfo(Re),Ge}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx={kernelName:n.MaxPoolGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{dy:_,input:T,output:O}=y,B=T;wt([T,O],"maxPoolGrad");const{filterSize:z,strides:K,pad:Q,dimRoundingMode:ue}=S,ae=n.backend_util.computePool2DInfo(B.shape,z,K,1,Q,ue),Re=new st(ae,"max",!0),ke=k.runWebGLProgram(Re,[B],B.dtype),Ge=new Ul(ae),qe=k.runWebGLProgram(Ge,[_,ke],B.dtype);return k.disposeIntermediateTensorInfo(ke),qe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mh={kernelName:n.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:F,attrs:y,backend:k})=>{const{x:S}=F,{filterSize:_,strides:T,pad:O,includeBatchInIndex:B}=y,z=k;n.util.assert(S.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${S.shape.length}.`);const K=[1,1];n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(T,K),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${T} and dilations '${K}'`);const Q=n.backend_util.computePool2DInfo(S.shape,_,T,K,O),[ue,ae]=function(Re,ke,Ge,qe){let Ne=new st(Ge,"max",!1);const Ke=qe.runWebGLProgram(Ne,[Re],"float32");return Ne=new st(Ge,"max",!0,!0,ke),[Ke,qe.runWebGLProgram(Ne,[Re],"float32")]}(S,B,Q,z);return[ue,ae]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi={kernelName:n.Mean,backendName:"webgl",kernelFunc:({inputs:F,attrs:y,backend:k})=>{const{x:S}=F,{keepDims:_,axis:T}=y,O=k,B=S.shape.length,z=n.util.parseAxisParam(T,S.shape);let K=z;const Q=n.backend_util.getAxesPermutation(K,B),ue=Q!=null,ae=O.shouldExecuteOnCPU([S]),Re=[];let ke=S;if(ue){if(ae){const an=O.texData.get(ke.dataId).values,kn=new Array(B);for(let Xn=0;Xn<kn.length;Xn++)kn[Xn]=S.shape[Q[Xn]];const Pn=sn(an,S.shape,S.dtype,Q,kn);ke=O.makeTensorInfo(kn,S.dtype),O.texData.get(ke.dataId).values=Pn}else ke=ui(S,Q,O);Re.push(ke),K=n.backend_util.getInnerMostAxes(K.length,B)}n.backend_util.assertAxesAreInnerMostDims("sum",K,B);const[Ge,qe]=n.backend_util.computeOutAndReduceShapes(ke.shape,K);let Ne=Ge;_&&(Ne=n.backend_util.expandShapeToKeepDim(Ge,z));const Ke=function(an,kn,Pn,Xn){const Hn=n.util.sizeFromShape(kn),Qn=jn({inputs:{x:an},attrs:{shape:[n.util.sizeFromShape(an.shape)/Hn,Hn]},backend:Xn}),Wn=Vr(Qn,"float32","mean",Xn),vs=jn({inputs:{x:Wn},attrs:{shape:Pn},backend:Xn});return Xn.disposeIntermediateTensorInfo(Qn),Xn.disposeIntermediateTensorInfo(Wn),vs}(ke,qe,Ne,O);for(const an of Re)O.disposeIntermediateTensorInfo(an);return Ke}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jl={kernelName:n.Min,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,keepDims:O}=S,B=_.shape.length,z=n.util.parseAxisParam(T,_.shape);let K=z;const Q=n.backend_util.getAxesPermutation(K,B);let ue=_;Q!=null&&(ue=Ur({inputs:{x:_},backend:k,attrs:{perm:Q}}),K=n.backend_util.getInnerMostAxes(K.length,_.shape.length)),n.backend_util.assertAxesAreInnerMostDims("min",K,B);const[ae,Re]=n.backend_util.computeOutAndReduceShapes(ue.shape,K),ke=jn({inputs:{x:ue},backend:k,attrs:{shape:[-1,n.util.sizeFromShape(Re)]}}),Ge=Vr(ke,ke.dtype,"min",k);let qe;return O?qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:n.backend_util.expandShapeToKeepDim(ae,z)}}):qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:ae}}),k.disposeIntermediateTensorInfo(ke),k.disposeIntermediateTensorInfo(Ge),Q!=null&&k.disposeIntermediateTensorInfo(ue),qe}},sx=Lr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,cpuKernelImpl:za}),rx={kernelName:n.Minimum,backendName:"webgl",kernelFunc:sx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ax{constructor(y,k,S){this.variableNames=["x"],this.outputShape=k.map((Q,ue)=>Q[0]+y[ue]+Q[1]);const _=y.length,T=pe(_),O=k.map(Q=>Q[0]).join(","),B=k.map((Q,ue)=>Q[0]+y[ue]).join(","),z=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,_),K=S==="reflect"?0:1;this.userCode=_!==1?`
      ${T} start = ${T}(${O});
      ${T} end = ${T}(${B});

      void main() {
        ${T} outC = getOutputCoords();
        for (int i = 0; i < ${_}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${K};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${K};
          }
        }
        ${T} coords = outC - start;
        setOutput(getX(${z}));
      }
    `:`
        int start = ${O};
        int end = ${B};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${K};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${K};
          }
          setOutput(getX(outC - start));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ox{constructor(y,k,S){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=k.map((ke,Ge)=>ke[0]+y[Ge]+ke[1]);const _=y.length,T=pe(_),O=k.map(ke=>ke[0]).join(","),B=k.map((ke,Ge)=>ke[0]+y[Ge]).join(","),z=Vn("rc",_),K=Vn("source",_),Q=`${z[_-1]} < ${this.outputShape[_-1]}`,ue=_===1?"source":`vec2(${K.slice(-2).join()})`,ae=S==="reflect"?0:1;let Re="";if(_===1){const ke=`
        ${T} source = rc;
        if (source < start) {
          source = start * 2 - source - ${ae};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${ae};
        }
        source -= start;
      `;Re=`
        ${T} rc = outputLoc;
        ${ke}
        result[0] = getChannel(getX(${K.join()}), ${ue});
        ${z[_-1]} += 1;
        if(${Q}) {
          ${ke}
          result[1] = getChannel(getX(${K.join()}), ${ue});
        }
      `}else{const ke=`
        ${T} source = rc;
        ${T} lt = ${T}(lessThan(source, start));
        ${T} gte = ${T}(greaterThanEqual(source, end));
        ${T} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${ae}) +
                gte * ((end - 1) * 2 - source + ${ae});
        source -= start;
      `;Re=`
        ${T} rc = outputLoc;
        ${ke}
        result[0] = getChannel(getX(${K.join()}), ${ue});
        ${z[_-1]} += 1;
        if(${Q}) {
          ${ke}
          result[1] = getChannel(getX(${K.join()}), ${ue});
        }
        rc = outputLoc;
        ${z[_-2]} += 1;
        if(${z[_-2]} < ${this.outputShape[_-2]}) {
          ${ke}
          result[2] = getChannel(getX(${K.join()}), ${ue});
          ${z[_-1]} += 1;
          if(${Q}) {
            ${ke}
            result[3] = getChannel(getX(${K.join()}), ${ue});
          }
        }
      `}this.userCode=`
      const ${T} start = ${T}(${O});
      const ${T} end = ${T}(${B});

      void main() {
        ${T} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${Re}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ix={kernelName:n.MirrorPad,backendName:"webgl",kernelFunc:({inputs:F,backend:y,attrs:k})=>{const{x:S}=F,{paddings:_,mode:T}=k,O=Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ox(S.shape,_,T):new ax(S.shape,_,T);return y.runWebGLProgram(O,[S],S.dtype)}},ux=Lr({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),cx={kernelName:n.Mod,backendName:"webgl",kernelFunc:ux};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ph{constructor(y,k,S){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[y,S],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${k-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${k-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wf=Lr({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),lx={kernelName:n.RealDiv,backendName:"webgl",kernelFunc:Wf},Lh="return a - b;",Bh=Lr({opSnippet:Lh,packedOpSnippet:Lh,supportsComplex:!0,cpuKernelImpl:We}),dx={kernelName:n.Sub,backendName:"webgl",kernelFunc:Bh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(F){const{inputs:y,backend:k,attrs:S}=F,{logits:_}=y,{dim:T}=S,O=n.util.parseAxisParam([T],_.shape),B=Wl({inputs:{x:_},backend:k,attrs:{reductionIndices:O,keepDims:!1}}),z=n.backend_util.expandShapeToKeepDim(B.shape,O),K=jn({inputs:{x:B},backend:k,attrs:{shape:z}}),Q=Bh({inputs:{a:_,b:K},backend:k}),ue=j({inputs:{x:Q},backend:k}),ae=jo({inputs:{x:ue},backend:k,attrs:{axis:O,keepDims:!1}}),Re=jn({inputs:{x:ae},backend:k,attrs:{shape:z}}),ke=Wf({inputs:{a:ue,b:Re},backend:k});return k.disposeIntermediateTensorInfo(B),k.disposeIntermediateTensorInfo(K),k.disposeIntermediateTensorInfo(Q),k.disposeIntermediateTensorInfo(ue),k.disposeIntermediateTensorInfo(ae),k.disposeIntermediateTensorInfo(Re),ke}const hx={kernelName:n.Softmax,backendName:"webgl",kernelFunc:Vf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const px={kernelName:n.Multinomial,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{logits:_}=y,{numSamples:T,seed:O,normalized:B}=S,z=B?_:Vf({inputs:{logits:_},backend:k,attrs:{dim:_.shape.length-1}}),K=z.shape[0],Q=z.shape[1],ue=new Ph(K,Q,T),ae=[[O]],Re=k.runWebGLProgram(ue,[z],"int32",ae);return B||k.disposeIntermediateTensorInfo(z),Re}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fx={kernelName:n.Neg,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{x:S}=y;if(k.shouldExecuteOnCPU([S])){const T=k.texData.get(S.dataId),[O,B]=Wo(T.values,S.shape,S.dtype);return k.makeTensorInfo(B,S.dtype,O)}let _;return _=Object(n.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Va(S.shape,`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`):new Or(S.shape,`if (isnan(x)) return x;
  return -x;
`),k.runWebGLProgram(_,[S],S.dtype)}},mx=n.kernel_impls.nonMaxSuppressionV3Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uf={kernelName:n.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(F){n.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:y,backend:k,attrs:S}=F,{boxes:_,scores:T}=y,{maxOutputSize:O,iouThreshold:B,scoreThreshold:z}=S,K=k.readSync(_.dataId),Q=k.readSync(T.dataId),{selectedIndices:ue}=mx(K,Q,O,B,z);return k.makeTensorInfo([ue.length],"int32",new Int32Array(ue))}},zh=n.kernel_impls.nonMaxSuppressionV4Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gx={kernelName:n.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(F){n.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:y,backend:k,attrs:S}=F,{boxes:_,scores:T}=y,{maxOutputSize:O,iouThreshold:B,scoreThreshold:z,padToMaxOutputSize:K}=S,Q=k.readSync(_.dataId),ue=k.readSync(T.dataId),{selectedIndices:ae,validOutputs:Re}=zh(Q,ue,O,B,z,K);return[k.makeTensorInfo([ae.length],"int32",new Int32Array(ae)),k.makeTensorInfo([],"int32",new Int32Array([Re]))]}},bx=n.kernel_impls.nonMaxSuppressionV5Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ld={kernelName:n.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(F){n.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:y,backend:k,attrs:S}=F,{boxes:_,scores:T}=y,{maxOutputSize:O,iouThreshold:B,scoreThreshold:z,softNmsSigma:K}=S,Q=k.readSync(_.dataId),ue=k.readSync(T.dataId),ae=O,Re=B,ke=z,Ge=K,{selectedIndices:qe,selectedScores:Ne}=bx(Q,ue,ae,Re,ke,Ge);return[k.makeTensorInfo([qe.length],"int32",new Int32Array(qe)),k.makeTensorInfo([Ne.length],"float32",new Float32Array(Ne))]}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bd{constructor(y,k,S,_){this.variableNames=["indices"],this.outputShape=[y,k],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${_}), float(${S}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zd={kernelName:n.OneHot,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{indices:_}=y,{dtype:T,depth:O,onValue:B,offValue:z}=S,K=n.util.sizeFromShape(_.shape),Q=new Bd(K,O,B,z),ue=jn({inputs:{x:_},backend:k,attrs:{shape:[K]}}),ae=k.runWebGLProgram(Q,[ue],T);k.disposeIntermediateTensorInfo(ue);const Re=jn({inputs:{x:ae},backend:k,attrs:{shape:[..._.shape,O]}});return k.disposeIntermediateTensorInfo(ae),Re}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(F){const{inputs:y,backend:k}=F,{x:S}=y;if(S.dtype==="complex64"){const _=pr({inputs:{input:S},backend:k}),T=Oc({inputs:{x:_},backend:k}),O=zi({inputs:{input:S},backend:k}),B=Oc({inputs:{x:O},backend:k}),z=Xr({inputs:{real:T,imag:B},backend:k});return k.disposeIntermediateTensorInfo(_),k.disposeIntermediateTensorInfo(T),k.disposeIntermediateTensorInfo(O),k.disposeIntermediateTensorInfo(B),z}return ut({attrs:{shape:S.shape,dtype:S.dtype,value:S.dtype==="string"?"":0},backend:k})}const xx={kernelName:n.ZerosLike,backendName:"webgl",kernelFunc:Oc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yx={kernelName:n.OnesLike,backendName:"webgl",kernelFunc:function F(y){const{inputs:k,backend:S}=y,{x:_}=k;if(_.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(_.dtype==="complex64"){const T=pr({inputs:{input:_},backend:S}),O=F({inputs:{x:T},backend:S}),B=zi({inputs:{input:_},backend:S}),z=Oc({inputs:{x:B},backend:S}),K=Xr({inputs:{real:O,imag:z},backend:S});return S.disposeIntermediateTensorInfo(T),S.disposeIntermediateTensorInfo(O),S.disposeIntermediateTensorInfo(B),S.disposeIntermediateTensorInfo(z),K}return ut({attrs:{shape:_.shape,dtype:_.dtype,value:1},backend:S})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wx={kernelName:n.Pack,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{axis:_}=S;if(y.length===1)return ie({inputs:{input:y[0]},backend:k,attrs:{dim:_}});const T=y[0].shape,O=y[0].dtype;y.forEach(K=>{n.util.assertShapesMatch(T,K.shape,"All tensors passed to stack must have matching shapes"),n.util.assert(O===K.dtype,()=>"All tensors passed to stack must have matching dtypes")});const B=[],z=Qu({inputs:y.map(K=>{const Q=ie({inputs:{input:K},backend:k,attrs:{dim:_}});return B.push(Q),Q}),backend:k,attrs:{axis:_}});return B.forEach(K=>k.disposeIntermediateTensorInfo(K)),z}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vx{constructor(y,k,S){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=k.map((K,Q)=>K[0]+y[Q]+K[1]);const _=y.length,T=pe(_),O=k.map(K=>K[0]).join(","),B=k.map((K,Q)=>K[0]+y[Q]).join(","),z=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,_);this.userCode=_!==1?`
      ${T} start = ${T}(${O});
      ${T} end = ${T}(${B});

      void main() {
        ${T} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${T} coords = outC - start;
          setOutput(getX(${z}));
        }
      }
    `:`
        int start = ${O};
        int end = ${B};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kx{constructor(y,k,S){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=k.map((Ge,qe)=>Ge[0]+y[qe]+Ge[1]);const _=y.length,T=pe(_),O=k.map(Ge=>Ge[0]).join(","),B=k.map((Ge,qe)=>Ge[0]+y[qe]).join(","),z=Vn("rc",_),K=Vn("source",_),Q=`${z[_-1]} < ${this.outputShape[_-1]}`,ue=_===1?"source":`vec2(${K.slice(-2).join()})`,ae=[`${T} rc = outputLoc;`,`${z[_-1]} += 1;
       if(${Q}) {
      `,_===1?"":`}
       rc = outputLoc;
       ${z[_-2]} += 1;
       if(${z[_-2]} < ${this.outputShape[_-2]}) {`,_===1?"":`  ${z[_-1]} += 1;
         if(${Q}) {`],Re=_===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let ke="";for(let Ge=0,qe=_===1?2:4;Ge<qe;Ge++)ke+=`
        ${ae[Ge]}
        if (${Re}) {
          result[${Ge}] = float(value);
        } else {
          ${T} source = rc - start;
          result[${Ge}] = getChannel(getX(${K.join()}), ${ue});
        }
      `;ke+=_===1?"} ":"}}",this.userCode=`
      const ${T} start = ${T}(${O});
      const ${T} end = ${T}(${B});

      void main() {
        ${T} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${ke}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jf=F=>{const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{paddings:T,constantValue:O}=S;if(n.util.sizeFromShape(_.shape)===0)return ut({backend:k,attrs:{shape:T.map((K,Q)=>K[0]+_.shape[Q]+K[1]),value:O,dtype:_.dtype}});const B=Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kx(_.shape,T,O):new vx(_.shape,T,O),z=[[O]];return k.runWebGLProgram(B,[_],_.dtype,z)},Gf={kernelName:n.PadV2,backendName:"webgl",kernelFunc:jf},Hf=Lr({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),Ix={kernelName:n.Pow,backendName:"webgl",kernelFunc:Hf},Cx={kernelName:n.Prod,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{axis:T,keepDims:O}=S,B=_.shape.length,z=[],K=n.util.parseAxisParam(T,_.shape);let Q=K;const ue=n.backend_util.getAxesPermutation(Q,B);let ae,Re=_;if(ue!=null&&(Re=Ur({inputs:{x:_},backend:k,attrs:{perm:ue}}),Q=n.backend_util.getInnerMostAxes(Q.length,B),z.push(Re)),n.backend_util.assertAxesAreInnerMostDims("prod",Q,B),k.shouldExecuteOnCPU([Re])){const ke=k.texData.get(Re.dataId).values,{outVals:Ge,outShape:qe,outDtype:Ne}=fo(Re.shape,Re.dtype,ke,Q);ae=k.makeTensorInfo(qe,Ne,Ge)}else{const[ke,Ge]=n.backend_util.computeOutAndReduceShapes(Re.shape,Q),qe=n.util.sizeFromShape(Ge),Ne=jn({inputs:{x:Re},backend:k,attrs:{shape:[-1,qe]}}),Ke=Vr(Ne,Object(n.sumOutType)(_.dtype),"prod",k);ae=jn({inputs:{x:Ke},backend:k,attrs:{shape:ke}}),z.push(Ne),z.push(Ke)}if(O){z.push(ae);const ke=n.backend_util.expandShapeToKeepDim(ae.shape,K);ae=jn({inputs:{x:ae},backend:k,attrs:{shape:ke}})}return z.forEach(ke=>k.disposeIntermediateTensorInfo(ke)),ae}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _x={kernelName:n.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{shape:_,values:T,defaultValue:O,rowPartitionTensors:B}=y,{rowPartitionTypes:z}=S,K=k.readSync(_.dataId),Q=k.readSync(T.dataId),ue=k.readSync(O.dataId),ae=B.map(qe=>k.readSync(qe.dataId)),Re=B.map(qe=>qe.shape),[ke,Ge]=no(K,_.shape,Q,T.shape,T.dtype,ue,O.shape,ae,Re,z);return k.makeTensorInfo(ke,T.dtype,Ge)}},qf=F=>{const{backend:y,attrs:k}=F,{start:S,stop:_,step:T,dtype:O}=k,B=Ta(S,_,T,O);return y.makeTensorInfo([B.length],O,B)},Sx={kernelName:n.Range,backendName:"webgl",kernelFunc:qf},sl=Ls({opSnippet:"return 1.0 / x;"}),$x={kernelName:n.Reciprocal,backendName:"webgl",kernelFunc:sl},Tx=Ls({opSnippet:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Nx={kernelName:n.Relu,backendName:"webgl",kernelFunc:Tx},Kf=Ls({opSnippet:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),Xf={kernelName:n.Relu6,backendName:"webgl",kernelFunc:Kf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yf{constructor(y,k,S,_,T){this.variableNames=["A"],this.outputShape=[];const[O,B,z,K]=y;this.outputShape=[O,k,S,K];const Q=[_&&k>1?B-1:B,_&&S>1?z-1:z],ue=[_&&k>1?k-1:k,_&&S>1?S-1:S];let ae;ae=T?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${Q[0]/ue[0]},
          ${Q[1]/ue[1]});
      const vec2 inputShapeRC = vec2(${B}.0, ${z}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${ae};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wh{constructor(y,k,S,_,T){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[O,B,z,K]=y;this.outputShape=[O,k,S,K];const Q=[_&&k>1?B-1:B,_&&S>1?z-1:z],ue=[_&&k>1?k-1:k,_&&S>1?S-1:S];let ae;ae=T?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${Q[0]/ue[0]},
          ${Q[1]/ue[1]},
          ${Q[1]/ue[1]});
      const vec3 inputShapeRC = vec3(${B}.0, ${z}.0,
                                     ${z}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${ae};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${K-1};
        bool hasNextRow = coords.z < ${S-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ex={kernelName:n.ResizeBilinear,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{images:_}=y,{alignCorners:T,halfPixelCenters:O,size:B}=S,[z,K]=B,Q=Object(n.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Wh(_.shape,z,K,T,O):new Yf(_.shape,z,K,T,O);return k.runWebGLProgram(Q,[_],"float32")}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rx{constructor(y,k,S){this.variableNames=["dy"],this.outputShape=[],this.outputShape=k;const[,_,T]=k,[,O,B]=y,z=[S&&O>1?_-1:_,S&&B>1?T-1:T],K=[S&&O>1?O-1:O,S&&B>1?B-1:B],Q=z[0]/K[0],ue=z[1]/K[1],ae=1/Q,Re=1/ue,ke=2*Math.ceil(ae)+2,Ge=2*Math.ceil(Re)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${Q});
        const float widthScale = float(${ue});

        const float invHeightScale = float(${ae});
        const float invWidthScale = float(${Re});

        const int winHeight = int(${ke});
        const int winWidth = int(${Ge});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${O}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${B}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${_-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${T-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zf={kernelName:n.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{images:_,dy:T}=y,{alignCorners:O}=S,B=new Rx(T.shape,_.shape,O);return k.runWebGLProgram(B,[T],T.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ax{constructor(y,k,S,_,T){this.variableNames=["A"],this.outputShape=[];const[O,B,z,K]=y;this.outputShape=[O,k,S,K];const Q=[_&&k>1?B-1:B,_&&S>1?z-1:z],ue=[_&&k>1?k-1:k,_&&S>1?S-1:S],ae=_?"0.5":"0.0";let Re;Re=T?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${Q[0]/ue[0]},
          ${Q[1]/ue[1]});
      const vec2 inputShapeRC = vec2(${B}.0, ${z}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Re};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${ae})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ox{constructor(y,k,S,_,T){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[O,B,z,K]=y;this.outputShape=[O,k,S,K];const Q=[_&&k>1?B-1:B,_&&S>1?z-1:z],ue=[_&&k>1?k-1:k,_&&S>1?S-1:S],ae=_?"0.5":"0.0";let Re;Re=T?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${Q[0]/ue[0]},
          ${Q[1]/ue[1]},
          ${Q[1]/ue[1]});
      const vec3 inputShapeRC = vec3(${B}.0, ${z}.0,
                                     ${z}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Re};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${ae})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${K-1};
        bool hasNextRow = coords.z < ${S-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fx={kernelName:n.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{images:_}=y,{alignCorners:T,halfPixelCenters:O,size:B}=S,[z,K]=B,Q=Object(n.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ox(_.shape,z,K,T,O):new Ax(_.shape,z,K,T,O);return k.runWebGLProgram(Q,[_],_.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dx{constructor(y,k,S){this.variableNames=["dy"],this.outputShape=[],this.outputShape=k;const[,_,T]=k,[,O,B]=y,z=[S&&O>1?_-1:_,S&&B>1?T-1:T],K=[S&&O>1?O-1:O,S&&B>1?B-1:B],Q=z[0]/K[0],ue=z[1]/K[1],ae=1/Q,Re=1/ue,ke=2*Math.ceil(ae)+2,Ge=2*Math.ceil(Re)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${Q});
        const float widthScale = float(${ue});

        const float invHeightScale = float(${ae});
        const float invWidthScale = float(${Re});

        const int winHeight = int(${ke});
        const int winWidth = int(${Ge});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${O}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${B}) {
              continue;
            }

            float sourceFracRow =
              float(${z[0]}) *
                (float(dyR) / float(${K[0]}));

            float sourceFracCol =
                float(${z[1]}) *
                  (float(dyC) / float(${K[1]}));

            int sourceNearestRow = int(min(
                float(int(${_}) - 1),
                ${S} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${T}) - 1),
                ${S} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mx={kernelName:n.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{images:_,dy:T}=y,{alignCorners:O}=S,B=new Dx(T.shape,_.shape,O);return k.runWebGLProgram(B,[T],T.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Px{constructor(y,k){this.variableNames=["x"];const S=y.length;if(S>4)throw new Error(`WebGL backend: Reverse of rank-${S} tensor is not yet supported`);if(this.outputShape=y,S===1)return void(this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${y[0]} - coord - 1));
        }
      `);const _=y.map((O,B)=>(z=>k.indexOf(z)!==-1&&y[z]!==1?`${y[z]} - coords[${z}] - 1`:`coords[${z}]`)(B)).join(","),T=pe(S);this.userCode=`
      void main() {
        ${T} coords = getOutputCoords();
        setOutput(getX(${_}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lx{constructor(y,k){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const S=y.length;if(S>4)throw new Error(`WebGL backend: Reverse of rank-${S} tensor is not yet supported`);this.outputShape=y;const _=Vn("rc",S),T=`${_[S-1]} + 1 < ${this.outputShape[S-1]}`,O=`${_[S-2]} + 1 < ${this.outputShape[S-2]}`,B=pe(S);function z(K){const Q=y.map((ue,ae)=>function(Re,ke){return k.indexOf(Re)!==-1&&y[Re]!==1?`${y[Re]} - ${ke[Re]} - 1`:`${ke[Re]}`}(ae,K));return`getChannel(getX(${Q.join(",")}), vec2(${Q.slice(-2).join(",")}))`}this.userCode=S===1?`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${y[0]} - rc - 1),
            ${y[0]} - rc - 1);
          if(${T}){
              result.g = getChannel(getX(${y[0]} - (rc  + 1) - 1),
                ${y[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:`
        void main() {
          ${B} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${function(K){return z(K)}(_.slice())};
          if(${T}){
            result.g = ${function(K){return K[S-1]="("+K[S-1]+" + 1)",z(K)}(_.slice())};
          }
          if(${O}) {
            result.b = ${function(K){return K[S-2]="("+K[S-2]+" + 1)",z(K)}(_.slice())};
            if(${T}) {
              result.a = ${function(K){return K[S-1]="("+K[S-1]+" + 1)",K[S-2]="("+K[S-2]+" + 1)",z(K)}(_.slice())};
            }
          }
          setOutput(result);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bx={kernelName:n.Reverse,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{dims:T}=S,O=_.shape.length,B=n.util.parseAxisParam(T,_.shape);if(O===0)return Wr({inputs:{x:_},backend:k});const z=Object(n.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Lx(_.shape,B):new Px(_.shape,B);return k.runWebGLProgram(z,[_],_.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zx{constructor(y,k){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const S=y[1],_=y[2];this.outputShape=y;let T="";T=typeof k=="number"?`float outputValue = ${k.toFixed(2)};`:`
        vec3 fill = vec3(${k.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${T}
          if(coordX >= 0 && coordX < ${_} && coordY >= 0 && coordY < ${S}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wx={kernelName:n.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:F,attrs:y,backend:k})=>{const{image:S}=F,{radians:_,fillValue:T,center:O}=y,B=k,z=new zx(S.shape,T),[K,Q]=n.backend_util.getImageCenter(O,S.shape[1],S.shape[2]),ue=[[K,Q,Math.sin(_),Math.cos(_)]];return B.runWebGLProgram(z,[S],S.dtype,ue)}},Vx=Ls({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),Qf={kernelName:n.Round,backendName:"webgl",kernelFunc:Vx},Ux=Ls({opSnippet:"return inversesqrt(x);",cpuKernelImpl:mo}),io={kernelName:n.Rsqrt,backendName:"webgl",kernelFunc:Ux};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cu{constructor(y,k,S,_,T,O,B=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=O;const z=pe(T.length),K=pe(O.length);let Q="";S===1?Q="i":S===2&&(Q="i, j");const ue=`getIndices(${Q})`;let ae="";_===1?ae="i":_===2&&(ae="i, coords[1]");const Re=`getUpdates(${ae})`,ke=k>1?"strides[j]":"strides";this.userCode=`
        ${z} strides = ${z}(${T});

        void main() {
          ${K} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${y}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${k}; j++) {
              int index = round(${ue});
              flattenedIndex += index * ${ke};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${Re};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jx={kernelName:n.ScatterNd,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{indices:_,updates:T}=y,{shape:O}=S,{sliceRank:B,numUpdates:z,sliceSize:K,strides:Q,outputSize:ue}=n.backend_util.calculateShapes(T,_,O),ae=[ue/K,K];if(ue===0)return k.makeTensorInfo(O,_.dtype);const Re=jn({inputs:{x:_},backend:k,attrs:{shape:[z,B]}}),ke=jn({inputs:{x:T},backend:k,attrs:{shape:[z,K]}}),Ge=k.makeTensorInfo([],"float32",new Float32Array([0])),qe=new cu(z,B,Re.shape.length,ke.shape.length,Q,ae),Ne=k.runWebGLProgram(qe,[ke,Re,Ge],ke.dtype),Ke=jn({inputs:{x:Ne},backend:k,attrs:{shape:O}});return k.disposeIntermediateTensorInfo(Re),k.disposeIntermediateTensorInfo(ke),k.disposeIntermediateTensorInfo(Ne),k.disposeIntermediateTensorInfo(Ge),Ke}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gx{constructor(y,k,S,_){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[y,S];const T=`for (int i = 0; i < ${Math.ceil(Math.log2(k+1))}; ++i) { if (left >= right) break;`,O=Object(n.env)().getNumber("WEBGL_VERSION")===2?"while (left < right) {":T,B=_==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${O}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${B} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hx={kernelName:n.SearchSorted,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{sortedSequence:_,values:T}=y,{side:O}=S,B=new Gx(_.shape[0],_.shape[1],T.shape[1],O),z=[[_.shape[1]]];return k.runWebGLProgram(B,[_,T],"int32",z)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qx{constructor(y,k,S){let _,T;if(this.variableNames=["c","a","b"],this.outputShape=k,S>4)throw Error(`Where for rank ${S} is not yet supported`);if(S===1)T="resRC",_="resRC";else{const B=["resRC.x","resRC.y","resRC.z","resRC.w"],z=[],K=[];for(let Q=0;Q<k.length;Q++)K.push(`${B[Q]}`),Q<y&&z.push(`${B[Q]}`);_=z.join(),T=K.join()}const O=pe(S);this.userCode=`
      void main() {
        ${O} resRC = getOutputCoords();
        float cVal = getC(${_});
        if (cVal >= 1.0) {
          setOutput(getA(${T}));
        } else {
          setOutput(getB(${T}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kx={kernelName:n.Select,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{condition:S,t:_,e:T}=y,O=new qx(S.shape.length,_.shape,_.shape.length);return k.runWebGLProgram(O,[S,_,T],Object(n.upcastType)(_.dtype,T.dtype))}},Xx=Ls({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${n.backend_util.SELU_SCALEALPHA};
  float scale = ${n.backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),Yx={kernelName:n.Selu,backendName:"webgl",kernelFunc:Xx},Zx=Ls({opSnippet:`if (isnan(x)) return x;
  return 1.0 / (1.0 + exp(-1.0 * x));
`,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Na}),Qx={kernelName:n.Sigmoid,backendName:"webgl",kernelFunc:Zx},Jx=Ls({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),e1={kernelName:n.Sign,backendName:"webgl",kernelFunc:Jx},t1=Ls({opSnippet:`if (isnan(x)) return x;
  return sin(x);
`}),n1={kernelName:n.Sin,backendName:"webgl",kernelFunc:t1},s1=Ls({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),r1={kernelName:n.Sinh,backendName:"webgl",kernelFunc:s1},a1=Ls({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),o1={kernelName:n.Softplus,backendName:"webgl",kernelFunc:a1},i1={kernelName:n.SpaceToBatchND,backendName:"webgl",kernelFunc:F=>{const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{blockShape:T,paddings:O}=S;n.util.assert(_.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const B=T.reduce((Ne,Ke)=>Ne*Ke),z=[[0,0]];z.push(...O);for(let Ne=1+T.length;Ne<_.shape.length;++Ne)z.push([0,0]);const K=[],Q=jf({inputs:{x:_},backend:k,attrs:{paddings:z,constantValue:0}}),ue=n.backend_util.getReshaped(Q.shape,T,B,!1),ae=n.backend_util.getPermuted(ue.length,T.length,!1),Re=n.backend_util.getReshapedPermuted(Q.shape,T,B,!1),ke=jn({inputs:{x:Q},backend:k,attrs:{shape:ue}}),Ge=Ur({inputs:{x:ke},backend:k,attrs:{perm:ae}}),qe=jn({inputs:{x:Ge},backend:k,attrs:{shape:Re}});return K.push(Q),K.push(ke),K.push(Ge),K.forEach(Ne=>k.disposeIntermediateTensorInfo(Ne)),qe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u1={kernelName:n.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{indices:S,values:_,denseShape:T,defaultValue:O}=y;if(T.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${T.shape}`);if(S.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${S.shape}`);if(_.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${_.shape}`);if(O.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${O.shape}`);const B=k.readSync(S.dataId),z=k.readSync(_.dataId),K=k.readSync(T.dataId),Q=k.readSync(O.dataId)[0],[ue,ae,Re,ke,Ge]=So(B,S.shape,S.dtype,z,_.dtype,K,Q);return[k.makeTensorInfo(ae,S.dtype,ue),k.makeTensorInfo([ae[0]],_.dtype,Re),k.makeTensorInfo([ke.length],"bool",new Uint8Array(ke.map(qe=>Number(qe)))),k.makeTensorInfo([Ge.length],S.dtype,new Int32Array(Ge))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c1={kernelName:n.SparseReshape,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{inputIndices:S,inputShape:_,newShape:T}=y;if(S.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${S.shape}`);if(_.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${_.shape}`);if(T.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${T.shape}`);const O=Array.from(k.readSync(_.dataId)),B=k.readSync(S.dataId),z=Array.from(k.readSync(T.dataId)),[K,Q,ue]=so(B,S.shape,S.dtype,O,z);return[k.makeTensorInfo(Q,S.dtype,K),k.makeTensorInfo([ue.length],T.dtype,new Int32Array(ue))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l1={kernelName:n.SparseSegmentMean,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{data:S,indices:_,segmentIds:T}=y;if(S.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(_.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${_.shape}`);if(T.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${T.shape}`);const O=k.readSync(S.dataId),B=k.readSync(_.dataId),z=k.readSync(T.dataId),[K,Q]=Zs(O,S.shape,S.dtype,B,z,!0);return k.makeTensorInfo(Q,S.dtype,K)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d1={kernelName:n.SparseSegmentSum,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k}=F,{data:S,indices:_,segmentIds:T}=y;if(S.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(_.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${_.shape}`);if(T.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${T.shape}`);const O=k.readSync(S.dataId),B=k.readSync(_.dataId),z=k.readSync(T.dataId),[K,Q]=Zs(O,S.shape,S.dtype,B,z);return k.makeTensorInfo(Q,S.dtype,K)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1={kernelName:n.SparseToDense,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{sparseIndices:_,sparseValues:T,defaultValue:O}=y,{outputShape:B}=S,{sliceRank:z,numUpdates:K,sliceSize:Q,strides:ue,outputSize:ae}=n.backend_util.calculateShapes(T,_,B);if(T.dtype==="string"){const qe=k.bufferSync(_),Ne=k.bufferSync(T),Ke=n.util.decodeString(k.readSync(O.dataId)[0]),an=Ar(qe,Ne,B,ae,Q,K,z,ue,Ke,!1);return k.makeTensorInfo(B,an.dtype,an.values)}const Re=new cu(K,z,_.shape.length,T.shape.length,ue,[ae,1],!1),ke=k.runWebGLProgram(Re,[T,_,O],T.dtype),Ge=jn({inputs:{x:ke},backend:k,attrs:{shape:B}});return k.disposeIntermediateTensorInfo(ke),Ge}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lu={kernelName:n.SplitV,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{numOrSizeSplits:T,axis:O}=S,B=n.util.parseAxisParam(O,_.shape)[0],z=n.backend_util.prepareSplitSize(_,T,B),K=_.shape.length,Q=new Array(K).fill(0),ue=_.shape.slice();return z.map(ae=>{const Re=[...ue];Re[B]=ae;const ke=Xt({inputs:{x:_},backend:k,attrs:{begin:Q,size:Re}});return Q[B]+=ae,ke})}},Jf="return sqrt(x);",p1=Ls({opSnippet:Jf,packedOpSnippet:Jf,cpuKernelImpl:Kr}),f1={kernelName:n.Sqrt,backendName:"webgl",kernelFunc:p1},m1=Ls({opSnippet:"return x * x;"}),g1={kernelName:n.Square,backendName:"webgl",kernelFunc:m1},em="return (a - b) * (a - b);",b1=Lr({opSnippet:em,packedOpSnippet:em}),Vh={kernelName:n.SquaredDifference,backendName:"webgl",kernelFunc:b1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x1={kernelName:n.Step,backendName:"webgl",kernelFunc:function({inputs:F,attrs:y,backend:k}){const{x:S}=F,_=`if (isnan(x)) return x;
    return x > 0.0 ? 1.0 : float(${y.alpha});
  `,T=new Or(S.shape,_);return k.runWebGLProgram(T,[S],S.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y1{constructor(y,k,S){this.variableNames=["x"],this.outputShape=S;const _=S.length,T=pe(S.length),O=pe(S.length);let B="";if(_===1)B="coords * strides + begin";else{let z=0;B=S.map((K,Q)=>(z++,S.length===1?`coords * strides[${Q}] + begin[${Q}]`:`coords[${z-1}] * strides[${Q}] + begin[${Q}]`)).join(",")}this.userCode=`
      ${T} begin = ${T}(${y});
      ${T} strides = ${T}(${k});

      void main() {
        ${O} coords = getOutputCoords();
        setOutput(getX(${B}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1={kernelName:n.StridedSlice,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{begin:T,end:O,strides:B,beginMask:z,endMask:K,ellipsisMask:Q,newAxisMask:ue,shrinkAxisMask:ae}=S,{finalShapeSparse:Re,finalShape:ke,isIdentity:Ge,sliceDim0:qe,isSimpleSlice:Ne,begin:Ke,end:an,strides:kn}=n.slice_util.sliceInfo(_.shape,T,O,B,z,K,Q,ue,ae);let Pn;if(Ge)Pn=jn({inputs:{x:_},backend:k,attrs:{shape:ke}});else if(qe||Ne){n.util.assert(_.shape.length>=1,()=>`Input must have rank at least 1, got: ${_.shape.length}`);const Hn=n.slice_util.computeOutShape(Ke,an,kn),Qn=Xt({inputs:{x:_},backend:k,attrs:{begin:Ke,size:Hn}});Pn=jn({inputs:{x:Qn},backend:k,attrs:{shape:ke}}),k.disposeIntermediateTensorInfo(Qn)}else if(k.shouldExecuteOnCPU([_])){const Hn=k.readSync(_.dataId),Qn=Object(n.buffer)(_.shape,_.dtype,Hn),Wn=Ra(Re,Qn,kn,Ke);Pn=k.makeTensorInfo(ke,_.dtype,Wn.values)}else{const Hn=new y1(Ke,kn,Re);Pn=k.runWebGLProgram(Hn,[_],_.dtype)}const Xn=jn({inputs:{x:Pn},backend:k,attrs:{shape:ke}});return k.disposeIntermediateTensorInfo(Pn),Xn}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1={kernelName:n.StringNGrams,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{separator:_,nGramWidths:T,leftPad:O,rightPad:B,padWidth:z,preserveShortSequences:K}=S,{data:Q,dataSplits:ue}=y,ae=k.readSync(Q.dataId),Re=k.readSync(ue.dataId),[ke,Ge]=fa(ae,Re,_,T,O,B,z,K);return[k.makeTensorInfo([ke.length],"string",ke),k.makeTensorInfo(ue.shape,"int32",Ge)]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k1={kernelName:n.StringSplit,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{skipEmpty:_}=S,{input:T,delimiter:O}=y;if(T.dtype!=="string")throw new Error("Input must be of datatype string");if(T.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${T.shape}`);if(O.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${O.shape}`);const B=k.readSync(T.dataId),z=k.readSync(O.dataId)[0],[K,Q,ue]=na(B,z,_),ae=Q.length;return[k.makeTensorInfo([ae,2],"int32",K),k.makeTensorInfo([ae],"string",Q),k.makeTensorInfo([2],"int32",new Int32Array(ue))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I1={kernelName:n.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{numBuckets:_}=S,{input:T}=y;if(T.dtype!=="string")throw new Error("Input must be of datatype string");if(_<=0)throw new Error("Number of buckets must be at least 1");const O=k.readSync(T.dataId),B=$o(O,_);return k.makeTensorInfo(T.shape,"int32",B)}},C1=Ls({opSnippet:"return tan(x);"}),_1={kernelName:n.Tan,backendName:"webgl",kernelFunc:C1},S1=Ls({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),$1={kernelName:n.Tanh,backendName:"webgl",kernelFunc:S1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T1{constructor(y,k){this.variableNames=["A"];const S=new Array(y.length);for(let O=0;O<S.length;O++)S[O]=y[O]*k[O];this.outputShape=S,this.rank=S.length;const _=pe(this.rank),T=function(O){const B=O.length;if(B>5)throw Error(`Tile for rank ${B} is not yet supported`);if(B===1)return`imod(resRC, ${O[0]})`;const z=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],K=[];for(let Q=0;Q<O.length;Q++)K.push(`imod(${z[Q]}, ${O[Q]})`);return K.join()}(y);this.userCode=`
      void main() {
        ${_} resRC = getOutputCoords();
        setOutput(getA(${T}));
      }
    `}}function tm(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{reps:T}=S;if(_.dtype==="string"||_.shape.length>5){const B=k.readSync(_.dataId),z=_.dtype==="string"?B.map(ue=>n.util.decodeString(ue)):B,K=Object(n.buffer)(_.shape,_.dtype,z),Q=It(K,T);return k.makeTensorInfo(Q.shape,Q.dtype,Q.values)}const O=new T1(_.shape,T);return k.runWebGLProgram(O,[_],_.dtype)}const N1={kernelName:n.Tile,backendName:"webgl",kernelFunc:tm};class E1{constructor(y){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=y,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class R1{constructor(y){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=y,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nc(F,y){y!==null&&F.disposeIntermediateTensorInfo(y)}function nm(F){let y=1;for(;y<F;)y*=2;return y}const A1={kernelName:n.TopK,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_}=y,{k:T,sorted:O}=S,B=Object(n.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),z=Object(n.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),K=_.shape,Q=K[K.length-1];if(k.shouldExecuteOnCPU([_])||Q<B||T>z){const Wn=k.readSync(_.dataId),[vs,fs]=Ut(Wn,K,_.dtype,T,O);return[k.makeTensorInfo(vs.shape,vs.dtype,vs.values),k.makeTensorInfo(fs.shape,fs.dtype,fs.values)]}if(T===0)return K[K.length-1]=0,[k.makeTensorInfo(K,_.dtype,[]),k.makeTensorInfo(K,"int32",[])];if(Q===1)return[_,ut({attrs:{shape:K,dtype:"int32",value:0},backend:k})];const ue=k.texData.get(_.dataId),ae=ue!==null&&ue.isPacked,Re=ae?k.unpackTensor(_):_,ke=n.util.sizeFromShape(K)/Q,Ge=jn({inputs:{x:Re},attrs:{shape:[ke,Q]},backend:k});ae&&nc(k,Re);const qe=nm(T),Ne=nm(Q);let Ke=null;const an=()=>Ke===null?[Ge,Ge]:[Ge,Ke],kn=(Wn,vs,fs)=>{const w=an(),g=new E1(fs),v=[[Q],[Ke===null?1:0],[Number.NEGATIVE_INFINITY],[Wn],[vs]],C=Ke;Ke=k.runWebGLProgram(g,w,"int32",v),nc(k,C)};for(let Wn=1;Wn<qe;Wn*=2){const vs=2*Wn;for(let fs=Wn;fs>=1;fs/=2)kn(vs,fs,[ke,Ne])}for(let Wn=Ne;Wn>qe;Wn/=2){const vs=an(),fs=new R1([ke,Wn/2]),w=[[Q],[Ke===null?1:0],[qe]],g=Ke;Ke=k.runWebGLProgram(fs,vs,"int32",w),nc(k,g);const v=qe/2,C=2*v;for(let $=v;$>=1;$/=2)kn(C,$,Ke.shape)}let Pn=Ke;Ke=Xt({inputs:{x:Ke},backend:k,attrs:{begin:0,size:[ke,T]}}),nc(k,Pn);let Xn=sa({inputs:{x:Ge,indices:Ke},backend:k,attrs:{axis:1,batchDims:1}});nc(k,Ge);const Hn=K.slice(0,-1);Hn.push(T),Pn=Ke,Ke=jn({inputs:{x:Ke},attrs:{shape:Hn},backend:k}),nc(k,Pn);const Qn=Xn;return Xn=jn({inputs:{x:Xn},attrs:{shape:Hn},backend:k}),nc(k,Qn),[Xn,Ke]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O1{constructor(y,k,S,_,T,O){this.variableNames=["Image","Transforms"],this.outputShape=O;const B=S==="nearest"?1:2;let z;switch(_){case"constant":default:z=1;break;case"reflect":z=2;break;case"wrap":z=3;break;case"nearest":z=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${z} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${z} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${z} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${y} && 0 <= coordX && coordX < ${k}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${T});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${T});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${k}));
                float mapY = mapCoord(inY, float(${y}));

                if (${B} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F1={kernelName:n.Transform,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{image:_,transforms:T}=y,{interpolation:O,fillMode:B,fillValue:z,outputShape:K}=S,[Q,ue,ae,Re]=_.shape,[ke,Ge]=K!=null?K:[ue,ae],qe=new O1(ue,ae,O,B,z,[Q,ke,Ge,Re]);return k.runWebGLProgram(qe,[_,T],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D1={kernelName:n.Unique,backendName:"webgl",kernelFunc:function(F){const{inputs:y,attrs:k,backend:S}=F,{axis:_}=k,{x:T}=y;wt(T,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const O=S.readSync(T.dataId),{outputValues:B,outputShape:z,indices:K}=vn(O,_,T.shape,T.dtype);return[S.makeTensorInfo(z,T.dtype,B),S.makeTensorInfo([K.length],"int32",K)]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M1={kernelName:n.Unpack,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{value:_}=y;let{axis:T}=S;T<0&&(T+=_.shape.length);const O=_,B=O.shape.length,z=_.shape[T],K=new Array(B-1);let Q=0;for(let Ge=0;Ge<B;Ge++)Ge!==T&&(K[Q++]=O.shape[Ge]);const ue=[],ae=new Array(B).fill(0),Re=O.shape.slice();Re[T]=1;const ke=new Array(z);for(let Ge=0;Ge<ke.length;Ge++){ae[T]=Ge;const qe=Xt({inputs:{x:O},backend:k,attrs:{begin:ae,size:Re}}),Ne=jn({inputs:{x:qe},backend:k,attrs:{shape:K}});ke[Ge]=Ne,ue.push(qe)}return ue.forEach(Ge=>k.disposeIntermediateTensorInfo(Ge)),ke}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P1{constructor(y,k){this.variableNames=["x","segmentIds"];const S=y.windowSize,_=y.batchSize,T=y.inSize,O=y.numSegments,B=O*Math.ceil(T/S);this.outputShape=[_,B];const z=4*Math.floor(S/4),K=S%4,Q=`
        sumValue += dot(values, segFilter);
    `;let ue="";T%S>0&&(ue=`
        if (inIdx < 0 || inIdx >= ${T}) {
          return initializationValue;
        }
      `);let ae="";T%S>0&&(ae=`
        if (inIdx < 0 || inIdx >= ${T}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${ue}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${ae}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${O})) * float(${S}));
        int currentSeg = int(mod(float(outIdx), float(${O})));

        float sumValue = 0.0;

        for (int i = 0; i < ${z}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${Q}
        }

        int inIdx = inOffset + ${z};
        if (${K===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${Q}
        } else if (${K===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${Q}
        } else if (${K===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${Q}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L1=[ar,Ni,ci,Os,su,ru,Oi,Eo,Mi,_c,Pi,Xu,$c,Pe,He,rt,xt,St,_t,en,Lt,Jn,Ss,Ms,fr,Ca,Li,ja,Ho,Ol,iu,ec,Ec,Qc,Ll,Eu,zl,Ru,tc,Se,Oe,Z,H,De,Te,Ye,Je,lt,ft,$t,Bt,A,q,te,he,Ue,et,Et,Dt,cn,yn,ss,us,ps,ks,or,yr,ma,Ji,Ha,Zu,pi,Ac,nl,Tu,mi,zb,Wb,Pf,jb,Hb,Kb,Yb,Jb,Oh,Lf,Fh,Bf,Dh,tx,nx,Mh,Vi,jl,rx,ix,cx,px,bs,fx,Uf,gx,Ld,Fs,zd,yx,wx,Gf,Ix,Nu,Cx,_x,Sx,er,lx,$x,Nx,Xf,hr,Ex,Zf,Fx,Mx,Bx,Wx,Qf,io,jx,Hx,Kx,Yx,Qx,e1,n1,r1,$n,hx,o1,i1,u1,c1,l1,d1,h1,lu,f1,g1,Vh,x1,w1,v1,k1,I1,dx,Ku,_1,$1,N1,A1,F1,oo,D1,M1,{kernelName:n.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(F){const{inputs:y,backend:k,attrs:S}=F,{x:_,segmentIds:T}=y,{numSegments:O}=S,B=_.shape.length,z=[];let K=0;const Q=n.backend_util.getAxesPermutation([K],B);let ue=_;Q!=null&&(ue=Ur({inputs:{x:_},backend:k,attrs:{perm:Q}}),z.push(ue),K=n.backend_util.getInnerMostAxes(1,B)[0]);const ae=n.backend_util.segment_util.computeOutShape(ue.shape,K,O),Re=n.util.sizeFromShape([ue.shape[K]]),ke=jn({inputs:{x:ue},backend:k,attrs:{shape:[-1,Re]}});z.push(ke);const Ge=Object(n.sumOutType)(_.dtype),qe=(an,kn,Pn,Xn,Hn)=>{const Qn=an.shape[0],Wn=an.shape[1],vs=n.backend_util.segment_util.segOpComputeOptimalWindowSize(Wn,Hn),fs=new P1({windowSize:vs,inSize:Wn,batchSize:Qn,numSegments:Hn},kn),w=k.compileAndRun(fs,[an,Pn],Xn);if(z.push(w),w.shape[1]===Hn)return w;const g=qf({backend:k,attrs:{start:0,stop:Hn,step:1,dtype:"float32"}}),v=tm({inputs:{x:g},backend:k,attrs:{reps:[Wn/vs]}});return z.push(g),z.push(v),qe(w,kn,v,Xn,Hn)},Ne=jn({inputs:{x:qe(ke,"unsortedSegmentSum",T,Ge,O)},backend:k,attrs:{shape:ae}});let Ke=Ne;if(Q!=null){z.push(Ne);const an=n.backend_util.getUndoAxesPermutation(Q);Ke=Ur({inputs:{x:Ke},backend:k,attrs:{perm:an}})}return z.forEach(an=>k.disposeIntermediateTensorInfo(an)),Ke}},xx];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const F of L1)Object(n.registerKernel)(F);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(s,e,t){var n=t(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r=Object(n.env)();r.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),r.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),r.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),r.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1),r.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),r.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),r.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),r.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a{constructor(A){this.device=A,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(A,R){return this.acquireBuffer(A,R,!0)}acquireBuffer(A,R,q=!1){const j=o(A,R);if(this.freeBuffers.has(j)||this.freeBuffers.set(j,[]),this.usedBuffers.has(j)||this.usedBuffers.set(j,[]),this.numBytesUsed+=A,this.numUsedBuffers++,this.freeBuffers.get(j).length>0){this.numFreeBuffers--;const ie=this.freeBuffers.get(j).shift();return this.usedBuffers.get(j).push(ie),ie}this.numBytesAllocated+=A;const te=this.device.createBuffer({size:A,usage:R,mappedAtCreation:q});return this.usedBuffers.get(j).push(te),te}releaseBuffer(A,R,q){if(this.freeBuffers.size===0)return;const j=o(R,q);this.freeBuffers.has(j)||this.freeBuffers.set(j,[]),this.freeBuffers.get(j).push(A),this.numFreeBuffers++,this.numUsedBuffers--;const te=this.usedBuffers.get(j),ie=te.indexOf(A);if(ie<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");te.splice(ie,1),this.numBytesUsed-=R}releaseUploadBuffer(A,R,q){A.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(A,R,q)},j=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((A,R)=>{A.forEach(q=>{q.destroy()})}),this.usedBuffers.forEach((A,R)=>{A.forEach(q=>{q.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function o(G,A){return`${G}_${A}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i{constructor(A){this.device=A,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(A,R,q,j){const te=A*R*c(q),ie=u(A,R,q,j);if(this.freeTextures.has(ie)||this.freeTextures.set(ie,[]),this.usedTextures.has(ie)||this.usedTextures.set(ie,[]),this.numBytesUsed+=te,this.numUsedTextures++,this.freeTextures.get(ie).length>0){this.numFreeTextures--;const xe=this.freeTextures.get(ie).shift();return this.usedTextures.get(ie).push(xe),xe}this.numBytesAllocated+=te;const he=this.device.createTexture({size:[A,R],format:q,usage:j});return this.usedTextures.get(ie).push(he),he}releaseTexture(A,R,q,j,te){if(this.freeTextures.size===0)return;const ie=u(R,q,j,te);this.freeTextures.has(ie)||this.freeTextures.set(ie,[]),this.freeTextures.get(ie).push(A),this.numFreeTextures++,this.numUsedTextures--;const he=this.usedTextures.get(ie),xe=he.indexOf(A);if(xe<0)throw new Error("Cannot release a texture that was never provided by this texture manager");he.splice(xe,1);const _e=R*q*c(j);this.numBytesUsed-=_e}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((A,R)=>{A.forEach(q=>{q.destroy()})}),this.usedTextures.forEach((A,R)=>{A.forEach(q=>{q.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function u(G,A,R,q){return`${G}_${A}_${R}_${q}`}function c(G){if(G==="rgba8unorm")return 16;throw new Error(`${G} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d(G,A){if(Math.max(...G)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const R=G.length,q=G.map(te=>`${A}[${te}]`),j=new Array(R-1);j[R-2]=q[R-1];for(let te=R-3;te>=0;--te)j[te]=`(${j[te+1]} * ${q[te+1]})`;return j}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h=(G,A,R,q)=>{const j=function(ie,he,xe){const _e=[];if(_e.push(`
      const workGroupSizeX = ${xe.workGroupSize[0]}u;
      const workGroupSizeY = ${xe.workGroupSize[1]}u;
      const workGroupSizeZ = ${xe.workGroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${N(xe)?"  return i32(globalId.x);":`  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
                   localId.y * workGroupSizeX + localId.x;
               let workGroupID = (globalId - localId)/vec3<u32>(
                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);

               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
                   workGroupID.y * numWorkgroups.x + workGroupID.x) *
                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
                   localInvocationIndex);
        `}
      }
    `),xe.isFromPixels)return _e.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${E(he.dtype,xe.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `),[b,_e.join(`
`),m(he.shape),xe.getUserCode()].join(`
`);let Ue="struct Uniforms { NAN : f32, ";xe.variableNames.forEach((Et,Tt)=>{const Dt=l(ie[Tt].shape.length);Ue+=`${Et.charAt(0).toLowerCase()+Et.slice(1)}Shape : ${Dt}, `}),Ue+=`outShape : ${l(he.shape.length)}, `,Ue+=`
         outShapeStrides: ${l(he.shape.length-1)}, `,xe.size&&(Ue+="size : i32, "),xe.uniforms&&(Ue+=xe.uniforms),Ue+="};",Ue=function(Et){const Tt=/(\w+)\s*:\s*vec(5|6)/g;Et=Et.replace(Tt,Wt=>"@align(16) "+Wt);const Dt=/vec(5|6)\s*,\s*(\w+)/g;return Et=Et.replace(Dt,(Wt,qt,cn)=>`vec${qt}, @align(16) ${cn}`)}(Ue),_e.push(Ue),xe.atomic?_e.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):_e.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${E(he.dtype,xe.isVec4)}>;
    `),xe.variableNames.forEach((Et,Tt)=>{_e.push(`
      @group(0) @binding(${1+Tt}) var<storage, read> ${Et}: array<${xe.variableTypes?xe.variableTypes[Tt]:E(ie[Tt].dtype,xe.isVec4)}>;
        `)}),Ue!==""&&_e.push(`
      @group(0) @binding(${1+xe.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const et=function(Et,Tt){const{x:Dt,y:Wt=[],z:qt=[]}=Tt,cn=Et.length;if(Dt.length===cn)return`fn getOutputCoords() -> ${l(cn)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let rn="";const yn=[Dt,Wt,qt];let Fn=0;for(let Kn=0;Kn<yn.length;Kn++){const us=yn[Kn];if(us.length!==0)if(Fn+=us.length,us.length===1)rn+=`let d${us[0]} = i32(globalId[${Kn}]);`;else{const ps=d(us,"uniforms.outShape");rn+=`var index${Kn} = i32(globalId[${Kn}]);`;for(let es=0;es<ps.length;es++)rn+=`let d${us[es]} = index${Kn} / ${ps[es]};`,es===ps.length-1?rn+=`let d${us[es+1]} = index${Kn} - d${us[es]} * ${ps[es]};`:rn+=`index${Kn} = index${Kn} - d${us[es]} * ${ps[es]};`}}const _n=[];for(let Kn=0;Kn<Fn;Kn++)_n.push(`d${Kn}`);const ss=l(Fn);let zn=`fn getOutputCoords() -> ${ss} {
  ${rn}
`;return _n.length===0?zn+=`return ${ss}(0); }`:zn+=`return ${ss}(${_n.join(",")}); }`,zn}(he.shape,xe.dispatchLayout),dt=[b,_e.join(`
`),m(he.shape),et,I(he.shape.length)];xe.atomic||dt.push(function(Et,Tt,Dt){const Wt=Et.length,qt=E(Tt,Dt);let cn;if(cn=Dt?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${qt}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${qt}(value);
    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${qt}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${qt}(value);
    }`,Wt>=2){const rn=["d0","d1","d2","d3","d4","d5"].slice(0,Wt),yn=l(Wt);cn+=Dt?`
      fn setOutputAtCoords(${rn.map(Fn=>`${Fn} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${yn}(${rn.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${rn.map(Fn=>`${Fn} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${yn}(${rn.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:`
      fn setOutputAtCoords(${rn.map(Fn=>`${Fn} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${yn}(${rn.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${rn.map(Fn=>`${Fn} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${yn}(${rn.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return cn}(he.shape,he.dtype,xe.isVec4));const ut=ie.map((Et,Tt)=>function(Dt,Wt,qt,cn){let rn=function(yn,Fn){const _n=yn.name,ss=yn.shape.length,zn=l(ss),Kn="get"+_n.charAt(0).toUpperCase()+_n.slice(1),us=["d0","d1","d2","d3","d4","d5"].slice(0,ss),ps=us.map(Ks=>`${Ks} : i32`).join(", ");if(ss<1)return Fn?`
        fn ${Kn}() -> vec4<f32> {
          return vec4<f32>(${_n}[0]);
        }
      `:`
      fn ${Kn}() ->f32 {
        return f32(${_n}[0]);
      }
    `;const es=`uniforms.${_n.charAt(0).toLowerCase()+_n.slice(1)}Shape`;let ks=`${ss}D`;return ss===0&&(ks="1D"),Fn?`
      fn ${Kn}(${ps}) -> vec4<f32> {
        return vec4<f32>(${_n}[getIndexFromCoords${ks}(${zn}(${us.join(",")}),
          ${es}) / 4]);
      }
      `:`
    fn ${Kn}(${ps}) -> f32 {
      return f32(${_n}[getIndexFromCoords${ks}(${zn}(${us.join(",")}),
        ${es})]);
    }
   `}(Dt,qt);return Dt.shape.length<=Wt.length&&(rn+=function(yn,Fn,_n,ss){const zn=yn.name,Kn=zn.charAt(0).toUpperCase()+zn.slice(1),us="get"+Kn+"ByOutput",ps=yn.shape.length,es=Fn.length,ks=l(es);if(n.util.arraysEqual(yn.shape,Fn)&&ss)return _n?`
      fn ${us}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${zn}[globalIndex]);
      }

      fn ${us}Coords(coords : ${ks}) -> vec4<f32> {
        return vec4<f32>(${zn}[${es>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${us}Index(globalIndex : i32) -> f32 {
      return f32(${zn}[globalIndex]);
    }

    fn ${us}Coords(coords : ${ks}) -> f32 {
      return f32(${zn}[${es>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;const Ks=n.backend_util.getBroadcastDims(yn.shape,Fn),sa=es-ps;let or="";if(ps===0)return _n?`
    fn ${us}Index(globalIndex : i32) -> vec4<f32> {
      return get${Kn}();
    }

    fn ${us}Coords(coords : ${ks}) -> vec4<f32> {
      return get${Kn}();
    }
  `:`
    fn ${us}Index(globalIndex : i32) -> f32{
      return get${Kn}();
    }

    fn ${us}Coords(coords : ${ks}) -> f32{
      return get${Kn}();
    }
  `;or=es<2&&Ks.length>=1?"coords = 0;":Ks.map(ma=>`coords.${p(ma+sa)} = 0;`).join(`
`);let _r="";if(es<2&&ps>0)_r="coords";else if(es>1){const ma=l(ps),Ha=yn.shape.map((vo,pi)=>`coords.${p(pi+sa)}`).join(", ");_r=`${ma}(${Ha})`}else _r="coords";const yr=`uniforms.${zn.charAt(0).toLowerCase()+zn.slice(1)}Shape`,Ga=`${ps}D`;return _n?`
    fn ${us}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${or}
      return ${zn}[getIndexFromCoords${Ga}(${_r}, ${yr}) / 4];
    }

    fn ${us}Coords(coordsIn : ${ks}) -> vec4<f32> {
      var coords = coordsIn;
      ${or}
      return ${zn}[getIndexFromCoords${Ga}(${_r}, ${yr}) / 4];
    }
  `:`
  fn ${us}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${or}
    return f32(${zn}[getIndexFromCoords${Ga}(${_r}, ${yr})]);
  }

  fn ${us}Coords(coordsIn : ${ks}) -> f32 {
    var coords = coordsIn;
    ${or}
    return f32(${zn}[getIndexFromCoords${Ga}(${_r}, ${yr})]);
  }
`}(Dt,Wt,qt,cn)),rn}(Et,he.shape,xe.variableTypes?xe.variableTypes[Tt]==="vec4<f32>":xe.isVec4,xe.dispatchLayout.x.length===he.shape.length)).join(`
`);return dt.push(ut),dt.push(xe.getUserCode()),dt.join(`
`)}(R,{dtype:q.dtype,shape:q.shape},A),te=G.createShaderModule({code:j,label:A.constructor.name});return G.createComputePipeline({compute:{module:te,entryPoint:"_start"},label:A.constructor.name,layout:"auto"})};function l(G){if(G<=1)return"i32";if(G===2)return"vec2<i32>";if(G===3)return"vec3<i32>";if(G===4)return"vec4<i32>";if(G===5)return"vec5";if(G===6)return"vec6";throw Error(`GPU for rank ${G} is not yet supported`)}function p(G){if(G===0)return"x";if(G===1)return"y";if(G===2)return"z";if(G===3)return"w";if(G===4)return"u";if(G===5)return"v";throw Error(`Index ${G} is not yet supported`)}function f(...G){let A;switch(G.length){case 0:A=`
        ${x()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main();
        }

        fn main()
      `;break;case 1:A=`
        ${x()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main(getGlobalIndex());
        }

        fn main(${G[0]} : i32)
      `;break;default:throw Error("Unreachable")}return A}function x(){return`
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`}const b=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;function m(G){const A=G.length;if(A<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const R=n.util.computeStrides(G),q=l(A),j=[];for(let ie=0;ie<A;ie++)j.push(`d${ie}`);if(R.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let te;return te="var index2 = index;"+R.map((ie,he)=>`${`let ${j[he]} = index2 / uniforms.outShapeStrides.${p(he)}`}; ${he===R.length-1?`let ${j[he+1]} = index2 - ${j[he]} * uniforms.outShapeStrides.${p(he)}`:`index2 = index2 - ${j[he]} * uniforms.outShapeStrides.${p(he)}`};`).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${q} {
      ${te}
      return ${q}(${j.join(",")});
    }
  `}function I(G){let A="";switch(G){case 0:case 1:A+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:A+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:A+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:A+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:A+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:A+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:n.util.assert(!1,()=>`Unsupported ${G}D shape`)}return A}function N(G){return G.dispatch[1]===1&&G.dispatch[2]===1}function E(G,A){return G==="float32"?A?"vec4<f32>":"f32":G==="int32"||G==="bool"?A?"vec4<i32>":"i32":G}const D=G=>{let A=1;for(let R=0;R<G.length;R++)A*=G[R];return A};function U(G,A,R=[1,1,1],q=[1,1,1]){const[j,te,ie]=[Math.ceil(D(G.x.map(he=>A[he]))/(R[0]*q[0])),G.y?Math.ceil(D(G.y.map(he=>A[he]))/(R[1]*q[1])):1,G.z?Math.ceil(D(G.z.map(he=>A[he]))/(R[2]*q[2])):1];return[j,te,ie]}function L(G,A,R=!1){if(R)return[8,8,1];const q=D(G.x.map(te=>A[te])),j=D(G.y.map(te=>A[te]));return q<=4?[4,16,1]:j<=4?[16,4,1]:[16,16,1]}function Y(G,A,R=!1){if(R)return[4,4,1];const q=D(G.x.map(te=>A[te])),j=D(G.y.map(te=>A[te]));return q<=4?[1,2,1]:j<=4?[2,1,1]:[2,2,1]}function V(G){return{x:G.map((A,R)=>R)}}function P(){return(typeof window!="undefined"||typeof WorkerGlobalScope!="undefined")&&!!navigator.gpu}var oe;(function(G){G[G.MatMulReduceProgram=0]="MatMulReduceProgram",G[G.MatMulSplitKProgram=1]="MatMulSplitKProgram",G[G.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",G[G.MatMulPackedProgram=3]="MatMulPackedProgram",G[G.MatMulMax=4]="MatMulMax"})(oe||(oe={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ne=Object(n.env)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class ge extends n.KernelBackend{constructor(A){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!P())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=A,this.queue=A.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=A.features.has("timestamp-query"),this.bufferManager=new a(this.device),this.textureManager=new i(this.device),this.tensorMap=new n.DataStorage(this,Object(n.engine)()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),Object(n.env)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:A,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return ge.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(A,R=!1){if(this.tensorDataPendingDisposal.indexOf(A)>=0)return!1;if(!this.tensorMap.has(A))return!0;const q=this.tensorMap.get(A);if(this.decRef(A),!R&&q.refCount>0)return!1;if(this.commandQueueOwnedIds.has(A))return this.tensorDataPendingDisposal.push(A),!1;const{complexTensorInfos:j}=this.tensorMap.get(A);return j!=null&&(this.disposeData(j.real.dataId,R),this.disposeData(j.imag.dataId,R)),this.releaseResource(A),this.tensorMap.delete(A),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(A){const R=this.tensorMap.get(A);if(R&&R.resourceInfo){if("texture"in R.resourceInfo){const q=R.resourceInfo;q.texture instanceof GPUTexture&&this.textureManager.releaseTexture(q.texture,q.width,q.height,q.format,q.usage),q.texture=null}else{const q=R.resourceInfo;this.bufferManager.releaseBuffer(q.buffer,q.size,q.usage),q.buffer=null}R.resourceInfo=null}}refCount(A){return this.tensorMap.has(A)?this.tensorMap.get(A).refCount:0}incRef(A){this.tensorMap.get(A).refCount++}decRef(A){this.tensorMap.has(A)&&this.tensorMap.get(A).refCount--}write(A,R,q){if(q==="complex64"&&A!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const j={id:this.nextDataId()};return this.tensorMap.set(j,{dtype:q,shape:R,values:A,refCount:1}),j}move(A,R,q,j,te){if(j==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(A,{dtype:j,shape:q,values:R,refCount:te})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(A=>{this.releaseResource(A),this.tensorMap.delete(A)}),this.uniformPendingDisposal.forEach(A=>this.bufferManager.releaseBuffer(A.buffer,A.size,A.usage)),this.stagingPendingDisposal.forEach(A=>this.bufferManager.releaseUploadBuffer(A.buffer,A.size,A.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(A,R){const q=this.bufferManager.acquireBuffer(R,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(A,0,q,0,R),this.submitQueue(),await q.mapAsync(GPUMapMode.READ);const j=q.getMappedRange().slice(0);return q.unmap(),q!=null&&this.bufferManager.releaseBuffer(q,R,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),Object(n.env)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(n.util.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),j}convertAndCacheOnCPU(A,R){const q=this.tensorMap.get(A);return this.releaseResource(A),q.values=R,q.values}readSync(A){const R=this.tensorMap.get(A),{values:q}=R;if(q==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return q}async read(A){if(!this.tensorMap.has(A))throw new Error(`Tensor ${A} was not registered!`);const R=this.tensorMap.get(A),{values:q}=R;if(q!=null)return this.convertAndCacheOnCPU(A,q);let j;if(R.dtype==="complex64"){const te=await Promise.all([this.read(R.complexTensorInfos.real.dataId),this.read(R.complexTensorInfos.imag.dataId)]),ie=te[0],he=te[1];j=n.backend_util.mergeRealAndImagArrays(ie,he)}else{const te=R.resourceInfo;j=function(ie,he){if(he==="float32")return new Float32Array(ie);if(he==="int32")return new Int32Array(ie);if(he==="bool"||he==="string")return Uint8Array.from(new Int32Array(ie));throw new Error(`Unknown dtype ${he}`)}(await this.getBufferData(te.buffer,te.size),R.dtype)}return this.convertAndCacheOnCPU(A,j),j}readToGPU(A){const R=this.tensorMap.get(A),{values:q,dtype:j,shape:te,resourceInfo:ie}=R;if(j==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(ie==null)throw q!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const he=ie.size,xe=this.bufferManager.acquireBuffer(he,ie.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(ie.buffer,0,xe,0,he),this.submitQueue();const _e=this.makeTensorInfo(te,j),Ue=Object(n.engine)().makeTensorFromTensorInfo(_e);return this.tensorMap.get(_e.dataId).resourceInfo={size:he,usage:this.defaultGpuBufferUsage(),buffer:xe},{tensorRef:Ue,buffer:xe,bufSize:he}}bufferSync(A){const R=this.readSync(A.dataId);if(A.dtype==="string")try{const q=R.map(j=>n.util.decodeString(j));return Object(n.buffer)(A.shape,A.dtype,q)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(n.buffer)(A.shape,A.dtype,R)}async time(A){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const R=this.activeTimers,q=[];let j=!1;this.programTimersStack==null?(this.programTimersStack=q,j=!0):this.activeTimers.push(q),this.activeTimers=q,A();const te=n.util.flatten(this.activeTimers.map(_e=>_e.query)).filter(_e=>_e!=null),ie=n.util.flatten(this.activeTimers.map(_e=>_e.name)).filter(_e=>_e!=null);this.activeTimers=R,j&&(this.programTimersStack=null);const he={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},xe=await Promise.all(te);return he.kernelMs=n.util.sum(xe),he.getExtraProfileInfo=()=>xe.map((_e,Ue)=>({name:ie[Ue],ms:_e})).map(_e=>`${_e.name}: ${_e.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,he}makeTensorInfo(A,R,q){return R==="string"&&q!=null&&q.length>0&&n.util.isString(q[0])&&(q=q.map(j=>n.util.encodeString(j))),{dataId:this.write(q,A,R),shape:A,dtype:R}}tensorToBinding(A){if(!A)return null;const R=this.tensorMap.get(A.dataId);if("texture"in R.resourceInfo){const j=R.resourceInfo;return j.texture instanceof GPUExternalTexture?j.texture:j.texture.createView()}const q=R.resourceInfo;return{offset:0,size:q.size,buffer:q.buffer}}async getQueryTime(A){return this.supportTimeQuery?this.getTimeFromQuerySet(A):0}uploadToGPU(A){const R=this.tensorMap.get(A);if(R.resourceInfo)return;const q=function(te){if(te==="float32"||te==="int32"||te==="bool"||te==="string")return 4;if(te==="complex64")return 8;throw new Error(`Unknown dtype ${te}`)}(R.dtype)*n.util.sizeFromShape(R.shape),j=this.bufferManager.acquireBuffer(q,this.defaultGpuBufferUsage());if(R.resourceInfo={size:q,usage:this.defaultGpuBufferUsage(),buffer:j},R.values){const te=this.bufferManager.acquireUploadBuffer(q,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),ie=te.getMappedRange();R.dtype==="int32"||R.dtype==="bool"?new Int32Array(ie).set(R.values):new Float32Array(ie).set(R.values),te.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(te,0,j,0,q);const he={size:q,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:te};this.stagingPendingDisposal.push(he)}}makeUniforms(A){let R=0,q=0;const j=[];A.forEach(xe=>{let _e;switch(xe.data.length===0&&(xe.data=[1]),xe.data.length){case 1:_e=4;break;case 2:_e=8;break;case 3:case 4:case 5:case 6:_e=16;break;default:n.util.assert(!1,()=>`Unsupported ${xe.data.length}D shape`)}q!==5&&q!==6||(_e=16),R=Math.ceil(R/_e)*_e,q=xe.data.length,j.push(R),R+=4*xe.data.length});const te=new ArrayBuffer(R);A.forEach((xe,_e)=>{const Ue=j[_e];xe.type==="int32"?new Int32Array(te,Ue,xe.data.length).set(xe.data):xe.type==="uint32"?new Uint32Array(te,Ue,xe.data.length).set(xe.data):new Float32Array(te,Ue,xe.data.length).set(xe.data)});const ie=this.bufferManager.acquireBuffer(R,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(ie,0,te,0,R);const he={size:R,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:ie};return this.uniformPendingDisposal.push(he),{offset:0,size:R,buffer:ie}}runWebGPUProgram(A,R,q,j,te){if(te||(te=this.makeTensorInfo(A.outputShape,q)),n.util.sizeFromShape(te.shape)===0)return this.tensorMap.get(te.dataId).values=n.util.getTypedArrayFromDType(te.dtype,0),te;this.uploadToGPU(te.dataId),A.dispatch=((ut,Et)=>{const Tt=ut.limits.maxComputeWorkgroupsPerDimension,Dt=Et.dispatchLayout,Wt=Et.dispatch;if(Wt.every(cn=>cn<=Tt))return Wt;n.util.assert(Wt[0]>Tt&&Dt.y===void 0&&Dt.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let qt=Math.ceil(Math.sqrt(Wt[0]));return qt>Tt?(qt=Math.ceil(Math.cbrt(Wt[0])),n.util.assert(qt<=Tt,()=>"Total dispatch size exceeds WebGPU maximum."),[qt,qt,qt]):[qt,qt,1]})(this.device,A);let ie=[],he=[];if(!A.isFromPixels){ie.push({type:"float32",data:[NaN]}),he=R.concat(te).map(Tt=>Tt.shape);const ut="int32";he.map(Tt=>{ie.push({type:ut,data:Tt})});const Et=n.util.computeStrides(te.shape);if(ie.push({type:ut,data:Et}),A.size){const Tt=n.util.sizeFromShape(A.outputShape);ie.push({type:ut,data:[A.isVec4?Tt/4:Tt]})}}const xe=R.map((ut,Et)=>{if(ut.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(ut.dataId),{dtype:this.tensorMap.get(ut.dataId).dtype,shape:ut.shape,name:A.variableNames[Et]}}),_e=function(ut,Et,Tt,Dt){let Wt=ut.shaderKey;if(ut.isFromPixels)return Wt;const qt=Tt.map(_n=>_n.dtype).concat(Dt.dtype),cn=Tt.map(_n=>n.backend_util.getBroadcastDims(_n.shape,Dt.shape)),rn=Tt.map(_n=>n.util.arraysEqual(_n.shape,Dt.shape)).join("_"),yn=cn.map(_n=>_n.join("_")).join(";"),Fn=N(ut)?"flatDispatch":"";return Wt+="_"+(ut.workGroupSize?ut.workGroupSize.join(","):"")+Et.map(_n=>_n.length).join(",")+qt.join(",")+ut.variableNames.join(",")+yn+rn+Fn,Wt}(A,he,xe,te);let Ue;_e in this.pipelineCache?Ue=this.pipelineCache[_e]:(Ue=h(this.device,A,xe,te),this.pipelineCache[_e]=Ue),j&&(ie=[...ie,...j]);const nt=[this.tensorToBinding(te),...R.map(ut=>this.tensorToBinding(ut)),this.makeUniforms(ie)],it=this.device.createBindGroup({layout:Ue.getBindGroupLayout(0),entries:nt.map((ut,Et)=>({binding:Et,resource:ut}))});this.ensureCommandEncoderReady();const et=this.getComputePass(),dt=this.activeTimers!=null;return dt&&this.supportTimeQuery&&et.writeTimestamp(this.querySet,0),et.setPipeline(Ue),et.setBindGroup(0,it),et.dispatchWorkgroups(A.dispatch[0],A.dispatch[1],A.dispatch[2]),dt&&this.supportTimeQuery&&et.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,R.forEach(ut=>{this.commandQueueOwnedIds.add(ut.dataId)}),this.commandQueueOwnedIds.add(te.dataId),Object(n.env)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),dt&&this.activeTimers.push({name:A.constructor.name,query:this.getQueryTime(this.querySet)}),te}async getTimeFromQuerySet(A){const R=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),q=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(A,0,2,R,0),this.currentCommandEncoder.copyBufferToBuffer(R,0,q,0,16),this.submitQueue(),await q.mapAsync(GPUMapMode.READ);const j=new BigUint64Array(q.getMappedRange()),te=Number(j[1]-j[0]);return q.unmap(),this.bufferManager.releaseBuffer(q,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(R,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),te/1e6}shouldExecuteOnCPU(A,R=ne){return Object(n.env)().getBool("WEBGPU_CPU_FORWARD")&&A.every(q=>this.tensorMap.get(q.dataId).resourceInfo==null&&n.util.sizeFromShape(q.shape)<R)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ye;ge.nextDataId=0,P()&&Object(n.registerBackend)("webgpu",async()=>{Object(n.env)().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const G={powerPreference:Object(n.env)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},A=await navigator.gpu.requestAdapter(G),R=A.limits,q={},j=A.features.has("timestamp-query");q.requiredLimits={maxComputeWorkgroupStorageSize:R.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:R.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:R.maxStorageBufferBindingSize},j&&(q.requiredFeatures=["timestamp-query"]);const te=await A.requestDevice(q);return new ge(te)},3),function(G){G[G.MUL=0]="MUL",G[G.ADD=1]="ADD",G[G.ATAN2=2]="ATAN2",G[G.SUB=3]="SUB",G[G.DIV=4]="DIV",G[G.EQUAL=5]="EQUAL",G[G.GREATER=6]="GREATER",G[G.GREATER_EQUAL=7]="GREATER_EQUAL",G[G.LESS=8]="LESS",G[G.LESS_EQUAL=9]="LESS_EQUAL",G[G.LOGICAL_AND=10]="LOGICAL_AND",G[G.NOT_EQUAL=11]="NOT_EQUAL",G[G.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",G[G.INT_DIV=13]="INT_DIV",G[G.POW=14]="POW",G[G.PRELU=15]="PRELU",G[G.MAX=16]="MAX",G[G.MIN=17]="MIN",G[G.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",G[G.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"}(ye||(ye={}));const Ee=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,X=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${Ee}
  `,je=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${X}

  return resultTemp;
`,Be=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;
  let valueForNaN = uniforms.NAN;
  ${Ee}
  return resultTemp;
  `;function tt(G,A,R="uniforms.NAN"){const q=A?X:`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `;return A?`
    let valueForNaN = ${R};
    var resultTemp = vec4<f32>(${G}(a, b));
    `+q+`
    return resultTemp;
  `:q+`
    return ${G}(a, b);
  `}function ct(G,A){switch(G){case ye.MUL:return"return a * b;";case ye.ADD:return"return a + b;";case ye.ATAN2:return tt("atan2",A);case ye.SUB:return"return a - b;";case ye.DIV:return"return a / b;";case ye.EQUAL:return A?"return vec4<f32>(a == b);":"return f32(a == b);";case ye.GREATER:return A?"return vec4<f32>(a > b);":"return f32(a > b);";case ye.GREATER_EQUAL:return A?"return vec4<f32>(a >= b);":"return f32(a >= b);";case ye.LESS:return A?"return vec4<f32>(a < b);":"return f32(a < b);";case ye.LESS_EQUAL:return A?"return vec4<f32>(a <= b);":"return f32(a <= b);";case ye.LOGICAL_AND:return A?`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`:"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case ye.NOT_EQUAL:return A?je:`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`;case ye.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case ye.INT_DIV:return A?`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `:`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `;case ye.PRELU:return A?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `:"if (a < 0.0) { return b * a; }  return a;";case ye.MAX:return tt("max",A);case ye.MIN:return tt("min",A);case ye.POW:return A?Be:`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `;case ye.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case ye.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error(`BinaryType ${G} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Me;(function(G){G[G.ABS=0]="ABS",G[G.CEIL=1]="CEIL",G[G.COS=2]="COS",G[G.COSH=3]="COSH",G[G.ELU=4]="ELU",G[G.EXP=5]="EXP",G[G.EXPM1=6]="EXPM1",G[G.FLOOR=7]="FLOOR",G[G.IS_NAN=8]="IS_NAN",G[G.LINEAR=9]="LINEAR",G[G.LOG=10]="LOG",G[G.LOGICAL_NOT=11]="LOGICAL_NOT",G[G.NEG=12]="NEG",G[G.RELU=13]="RELU",G[G.RELU6=14]="RELU6",G[G.LEAKYRELU=15]="LEAKYRELU",G[G.RECIPROCAL=16]="RECIPROCAL",G[G.RSQRT=17]="RSQRT",G[G.SIN=18]="SIN",G[G.SINH=19]="SINH",G[G.SIGMOID=20]="SIGMOID",G[G.SQRT=21]="SQRT",G[G.SQUARE=22]="SQUARE",G[G.TANH=23]="TANH",G[G.TO_INT=24]="TO_INT"})(Me||(Me={}));function wt(G,A){switch(G){case Me.ABS:return"return abs(a);";case Me.COS:return"return cos(a);";case Me.COSH:return`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;case Me.CEIL:return"return ceil(a);";case Me.ELU:return A?`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`:"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Me.EXP:return"return exp(a);";case Me.EXPM1:return"return exp(a) - 1.0;";case Me.FLOOR:return"return floor(a);";case Me.IS_NAN:return"return f32(isnan(a));";case Me.LINEAR:return"return a;";case Me.LOG:return`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`;case Me.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Me.NEG:return"return -a;";case Me.LEAKYRELU:return A?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`:"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Me.RECIPROCAL:return"return 1.0 / a;";case Me.RELU:return A?`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`:"return select(a, 0.0, a < 0.0);";case Me.RELU6:return A?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Me.RSQRT:return"return 1.0/sqrt(a);";case Me.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Me.SIN:return"return sin(a);";case Me.SINH:return`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;case Me.SQRT:return"return sqrt(a);";case Me.SQUARE:return"return a * a;";case Me.TANH:return`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;case Me.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${G} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at=G=>{switch(G){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${G}-component is not supported.`)}};function Gt(G,A=!1,R=!1,q=3){if(G===null)return"";let j="";if(G==="linear")j=wt(Me.LINEAR);else if(G==="relu")j=wt(Me.RELU,R);else if(G==="elu")j=wt(Me.ELU,R);else if(G==="relu6")j=wt(Me.RELU6,R);else if(G==="prelu")j=ct(ye.PRELU,R);else if(G==="sigmoid")j=wt(Me.SIGMOID,R);else{if(G!=="leakyrelu")throw new Error(`Activation ${G} has not been implemented for the WebGPU backend.`);j=wt(Me.LEAKYRELU,R)}const te=at(R?4:1);let ie="";return ie=A?`
      fn activation(a : ${te}, coords : vec${q}<i32>) -> ${te} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${j}
      }`:`
      fn activation(a : ${te}, coords : vec${q}<i32>) -> ${te} {
        ${j}
      }`,ie}function Ht(G,A){return`
      ${G?"value = value + getBiasByOutputCoords(coords);":""}
      ${A?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(G,A,R,q,j=!1,te=!1,ie=!1,he=1){n.util.assert(R&&he===1||!R,()=>`transposeA ${R} is not compatible with component size ${he}`);const xe=`
      let batch = ${G?"0":"batchIn"};
      let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
      ${R?`value = A[(batch * batchASize + col * uniforms.aShape[2] + row) / ${he}];`:`value = A[(batch * batchASize + row * uniforms.aShape[2] + col) / ${he}];`}

    `;let _e;return _e=q===!1?`value = B[(batch * batchBSize + row * uniforms.bShape[2] + col) / ${he}];`:`value = B[(batch * batchBSize + col * uniforms.bShape[2] + row) / ${he}];`,`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${at(he)} {
    var value = ${at(he)}(0.0);
    let col = colIn * ${he};
    ${j&&ie?xe:`
    ${R?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${xe}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${at(he)} {
    let col = colIn * ${he};
    let batch = ${A?"0":"batchIn"};
    let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
    var value = ${at(he)}(0.0);
    ${_e}
    return value;
  }
  `}function mn(G,A,R,q,j,te,ie=!1,he=!1,xe=!1,_e=1){return`
  ${dn(R,q,j,te,ie,he,xe,_e)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${at(_e)}) {
    let col = colIn * ${_e};
    ${ie&&he?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ht(G,A)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}function Rn(G,A,R=!1,q=32,j=!1,te=32,ie=!1){const he=A[1]*G[1],xe=A[0]*G[0],_e=R?he:q,Ue=R?q:he,nt=_e/A[0],it=q/A[1];return n.util.assert((R&&nt===4&&G[1]===4||!R&&(nt===3||nt===4))&&_e%A[0]==0&&q%A[1]==0&&G[0]===4,()=>`If transposeA ${R} is true, innerElementSize ${nt} and workPerThread[1] ${G[1]} must be 4.
          Otherwise, innerElementSize ${nt} must be 3 or 4.
      tileAWidth ${_e} must be divisible by workGroupSize[0]${A[0]}. tileInner ${q} must be divisible by workGroupSize[1] ${A[1]}. ColPerThread ${G[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${nt}<f32>, ${_e/nt}>, ${Ue}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${xe/G[0]}>, ${q}>;

  const RowPerThread = ${G[1]};
  const ColPerThread = ${G[0]};
  const InnerElementSize = ${nt};
  const TileInner = ${q};

  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
            @builtin(workgroup_id) workgroupId: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;

    let localRow = i32(localId.y);
    let tileRow = ${ie?"0":"localRow * RowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${ie?"0":"i32(globalId.y) * RowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${j?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${he};

    let numTiles = ${j?`${Math.ceil(te/q)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
    var kStart = ${j?`i32(globalId.z) * ${te}`:"0"};

    var acc: array<vec4<f32>, RowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${it};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${(et=>et?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / InnerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / InnerElementSize + inputCol);
        `)(R)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${it}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];
            ${nt===3?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}

            ${((et,dt)=>et?`
        let ACached0 = mm_Asub[k * InnerElementSize][localRow];
        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];
        ${dt===3?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}
        for (var i = 0; i < RowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${dt===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < RowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${dt===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(R,nt)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}function ee(G,A,R=!1,q=32,j=!1,te=32){const ie=G[1]*A[1],he=G[0]*A[0],xe=R?ie:q,_e=R?q:ie;n.util.assert(_e%A[1]==0&&xe%A[0]==0&&q%A[1]==0,()=>`tileAHight ${_e} must be divisible by workGroupSize[1]${A[1]}, tileAWidth ${xe} must be divisible by workGroupSize[0]${A[0]}, tileInner ${q} must be divisible by workGroupSize[1]${A[1]}`);const Ue=_e/A[1],nt=xe/A[0],it=q/A[1];return`
    var<workgroup> mm_Asub : array<array<f32, ${xe}>, ${_e}>;
    var<workgroup> mm_Bsub : array<array<f32, ${he}>, ${q}>;
    const RowPerThread = ${G[1]};
    const ColPerThread = ${G[0]};
    const TileInner = ${q};

    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
              @builtin(workgroup_id) workgroupId: vec3<u32>) {
      localId = LocalId;
      globalId = GlobalId;
      numWorkgroups = NumWorkgroups;

      let tileRow = i32(localId.y) * RowPerThread;
      let tileCol = i32(localId.x) * ColPerThread;

      let globalRow = i32(globalId.y) * RowPerThread;
      let globalCol = i32(globalId.x) * ColPerThread;
      let batch = ${j?"0":"i32(globalId.z)"};
      let globalRowStart = i32(workgroupId.y) * ${ie};

      let numTiles = ${j?`${Math.ceil(te/q)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
      var kStart = ${j?`i32(globalId.z) * ${te}`:"0"};

      var acc : array<array<f32, ColPerThread>, RowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let tileRowA = i32(localId.y) * ${Ue};
      let tileColA = i32(localId.x) * ${nt};
      let tileRowB = i32(localId.y) * ${it};
      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${Ue}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${nt}; innerCol = innerCol + 1) {
            let inputRow = tileRowA + innerRow;
            let inputCol = tileColA + innerCol;
            ${(et=>et?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `)(R)}
          }
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${it}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalCol + innerCol);
          }
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ColPerThread>;
        for (var k = 0; k < TileInner; k = k + 1) {
          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            ${(et=>et?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(R)}
            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          mm_write(batch, globalRow + innerRow, globalCol + innerCol,
              acc[innerRow][innerCol]);
        }
      }
    }
  `}class se{constructor(A,R,q,j,te=!1,ie=!1,he=null,xe=null,_e=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=R,this.dispatchLayout={x:[2],y:[1],z:[0]};const Ue=te?A[1]:A[2];if(this.isVec4=(Ue%4==0&&!te||R[1]%4==0&&te)&&R[2]%4==0&&!ie,this.isVectorA=R[1]===1&&!te,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{const et=function(dt,ut,Et,Tt=!1){const Dt=[8,8,1],Wt=[4,4,1];return Tt||(dt<=8&&(Wt[1]=1),ut<=16&&Et<=16&&(Dt[0]=4)),{workGroupSize:Dt,elementsPerThread:Wt}}(R[1],Ue,R[2],te);this.workGroupSize=et.workGroupSize,this.elementsPerThread=et.elementsPerThread}this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);const nt=he!=null,it=_e!=null;nt&&this.variableNames.push("bias"),it&&this.variableNames.push("preluActivationWeights"),this.transposeA=te,this.transposeB=ie,this.addBias=nt,this.activation=xe,this.hasPreluActivationWeights=it,this.batchAEqualOne=q,this.batchBEqualOne=j,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(R[1],R[2],Ue),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${te}_${ie}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getShapeFit(A,R,q){const j=this.workGroupSize[1]*this.elementsPerThread[1],te=this.workGroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workGroupSize[0]:this.tileInner=te,[A%j==0,R%te==0,q%this.tileInner==0]}getUserCode(){return`
      ${Gt(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${mn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Rn(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?function(R,q=!1){return n.util.assert(R[1]===1&&R[2]===1,()=>`A linear work group size is required. But got ${R}.`),`
    const TileSize = ${4*R[0]};
    var<workgroup> mm_Asub : array<vec4<f32>, ${R[0]}>;

    ${f()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${(j=>j?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `)(q)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}(this.workGroupSize,this.transposeA):ee(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class we{constructor(A,R,q,j=!1,te=!1,ie=null,he=null,xe=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=A,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize);const _e=ie!=null,Ue=xe!=null;_e&&this.variableNames.push("bias"),Ue&&this.variableNames.push("preluActivationWeights"),this.transposeA=j,this.transposeB=te,this.addBias=_e,this.activation=he,this.hasPreluActivationWeights=Ue,this.batchAEqualOne=R,this.batchBEqualOne=q,this.shaderKey=`matMulReduce_${this.activation}_${j}_${te}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${Gt(this.activation,this.hasPreluActivationWeights)}
      ${mn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${f()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pt{constructor(A,R,q,j=!1,te=!1,ie=null,he=null,xe=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=q,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(q[2]/this.workGroupSize[0]),Math.ceil(q[1]/this.workGroupSize[1]),q[0]];const _e=ie!=null;_e&&this.variableNames.push("bias");const Ue=xe!=null;Ue&&this.variableNames.push("preluActivationWeights"),this.transposeA=j,this.transposeB=te,this.addBias=_e,this.activation=he,this.hasPreluActivationWeights=Ue,this.batchAEqualOne=A[0]===1,this.batchBEqualOne=R[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${j}_${te}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${Gt(this.activation,this.hasPreluActivationWeights)}
      ${mn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${function(A){const R=A[1],q=A[0],j=R>q?R:q;return`
  var<workgroup> mm_Asub : array<array<f32, ${j}>, ${R}>;
  var<workgroup> mm_Bsub : array<array<f32, ${q}>, ${j}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${f()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${j} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${j};
    globalRowB = globalRowB + ${j};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${j};
      globalRowB = globalRowB + ${j};

      for (var k = 0; k < ${j}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}(this.workGroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bt{constructor(A,R,q,j,te=!1,ie=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,n.util.assert(A[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=A,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(te&&this.outputShape[1]%4==0||!te&&R%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=U(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],R],this.workGroupSize,this.elementsPerThread),this.transposeA=te,this.transposeB=ie,this.batchAEqualOne=q,this.batchBEqualOne=j,this.shaderKey=`matMulSplitK_${te}_${ie}_${q}_${j}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const A=this.isVec4?4:1;return`
      ${dn(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,A)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${at(A)}) {
        let col = colIn * ${A};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${(q=>`
      for (var i = 0; i < ${q}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${q>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `)(A)}
        }
      }
      ${this.isVec4?Rn(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):ee(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class At{constructor(A,R=null,q=null,j=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=R!=null,this.hasPreluActivationWeights=j!=null,this.activation=q,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${q}`}getUserCode(){return`
    ${Gt(this.activation,this.hasPreluActivationWeights)}
    ${f("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ht(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $e{constructor(A){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${f("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(G){const{backend:A,attrs:R}=G,{shape:q,value:j}=R;let{dtype:te}=R;if(te=te||n.util.inferDtype(j),te==="string"){const ie=n.util.getArrayFromDType(te,n.util.sizeFromShape(q));return ie.fill(j),A.makeTensorInfo(q,te,ie)}{const ie=new $e(q),he=[{type:"float32",data:[j]}];return A.runWebGPUProgram(ie,[],te,he)}}const Pt={kernelName:n.Fill,backendName:"webgpu",kernelFunc:ht};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot(G){const{inputs:A,attrs:R}=G,{x:q}=A,{shape:j}=R,te=n.util.sizeFromShape(q.shape),ie=n.util.inferFromImplicitShape(j,te),he=n.util.sizeFromShape(ie);return n.util.assert(te===he,()=>`The new shape (${ie}) has ${he} elements and the old shape (${q.shape}) has ${te} elements. The new shape and old shape must have the same number of elements.`),G.backend.incRef(q.dataId),{dataId:q.dataId,shape:ie,dtype:q.dtype}}const xn={kernelName:n.Reshape,backendName:"webgpu",kernelFunc:Ot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn({a:G,b:A,transposeA:R,transposeB:q,backend:j,bias:te=null,preluActivationWeights:ie=null,leakyreluAlpha:he=0,activation:xe=null}){const _e=G.shape.length,Ue=A.shape.length,nt=R?G.shape[_e-2]:G.shape[_e-1],it=q?A.shape[Ue-1]:A.shape[Ue-2],et=R?G.shape[_e-1]:G.shape[_e-2],dt=q?A.shape[Ue-2]:A.shape[Ue-1],ut=G.shape.slice(0,-2),Et=A.shape.slice(0,-2),Tt=n.util.sizeFromShape(ut),Dt=n.util.sizeFromShape(Et),Wt=n.broadcast_util.assertAndGetBroadcastShape(G.shape.slice(0,-2),A.shape.slice(0,-2)).concat([et,dt]);n.util.assert(nt===it,()=>`Error in matMul: inner shapes (${nt}) and (${it}) of Tensors with shapes ${G.shape} and ${A.shape} and transposeA=${R} and transposeB=${q} must match.`);const qt=R?[Tt,nt,et]:[Tt,et,nt],cn=q?[Dt,dt,it]:[Dt,it,dt],rn=Ot({inputs:{x:G},backend:j,attrs:{shape:qt}}),yn=Ot({inputs:{x:A},backend:j,attrs:{shape:cn}}),Fn=[rn,yn],_n=Math.max(Tt,Dt),ss=Tt===1,zn=Dt===1,Kn=[rn,yn],us=[{type:"int32",data:[et]},{type:"int32",data:[dt]},{type:"int32",data:[nt]}];let ps,es;const ks=[_n,et,dt];let Ks=Object(n.env)().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(Ks<0&&(Ks=et*dt<=128?oe.MatMulReduceProgram:_n===1&&et<=128&&dt<=48&&it>=2e3?oe.MatMulSplitKProgram:et<=16&&(dt<=512||it>=2*dt)||dt<=16&&(et<=512||nt>=2*et)?oe.MatMulSmallOutputSizeProgram:oe.MatMulPackedProgram),Ks){case oe.MatMulReduceProgram:ps=new we(ks,ss,zn,R,q,te,xe,ie);break;case oe.MatMulSplitKProgram:if(es=ht({backend:j,attrs:{shape:ks,value:0,dtype:G.dtype}}),ps=new bt(ks,it,ss,zn,R,q),te||xe){es=j.runWebGPUProgram(ps,Kn,G.dtype,us,es);const or=new At(es.shape,te,xe,ie);let _r=null;const yr=[es];te&&yr.push(te),ie&&yr.push(ie),xe==="leakyrelu"&&(_r=[{type:"float32",data:[he]}],or.uniforms+=" alpha : f32,");const Ga=j.runWebGPUProgram(or,yr,es.dtype,_r);Fn.push(es);const ma=Ot({inputs:{x:Ga},backend:j,attrs:{shape:Wt}});Fn.push(Ga);for(const Ha of Fn)j.disposeData(Ha.dataId);return ma}break;case oe.MatMulSmallOutputSizeProgram:ps=new pt(qt,cn,ks,R,q,te,xe,ie);break;case oe.MatMulPackedProgram:ps=new se(qt,ks,ss,zn,R,q,te,xe,ie);break;default:throw new Error(`Unsupported MatMulProgramType ${Ks}.`)}te&&Kn.push(te),ie&&Kn.push(ie),xe==="leakyrelu"&&(us.push({type:"float32",data:[he]}),ps.uniforms+=" alpha : f32,"),es=j.runWebGPUProgram(ps,Kn,G.dtype,us,es);const sa=Ot({inputs:{x:es},backend:j,attrs:{shape:Wt}});Fn.push(es);for(const or of Fn)j.disposeData(or.dataId);return sa}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pe={kernelName:n._FusedMatMul,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{a:j,b:te,bias:ie,preluActivationWeights:he}=A,{transposeA:xe,transposeB:_e,activation:Ue,leakyreluAlpha:nt}=q;return Dn({a:j,b:te,transposeA:xe,transposeB:_e,backend:R,bias:ie,preluActivationWeights:he,leakyreluAlpha:nt,activation:Ue})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class be{constructor(A,R,q){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=n.backend_util.assertAndGetBroadcastShape(R,q),this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${A}`,this.op=A}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${ct(this.op,!1)}
      }

      ${f("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qe{constructor(A,R,q){this.size=!0,this.variableNames=["A","B"],this.outputShape=n.backend_util.assertAndGetBroadcastShape(R,q),this.dispatchLayout=V(this.outputShape),this.op=A,this.useSharedMemoryWithA=R.length===1&&q.length>1&&R[0]<1024,this.useSharedMemoryWithB=q.length===1&&R.length>1&&q[0]<1024,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?q[0]:R[0],this.shaderKey=`binary_${this.type}_${A}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4):(n.util.arraysEqual(R,q)&&n.util.sizeFromShape(R)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${A}`,this.workGroupSize=[128,1,1]),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let A;if(this.type==="shared"){const R=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",q=this.useSharedMemoryWithB?`let a = getAByOutputCoords(coords);
          let b = sharedBuf[${R}];`:`let a = sharedBuf[${R}];
          let b = getBByOutputCoords(coords);`;A=`
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${ct(this.op,this.isVec4)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${f("index")} {
          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;
            if(flatIndex < uniforms.size) {
              let coords = getCoordsFromIndex(flatIndex);

              ${q}
              setOutputAtIndex(flatIndex, binaryOperation(a, b));
            }
          }
        }
        `}else{const R=this.type==="vec4"?"vec4<f32>":"f32";A=`
       fn binaryOperation(a : ${R}, b : ${R}) -> ${R} {
         ${ct(this.op,this.isVec4)}
       }
       ${f("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `}return A}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(G){const{inputs:A}=G,{x:R}=A;return G.backend.incRef(R.dataId),{dataId:R.dataId,shape:R.shape,dtype:R.dtype}}const Ws={kernelName:n.Identity,backendName:"webgpu",kernelFunc:Un};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(G){const{inputs:A,backend:R}=G,{real:q,imag:j}=A,te=R.makeTensorInfo(q.shape,"complex64"),ie=R.tensorMap.get(te.dataId),he=Un({inputs:{x:q},backend:R}),xe=Un({inputs:{x:j},backend:R});return ie.complexTensorInfos={real:he,imag:xe},te}const As={kernelName:n.Complex,backendName:"webgpu",kernelFunc:Gs};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xs{constructor(A,R){this.variableNames=["A"],this.size=!0,this.workGroupSize=[128,1,1],this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=R,this.shaderKey=`unary_${R}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${wt(this.op,!1)}
      }
      ${f("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ds({opType:G,cpuKernelImpl:A,dtype:R}){return({inputs:q,backend:j})=>{const{x:te}=q,ie=j,he=R||te.dtype;if(ie.shouldExecuteOnCPU([te])&&A!=null){const _e=ie.tensorMap.get(te.dataId),Ue=A(_e.values,he);return ie.makeTensorInfo(te.shape,he,Ue)}const xe=new xs(te.shape,G);return ie.runWebGPUProgram(xe,[te],he)}}function Ys({opType:G,cpuKernelImpl:A,supportsComplex:R=!1,dtype:q}){return({inputs:j,backend:te})=>{const{a:ie,b:he}=j,xe=te;if(R&&ie.dtype==="complex64"){const nt=xe.tensorMap.get(ie.dataId),it=xe.tensorMap.get(he.dataId);let et,dt;if(G!==ye.MUL)[et,dt]=[[nt.complexTensorInfos.real,it.complexTensorInfos.real],[nt.complexTensorInfos.imag,it.complexTensorInfos.imag]].map(Et=>{const[Tt,Dt]=Et,Wt={dataId:Tt.dataId,dtype:Tt.dtype,shape:ie.shape},qt={dataId:Dt.dataId,dtype:Dt.dtype,shape:he.shape},cn=new Qe(G,ie.shape,he.shape);return xe.runWebGPUProgram(cn,[Wt,qt],Object(n.upcastType)(Tt.dtype,Dt.dtype))});else{const Et=new be(ye.COMPLEX_MULTIPLY_REAL,ie.shape,he.shape),Tt=new be(ye.COMPLEX_MULTIPLY_IMAG,ie.shape,he.shape),Dt=[{dataId:nt.complexTensorInfos.real.dataId,dtype:nt.complexTensorInfos.real.dtype,shape:ie.shape},{dataId:nt.complexTensorInfos.imag.dataId,dtype:nt.complexTensorInfos.imag.dtype,shape:ie.shape},{dataId:it.complexTensorInfos.real.dataId,dtype:it.complexTensorInfos.real.dtype,shape:he.shape},{dataId:it.complexTensorInfos.imag.dataId,dtype:it.complexTensorInfos.imag.dtype,shape:he.shape}];et=xe.runWebGPUProgram(Et,Dt,"float32"),dt=xe.runWebGPUProgram(Tt,Dt,"float32")}const ut=Gs({inputs:{real:et,imag:dt},backend:xe});return xe.disposeData(et.dataId),xe.disposeData(dt.dataId),ut}const _e=q||Object(n.upcastType)(ie.dtype,he.dtype);if((ie.dtype==="string"||he.dtype==="string"||xe.shouldExecuteOnCPU([ie,he]))&&A!=null){const nt=xe.tensorMap.get(ie.dataId).values,it=xe.tensorMap.get(he.dataId).values,et=ie.dtype==="string"?n.backend_util.fromUint8ToStringArray(nt):nt,dt=ie.dtype==="string"?n.backend_util.fromUint8ToStringArray(it):it,[ut,Et]=A(ie.shape,he.shape,et,dt,_e);return xe.makeTensorInfo(Et,_e,ut)}const Ue=new Qe(G,ie.shape,he.shape);return xe.runWebGPUProgram(Ue,[ie,he],_e)}}var pn=t(28);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Nn,castImpl:ts,ceilImpl:$s,concatImpl:Ns,equalImpl:ys,expImpl:Vs,expm1Impl:Us,floorImpl:jt,gatherNdImpl:re,gatherV2Impl:de,greaterEqualImpl:ot,greaterImpl:Ct,lessEqualImpl:Yt,lessImpl:on,logImpl:tn,maxImpl:bn,maximumImpl:On,minimumImpl:Mn,multiplyImpl:wn,negImpl:gs,notEqualImpl:Hs,prodImpl:xr,rangeImpl:Ir,rsqrtImpl:qs,scatterImpl:ta,simpleAbsImpl:pa,sliceImpl:rr,stridedSliceImpl:eo,stringNGramsImpl:Qs,subImpl:mr,tileImpl:$r,topKImpl:ia,transposeImpl:Pr,uniqueImpl:Cr}=pn,Ba=ds({opType:Me.ABS,cpuKernelImpl:pa}),za={kernelName:n.Abs,backendName:"webgpu",kernelFunc:Ba},to=Ys({opType:ye.ADD,cpuKernelImpl:Nn,supportsComplex:!0}),Wo={kernelName:n.Add,backendName:"webgpu",kernelFunc:to};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class si{constructor(A){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A[0],this.variableNames=A.map((R,q)=>`T${q}`),this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const A=[];this.variableNames.forEach(q=>{A.push(`let v${q} = get${q}ByOutputCoords(coords);`)});const R=this.variableNames.map(q=>`v${q}`).join(" + ");return`
      ${f("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${A.join(`
        `)}
            setOutputAtIndex(flatIndex, ${R});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo={kernelName:n.AddN,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R}=G,q=A;if(q.length===1)return Un({inputs:{x:q[0]},backend:R});const j=q.map(he=>he.dtype).reduce((he,xe)=>Object(n.upcastType)(he,xe)),te=q.map(he=>he.shape),ie=new si(te);return R.runWebGPUProgram(ie,q,j)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class no{constructor(A,R,q){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const j=[R];this.op=q==="min"?"<":">";const[te,ie]=n.backend_util.computeOutAndReduceShapes(A,j);this.outputShape=te.length===0?[1]:te,this.dispatchLayout=V(this.outputShape),n.util.sizeFromShape(ie)<32||n.util.sizeFromShape(te)>1e3?(this.type="plain",this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=U(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=A,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const A=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${p(this.inputShape.length-1)}`,R=()=>{let q="";if(this.outputShape.length===1)this.inputShape.length!==1&&(q+="outputCoords,");else for(let j=0;j<this.outputShape.length;j++)q+=`outputCoords.${p(j)},`;return q};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `}

      ${f("index")} {
        let outputIndex = index / i32(workGroupSizeX);
        let reduceLength = ${A()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = getX(${R()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${f("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${R()} 0);
          let reduceLength = ${A()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${R()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ta{constructor(A,R){this.variableNames=["A"],this.workGroupSize=[16,16,1];const q=new Array(A.length);for(let j=0;j<q.length;j++)q[j]=A[R[j]];this.outputShape=q,this.dispatchLayout={x:[0],y:[1]},this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      const TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,
                @builtin(workgroup_id) workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = A[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mo{constructor(A,R){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;const q=new Array(A.length);for(let j=0;j<q.length;j++)q[j]=A[R[j]];this.outputShape=q,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=R,this.shaderKey=`transpose_${R}`}getUserCode(){const A=l(this.outputShape.length),R=function(q){const j=q.length;if(j>6)throw Error(`Transpose for rank ${j} is not yet supported`);const te=new Array(j);for(let ie=0;ie<q.length;ie++)te[q[ie]]=`resRC.${p(ie)}`;return te.join()}(this.newDim);return`
      ${f("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${A}(${R}), uniforms.aShape)]);
          }
        }
      }
    `}}function Ar(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{perm:te}=q,ie=R,he=j.shape.length,xe=new Array(he);for(let Ue=0;Ue<xe.length;Ue++)xe[Ue]=j.shape[te[Ue]];if(R.shouldExecuteOnCPU([j])){const Ue=ie.tensorMap.get(j.dataId).values,nt=Pr(Ue,j.shape,j.dtype,te,xe);return R.makeTensorInfo(xe,j.dtype,nt)}if(j.shape.length===2&&n.util.arraysEqual(te,[1,0])){const Ue=new Ta(j.shape,te);return ie.runWebGPUProgram(Ue,[j],j.dtype)}const _e=new mo(j.shape,te);return ie.runWebGPUProgram(_e,[j],j.dtype)}const Na={kernelName:n.Transpose,backendName:"webgpu",kernelFunc:Ar};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ea={kernelName:n.ArgMax,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te}=q;let ie=n.util.parseAxisParam(te,j.shape);const he=n.backend_util.getAxesPermutation(ie,j.shape.length);let xe=j;const _e=[];he!=null&&(xe=Ar({inputs:{x:j},backend:R,attrs:{perm:he}}),_e.push(xe),ie=n.backend_util.getInnerMostAxes(ie.length,xe.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMax",[ie[0]],xe.shape.length);const Ue=new no(xe.shape,ie[0],"max"),nt=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],it=R.runWebGPUProgram(Ue,[xe],"int32",nt);return _e.forEach(et=>R.disposeData(et.dataId)),it}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vo={kernelName:n.ArgMin,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te}=q;let ie=n.util.parseAxisParam(te,j.shape);const he=n.backend_util.getAxesPermutation(ie,j.shape.length);let xe=j;const _e=[];he!=null&&(xe=Ar({inputs:{x:j},backend:R,attrs:{perm:he}}),_e.push(xe),ie=n.backend_util.getInnerMostAxes(ie.length,xe.shape.length)),n.backend_util.assertAxesAreInnerMostDims("argMin",[ie[0]],xe.shape.length);const Ue=new no(xe.shape,ie[0],"min"),nt=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],it=R.runWebGPUProgram(Ue,[xe],"int32",nt);return _e.forEach(et=>R.disposeData(et.dataId)),it}},So=Ys({opType:ye.ATAN2}),so={kernelName:n.Atan2,backendName:"webgpu",kernelFunc:So};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zs{constructor(A,R){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=A.outShape,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${R}`,this.poolType=R}getUserCode(){let A="resultValue = max(value, resultValue);";this.poolType==="avg"&&(A="resultValue = resultValue + value; count = count + 1.0;");let R="resultValue";return this.poolType==="avg"&&(R="resultValue / count"),`
      ${f("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${A}
            }
          }

          setOutputAtIndex(index, ${R});
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kr{constructor(A){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=A.outShape,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ra{constructor(A,R){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[A.batchSize,A.inSize];const[q]=n.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=q.length===0?[1]:q,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=R,this.shaderKey=`reduce_${R}`}getUserCode(){let A="",R="0.0";this.reduceType==="min"||this.reduceType==="max"?(A=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,R="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?A=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(A=" bestValue = bestValue * candidate; ",R="1.0");const q=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${f("index")} {
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${R};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${A}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${A}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${q}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fa(G,A,R,q,j){const te=G.shape.length,ie=[],he=n.util.parseAxisParam(A,G.shape);let xe=he;const _e=n.backend_util.getAxesPermutation(xe,te);let Ue=G;_e!=null&&(Ue=Ar({inputs:{x:G},attrs:{perm:_e},backend:j}),xe=n.backend_util.getInnerMostAxes(xe.length,te),ie.push(Ue)),n.backend_util.assertAxesAreInnerMostDims(q,xe,te);const[nt,it]=n.backend_util.computeOutAndReduceShapes(Ue.shape,xe);let et,dt=nt;if(R&&(dt=n.backend_util.expandShapeToKeepDim(nt,he)),q!=="max"&&q!=="prod"||!j.shouldExecuteOnCPU([Ue])){const ut=n.util.sizeFromShape(it),Et={windowSize:ut,inSize:ut,batchSize:n.util.sizeFromShape(Ue.shape)/ut,outSize:1},Tt=q==="mean"?"float32":Object(n.sumOutType)(G.dtype),Dt=[{type:"int32",data:[ut]}],Wt=new Ra(Et,q),qt=j.runWebGPUProgram(Wt,[Ue],Tt,Dt);ie.push(qt),et=Ot({inputs:{x:qt},attrs:{shape:dt},backend:j})}else{const ut=j.tensorMap.get(Ue.dataId).values;switch(q){case"max":const Et=bn(ut,n.util.sizeFromShape(it),dt,G.dtype);et=j.makeTensorInfo(dt,G.dtype,Et);break;case"prod":const{outVals:Tt,outShape:Dt,outDtype:Wt}=xr(Ue.shape,Ue.dtype,ut,xe);et=j.makeTensorInfo(Dt,Wt,Tt);break;default:throw new Error(`${q} CPU implementation is not yet supported.`)}}return ie.forEach(ut=>j.disposeData(ut.dataId)),et}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function na(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{reductionIndices:te,keepDims:ie}=q;return fa(j,te,ie,"max",R)}const $o={kernelName:n.Max,backendName:"webgpu",kernelFunc:na};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{keepDims:te,axis:ie}=q;return fa(j,ie,te,"mean",R)}const It={kernelName:n.Mean,backendName:"webgpu",kernelFunc:We};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ut(G,A,R,q){if(A.filterWidth===1&&A.filterHeight===1&&n.util.arraysEqual(A.inShape,A.outShape))return Un({inputs:{x:G},backend:q});if(A.filterWidth===A.inWidth&&A.filterHeight===A.inHeight&&A.batchSize===1&&A.padInfo.type==="VALID"){const ie=G.shape.length,he=Ot({inputs:{x:G},backend:q,attrs:{shape:[G.shape[ie-3]*G.shape[ie-2],G.shape[ie-1]]}});let xe;R==="avg"?xe=We({inputs:{x:he},backend:q,attrs:{axis:0,keepDims:!1}}):(n.util.assert(R==="max",()=>`Invalid pool type ${R}`),xe=na({inputs:{x:he},backend:q,attrs:{reductionIndices:0,keepDims:!1}}));const _e=Ot({inputs:{x:xe},backend:q,attrs:{shape:A.outShape}});return q.disposeData(he.dataId),q.disposeData(xe.dataId),_e}let j;const te=[{type:"int32",data:[A.strideHeight,A.strideWidth]}];return A.filterHeight===1&&A.filterWidth===1?j=new Kr(A):(R==="avg"?j=new Zs(A,"avg"):(n.util.assert(R==="max",()=>`Invalid pool type ${R}`),j=new Zs(A,"max")),te.push({type:"int32",data:[A.padInfo.top,A.padInfo.left]},{type:"int32",data:[A.dilationHeight,A.dilationWidth]},{type:"int32",data:[A.inHeight,A.inWidth]},{type:"int32",data:[A.effectiveFilterHeight,A.effectiveFilterWidth]})),q.runWebGPUProgram(j,[G],G.dtype,te)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sn={kernelName:n.AvgPool,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{filterSize:te,strides:ie,pad:he,dimRoundingMode:xe}=q;return Ut(j,n.backend_util.computePool2DInfo(j.shape,te,ie,1,he,xe),"avg",R)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vn={kernelName:n.BatchMatMul,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{a:j,b:te}=A,{transposeA:ie,transposeB:he}=q;return Dn({a:j,b:te,transposeA:ie,transposeB:he,backend:R})}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fn{constructor(A,R){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=R,this.rank=R.length,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=A,this.uniforms=`start : ${l(A.length)}, `,this.shaderKey="slice"}getUserCode(){const A=l(this.rank),R=function(j){if(j===1)return"sourceLoc";if(j<=6)return Vn.slice(0,j).map(te=>`sourceLoc.${te}`).join(",");throw Error(`Slicing for rank ${j} is not yet supported`)}(this.rank);let q;return q=this.start.length===1?this.outputShape.map((j,te)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((j,te)=>`sourceLoc.${Vn[te]} = uniforms.start.${p(te)} + coords.${Vn[te]};`),`
      ${f("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${A};
          let coords = getCoordsFromIndex(index);
          ${q.join(`
`)}
          setOutputAtIndex(index, getSource(${R}));
        }
      }
    `}}const Vn=["x","y","z","w","u","v"];function hs(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{begin:te,size:ie}=q,[he,xe]=n.slice_util.parseSliceParams(j,te,ie);if(n.slice_util.assertParamsValid(j,he,xe),R.shouldExecuteOnCPU([j])||j.dtype==="string"){const nt=R.tensorMap.get(j.dataId),it=rr(nt.values,he,xe,j.shape,j.dtype);return R.makeTensorInfo(xe,j.dtype,it)}if(n.util.sizeFromShape(xe)===0)return R.makeTensorInfo(xe,j.dtype,[]);const _e=new fn(he,xe),Ue=[{type:"int32",data:he}];return R.runWebGPUProgram(_e,[j],j.dtype,Ue)}const Es={kernelName:n.Slice,backendName:"webgpu",kernelFunc:hs},dr={kernelName:n.BatchToSpaceND,backendName:"webgpu",kernelFunc:G=>{const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{blockShape:te,crops:ie}=q;n.util.assert(j.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const he=te.reduce((Dt,Wt)=>Dt*Wt),xe=n.backend_util.getReshaped(j.shape,te,he),_e=n.backend_util.getPermuted(xe.length,te.length),Ue=n.backend_util.getReshapedPermuted(j.shape,te,he),nt=n.backend_util.getSliceBeginCoords(ie,te.length),it=n.backend_util.getSliceSize(Ue,ie,te.length),et=[],dt=Ot({inputs:{x:j},backend:R,attrs:{shape:xe}}),ut=Ar({inputs:{x:dt},backend:R,attrs:{perm:_e}}),Et=Ot({inputs:{x:ut},backend:R,attrs:{shape:Ue}}),Tt=hs({inputs:{x:Et},backend:R,attrs:{begin:nt,size:it}});return et.push(dt),et.push(ut),et.push(Et),et.forEach(Dt=>R.disposeData(Dt.dataId)),Tt}},Js=Ys({opType:ye.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Hs}),ga={kernelName:n.NotEqual,backendName:"webgpu",kernelFunc:Js};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(G){const{inputs:A,backend:R}=G,{input:q}=A;return Un({inputs:{x:R.tensorMap.get(q.dataId).complexTensorInfos.real},backend:R})}const Or={kernelName:n.Real,backendName:"webgpu",kernelFunc:ur};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro={kernelName:n.Cast,backendName:"webgpu",kernelFunc:function G(A){const{inputs:R,backend:q,attrs:j}=A,{x:te}=R,{dtype:ie}=j;if(ie==="complex64"){if(te.dtype==="complex64")return Un({inputs:{x:te},backend:q});const he=n.zeros(te.shape),xe=G({inputs:{x:te},backend:q,attrs:{dtype:"float32"}}),_e=Gs({inputs:{real:xe,imag:he},backend:q});return he.dispose(),q.disposeData(xe.dataId),_e}if(te.dtype==="complex64"){const he=ur({inputs:{input:te},backend:q}),xe=G({inputs:{x:he},backend:q,attrs:{dtype:ie}});return q.disposeData(he.dataId),xe}if(!n.util.hasEncodingLoss(te.dtype,ie)){const he=Un({inputs:{x:te},backend:q});return{dataId:he.dataId,shape:he.shape,dtype:ie}}if(q.shouldExecuteOnCPU([te])){const he=q.tensorMap.get(te.dataId).values,[xe,_e,Ue]=ts(he,te.shape,te.dtype,ie);return q.makeTensorInfo(xe,_e,Ue)}if(ie==="int32")return function(he,xe){const _e=new xs(he.shape,Me.TO_INT),Ue=xe.runWebGPUProgram(_e,[he],"int32");return{dataId:Ue.dataId,shape:Ue.shape,dtype:Ue.dtype}}(te,q);if(ie==="bool"){const he=q.makeTensorInfo([],"bool",n.util.getTypedArrayFromDType("bool",1)),xe=Js({inputs:{a:te,b:he},backend:q});return q.disposeData(he.dataId),xe}throw new Error(`Error in Cast: failed to cast ${te.dtype} to ${ie}`)}},Wa=ds({opType:Me.CEIL,cpuKernelImpl:$s}),Va={kernelName:n.Ceil,backendName:"webgpu",kernelFunc:Wa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qi{constructor(A){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${f("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _i{constructor(A){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${f("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri={kernelName:n.ClipByValue,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{clipValueMin:te,clipValueMax:ie}=q;let he;const xe=[{type:"float32",data:[te]},{type:"float32",data:[ie]}];return he=n.util.sizeFromShape(j.shape)%4==0?new Qi(j.shape):new _i(j.shape),R.runWebGPUProgram(he,[j],j.dtype,xe)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $u{constructor(A){this.uniforms="",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n.backend_util.computeOutShape(A,1),this.variableNames=A.map((R,q)=>`T${q}`),this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=A.length-1;for(let R=0;R<this.offsetLength;R++)this.uniforms+=`offset${R} : i32,`;this.shaderKey="concat"}getUserCode(){const A=[];if(this.offsetLength>0){A.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let j=1;j<this.offsetLength;j++)A.push(`else if (yC < uniforms.offset${[j]}){ setOutputAtCoords(coords.x, coords.y, getT${j}(yR, yC - uniforms.offset${j-1})); }`);const R=this.offsetLength,q=this.offsetLength-1;A.push(`else { setOutputAtCoords(coords.x, coords.y, getT${R}(yR, yC - uniforms.offset${q})); }`)}else A.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${f("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${A.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function go(G){const{inputs:A,backend:R}=G,{input:q}=A;return Un({inputs:{x:R.tensorMap.get(q.dataId).complexTensorInfos.imag},backend:R})}const bo={kernelName:n.Imag,backendName:"webgpu",kernelFunc:go};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(G,A,R){const q=G[0].dtype;if(q==="complex64"){const dt=G.map(Wt=>ur({inputs:{input:Wt},backend:R})),ut=G.map(Wt=>go({inputs:{input:Wt},backend:R})),Et=Ua(dt,A,R),Tt=Ua(ut,A,R),Dt=Gs({inputs:{real:Et,imag:Tt},backend:R});return dt.forEach(Wt=>R.disposeData(Wt.dataId)),ut.forEach(Wt=>R.disposeData(Wt.dataId)),R.disposeData(Et.dataId),R.disposeData(Tt.dataId),Dt}let j=R.shouldExecuteOnCPU(G);if(q==="string"&&(j=!0),j){const dt=G.map(cn=>{const rn=n.util.sizeFromShape(cn.shape.slice(A));return Ot({inputs:{x:cn},backend:R,attrs:{shape:[-1,rn]}})}),ut=dt.map(cn=>({vals:R.readSync(cn.dataId),shape:cn.shape})),Et=n.backend_util.computeOutShape(dt.map(cn=>cn.shape),1),Tt=dt[0].shape[0]===1,Dt=Ns(ut,Et,q,Tt),Wt=n.backend_util.computeOutShape(G.map(cn=>cn.shape),A),qt=R.makeTensorInfo(Wt,q,Dt);return dt.forEach(cn=>R.disposeData(cn.dataId)),qt}const te=R.device.limits.maxStorageBuffersPerShaderStage-1;if(G.length>te){const dt=[];for(let Et=0;Et<G.length;Et+=te){const Tt=G.slice(Et,Et+te);dt.push(Ua(Tt,A,R))}const ut=Ua(dt,A,R);for(const Et of dt)R.disposeData(Et.dataId);return ut}const{tensors2D:ie,outShape:he}=function(dt,ut,Et){const Tt=n.backend_util.computeOutShape(dt.map(Dt=>Dt.shape),ut);return{tensors2D:dt.map(Dt=>Ot({inputs:{x:Dt},backend:Et,attrs:{shape:[n.util.sizeFromShape(Dt.shape.slice(0,ut)),n.util.sizeFromShape(Dt.shape.slice(ut))]}})),outShape:Tt}}(G,A,R),xe=ie.map(dt=>dt.shape),_e=new $u(xe),Ue=[],nt=new Array(xe.length-1);if(nt.length>0){nt[0]=xe[0][1],Ue.push({type:"int32",data:[nt[0]]});for(let dt=1;dt<nt.length;dt++)nt[dt]=nt[dt-1]+xe[dt][1],Ue.push({type:"int32",data:[nt[dt]]})}const it=R.runWebGPUProgram(_e,ie,ie[0].dtype,Ue);ie.forEach(dt=>R.disposeData(dt.dataId));const et=Ot({inputs:{x:it},backend:R,attrs:{shape:he}});return R.disposeData(it.dataId),et}function Wr(G){const{inputs:A,backend:R,attrs:q}=G,{axis:j}=q,te=n.util.parseAxisParam(j,A[0].shape)[0],ie=n.backend_util.computeOutShape(A.map(_e=>_e.shape),te);if(n.util.sizeFromShape(ie)===0)return R.makeTensorInfo(ie,A[0].dtype,[]);const he=A.filter(_e=>n.util.sizeFromShape(_e.shape)>0);if(he.length===1)return Un({inputs:{x:he[0]},backend:R});const xe=he.map(_e=>_e.shape);return n.backend_util.assertParamsConsistent(xe,te),Ua(he,te,R)}const Ji={kernelName:n.Concat,backendName:"webgpu",kernelFunc:Wr};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xr{constructor(A,R,q,j,te=!1,ie=null,he=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=A.outShape,this.isChannelsLast=A.dataFormat==="channelsLast",this.isVec4=((A.inChannels%4==0||A.inChannels%3==0)&&this.isChannelsLast||A.outWidth%4==0&&!this.isChannelsLast)&&A.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=L(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Y(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&A.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),te&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),he&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],te&&this.variableNames.push("bias"),he&&this.variableNames.push("preluActivationWeights")),this.addBias=te,this.activation=ie,this.hasPreluActivationWeights=he,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=R%this.tileAOuter==0,this.fitBOuter=q%this.tileBOuter==0,this.fitInner=j%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}`}getUserCode(){const A=this.isVec4?Rn(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):ee(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner),R=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${function(q,j,te,ie,he=!1,xe=null,_e=!1,Ue=4,nt=4,it=4){const et=q?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,dt=q?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,ut=q?"uniforms.xShape[1]":"uniforms.xShape[2]",Et=q?"uniforms.xShape[2]":"uniforms.xShape[3]",Tt=q?"row":"col",Dt=q?"col":"row",Wt=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${q?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${Tt} / outWidth;
      let outCol = ${Tt} % outWidth;

      let WRow = ${Dt} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${Dt} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${Dt} % inChannels;
      var resData = ${at(Ue)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${ut} && xCol >= 0 && xCol < ${Et}) {
        ${et}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${(_n=>{switch(_n){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${_n} is not supported.`)}})(Ue)}
      }
      return resData;`,qt=q?j&&ie?`
      let col = colIn * ${Ue};
      ${Wt}`:`
      let col = colIn * ${Ue};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${Wt}
      }
      return ${at(Ue)}(0.0);`:ie&&te?`
      let col = colIn * ${Ue};
      ${Wt}`:`
      let col = colIn * ${Ue};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${Wt}
      }
      return ${at(Ue)}(0.0);`,cn=`${(_n=>{switch(_n){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${_n} is not supported.`)}})(nt)}`,rn=at(it),yn=at(q?Ue:nt),Fn=at(q?nt:Ue);return`
      ${Gt(xe,_e,it===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${yn} {
        ${q?qt:cn}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Fn} {
        ${q?cn:qt}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${rn}) {
        let col = colIn * ${it};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${q?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${dt}
        ${Ht(he,xe)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,R[0],R[1],R[2])}
    ${A}
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(G,A){const R=G.length;return R>=3?A?[...G.slice(0,-3),G[R-3]*G[R-2],G[R-1]]:[...G.slice(0,-3),G[R-3],G[R-2]*G[R-1]]:!A&&R===1&&G[0]>1?[G[0],1]:null}function To({x:G,filter:A,convInfo:R,backend:q,bias:j=null,preluActivationWeights:te=null,leakyreluAlpha:ie=0,activation:he=null}){const xe=j!=null,_e=te!=null,Ue=R.dataFormat==="channelsLast";if(Ue&&R.filterHeight===R.inHeight&&R.filterWidth===R.inWidth&&R.padInfo.type==="VALID"||R.filterHeight===1&&R.filterWidth===1&&R.dilationHeight===1&&R.dilationWidth===1&&R.strideHeight===1&&R.strideWidth===1&&(R.padInfo.type==="SAME"||R.padInfo.type==="VALID"))return function({x:qt,filter:cn,convInfo:rn,backend:yn,bias:Fn=null,preluActivationWeights:_n=null,leakyreluAlpha:ss=0,activation:zn=null}){const Kn=rn.dataFormat==="channelsLast",us=!Kn,ps=[];let es,ks;if(Kn&&rn.filterHeight===rn.inHeight&&rn.filterWidth===rn.inWidth&&rn.padInfo.type==="VALID"){const or=rn.inHeight*rn.inWidth*rn.inChannels;es=Ot({inputs:{x:qt},backend:yn,attrs:{shape:[1,rn.batchSize,or]}}),ks=Ot({inputs:{x:cn},backend:yn,attrs:{shape:[1,or,rn.outChannels]}})}else es=Ot({inputs:{x:qt},backend:yn,attrs:{shape:Kn?[rn.batchSize,rn.inHeight*rn.inWidth,rn.inChannels]:[rn.batchSize,rn.inChannels,rn.inHeight*rn.inWidth]}}),ks=Ot({inputs:{x:cn},backend:yn,attrs:{shape:[1,rn.inChannels,rn.outChannels]}});if(ps.push(es),ps.push(ks),_n!=null){const or=ja(_n.shape,Kn);or!=null&&(_n=Ot({inputs:{x:_n},backend:yn,attrs:{shape:or}}),ps.push(_n))}if(Fn!=null){const or=ja(Fn.shape,Kn);or!=null&&(Fn=Ot({inputs:{x:Fn},backend:yn,attrs:{shape:or}}),ps.push(Fn))}const Ks=Dn({a:Kn?es:ks,b:Kn?ks:es,transposeA:us,transposeB:!1,backend:yn,bias:Fn,activation:zn,preluActivationWeights:_n,leakyreluAlpha:ss}),sa=Ot({inputs:{x:Ks},backend:yn,attrs:{shape:rn.outShape}});ps.push(Ks);for(const or of ps)yn.disposeData(or.dataId);return sa}({x:G,filter:A,convInfo:R,backend:q,bias:j,activation:he,preluActivationWeights:te,leakyreluAlpha:ie});const nt=Ue?R.outHeight*R.outWidth:R.outChannels,it=Ue?R.outChannels:R.outHeight*R.outWidth,et=R.filterHeight*R.filterWidth*R.inChannels,dt=[R.padInfo.top,R.padInfo.left],ut=[{type:"int32",data:[R.filterHeight,R.filterWidth]},{type:"int32",data:[...dt]},{type:"int32",data:[R.strideHeight,R.strideWidth]},{type:"int32",data:[R.dilationHeight,R.dilationWidth]},{type:"int32",data:[nt]},{type:"int32",data:[it]},{type:"int32",data:[et]}],Et=new Xr(R,nt,it,et,xe,he,_e),Tt=[],Dt=[G,A];xe&&(Ue||j.shape.length!==1||(j=Ot({inputs:{x:j},backend:q,attrs:{shape:[j.shape[0],1,1]}}),Tt.push(j)),Dt.push(j)),_e&&(Ue||te.shape.length!==1||(te=Ot({inputs:{x:te},backend:q,attrs:{shape:[te.shape[0],1,1]}}),Tt.push(te)),Dt.push(te)),he==="leakyrelu"&&(ut.push({type:"float32",data:[ie]}),Et.uniforms+=" alpha : f32,");const Wt=q.runWebGPUProgram(Et,Dt,G.dtype,ut);for(const qt of Tt)q.disposeData(qt.dataId);return Wt}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai={kernelName:n.Conv2D,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,attrs:R,backend:q}=G,{x:j,filter:te}=A,{strides:ie,pad:he,dataFormat:xe,dilations:_e,dimRoundingMode:Ue}=R,nt=n.backend_util.convertConv2DDataFormat(xe);return To({x:j,filter:te,convInfo:n.backend_util.computeConv2DInfo(j.shape,te.shape,ie,_e,he,Ue,!1,nt),backend:q})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tu{constructor(A){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=A.inShape,n.util.assert(A.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=A.inChannels%4==0&&A.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=L(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Y(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const A=this.isVec4?Rn(this.elementsPerThread,this.workGroupSize):ee(this.elementsPerThread,this.workGroupSize);return`
    ${function(R=4){const q=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${at(R)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${at(R)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${R}];
      }
      return ${at(R)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${at(R)} {
    let col = colIn * ${R};
    ${q}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${at(R)} {
    let col = colIn * ${R};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${(j=>{switch(j){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${j} is not supported.`)}})(R)}
    }
    return ${at(R)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${at(R)}) {
    let col = colIn * ${R};
    if (row < uniforms.dimAOuter && (col + ${R-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${R}] = value;
    }
  }`}(this.isVec4?4:1)}
    ${A}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oi{constructor(A){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A.inShape,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=A.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const A=this.isChannelsLast?1:2,R=this.isChannelsLast?2:3,q=this.isChannelsLast?3:1;return`
    ${f("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${q}];

        let dyCorner = vec2<i32>(coords[${A}]), coords[${R}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo={kernelName:n.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{dy:j,filter:te}=A,{inputShape:ie,strides:he,pad:xe,dataFormat:_e,dimRoundingMode:Ue}=q,nt=n.backend_util.convertConv2DDataFormat(_e),it=n.backend_util.computeConv2DInfo(ie,te.shape,he,1,xe,Ue,!1,nt),et=[{type:"int32",data:[it.filterHeight,it.filterWidth]},{type:"int32",data:[it.filterHeight-1-it.padInfo.top,it.filterWidth-1-it.padInfo.left]},{type:"int32",data:[it.strideHeight,it.strideWidth]},{type:"int32",data:[it.batchSize,it.outHeight,it.outWidth,it.outChannels]}];let dt;if(Object(n.env)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))dt=new oi(it);else{dt=new Tu(it);const ut=it.inShape[1]*it.inShape[2],Et=it.inShape[3],Tt=it.filterHeight*it.filterWidth*it.outChannels;et.push({type:"uint32",data:[ut]},{type:"uint32",data:[Et]},{type:"uint32",data:[Tt]})}return R.runWebGPUProgram(dt,[j,te],"float32",et)}},Nu=ds({opType:Me.COS}),Ls={kernelName:n.Cos,backendName:"webgpu",kernelFunc:Nu},Lr=ds({opType:Me.COSH}),ao={kernelName:n.Cosh,backendName:"webgpu",kernelFunc:Lr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Si{constructor(A,R,q,j){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;const[te]=R;this.outputShape=[te,q[0],q[1],A],this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=j==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[A,R]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[q,j,te]=this.cropHeightBiggerThan1?[`(${A} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${A} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${A}`],[ie,he,xe]=this.cropWidthBiggerThan1?[`(${R} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${R} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${R}`];return`
    ${f("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${q});
        let width_ratio = f32(${ie});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${j};
        let width_scale = ${he};
        let in_y = ${te};
        if( in_y < 0.0 || in_y > ${A} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${xe};
        if( in_x < 0.0 || in_x > ${R} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu={kernelName:n.CropAndResize,backendName:"webgpu",kernelFunc:G=>{const{inputs:A,backend:R,attrs:q}=G,{image:j,boxes:te,boxInd:ie}=A,{cropSize:he,method:xe,extrapolationValue:_e}=q,Ue=new Si(j.shape[3],te.shape,he,xe),nt=[{type:"float32",data:[_e]}];return R.runWebGPUProgram(Ue,[j,te,ie],"float32",nt)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var No;(function(G){G.Prod="*",G.Sum="+"})(No||(No={}));class $i{constructor(A,R,q,j){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workGroupSize=[128,1,1],this.outputShape=R,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=q,this.reverse=j,this.op=A,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const A=this.outputShape.length,R=this.op===No.Prod?"1.0":"0.0",q=this.exclusive?R:`getX(${Ti(A,"coords",this.op)})`,j=this.outputShape[this.outputShape.length-1];let te="",ie="";return this.exclusive?(te=this.reverse?"end != "+(j-1):"end != 0",ie=this.reverse?"end + 1":"end - 1"):(te=this.reverse?`end + pow2 < ${j}`:"end >= pow2",ie=this.reverse?"end + pow2":"end - pow2"),`
      ${f("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${ii(A,"coords",this.op)};
         var val = ${q};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${te}) {
           let idx = ${ie};
           ${ii(A,"coords",this.op)} = idx;
           val ${this.op}= getX(${Ti(A,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function Ti(G,A,R){if(G===1)return`${A}`;if(G===2)return`${A}.x, ${A}.y`;if(G===3)return`${A}.x, ${A}.y, ${A}.z`;if(G===4)return`${A}.x, ${A}.y, ${A}.z, ${A}.w`;throw Error(`Cumulative ${R} for rank ${G} is not yet supported`)}function ii(G,A,R){if(G===1)return`${A}`;if(G===2)return`${A}.y`;if(G===3)return`${A}.z`;if(G===4)return`${A}.w`;throw Error(`Cumulative ${R} for rank ${G} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(G,A,R,q,j,te){const ie=A.shape.length,he=n.backend_util.getAxesPermutation([q],ie);let xe=A;he!=null&&(xe=Ar({inputs:{x:A},backend:R,attrs:{perm:he}}));const _e=n.backend_util.getInnerMostAxes(1,ie)[0];if(_e!==ie-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${A.shape.length-1} but got axis=${q}`);const Ue=xe.shape[_e];let nt=Un({inputs:{x:xe},backend:R});for(let it=0;it<=Math.ceil(Math.log2(Ue))-1;it++){const et=new $i(G,xe.shape,!1,te),dt=nt,ut=[{type:"float32",data:[it]}];nt=R.runWebGPUProgram(et,[nt],nt.dtype,ut),R.disposeData(dt.dataId)}if(j){const it=new $i(G,xe.shape,j,te),et=nt,dt=[{type:"float32",data:[0]}];nt=R.runWebGPUProgram(it,[nt],nt.dtype,dt),R.disposeData(et.dataId)}if(he!=null){const it=Ar({inputs:{x:nt},backend:R,attrs:{perm:n.backend_util.getUndoAxesPermutation(he)}});return R.disposeData(nt.dataId),R.disposeData(xe.dataId),it}return nt}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jn={kernelName:n.Cumprod,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te,exclusive:ie,reverse:he}=q;return bs(No.Prod,j,R,te,ie,he)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hr={kernelName:n.Cumsum,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te,exclusive:ie,reverse:he}=q;return bs(No.Sum,j,R,te,ie,he)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gn{constructor(A,R){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${R}`,this.dataFormat=R}getUserCode(){return`
      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aa={kernelName:n.DepthToSpace,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{blockSize:te,dataFormat:ie}=q,he=j.shape[0],xe=(ie==="NHWC"?j.shape[1]:j.shape[2])*te,_e=(ie==="NHWC"?j.shape[2]:j.shape[3])*te,Ue=(ie==="NHWC"?j.shape[3]:j.shape[1])/(te*te),nt=[{type:"int32",data:[te]}],it=new Gn(ie==="NHWC"?[he,xe,_e,Ue]:[he,Ue,xe,_e],ie);return R.runWebGPUProgram(it,[j],j.dtype,nt)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vr{constructor(A,R,q,j=!1,te=null,ie=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=A,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),j&&this.variableNames.push("bias"),ie&&this.variableNames.push("preluActivationWeights"),this.addBias=j,this.activation=te,this.hasPreluActivation=ie,this.filterHeight=R,this.filterWidth=q,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const A=this.filterWidth*this.filterHeight,R=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],q=this.workGroupSize[1]+this.filterHeight-1,j=this.workGroupSize[0]+this.filterWidth-1;return`
      ${Gt(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${j}>, ${q}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
        localId = LocalId;
        globalId = GlobalId;
        let localIndex = i32(LocalIndex);
        numWorkgroups = NumWorkgroups;
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${q}; inputRow = inputRow + ${this.workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${j}; inputCol = inputCol + ${this.workGroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = localIndex;
        ${A<R?`if (wIndex < ${A})`:`for(; wIndex < ${A}; wIndex = wIndex + ${R})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ht(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ua{constructor(A,R=!1,q=null,j=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=A.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,4,1]),n.util.assert(A.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),R&&this.variableNames.push("bias"),j&&this.variableNames.push("preluActivationWeights"),this.convInfo=A,this.addBias=R,this.activation=q,this.hasPreluActivation=j,this.shaderKey=`depthwiseVec4_${q}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}`}getUserCode(){const A=4+this.convInfo.filterWidth-1;return`
      ${Gt(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, row, col, channel);
        }
        return value;
      }
      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * 4;
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${A}>;
        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          for (var i = 0; i < ${A}; i++)
          {
            xVals[i] = readX(batch, xR, xCCorner + i, d1);
          }
          for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
            let wValue = getW(wR, wC, d1, 0);
            dotProd[0] = dotProd[0] + xVals[0 + wC] * wValue;
            dotProd[1] = dotProd[1] + xVals[1 + wC] * wValue;
            dotProd[2] = dotProd[2] + xVals[2 + wC] * wValue;
            dotProd[3] = dotProd[3] + xVals[3 + wC] * wValue;
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ht(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tu{constructor(A,R=!1,q=null,j=!1){this.variableNames=["x","W"],this.uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`,this.workGroupSize=[256,1,1],this.outputShape=A.outShape,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=A.dataFormat==="channelsLast",R&&this.variableNames.push("bias"),j&&this.variableNames.push("preluActivationWeights"),this.convInfo=A,this.addBias=R,this.activation=q,this.hasPreluActivation=j,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const A=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Gt(this.activation,this.hasPreluActivation,!1,4)}

      ${f()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
        let d2 = coords[${this.isChannelsLast?3:1}];
        let channelMul = uniforms.wShape[3];
        let d1 = d2 / channelMul;
        let q = d2 % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
        var value = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = ${A};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = ${A};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          }
          ${Ht(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ui={kernelName:n.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j,filter:te}=A,{strides:ie,pad:he,dataFormat:xe,dilations:_e,dimRoundingMode:Ue}=q,nt=n.backend_util.convertConv2DDataFormat(xe);let it=_e;it==null&&(it=[1,1]);const et=n.backend_util.computeConv2DInfo(j.shape,te.shape,ie,it,he,Ue,!0,nt),dt=[{type:"int32",data:[et.padInfo.top,et.padInfo.left]},{type:"int32",data:[et.inHeight,et.inWidth]}],ut=et.dataFormat==="channelsLast";let Et;return!ut&&et.inHeight>16&&et.inWidth>16&&et.strideHeight===1&&et.strideWidth===1&&et.dilationWidth===1&&et.dilationHeight===1&&et.inChannels===et.outChannels?Et=new Vr(et.outShape,et.filterHeight,et.filterWidth):ut&&et.inHeight>4&&et.inWidth>4&&et.strideHeight===1&&et.strideWidth===1&&et.inChannels===et.outChannels&&et.dilationHeight===1&&et.dilationWidth===1&&et.inChannels%4==0?Et=new ua(et):(Et=new tu(et),dt.push({type:"int32",data:[et.filterHeight]},{type:"int32",data:[et.filterWidth]},{type:"int32",data:[et.strideHeight,et.strideWidth]},{type:"int32",data:[et.dilationHeight,et.dilationWidth]})),R.runWebGPUProgram(Et,[j,te],j.dtype,dt)}},jo=Ys({opType:ye.MUL,cpuKernelImpl:wn,supportsComplex:!0}),Ku={kernelName:n.Multiply,backendName:"webgpu",kernelFunc:jo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te,keepDims:ie}=q;return fa(j,te,ie,"sum",R)}const oo={kernelName:n.Sum,backendName:"webgpu",kernelFunc:Ur};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Go={kernelName:n.Einsum,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{equation:j}=q,te=A,{allDims:ie,summedDims:he,idDims:xe}=n.backend_util.decodeEinsumEquation(j,te.length);n.backend_util.checkEinsumDimSizes(ie.length,xe,te);const{path:_e,steps:Ue}=n.backend_util.getEinsumComputePath(he,xe),nt=Ue.length;let it=null,et=ie.length;const dt=[];for(let ut=0;ut<nt;++ut){for(const Et of Ue[ut]){const{permutationIndices:Tt,expandDims:Dt}=n.backend_util.getEinsumPermutation(et,xe[Et]);let Wt;n.backend_util.isIdentityPermutation(Tt)?Wt=te[Et]:(Wt=Ar({inputs:{x:te[Et]},backend:R,attrs:{perm:Tt}}),dt.push(Wt));const qt=Wt.shape.slice();for(let cn=0;cn<Dt.length;++cn)qt.splice(Dt[cn],0,1);n.util.arraysEqual(Wt.shape,qt)||(Wt=Ot({inputs:{x:Wt},backend:R,attrs:{shape:qt}}),dt.push(Wt)),it===null?it=Wt:(it=jo({inputs:{a:Wt,b:it},backend:R}),dt.push(it))}ut<nt-1&&(_e[ut]>=0&&(it=Ur({inputs:{x:it},backend:R,attrs:{axis:_e[ut]-(ie.length-et),keepDims:!1}}),dt.push(it)),et--)}for(const ut of dt)ut!==it&&R.disposeData(ut.dataId);return it}},ar=ds({opType:Me.ELU}),xo={kernelName:n.Elu,backendName:"webgpu",kernelFunc:ar},Ni=Ys({opType:ye.EQUAL,dtype:"bool",cpuKernelImpl:ys}),nu={kernelName:n.Equal,backendName:"webgpu",kernelFunc:Ni},ci=ds({opType:Me.EXP,cpuKernelImpl:Vs,dtype:"float32"}),li={kernelName:n.Exp,backendName:"webgpu",kernelFunc:ci};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Os(G){const{inputs:A,attrs:R,backend:q}=G,{dim:j}=R,{input:te}=A,ie=te.shape.length,he=te.shape.slice();let xe=j;return j<0&&(n.util.assert(-(ie+1)<=j,()=>`Axis must be in the interval [${-(ie+1)}, ${ie}]`),xe=ie+j+1),he.splice(xe,0,1),Ot({inputs:{x:te},backend:q,attrs:{shape:he}})}const Ei={kernelName:n.ExpandDims,backendName:"webgpu",kernelFunc:Os},Ia=ds({opType:Me.EXPM1,cpuKernelImpl:Us}),su={kernelName:n.Expm1,backendName:"webgpu",kernelFunc:Ia};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ri{constructor(A){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ai={kernelName:n.FlipLeftRight,backendName:"webgpu",kernelFunc:({inputs:G,backend:A})=>{const{image:R}=G,q=A,j=new Ri(R.shape);return q.runWebGPUProgram(j,[R],R.dtype)}},ru=ds({opType:Me.FLOOR,cpuKernelImpl:jt}),Oi={kernelName:n.Floor,backendName:"webgpu",kernelFunc:ru},Eo=Ys({opType:ye.INT_DIV,dtype:"int32"}),Fi={kernelName:n.FloorDiv,backendName:"webgpu",kernelFunc:Eo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cc{constructor(A,R,q=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[R,1,1]),this.importVideo=q,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const A=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${f("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${A};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Di={kernelName:n.FromPixels,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G;let{pixels:j}=A;const{numChannels:te}=q;if(j==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const ie=typeof HTMLVideoElement!="undefined"&&j instanceof HTMLVideoElement,he=typeof HTMLImageElement!="undefined"&&j instanceof HTMLImageElement,xe=typeof HTMLCanvasElement!="undefined"&&j instanceof HTMLCanvasElement||typeof OffscreenCanvas!="undefined"&&j instanceof OffscreenCanvas,_e=typeof ImageBitmap!="undefined"&&j instanceof ImageBitmap,[Ue,nt]=ie?[j.videoWidth,j.videoHeight]:[j.width,j.height],it=[nt,Ue,te],et=Object(n.env)().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&ie,dt=ie||he;if(_e||xe||dt){let Dt;if(et){const _n=j;if(!Mi.has(_n)||Mi.get(_n).expired){const ss={source:_n};Mi.set(_n,R.device.importExternalTexture(ss))}Dt={width:Ue,height:nt,format:null,usage:null,texture:Mi.get(_n)}}else{if(dt){const Kn=Object(n.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");Ro!=null&&Kn===au||(au=Kn,Ro=document.createElement("canvas").getContext("2d",{willReadFrequently:au})),Ro.canvas.width=Ue,Ro.canvas.height=nt,Ro.drawImage(j,0,0,Ue,nt),j=Ro.canvas}const _n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,ss="rgba8unorm",zn=R.textureManager.acquireTexture(it[1],it[0],ss,_n);R.queue.copyExternalImageToTexture({source:j},{texture:zn},[it[1],it[0]]),Dt={width:Ue,height:nt,format:ss,usage:_n,texture:zn}}const Wt=n.util.sizeFromShape(it),qt=n.util.computeStrides(it),cn=new Cc(it,te,et),rn=[{type:"uint32",data:[Wt]},{type:"uint32",data:[te]},{type:"uint32",data:[...qt]}],yn=R.makeTensorInfo([nt,Ue],"int32");R.tensorMap.get(yn.dataId).resourceInfo=Dt;const Fn=R.runWebGPUProgram(cn,[yn],"int32",rn);return R.disposeData(yn.dataId),Fn}const ut=j.data;let Et=ut;if(te!=null&&te!==4){Et=new Uint8Array(j.width*j.height*te);const Dt=ut.length;let Wt=0;for(let qt=0;qt<Dt;qt++)qt%4<te&&(Et[Wt++]=ut[qt])}const Tt=R.makeTensorInfo(it,"int32",new Int32Array(Et));return R.uploadToGPU(Tt.dataId),Tt}};let Ro,au=Object(n.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Mi=new Map;class _c{constructor(A,R,q,j,te){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.backend_util.assertAndGetBroadcastShape(A,R),n.backend_util.assertAndGetBroadcastShape(A,q),this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),j!=null&&(n.backend_util.assertAndGetBroadcastShape(A,j),this.variableNames.push("offset")),te!=null&&(n.backend_util.assertAndGetBroadcastShape(A,te),this.variableNames.push("scale")),this.offsetShape=j,this.scaleShape=te,this.shaderKey="batchNorm"}getUserCode(){let A="0.0";this.offsetShape!=null&&(A="getOffsetByOutputIndex(index)");let R="1.0";return this.scaleShape!=null&&(R="getScaleByOutputIndex(index)"),`
      ${f("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${A};
          let scaleValue = ${R};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const di={kernelName:n.FusedBatchNorm,backendName:"webgpu",kernelFunc:({inputs:G,attrs:A,backend:R})=>{const{x:q,scale:j,offset:te,mean:ie,variance:he}=G,{varianceEpsilon:xe}=A,_e=R,Ue=[q,ie,he];let nt=null;te!=null&&(nt=te.shape,Ue.push(te));let it=null;j!=null&&(it=j.shape,Ue.push(j));const et=new _c(q.shape,ie.shape,he.shape,nt,it),dt=[{type:"float32",data:[xe]}];return _e.runWebGPUProgram(et,Ue,q.dtype,dt)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi={kernelName:n.FusedConv2D,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j,filter:te,bias:ie,preluActivationWeights:he}=A,{strides:xe,pad:_e,dataFormat:Ue,dilations:nt,dimRoundingMode:it,activation:et,leakyreluAlpha:dt}=q,ut=n.backend_util.convertConv2DDataFormat(Ue);return To({x:j,filter:te,convInfo:n.backend_util.computeConv2DInfo(j.shape,te.shape,xe,nt,_e,it,!1,ut),backend:R,bias:ie,preluActivationWeights:he,leakyreluAlpha:dt,activation:et})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ou={kernelName:n.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j,filter:te,bias:ie,preluActivationWeights:he}=A,{strides:xe,pad:_e,dilations:Ue,dimRoundingMode:nt,activation:it,leakyreluAlpha:et}=q;let dt=Ue;dt==null&&(dt=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(xe,dt),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${xe} and dilations '${dt}'`);const ut=n.backend_util.computeConv2DInfo(j.shape,te.shape,xe,dt,_e,nt,!0),Et=[j,te],Tt=ie!=null,Dt=he!=null;Tt&&Et.push(ie),Dt&&Et.push(he);const Wt=[{type:"int32",data:[ut.padInfo.top,ut.padInfo.left]},{type:"int32",data:[ut.inHeight,ut.inWidth]}];let qt;return ut.inHeight>4&&ut.inWidth>4&&ut.strideHeight===1&&ut.strideWidth===1&&ut.inChannels===ut.outChannels&&ut.dilationHeight===1&&ut.dilationWidth===1&&ut.inChannels%4==0?qt=new ua(ut,Tt,it,Dt):(qt=new tu(ut,Tt,it,Dt),Wt.push({type:"int32",data:[ut.filterHeight]},{type:"int32",data:[ut.filterWidth]},{type:"int32",data:[ut.strideHeight,ut.strideWidth]},{type:"int32",data:[ut.dilationHeight,ut.dilationWidth]})),it==="leakyrelu"&&(Wt.push({type:"float32",data:[et]}),qt.uniforms+=" alpha : f32,"),R.runWebGPUProgram(qt,Et,"float32",Wt)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xu{constructor(A,R){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=R,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${A}`,this.sliceDim=A,this.uniforms=`sliceDim : i32, strides : ${l(A)},`}getUserCode(){let A;return A=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`
      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${A};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sc={kernelName:n.GatherNd,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R}=G,{params:q,indices:j}=A,te=j.shape,ie=te[te.length-1],he=n.util.sizeFromShape(q.shape),[xe,_e,Ue,nt]=n.backend_util.prepareAndValidate(q,j),it=Ot({inputs:{x:j},backend:R,attrs:{shape:[_e,ie]}}),et=Ot({inputs:{x:q},backend:R,attrs:{shape:[n.util.sizeFromShape(q.shape)/Ue,Ue]}});if(R.shouldExecuteOnCPU([q,j])||q.dtype==="string"){const Dt=R.readSync(j.dataId),Wt=R.bufferSync(q),qt=re(Dt,Wt,q.dtype,_e,ie,Ue,nt,q.shape,he);return R.makeTensorInfo(xe,q.dtype,qt.values)}const dt=new Xu(ie,[_e,Ue]),ut=[{type:"int32",data:[ie]},{type:"int32",data:nt}],Et=R.runWebGPUProgram(dt,[et,it],et.dtype,ut),Tt=Ot({inputs:{x:Et},backend:R,attrs:{shape:xe}});return R.disposeData(it.dataId),R.disposeData(et.dataId),R.disposeData(Et.dataId),Tt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $c{constructor(A,R){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A.slice(),this.aShape=A,this.outputShape=R,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const A=function(R){const q=["resRC.x","resRC.y","resRC.z","resRC.w"],j=[];for(let te=0;te<R.length;te++)te===2?j.push("indexZ"):j.push(`${q[te]}`);return j.join()}(this.aShape);return`
      ${f("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${A}));
        }
      }
    `}}function Yu(G){const{inputs:A,backend:R,attrs:q}=G,{x:j,indices:te}=A,{axis:ie,batchDims:he}=q,xe=n.util.parseAxisParam(ie,j.shape)[0],_e=n.backend_util.segment_util.collectGatherOpShapeInfo(j,te,xe,he),Ue=n.util.sizeFromShape(te.shape),nt=[],it=Ot({inputs:{x:j},backend:R,attrs:{shape:[_e.batchSize,_e.outerSize,_e.dimSize,_e.sliceSize]}}),et=Ot({inputs:{x:te},backend:R,attrs:{shape:[_e.batchSize,Ue/_e.batchSize]}});nt.push(it),nt.push(et);const dt=[_e.batchSize,_e.outerSize,Ue/_e.batchSize,_e.sliceSize];if(R.shouldExecuteOnCPU([j,te])){const Dt=R.tensorMap.get(et.dataId).values,Wt=Object(n.buffer)(et.shape,et.dtype,Dt),qt=R.tensorMap.get(it.dataId).values,cn=Object(n.buffer)(it.shape,it.dtype,qt),rn=de(cn,Wt,dt);return nt.forEach(yn=>R.disposeData(yn.dataId)),R.makeTensorInfo(_e.outputShape,rn.dtype,rn.values)}const ut=new $c(it.shape,dt),Et=R.runWebGPUProgram(ut,[it,et],it.dtype);nt.push(Et);const Tt=Ot({inputs:{x:Et},backend:R,attrs:{shape:_e.outputShape}});return nt.forEach(Dt=>R.disposeData(Dt.dataId)),Tt}const Pe={kernelName:n.GatherV2,backendName:"webgpu",kernelFunc:Yu},me=Ys({opType:ye.GREATER,cpuKernelImpl:Ct,dtype:"bool"}),He={kernelName:n.Greater,backendName:"webgpu",kernelFunc:me},st=Ys({opType:ye.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:ot}),Ae={kernelName:n.GreaterEqual,backendName:"webgpu",kernelFunc:st},rt=ds({opType:Me.IS_NAN,dtype:"bool"}),xt={kernelName:n.IsNan,backendName:"webgpu",kernelFunc:rt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nt={kernelName:n.LeakyRelu,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{alpha:te}=q,ie=[{type:"float32",data:[te]}],he=new xs(j.shape,Me.LEAKYRELU);return he.uniforms="alpha : f32,",R.runWebGPUProgram(he,[j],"float32",ie)}},vt=Ys({opType:ye.LESS,dtype:"bool",cpuKernelImpl:on}),St={kernelName:n.Less,backendName:"webgpu",kernelFunc:vt},_t=Ys({opType:ye.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Yt}),en={kernelName:n.LessEqual,backendName:"webgpu",kernelFunc:_t},Kt=ds({opType:Me.LOG,cpuKernelImpl:tn}),Ze={kernelName:n.Log,backendName:"webgpu",kernelFunc:Kt},Lt=Ys({opType:ye.LOGICAL_AND,dtype:"bool"}),Jt={kernelName:n.LogicalAnd,backendName:"webgpu",kernelFunc:Lt},un=ds({opType:Me.LOGICAL_NOT}),In={kernelName:n.LogicalNot,backendName:"webgpu",kernelFunc:un},Xt=Ys({opType:ye.MAX,cpuKernelImpl:On}),$n={kernelName:n.Maximum,backendName:"webgpu",kernelFunc:Xt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jn={kernelName:n.MaxPool,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{filterSize:te,strides:ie,pad:he,dimRoundingMode:xe}=q;return Ut(j,n.backend_util.computePool2DInfo(j.shape,te,ie,1,he,xe),"max",R)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ss={kernelName:n.Min,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te,keepDims:ie}=q;return fa(j,te,ie,"min",R)}},Ms=Ys({opType:ye.MIN,cpuKernelImpl:Mn}),Ps={kernelName:n.Minimum,backendName:"webgpu",kernelFunc:Ms};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs{constructor(A,R,q){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=R.map((j,te)=>j[0]+A[te]+j[1]),this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=A,R.map((j,te)=>{this.uniforms+=` pad${te} : vec2<i32>,`}),this.offset=q==="reflect"?0:1,this.shaderKey=`mirrorPad_${q}`}getUserCode(){const A=this.xShape.length,R=this.xShape.map((_e,Ue)=>`uniforms.pad${Ue}[0]`).join(","),q=this.xShape.map((_e,Ue)=>`uniforms.pad${Ue}[0] + uniforms.xShape${A>1?`[${Ue}]`:""}`).join(","),j=A===1?"start":"start[i]",te=A===1?"end":"end[i]",ie=A===1?"outC":"outC[i]",he=l(A),xe=A>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,A):"coords";return`
      ${f("index")} {
        if (index < uniforms.size) {
          let start = ${he}(${R});
          let end = ${he}(${q});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${A}; i = i + 1) {
            if (${ie} < ${j}) {
              ${ie} = ${j} * 2 - ${ie} - ${this.offset};
            } else if(${ie} >= ${te}) {
              ${ie} = (${te} - 1) * 2 - ${ie} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${xe}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pr={kernelName:n.MirrorPad,backendName:"webgpu",kernelFunc:({inputs:G,attrs:A,backend:R})=>{const{x:q}=G,{paddings:j,mode:te}=A,ie=R,he=j.map(_e=>({type:"int32",data:[_e[0],_e[1]]})),xe=new Fs(q.shape,j,te);return ie.runWebGPUProgram(xe,[q],q.dtype,he)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er={kernelName:n.Neg,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R}=G,{x:q}=A;if(R.shouldExecuteOnCPU([q])){const te=R.tensorMap.get(q.dataId),[ie,he]=gs(te.values,q.shape,q.dtype);return R.makeTensorInfo(he,q.dtype,ie)}const j=new xs(q.shape,Me.NEG);return R.runWebGPUProgram(j,[q],q.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fr={kernelName:n.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(G){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:A,backend:R,attrs:q}=G,{boxes:j,scores:te}=A,{maxOutputSize:ie,iouThreshold:he,scoreThreshold:xe}=q,_e=R.readSync(j.dataId),Ue=R.readSync(te.dataId),{selectedIndices:nt}=n.kernel_impls.nonMaxSuppressionV3Impl(_e,Ue,ie,he,xe);return R.makeTensorInfo([nt.length],"int32",new Int32Array(nt))}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cr={kernelName:n.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(G){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:A,backend:R,attrs:q}=G,{boxes:j,scores:te}=A,{maxOutputSize:ie,iouThreshold:he,scoreThreshold:xe,softNmsSigma:_e}=q,Ue=R.readSync(j.dataId),nt=R.readSync(te.dataId),it=ie,et=he,dt=xe,ut=_e,{selectedIndices:Et,selectedScores:Tt}=n.kernel_impls.nonMaxSuppressionV5Impl(Ue,nt,it,et,dt,ut);return[R.makeTensorInfo([Et.length],"int32",new Int32Array(Et)),R.makeTensorInfo([Tt.length],"float32",new Float32Array(Tt))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(G){const{inputs:A,backend:R}=G,{x:q}=A;if(q.dtype==="complex64"){const j=ur({inputs:{input:q},backend:R}),te=jr({inputs:{x:j},backend:R}),ie=go({inputs:{input:q},backend:R}),he=jr({inputs:{x:ie},backend:R}),xe=Gs({inputs:{real:te,imag:he},backend:R});return R.disposeData(j.dataId),R.disposeData(te.dataId),R.disposeData(ie.dataId),R.disposeData(he.dataId),xe}return ht({attrs:{shape:q.shape,dtype:q.dtype,value:q.dtype==="string"?"":0},backend:R})}const Ca={kernelName:n.ZerosLike,backendName:"webgpu",kernelFunc:jr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yo={kernelName:n.OnesLike,backendName:"webgpu",kernelFunc:function G(A){const{inputs:R,backend:q}=A,{x:j}=R;if(j.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(j.dtype==="complex64"){const te=ur({inputs:{input:j},backend:q}),ie=G({inputs:{x:te},backend:q}),he=go({inputs:{input:j},backend:q}),xe=jr({inputs:{x:he},backend:q}),_e=Gs({inputs:{real:ie,imag:xe},backend:q});return q.disposeData(te.dataId),q.disposeData(ie.dataId),q.disposeData(he.dataId),q.disposeData(xe.dataId),_e}return ht({attrs:{shape:j.shape,dtype:j.dtype,value:1},backend:q})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ao={kernelName:n.Pack,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{axis:j}=q;if(A.length===1)return Os({inputs:{input:A[0]},backend:R,attrs:{dim:j}});const te=A[0].shape,ie=A[0].dtype;A.forEach(_e=>{n.util.assertShapesMatch(te,_e.shape,"All tensors passed to stack must have matching shapes"),n.util.assert(ie===_e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const he=[],xe=Wr({inputs:A.map(_e=>{const Ue=Os({inputs:{input:_e},backend:R,attrs:{dim:j}});return he.push(Ue),Ue}),backend:R,attrs:{axis:j}});return he.forEach(_e=>R.disposeData(_e.dataId)),xe}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Li{constructor(A,R){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=R.map((q,j)=>q[0]+A[j]+q[1]),this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),R.map((q,j)=>{this.uniforms+=` pad${j} : vec2<i32>,`}),this.xShape=A,this.shaderKey="pad"}getUserCode(){const A=this.xShape.length,R=l(A),q=this.xShape.map((Ue,nt)=>`uniforms.pad${nt}[0]`).join(","),j=this.xShape.map((Ue,nt)=>`uniforms.pad${nt}[0] + uniforms.xShape${A>1?`[${nt}]`:""}`).join(","),te=A>1?`${R}(${q})`:`${q}`,ie=A>1?`${R}(${j})`:`${j}`,he=A>1?"any(outC < start)":"outC < start",xe=A>1?"any(outC >= end)":"outC >= end",_e=A>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,A):"coords";return`
      ${f("index")} {
        if (index < uniforms.size) {
          let start = ${te};
          let end = ${ie};
          let outC = getCoordsFromIndex(index);

          if (${he} || ${xe}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${_e}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hi=G=>{const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{paddings:te,constantValue:ie}=q;if(te.every(_e=>n.util.arraysEqual(_e,[0,0])))return Un({inputs:{x:j},backend:R});if(n.util.sizeFromShape(j.shape)===0)return ht({backend:R,attrs:{shape:te.map((_e,Ue)=>_e[0]+j.shape[Ue]+_e[1]),value:ie,dtype:j.dtype}});const he=[{type:"float32",data:[ie]}];te.map(_e=>he.push({type:"int32",data:[_e[0],_e[1]]}));const xe=new Li(j.shape,te);return R.runWebGPUProgram(xe,[j],j.dtype,he)},wo={kernelName:n.PadV2,backendName:"webgpu",kernelFunc:hi},Ho=Ys({opType:ye.POW}),qo={kernelName:n.Pow,backendName:"webgpu",kernelFunc:Ho},Bi={kernelName:n.Prelu,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R}=G,{x:q,alpha:j}=A,te=new Qe(ye.PRELU,q.shape,j.shape);return R.runWebGPUProgram(te,[q,j],"float32")}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ca={kernelName:n.Prod,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{axis:te,keepDims:ie}=q;return fa(j,te,ie,"prod",R)}},zi={kernelName:n.Range,backendName:"webgpu",kernelFunc:G=>{const{backend:A,attrs:R}=G,{start:q,stop:j,step:te,dtype:ie}=R,he=Ir(q,j,te,ie);return A.makeTensorInfo([he.length],ie,he)}},Zu=Ys({opType:ye.DIV}),Wi={kernelName:n.RealDiv,backendName:"webgpu",kernelFunc:Zu},Qu=ds({opType:Me.RECIPROCAL}),Ol={kernelName:n.Reciprocal,backendName:"webgpu",kernelFunc:Qu},Kc=ds({opType:Me.RELU}),Fl={kernelName:n.Relu,backendName:"webgpu",kernelFunc:Kc},Xc=ds({opType:Me.RELU6}),Tc={kernelName:n.Relu6,backendName:"webgpu",kernelFunc:Xc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ju{constructor(A,R,q){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[A[0],R,q,A[3]],this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${f("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yc={kernelName:n.ResizeBilinear,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{images:j}=A,{alignCorners:te,size:ie,halfPixelCenters:he}=q,[xe,_e]=ie,Ue=[{type:"float32",data:[te&&xe>1?1:0,te&&_e>1?1:0]},{type:"float32",data:[he?.5:0]}],nt=new Ju(j.shape,xe,_e);return R.runWebGPUProgram(nt,[j],"float32",Ue)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nc{constructor(A,R,q,j){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[A[0],R,q,A[3]],this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=j,this.shaderKey=`resizeNearest_${j}`}getUserCode(){let A;return A=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${A};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iu={kernelName:n.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{images:j}=A,{alignCorners:te,halfPixelCenters:ie,size:he}=q,[xe,_e]=he,Ue=[{type:"float32",data:[te&&xe>1?1:0,te&&_e>1?1:0]},{type:"float32",data:[te?.5:0]}],nt=new Nc(j.shape,xe,_e,ie);return R.runWebGPUProgram(nt,[j],j.dtype,Ue)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dl{constructor(A,R){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=A,typeof R=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${f("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ml={kernelName:n.RotateWithOffset,backendName:"webgpu",kernelFunc:({inputs:G,attrs:A,backend:R})=>{const{image:q}=G,{radians:j,fillValue:te,center:ie}=A,he=R,xe=new Dl(q.shape,te),[_e,Ue]=n.backend_util.getImageCenter(ie,q.shape[1],q.shape[2]),nt=[{type:"float32",data:[_e]},{type:"float32",data:[Ue]},{type:"float32",data:[Math.sin(j)]},{type:"float32",data:[Math.cos(j)]}];return typeof te=="number"?nt.push({type:"float32",data:[Number.parseFloat(te.toFixed(2))]}):nt.push({type:"float32",data:te}),he.runWebGPUProgram(xe,[q],q.dtype,nt)}},Pl=ds({opType:Me.RSQRT,cpuKernelImpl:qs}),Zc={kernelName:n.Rsqrt,backendName:"webgpu",kernelFunc:Pl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ec{constructor(A,R,q,j,te,ie,he,xe=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=ie,this.type=he,this.sumDupeIndices=xe,this.dispatchLayout=V(A),this.dispatch=U(this.dispatchLayout,A,this.workGroupSize),this.sliceDimGreaterThanOne=R>1,this.shaderKey=`scatter_${q}_${j}_${this.sliceDimGreaterThanOne}_${he}_${xe}`;const _e=l(te.length);this.uniforms=`sliceDim : i32, strides: ${_e}, size: i32,`,this.updatesRank=j,this.indicesRank=q}getUserCode(){let A="";this.indicesRank===1?A="coords[0]":this.indicesRank===2&&(A="coords[0], j");const R=`getIndices(${A})`,q=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let j="",te="";this.dispatchLayout.x.length===1?(j="flattenedIndex",te=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(j="vec2<i32>(flattenedIndex, coords[1])",te=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const ie=`getUpdates(${Array.from({length:this.updatesRank},(he,xe)=>`coords[${xe}]`).join(", ")})`;return`
    ${te}

      ${f("index")} {
        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${R}));
            flattenedIndex = flattenedIndex + indexInside * ${q};
          }
          let updateValue =
              ${E(this.type,!1)}(${ie});
          let flatIndex = getOutputIndexFromCoords(${j});

          ${((he,xe)=>{let _e=`atomicAdd(${he}, bitcast<i32>(${xe}))`;this.type==="float32"&&(_e=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${xe});
            loop {
              let info = atomicCompareExchangeWeak(${he}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${xe});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);const Ue=`atomicStore(${he}, bitcast<i32>(${xe}));`;return this.sumDupeIndices?_e:Ue})("&result[flatIndex]","updateValue")};
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ec={kernelName:n.ScatterNd,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{indices:j,updates:te}=A,{shape:ie}=q,{sliceRank:he,numUpdates:xe,sliceSize:_e,strides:Ue,outputSize:nt}=n.backend_util.calculateShapes(te,j,ie),it=[nt/_e,_e];if(nt===0)return R.makeTensorInfo(ie,j.dtype);const et=Ot({inputs:{x:j},backend:R,attrs:{shape:[xe,he]}}),dt=Ot({inputs:{x:te},backend:R,attrs:{shape:[xe,_e]}}),ut=dt.dtype,Et=ht({backend:R,attrs:{shape:it,value:0,dtype:ut}}),Tt=[{type:"int32",data:[he]},{type:"int32",data:Ue},{type:"int32",data:[n.util.sizeFromShape(dt.shape)]}],Dt=new ec(dt.shape,he,et.shape.length,dt.shape.length,Ue,it,ut),Wt=R.runWebGPUProgram(Dt,[dt,et],ut,Tt,Et),qt=Ot({inputs:{x:Wt},backend:R,attrs:{shape:ie}});return R.disposeData(et.dataId),R.disposeData(dt.dataId),R.disposeData(Wt.dataId),qt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qc{constructor(A,R,q){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=R,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=A,this.rank=q,this.shaderKey="select"}getUserCode(){let A,R;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)R="resRC",A="resRC";else{const q=["resRC.x","resRC.y","resRC.z","resRC.w"],j=[],te=[];for(let ie=0;ie<this.outputShape.length;ie++)te.push(`${q[ie]}`),ie<this.cRank&&j.push(`${q[ie]}`);A=j.join(),R=te.join()}return`
      ${f("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${A});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${R}));
          } else {
            setOutputAtIndex(index, getB(${R}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ll={kernelName:n.Select,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R}=G,{condition:q,t:j,e:te}=A,ie=new Qc(q.shape.length,j.shape,j.shape.length);return R.runWebGPUProgram(ie,[q,j,te],Object(n.upcastType)(j.dtype,te.dtype))}},Eu=ds({opType:Me.SIGMOID}),Bl={kernelName:n.Sigmoid,backendName:"webgpu",kernelFunc:Eu},zl=ds({opType:Me.SIN}),Jc={kernelName:n.Sin,backendName:"webgpu",kernelFunc:zl},Ru=ds({opType:Me.SINH}),uu={kernelName:n.Sinh,backendName:"webgpu",kernelFunc:Ru},tc=Ys({opType:ye.SUB,cpuKernelImpl:mr,supportsComplex:!0}),gr={kernelName:n.Sub,backendName:"webgpu",kernelFunc:tc};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rc={kernelName:n.Softmax,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{logits:j}=A,{dim:te}=q,ie=n.util.parseAxisParam([te],j.shape),he=na({inputs:{x:j},backend:R,attrs:{reductionIndices:ie,keepDims:!1}}),xe=n.backend_util.expandShapeToKeepDim(he.shape,ie),_e=Ot({inputs:{x:he},backend:R,attrs:{shape:xe}}),Ue=tc({inputs:{a:j,b:_e},backend:R}),nt=ci({inputs:{x:Ue},backend:R}),it=Ur({inputs:{x:nt},backend:R,attrs:{axis:ie,keepDims:!1}}),et=Ot({inputs:{x:it},backend:R,attrs:{shape:xe}}),dt=Zu({inputs:{a:nt,b:et},backend:R});return R.disposeData(he.dataId),R.disposeData(_e.dataId),R.disposeData(Ue.dataId),R.disposeData(nt.dataId),R.disposeData(it.dataId),R.disposeData(et.dataId),dt}},Au={kernelName:n.SpaceToBatchND,backendName:"webgpu",kernelFunc:G=>{const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{blockShape:te,paddings:ie}=q;n.util.assert(j.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const he=te.reduce((Tt,Dt)=>Tt*Dt),xe=[[0,0]];xe.push(...ie);for(let Tt=1+te.length;Tt<j.shape.length;++Tt)xe.push([0,0]);const _e=[],Ue=hi({inputs:{x:j},backend:R,attrs:{paddings:xe,constantValue:0}}),nt=n.backend_util.getReshaped(Ue.shape,te,he,!1),it=n.backend_util.getPermuted(nt.length,te.length,!1),et=n.backend_util.getReshapedPermuted(Ue.shape,te,he,!1),dt=Ot({inputs:{x:Ue},backend:R,attrs:{shape:nt}}),ut=Ar({inputs:{x:dt},backend:R,attrs:{perm:it}}),Et=Ot({inputs:{x:ut},backend:R,attrs:{shape:et}});return _e.push(Ue),_e.push(dt),_e.push(ut),_e.forEach(Tt=>R.disposeData(Tt.dataId)),Et}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class el{constructor(A,R){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const q=new Array(A.length);for(let j=0;j<q.length;j++)q[j]=A[j]*R[j];this.outputShape=q,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const A=function(R,q=""){if(R>=5)throw Error(`Tile for rank ${R} is not yet supported`);if(R===1)return`(resRC % ${q}aShape)`;const j=["resRC.x","resRC.y","resRC.z","resRC.w"],te=[];for(let ie=0;ie<R;ie++)te.push(`(${j[ie]} % ${q}aShape[${ie}])`);return te.join()}(this.rank,"uniforms.");return`
      ${f("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${A}));
        }
      }
    `}}function Ko(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{reps:te}=q;if(R.shouldExecuteOnCPU([j])||j.dtype==="string"||j.shape.length>=5){const he=R.readSync(j.dataId),xe=j.dtype==="string"?he.map(nt=>n.util.decodeString(nt)):he,_e=Object(n.buffer)(j.shape,j.dtype,xe),Ue=$r(_e,te);return R.makeTensorInfo(Ue.shape,Ue.dtype,Ue.values)}const ie=new el(j.shape,te);return R.runWebGPUProgram(ie,[j],j.dtype)}const Se={kernelName:n.Tile,backendName:"webgpu",kernelFunc:Ko};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe={kernelName:n.SparseToDense,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{sparseIndices:j,sparseValues:te,defaultValue:ie}=A,{outputShape:he}=q,{sliceRank:xe,numUpdates:_e,sliceSize:Ue,strides:nt,outputSize:it}=n.backend_util.calculateShapes(te,j,he),et=!1;if(te.dtype==="string"){const yn=R.bufferSync(j),Fn=R.bufferSync(te),_n=n.util.decodeString(R.readSync(ie.dataId)[0]),ss=ta(yn,Fn,he,it,Ue,_e,xe,nt,_n,et);return R.makeTensorInfo(he,ss.dtype,ss.values)}const dt=[it/Ue,Ue],ut=Ot({inputs:{x:j},backend:R,attrs:{shape:[_e,xe]}}),Et=te.shape.length?Ot({inputs:{x:te},backend:R,attrs:{shape:[_e,Ue]}}):Un({inputs:{x:te},backend:R}),Tt=Et.dtype,Dt=R.makeTensorInfo([],Tt,n.util.makeZerosTypedArray(1,Tt)),Wt=Ot({inputs:{x:ie},backend:R,attrs:{shape:Array(dt.length).fill(1)}}),qt=Ko({inputs:{x:Wt},backend:R,attrs:{reps:dt}}),cn=[{type:"int32",data:[xe]},{type:"int32",data:nt},{type:"int32",data:[n.util.sizeFromShape([_e,Ue])]}];switch(_e){case 0:break;case 1:{const yn=new ec([_e,Ue],xe,ut.shape.length,Et.shape.length,nt,dt,Tt,et);R.runWebGPUProgram(yn,[Et,ut],Tt,cn,qt)}break;default:{const yn=new ec([_e,Ue],xe,ut.shape.length,Dt.shape.length,nt,dt,Tt,et);R.runWebGPUProgram(yn,[Dt,ut],Tt,cn,qt)}{const yn=new ec([_e,Ue],xe,ut.shape.length,Et.shape.length,nt,dt,Tt);R.runWebGPUProgram(yn,[Et,ut],Tt,cn,qt)}}const rn=Ot({inputs:{x:qt},backend:R,attrs:{shape:he}});return R.disposeData(ut.dataId),R.disposeData(Et.dataId),R.disposeData(Wt.dataId),R.disposeData(Dt.dataId),R.disposeData(qt.dataId),rn}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z={kernelName:n.SplitV,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{numOrSizeSplits:te,axis:ie}=q,he=n.util.parseAxisParam(ie,j.shape)[0],xe=n.backend_util.prepareSplitSize(j,te,he),_e=j.shape.length,Ue=new Array(_e).fill(0),nt=j.shape.slice();return xe.map(it=>{const et=[...nt];et[he]=it;const dt=hs({inputs:{x:j},backend:R,attrs:{begin:Ue,size:et}});return Ue[he]+=it,dt})}},fe=ds({opType:Me.SQRT}),H={kernelName:n.Sqrt,backendName:"webgpu",kernelFunc:fe},ce={kernelName:n.Square,backendName:"webgpu",kernelFunc:({inputs:G,backend:A})=>{const{x:R}=G,q=A,j=new xs(R.shape,Me.SQUARE);return q.runWebGPUProgram(j,[R],R.dtype)}},Ce=Ys({opType:ye.SQUARED_DIFFERENCE}),De={kernelName:n.SquaredDifference,backendName:"webgpu",kernelFunc:Ce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fe{constructor(A){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const R=l(this.outputShape.length);this.uniforms=`begin : ${R},  strides : ${R}, `,this.shaderKey="stridedSlice"}getUserCode(){let A="";if(this.outputShape.length===1)A="coords * uniforms.strides + uniforms.begin";else{let R=0;A=this.outputShape.map((q,j)=>(R++,this.outputShape.length===1?`coords * uniforms.strides[${j}] + uniforms.begin[${j}]`:`coords[${R-1}] * uniforms.strides[${j}] + uniforms.begin[${j}]`)).join(",")}return`
       ${f("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${A}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ie={kernelName:n.StridedSlice,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{begin:te,end:ie,strides:he,beginMask:xe,endMask:_e,ellipsisMask:Ue,newAxisMask:nt,shrinkAxisMask:it}=q,{finalShapeSparse:et,finalShape:dt,isIdentity:ut,sliceDim0:Et,isSimpleSlice:Tt,begin:Dt,end:Wt,strides:qt}=n.slice_util.sliceInfo(j.shape,te,ie,he,xe,_e,Ue,nt,it);let cn;if(ut)cn=Ot({inputs:{x:j},backend:R,attrs:{shape:dt}});else if(Et||Tt){n.util.assert(j.shape.length>=1,()=>`Input must have rank at least 1, got: ${j.shape.length}`);const rn=n.slice_util.computeOutShape(Dt,Wt,qt),yn=hs({inputs:{x:j},backend:R,attrs:{begin:Dt,size:rn}});cn=Ot({inputs:{x:yn},backend:R,attrs:{shape:dt}}),R.disposeData(yn.dataId)}else if(R.shouldExecuteOnCPU([j])){const rn=R.readSync(j.dataId),yn=Object(n.buffer)(j.shape,j.dtype,rn),Fn=eo(et,yn,qt,Dt);cn=R.makeTensorInfo(dt,j.dtype,Fn.values)}else{const rn=new Fe(et),yn=[{type:"int32",data:Dt},{type:"int32",data:qt}],Fn=R.runWebGPUProgram(rn,[j],j.dtype,yn);cn=Ot({inputs:{x:Fn},backend:R,attrs:{shape:dt}}),R.disposeData(Fn.dataId)}return cn}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Te={kernelName:n.StringNGrams,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{separator:j,nGramWidths:te,leftPad:ie,rightPad:he,padWidth:xe,preserveShortSequences:_e}=q,{data:Ue,dataSplits:nt}=A,it=R.readSync(Ue.dataId),et=R.readSync(nt.dataId),[dt,ut]=Qs(it,et,j,te,ie,he,xe,_e);return[R.makeTensorInfo([dt.length],"string",dt),R.makeTensorInfo(nt.shape,"int32",ut)]}},Ye=ds({opType:Me.TANH}),Le={kernelName:n.Tanh,backendName:"webgpu",kernelFunc:Ye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Je{constructor(A){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${f("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class gt{constructor(A){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${f("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(G,A){A!==null&&G.disposeData(A.dataId)}function ft(G){let A=1;for(;A<G;)A*=2;return A}const yt={kernelName:n.TopK,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{x:j}=A,{k:te,sorted:ie}=q,he=j.shape,xe=he[he.length-1];if(R.shouldExecuteOnCPU([j])){const qt=R.readSync(j.dataId),[cn,rn]=ia(qt,he,j.dtype,te,ie);return[R.makeTensorInfo(cn.shape,cn.dtype,cn.values),R.makeTensorInfo(rn.shape,rn.dtype,rn.values)]}if(te===0)return he[he.length-1]=0,[R.makeTensorInfo(he,j.dtype,[]),R.makeTensorInfo(he,"int32",[])];if(xe===1)return[j,ht({attrs:{shape:he,dtype:"int32",value:0},backend:R})];const _e=n.util.sizeFromShape(he)/xe,Ue=Ot({inputs:{x:j},attrs:{shape:[_e,xe]},backend:R}),nt=ft(te),it=ft(xe);let et=null;const dt=()=>et===null?[Ue,Ue]:[Ue,et],ut=(qt,cn,rn)=>{const yn=dt(),Fn=new Je(rn),_n=[{type:"int32",data:[xe]},{type:"int32",data:[et===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[qt]},{type:"int32",data:[cn]}],ss=et;et=R.runWebGPUProgram(Fn,yn,"int32",_n),lt(R,ss)};for(let qt=1;qt<nt;qt*=2){const cn=2*qt;for(let rn=qt;rn>=1;rn/=2)ut(cn,rn,[_e,it])}for(let qt=it;qt>nt;qt/=2){const cn=dt(),rn=new gt([_e,qt/2]),yn=[{type:"int32",data:[xe]},{type:"int32",data:[et===null?1:0]},{type:"int32",data:[nt]}],Fn=et;et=R.runWebGPUProgram(rn,cn,"int32",yn),lt(R,Fn);const _n=nt/2,ss=2*_n;for(let zn=_n;zn>=1;zn/=2)ut(ss,zn,et.shape)}let Et=et;et=hs({inputs:{x:et},backend:R,attrs:{begin:0,size:[_e,te]}}),lt(R,Et);let Tt=Yu({inputs:{x:Ue,indices:et},backend:R,attrs:{axis:1,batchDims:1}});lt(R,Ue);const Dt=he.slice(0,-1);Dt.push(te),Et=et,et=Ot({inputs:{x:et},attrs:{shape:Dt},backend:R}),lt(R,Et);const Wt=Tt;return Tt=Ot({inputs:{x:Tt},attrs:{shape:Dt},backend:R}),lt(R,Wt),[Tt,et]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $t{constructor(A){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=A,this.dispatchLayout=V(this.outputShape),this.dispatch=U(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${f("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bt=[pe,za,Wo,fo,Ea,Vo,so,sn,vn,dr,ro,Va,ri,As,Ji,ai,Uo,Ls,ao,eu,jn,hr,Aa,ui,Go,xo,nu,li,Ei,su,Pt,Ai,Di,Oi,Fi,di,Pi,ou,Sc,Pe,He,Ae,Ws,bo,xt,Nt,St,en,Ze,Jt,In,$o,$n,Jn,It,Ss,Ps,pr,Ku,er,fr,cr,ga,yo,Ao,wo,qo,Bi,ca,zi,Or,Wi,Ol,Fl,Tc,xn,Yc,iu,Ml,Zc,Ec,Ll,Bl,Jc,uu,Es,Ie,Te,Rc,Au,Oe,Z,H,ce,De,gr,oo,Le,Se,yt,{kernelName:n.Transform,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{image:j,transforms:te}=A,{interpolation:ie,fillMode:he,fillValue:xe,outputShape:_e}=q,[Ue,nt,it,et]=j.shape,[dt,ut]=_e!=null?_e:[nt,it],Et=new $t([Ue,dt,ut,et]),Tt=ie==="nearest"?1:2;let Dt;switch(he){case"constant":default:Dt=1;break;case"reflect":Dt=2;break;case"wrap":Dt=3;break;case"nearest":Dt=4}const Wt=[{type:"int32",data:[Tt]},{type:"int32",data:[Dt]},{type:"float32",data:[xe]}];return R.runWebGPUProgram(Et,[j,te],"float32",Wt)}},Na,{kernelName:n.Unpack,backendName:"webgpu",kernelFunc:function(G){const{inputs:A,backend:R,attrs:q}=G,{value:j}=A;let{axis:te}=q;te<0&&(te+=j.shape.length);const ie=j,he=ie.shape.length,xe=j.shape[te],_e=new Array(he-1);let Ue=0;for(let ut=0;ut<he;ut++)ut!==te&&(_e[Ue++]=ie.shape[ut]);const nt=[],it=new Array(he).fill(0),et=ie.shape.slice();et[te]=1;const dt=new Array(xe);for(let ut=0;ut<dt.length;ut++){it[te]=ut;const Et=hs({inputs:{x:ie},backend:R,attrs:{begin:it,size:et}}),Tt=Ot({inputs:{x:Et},backend:R,attrs:{shape:_e}});dt[ut]=Tt,nt.push(Et)}return nt.forEach(ut=>R.disposeData(ut.dataId)),dt}},Ca];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const G of Bt)Object(n.registerKernel)(G);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(s,e,t){var n=t(0),r=t(7);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a=n.kernel_impls.whereImpl;class o extends n.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new n.DataStorage(this,Object(n.engine)())}nextDataId(){return o.nextDataId++}write(Oe,Z,fe){this.firstUse&&(this.firstUse=!1,Object(n.env)().get("IS_NODE")&&n.backend_util.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const H={id:this.nextDataId()};return this.data.set(H,{values:Oe,dtype:fe,refCount:1}),H}makeTensorInfo(Oe,Z,fe){let H;if(Z==="string"&&fe!=null&&fe.length>0&&n.util.isString(fe[0])){const ce=fe.map(Ce=>n.util.encodeString(Ce));H=this.write(ce,Oe,Z)}else H=this.write(fe,Oe,Z);return{dataId:H,shape:Oe,dtype:Z}}refCount(Oe){return this.data.has(Oe)?this.data.get(Oe).refCount:0}incRef(Oe){this.data.get(Oe).refCount++}decRef(Oe){this.data.has(Oe)&&this.data.get(Oe).refCount--}move(Oe,Z,fe,H,ce){this.data.set(Oe,{values:Z,dtype:H,refCount:ce})}numDataIds(){return this.data.numDataIds()}async read(Oe){return this.readSync(Oe)}readSync(Oe){const{dtype:Z,complexTensorInfos:fe}=this.data.get(Oe);if(Z==="complex64"){const H=this.readSync(fe.real.dataId),ce=this.readSync(fe.imag.dataId);return n.backend_util.mergeRealAndImagArrays(H,ce)}return this.data.get(Oe).values}bufferSync(Oe){const Z=this.readSync(Oe.dataId);if(Oe.dtype==="string")try{const fe=Z.map(H=>n.util.decodeString(H));return Object(n.buffer)(Oe.shape,Oe.dtype,fe)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(n.buffer)(Oe.shape,Oe.dtype,Z)}makeOutput(Oe,Z,fe){return Object(n.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(Z,fe,Oe),this)}disposeData(Oe,Z=!1){if(this.data.has(Oe)){if(this.data.get(Oe).refCount--,!Z&&this.data.get(Oe).refCount>0)return!1;const{complexTensorInfos:fe}=this.data.get(Oe);fe!=null&&(this.disposeData(fe.real.dataId,!0),this.disposeData(fe.imag.dataId,!0)),this.data.delete(Oe)}return!0}disposeIntermediateTensorInfo(Oe){this.disposeData(Oe.dataId)}async time(Oe){const Z=n.util.now();return Oe(),{kernelMs:n.util.now()-Z}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(Oe){Object(r.a)([Oe],"where");const Z=this.readSync(Oe.dataId);return a(Oe.shape,Z)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}o.nextDataId=0,Object(n.registerBackend)("cpu",()=>new o,1);var i=t(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u=Object(i.a)(n.Elu,Se=>Se>=0?Se:Math.exp(Se)-1),c={kernelName:n.Elu,backendName:"cpu",kernelFunc:u};var d=t(19);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{alpha:ce}=fe;Object(r.a)([H],"leakyRelu");const Ce=n.util.sizeFromShape(H.shape),De=Z.data.get(H.dataId).values,Fe=n.util.getTypedArrayFromDType("float32",Ce);for(let Ie=0;Ie<De.length;Ie++)Fe[Ie]=De[Ie]<0?ce*De[Ie]:De[Ie];return Z.makeTensorInfo(H.shape,"float32",Fe)}const l={kernelName:n.LeakyRelu,backendName:"cpu",kernelFunc:h};var p=t(12);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f=Object(p.a)((Se,Oe)=>Se<0?Oe*Se:Se);function x(Se){const{inputs:Oe,backend:Z}=Se,{x:fe,alpha:H}=Oe;Object(r.a)([fe,H],"prelu");const ce=Z.data.get(fe.dataId).values,Ce=Z.data.get(H.dataId).values,[De,Fe]=f(fe.shape,H.shape,ce,Ce,"float32");return Z.makeTensorInfo(Fe,"float32",De)}const b={kernelName:n.Prelu,backendName:"cpu",kernelFunc:x},m=Object(i.a)(n.Relu,Se=>Math.max(0,Se)),I={kernelName:n.Relu,backendName:"cpu",kernelFunc:m},N=Object(i.a)(n.Relu6,Se=>Math.min(Math.max(0,Se),6)),E={kernelName:n.Relu6,backendName:"cpu",kernelFunc:N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var D=t(47);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U(Se,Oe,Z,fe,H){if(Z==="linear")return Object(d.a)({inputs:{x:Oe},backend:Se});if(Z==="relu")return m({inputs:{x:Oe},backend:Se});if(Z==="elu")return u({inputs:{x:Oe},backend:Se});if(Z==="relu6")return N({inputs:{x:Oe},backend:Se});if(Z==="prelu")return x({inputs:{x:Oe,alpha:fe},backend:Se});if(Z==="leakyrelu")return h({inputs:{x:Oe},backend:Se,attrs:{alpha:H}});if(Z==="sigmoid")return Object(D.a)({inputs:{x:Oe},backend:Se});throw new Error(`Activation ${Z} has not been implemented for the CPU backend.`)}var L=t(24);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{shape:ce}=fe,Ce=n.util.sizeFromShape(H.shape),De=n.util.inferFromImplicitShape(ce,Ce),Fe=n.util.sizeFromShape(De);n.util.assert(Ce===Fe,()=>`The new shape (${De}) has ${Fe} elements and the old shape (${H.shape}) has ${Ce} elements. The new shape and old shape must have the same number of elements.`),Z.incRef(H.dataId);const Ie=Z.data.get(H.dataId);if(Ie.complexTensorInfos!=null){const Te=Ie.complexTensorInfos.real,Ye=Ie.complexTensorInfos.imag;Te.shape=De,Ye.shape=De}return{dataId:H.dataId,shape:De,dtype:H.dtype}}const V={kernelName:n.Reshape,backendName:"cpu",kernelFunc:Y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{a:H,b:ce}=Oe,{transposeA:Ce,transposeB:De}=fe;Object(r.a)([H,ce],"matMul");const Fe=H.shape.length,Ie=ce.shape.length,Te=Ce?H.shape[Fe-2]:H.shape[Fe-1],Ye=De?ce.shape[Ie-1]:ce.shape[Ie-2],Le=Ce?H.shape[Fe-1]:H.shape[Fe-2],Je=De?ce.shape[Ie-2]:ce.shape[Ie-1],gt=H.shape.slice(0,-2),lt=ce.shape.slice(0,-2),ft=n.util.sizeFromShape(gt),yt=n.util.sizeFromShape(lt),$t=n.broadcast_util.assertAndGetBroadcastShape(H.shape.slice(0,-2),ce.shape.slice(0,-2)).concat([Le,Je]);n.util.assert(Te===Ye,()=>`Error in matMul: inner shapes (${Te}) and (${Ye}) of Tensors with shapes ${H.shape} and ${ce.shape} and transposeA=${Ce} and transposeB=${De} must match.`);const Bt=De?[yt,Je,Ye]:[yt,Ye,Je],G=Y({inputs:{x:H},backend:Z,attrs:{shape:Ce?[ft,Te,Le]:[ft,Le,Te]}}),A=Y({inputs:{x:ce},backend:Z,attrs:{shape:Bt}}),R=Ce?G.shape[1]:G.shape[2],q=Ce?G.shape[2]:G.shape[1],j=De?A.shape[1]:A.shape[2],te=Math.max(ft,yt),ie=Z.data.get(G.dataId).values,he=Z.data.get(A.dataId).values,xe=n.util.computeStrides(G.shape),_e=n.util.computeStrides(A.shape),[Ue,nt,it]=Ce?[xe[0],1,xe[1]]:[xe[0],xe[1],1],[et,dt,ut]=De?[1,_e[1],_e[0]]:[_e[1],1,_e[0]],Et=q*j,Tt=Object(n.buffer)([te,q,j],G.dtype),Dt=Tt.values,Wt=Z.blockSize;for(let qt=0;qt<te;qt++)for(let cn=0;cn<q;cn+=Wt)for(let rn=0;rn<j;rn+=Wt)for(let yn=0;yn<R;yn+=Wt){const Fn=Math.min(cn+Wt,q),_n=Math.min(rn+Wt,j),ss=Math.min(yn+Wt,R);for(let zn=cn;zn<Fn;zn++)for(let Kn=rn;Kn<_n;Kn++){let us=0;for(let ps=yn;ps<ss;ps++){const es=Math.min(qt,ft-1)*Ue,ks=Math.min(qt,yt-1)*ut;us+=ie[es+zn*nt+ps*it]*he[ps*et+Kn*dt+ks]}Dt[qt*Et+(zn*j+Kn)]+=us}}return Z.disposeIntermediateTensorInfo(G),Z.disposeIntermediateTensorInfo(A),Z.makeTensorInfo($t,Tt.dtype,Tt.values)}const oe={kernelName:n.BatchMatMul,backendName:"cpu",kernelFunc:P};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ne={kernelName:n._FusedMatMul,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{a:H,b:ce,bias:Ce,preluActivationWeights:De}=Oe,{transposeA:Fe,transposeB:Ie,activation:Te,leakyreluAlpha:Ye}=fe;let Le,Je,gt;const lt=[];Le=P({inputs:{a:H,b:ce},attrs:{transposeA:Fe,transposeB:Ie},backend:Z}),Ce&&(Je=Object(L.a)({inputs:{a:Le,b:Ce},backend:Z}),lt.push(Le),Le=Je),Te&&(gt=U(Z,Le,Te,De,Ye),lt.push(Le),Le=gt);for(const ft of lt)Z.disposeIntermediateTensorInfo(ft);return Le}};var ge=t(56);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ye=Object(i.a)(n.Acos,Se=>Math.acos(Se)),Ee={kernelName:n.Acos,backendName:"cpu",kernelFunc:ye},X=Object(i.a)(n.Acosh,Se=>Math.acosh(Se)),je={kernelName:n.Acosh,backendName:"cpu",kernelFunc:X},Be={kernelName:n.AddN,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,fe=Oe;Object(r.a)(Oe,"addN");const H=fe.map(De=>Z.data.get(De.dataId).values),ce=Object(n.buffer)(fe[0].shape,fe[0].dtype),Ce=ce.values;for(let De=0;De<fe.length;De++){const Fe=H[De];for(let Ie=0;Ie<Ce.length;Ie++)Ce[Ie]+=Fe[Ie]}return Z.makeTensorInfo(ce.shape,ce.dtype,ce.values)}};var tt=t(16);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ct={kernelName:n.All,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,keepDims:Ce}=fe;Object(r.a)(H,"all");const De=n.util.parseAxisParam(ce,H.shape);let Fe=De;const Ie=n.backend_util.getAxesPermutation(Fe,H.shape.length);let Te=H;Ie!=null&&(Te=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:Ie}}),Fe=n.backend_util.getInnerMostAxes(Fe.length,H.shape.length)),n.backend_util.assertAxesAreInnerMostDims("all",Fe,Te.shape.length);const[Ye,Le]=n.backend_util.computeOutAndReduceShapes(Te.shape,Fe),Je=n.util.sizeFromShape(Le),gt=n.util.makeZerosTypedArray(n.util.sizeFromShape(Ye),Te.dtype),lt=Z.data.get(Te.dataId).values;for(let yt=0;yt<gt.length;++yt){const $t=yt*Je;let Bt=lt[$t];for(let G=0;G<Je;++G){const A=lt[$t+G];Bt=Bt&&A}gt[yt]=Bt}Ie!=null&&Z.disposeIntermediateTensorInfo(Te);const ft=Z.makeTensorInfo(Ye,Te.dtype,gt);if(Ce){const yt=Y({inputs:{x:ft},backend:Z,attrs:{shape:n.backend_util.expandShapeToKeepDim(Ye,De)}});return Z.disposeIntermediateTensorInfo(ft),yt}return ft}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Me={kernelName:n.Any,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,keepDims:Ce}=fe;Object(r.a)(H,"any");const De=n.util.parseAxisParam(ce,H.shape);let Fe=De;const Ie=n.backend_util.getAxesPermutation(Fe,H.shape.length);let Te=H;Ie!=null&&(Te=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:Ie}}),Fe=n.backend_util.getInnerMostAxes(Fe.length,H.shape.length)),n.backend_util.assertAxesAreInnerMostDims("any",Fe,Te.shape.length);const[Ye,Le]=n.backend_util.computeOutAndReduceShapes(Te.shape,Fe),Je=n.util.sizeFromShape(Le),gt=n.util.makeZerosTypedArray(n.util.sizeFromShape(Ye),Te.dtype),lt=Z.data.get(Te.dataId).values;for(let yt=0;yt<gt.length;++yt){const $t=yt*Je;let Bt=lt[$t];for(let G=0;G<Je;++G){const A=lt[$t+G];Bt=Bt||A}gt[yt]=Bt}Ie!=null&&Z.disposeIntermediateTensorInfo(Te);const ft=Z.makeTensorInfo(Ye,Te.dtype,gt);if(Ce){const yt=Y({inputs:{x:ft},backend:Z,attrs:{shape:n.backend_util.expandShapeToKeepDim(Ye,De)}});return Z.disposeIntermediateTensorInfo(ft),yt}return ft}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wt={kernelName:n.ArgMax,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce}=fe;Object(r.a)(H,"argMax");let Ce=n.util.parseAxisParam(ce,H.shape);const De=n.backend_util.getAxesPermutation(Ce,H.shape.length);let Fe=H;const Ie=[];De!=null&&(Fe=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:De}}),Ie.push(Fe),Ce=n.backend_util.getInnerMostAxes(Ce.length,Fe.shape.length)),Ce=[Ce[0]],n.backend_util.assertAxesAreInnerMostDims("argMax",Ce,Fe.shape.length);const[Te,Ye]=n.backend_util.computeOutAndReduceShapes(Fe.shape,Ce),Le=n.util.sizeFromShape(Te),Je=n.util.makeZerosTypedArray(Le,"int32"),gt=n.util.sizeFromShape(Ye),lt=Z.data.get(Fe.dataId).values;for(let ft=0;ft<Je.length;++ft){const yt=ft*gt;let $t=lt[yt],Bt=0;for(let G=0;G<gt;++G){const A=lt[yt+G];A>$t&&($t=A,Bt=G)}Je[ft]=Bt}return Ie.forEach(ft=>Z.disposeIntermediateTensorInfo(ft)),Z.makeTensorInfo(Te,"int32",Je)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at={kernelName:n.ArgMin,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce}=fe;Object(r.a)(H,"argMin");let Ce=n.util.parseAxisParam(ce,H.shape);const De=n.backend_util.getAxesPermutation(Ce,H.shape.length);let Fe=H;const Ie=[];De!=null&&(Fe=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:De}}),Ie.push(Fe),Ce=n.backend_util.getInnerMostAxes(Ce.length,Fe.shape.length)),Ce=[Ce[0]],n.backend_util.assertAxesAreInnerMostDims("argMin",Ce,Fe.shape.length);const[Te,Ye]=n.backend_util.computeOutAndReduceShapes(Fe.shape,Ce),Le=n.util.sizeFromShape(Te),Je=n.util.makeZerosTypedArray(Le,"int32"),gt=n.util.sizeFromShape(Ye),lt=Z.data.get(Fe.dataId).values;for(let ft=0;ft<Je.length;++ft){const yt=ft*gt;let $t=lt[yt],Bt=0;for(let G=0;G<gt;++G){const A=lt[yt+G];A<$t&&($t=A,Bt=G)}Je[ft]=Bt}return Ie.forEach(ft=>Z.disposeIntermediateTensorInfo(ft)),Z.makeTensorInfo(Te,"int32",Je)}},Gt=Object(i.a)(n.Asin,Se=>Math.asin(Se)),Ht={kernelName:n.Asin,backendName:"cpu",kernelFunc:Gt},dn=Object(i.a)(n.Asinh,Se=>Math.asinh(Se)),mn={kernelName:n.Asinh,backendName:"cpu",kernelFunc:dn},Rn=Object(i.a)(n.Atan,Se=>Math.atan(Se)),ee={kernelName:n.Atan,backendName:"cpu",kernelFunc:Rn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var se=t(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const we=Object(p.a)((Se,Oe)=>Math.atan2(Se,Oe)),pt=Object(se.a)(n.Atan2,we),bt={kernelName:n.Atan2,backendName:"cpu",kernelFunc:pt},At=Object(i.a)(n.Atanh,Se=>Math.atanh(Se)),$e={kernelName:n.Atanh,backendName:"cpu",kernelFunc:At};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(Se,Oe,Z,fe,H,ce){const Ce=H.strideHeight,De=H.strideWidth,Fe=H.dilationHeight,Ie=H.dilationWidth,Te=H.effectiveFilterHeight,Ye=H.effectiveFilterWidth,Le=H.padInfo.top,Je=H.padInfo.left,gt=ce==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,lt=Object(n.buffer)(H.outShape,Z),ft=lt.values,yt=H.outShape[1]*H.outShape[2]*H.outShape[3],$t=H.outShape[2]*H.outShape[3],Bt=H.outShape[3];for(let G=0;G<H.batchSize;++G){const A=G*yt,R=G*fe[0];for(let q=0;q<H.inChannels;++q)for(let j=0;j<H.outHeight;++j){const te=j*Ce-Le,ie=Math.max(0,te),he=Math.min(H.inHeight,Te+te),xe=A+j*$t;for(let _e=0;_e<H.outWidth;++_e){const Ue=_e*De-Je,nt=Math.max(0,Ue),it=Math.min(H.inWidth,Ye+Ue);let et=gt,dt=0,ut=0;for(let Et=ie;Et<he;Et+=Fe){const Tt=R+Et*fe[1];for(let Dt=nt;Dt<it;Dt+=Ie){const Wt=Se[Tt+Dt*fe[2]+q];ce==="max"&&Wt>et?et=Wt:ce==="avg"&&(dt+=Wt,ut++)}if(isNaN(et))break}ft[xe+_e*Bt+q]=ce==="avg"?dt/ut:et}}}return lt}function Pt(Se,Oe,Z,fe,H=!1,ce=!1){const Ce=Object(n.buffer)(fe.outShape,"int32"),De=fe.strideHeight,Fe=fe.strideWidth,Ie=fe.dilationHeight,Te=fe.dilationWidth,Ye=fe.effectiveFilterHeight,Le=fe.effectiveFilterWidth,Je=fe.padInfo.top,gt=fe.padInfo.left,lt=Object(n.buffer)(Oe,Z,Se);for(let ft=0;ft<fe.batchSize;++ft)for(let yt=0;yt<fe.inChannels;++yt)for(let $t=0;$t<fe.outHeight;++$t){const Bt=$t*De-Je;let G=Bt;for(;G<0;)G+=Ie;const A=Math.min(fe.inHeight,Ye+Bt);for(let R=0;R<fe.outWidth;++R){const q=R*Fe-gt;let j=q;for(;j<0;)j+=Te;const te=Math.min(fe.inWidth,Le+q);let ie=Number.NEGATIVE_INFINITY,he=-1;for(let xe=G;xe<A;xe+=Ie){const _e=xe-Bt;for(let Ue=j;Ue<te;Ue+=Te){const nt=Ue-q,it=lt.get(ft,xe,Ue,yt);it>ie&&(ie=it,he=H?ce?((ft*fe.inHeight+xe)*fe.inWidth+Ue)*fe.inChannels+yt:(xe*fe.inWidth+Ue)*fe.inChannels+yt:_e*Le+nt)}}Ce.set(he,ft,$t,R,yt)}}return Ce}function Ot(Se,Oe,Z,fe,H,ce){const Ce=H.strideDepth,De=H.strideHeight,Fe=H.strideWidth,Ie=H.dilationDepth,Te=H.dilationHeight,Ye=H.dilationWidth,Le=H.effectiveFilterDepth,Je=H.effectiveFilterHeight,gt=H.effectiveFilterWidth,lt=H.padInfo.front,ft=H.padInfo.top,yt=H.padInfo.left,$t=ce==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,Bt=Object(n.buffer)(H.outShape,Z),G=Bt.values,A=H.outShape[1]*H.outShape[2]*H.outShape[3]*H.outShape[4],R=H.outShape[2]*H.outShape[3]*H.outShape[4],q=H.outShape[3]*H.outShape[4],j=H.outShape[4];for(let te=0;te<H.batchSize;++te){const ie=te*A,he=te*fe[0];for(let xe=0;xe<H.inChannels;++xe)for(let _e=0;_e<H.outDepth;++_e){const Ue=_e*Ce-lt;let nt=Ue;for(;nt<0;)nt+=Ie;const it=Math.min(H.inDepth,Le+Ue),et=ie+_e*R;for(let dt=0;dt<H.outHeight;++dt){const ut=dt*De-ft;let Et=ut;for(;Et<0;)Et+=Te;const Tt=Math.min(H.inHeight,Je+ut),Dt=et+dt*q;for(let Wt=0;Wt<H.outWidth;++Wt){const qt=Wt*Fe-yt;let cn=qt;for(;cn<0;)cn+=Ye;const rn=Math.min(H.inWidth,gt+qt),yn=Dt+Wt*j;let Fn=$t,_n=0,ss=0;for(let zn=nt;zn<it;zn+=Ie){const Kn=he+zn*fe[1];for(let us=Et;us<Tt;us+=Te){const ps=Kn+us*fe[2];for(let es=cn;es<rn;es+=Ye){const ks=Se[ps+es*fe[3]+xe];if(ce==="max"&&ks>Fn?Fn=ks:ce==="avg"&&(_n+=ks,ss++),isNaN(Fn))break}if(isNaN(Fn))break}if(isNaN(Fn))break}G[yn+xe]=ce==="avg"?_n/ss:Fn}}}}return Bt}const xn={kernelName:n.AvgPool,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe;Object(r.a)(H,"avgPool");const{filterSize:ce,strides:Ce,pad:De,dimRoundingMode:Fe}=fe;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(Ce,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${Ce} and dilations '1'`);const Ie=n.backend_util.computePool2DInfo(H.shape,ce,Ce,1,De,Fe);let Te;if(Ie.filterWidth===1&&Ie.filterHeight===1&&n.util.arraysEqual(Ie.inShape,Ie.outShape))Te=Object(d.a)({inputs:{x:H},backend:Z});else{const Ye=Z.data.get(H.dataId).values,Le=n.util.computeStrides(H.shape),Je=ht(Ye,H.shape,H.dtype,Le,Ie,"avg");Te=Z.makeTensorInfo(Ie.outShape,H.dtype,Je.values)}return Te}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dn={kernelName:n.AvgPool3D,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{filterSize:ce,strides:Ce,pad:De,dimRoundingMode:Fe,dataFormat:Ie}=fe;Object(r.a)(H,"avgPool3d");const Te=n.backend_util.computePool3DInfo(H.shape,ce,Ce,1,De,Fe,Ie),Ye=Ot(Z.data.get(H.dataId).values,H.shape,H.dtype,n.util.computeStrides(H.shape),Te,"avg");return Z.makeTensorInfo(Ye.shape,"float32",Ye.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pe={kernelName:n.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,input:ce}=Oe,{filterSize:Ce,strides:De,pad:Fe,dimRoundingMode:Ie}=fe;Object(r.a)([H,ce],"avgPool3DGrad");const Te=n.backend_util.computePool3DInfo(ce.shape,Ce,De,1,Fe,Ie),Ye=Te.strideDepth,Le=Te.strideHeight,Je=Te.strideWidth,gt=Te.filterDepth,lt=Te.filterHeight,ft=Te.filterWidth,yt=Te.dilationDepth,$t=Te.dilationHeight,Bt=Te.dilationWidth,G=Te.effectiveFilterDepth,A=Te.effectiveFilterHeight,R=Te.effectiveFilterWidth,q=G-1-Te.padInfo.front,j=R-1-Te.padInfo.left,te=A-1-Te.padInfo.top,ie=Object(n.buffer)(ce.shape,"float32"),he=1/(gt*lt*ft),xe=Z.bufferSync(H);for(let _e=0;_e<Te.batchSize;++_e)for(let Ue=0;Ue<Te.inChannels;++Ue)for(let nt=0;nt<Te.inDepth;++nt)for(let it=0;it<Te.inHeight;++it)for(let et=0;et<Te.inWidth;++et){const dt=nt-q,ut=it-te,Et=et-j;let Tt=0;for(let Dt=0;Dt<G;Dt+=yt){const Wt=(dt+Dt)/Ye;if(!(Wt<0||Wt>=Te.outDepth||Math.floor(Wt)!==Wt))for(let qt=0;qt<A;qt+=$t){const cn=(ut+qt)/Le;if(!(cn<0||cn>=Te.outHeight||Math.floor(cn)!==cn))for(let rn=0;rn<R;rn+=Bt){const yn=(Et+rn)/Je;yn<0||yn>=Te.outWidth||Math.floor(yn)!==yn||(Tt+=xe.get(_e,Wt,cn,yn,Ue))}}}ie.set(Tt*he,_e,nt,it,et,Ue)}return Z.makeTensorInfo(ie.shape,ie.dtype,ie.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const be={kernelName:n.AvgPoolGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,input:ce}=Oe,Ce=ce;Object(r.a)([H,ce],"avgPoolGrad");const{filterSize:De,strides:Fe,pad:Ie}=fe,Te=n.backend_util.computePool2DInfo(Ce.shape,De,Fe,1,Ie),Ye=Te.strideHeight,Le=Te.strideWidth,Je=Te.filterHeight,gt=Te.filterWidth,lt=Te.dilationHeight,ft=Te.dilationWidth,yt=Te.effectiveFilterHeight,$t=Te.effectiveFilterWidth,Bt=$t-1-Te.padInfo.left,G=yt-1-Te.padInfo.top,A=Object(n.buffer)(Ce.shape,"float32"),R=1/(Je*gt),q=Z.data.get(H.dataId).values,j=Object(n.buffer)(H.shape,"float32",q);for(let te=0;te<Te.batchSize;++te)for(let ie=0;ie<Te.inChannels;++ie)for(let he=0;he<Te.inHeight;++he)for(let xe=0;xe<Te.inWidth;++xe){const _e=he-G,Ue=xe-Bt;let nt=0;for(let it=0;it<yt;it+=lt){const et=(_e+it)/Ye;if(!(et<0||et>=Te.outHeight||Math.floor(et)!==et))for(let dt=0;dt<$t;dt+=ft){const ut=(Ue+dt)/Le;ut<0||ut>=Te.outWidth||Math.floor(ut)!==ut||(nt+=j.get(te,et,ut,ie))}}A.set(nt*R,te,he,xe,ie)}return Z.makeTensorInfo(A.shape,A.dtype,A.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qe={kernelName:n.FusedBatchNorm,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,scale:ce,offset:Ce,mean:De,variance:Fe}=Oe;n.util.assert(De.shape.length===Fe.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),n.util.assert(Ce==null||De.shape.length===Ce.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),n.util.assert(ce==null||De.shape.length===ce.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Object(r.a)([H,De,Fe,ce,Ce],"batchNorm");let{varianceEpsilon:Ie}=fe;Ie==null&&(Ie=.001);const Te=Z.data.get(H.dataId).values,Ye=Z.data.get(De.dataId).values,Le=Z.data.get(Fe.dataId).values,Je=ce?Z.data.get(ce.dataId).values:new Float32Array([1]),gt=Ce?Z.data.get(Ce.dataId).values:new Float32Array([0]),lt=new Float32Array(Te.length),ft=gt.length,yt=Je.length,$t=Le.length,Bt=Ye.length;let G=0,A=0,R=0,q=0;for(let j=0;j<Te.length;++j)lt[j]=gt[G++]+(Te[j]-Ye[A++])*Je[R++]/Math.sqrt(Le[q++]+Ie),G>=ft&&(G=0),A>=Bt&&(A=0),R>=yt&&(R=0),q>=$t&&(q=0);return Z.makeTensorInfo(H.shape,H.dtype,lt)}};var Un=t(23);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ws={kernelName:n.BatchToSpaceND,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{blockShape:ce,crops:Ce}=fe;Object(r.a)([H],"batchToSpaceND");const De=ce.reduce((yt,$t)=>yt*$t),Fe=n.backend_util.getReshaped(H.shape,ce,De),Ie=n.backend_util.getPermuted(Fe.length,ce.length),Te=n.backend_util.getReshapedPermuted(H.shape,ce,De),Ye=n.backend_util.getSliceBeginCoords(Ce,ce.length),Le=n.backend_util.getSliceSize(Te,Ce,ce.length),Je=Y({inputs:{x:H},backend:Z,attrs:{shape:Fe}}),gt=Object(tt.a)({inputs:{x:Je},backend:Z,attrs:{perm:Ie}}),lt=Y({inputs:{x:gt},backend:Z,attrs:{shape:Te}}),ft=Object(Un.a)({inputs:{x:lt},backend:Z,attrs:{begin:Ye,size:Le}});return Z.disposeIntermediateTensorInfo(Je),Z.disposeIntermediateTensorInfo(gt),Z.disposeIntermediateTensorInfo(lt),ft}};var Gs=t(35);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const As={kernelName:n.Bincount,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,weights:ce}=Oe,{size:Ce}=fe,De=Z.data.get(H.dataId).values,Fe=Z.data.get(ce.dataId).values,Ie=Object(Gs.a)(De,Fe,ce.dtype,ce.shape,Ce);return Z.makeTensorInfo([Ce],ce.dtype,Ie)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xs={kernelName:n.BroadcastArgs,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{s0:fe,s1:H}=Oe,ce=Z.data.get(fe.dataId).values,Ce=Z.data.get(H.dataId).values,De=n.backend_util.assertAndGetBroadcastShape(Array.from(ce),Array.from(Ce));return Z.makeTensorInfo([De.length],"int32",Int32Array.from(De))}};var ds=t(25),Ys=t(57);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pn=Object(i.a)(n.ClipByValue,(Se,Oe)=>{const Z=Oe;return Se>Z.clipValueMax?Z.clipValueMax:Se<Z.clipValueMin?Z.clipValueMin:Se}),Nn={kernelName:n.ClipByValue,backendName:"cpu",kernelFunc:pn};var ts=t(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $s={kernelName:n.ComplexAbs,backendName:"cpu",kernelFunc:Se=>{const{x:Oe}=Se.inputs,Z=Se.backend,fe=new Float32Array(n.util.sizeFromShape(Oe.shape)),H=Z.data.get(Oe.dataId),ce=H.complexTensorInfos.real,Ce=H.complexTensorInfos.imag,De=Z.data.get(ce.dataId).values,Fe=Z.data.get(Ce.dataId).values;for(let Ie=0;Ie<De.length;Ie++){const Te=De[Ie],Ye=Fe[Ie];fe[Ie]=Math.hypot(Te,Ye)}return Z.makeOutput(fe,Oe.shape,"float32")}};var Ns=t(58);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(Se){const{inputs:Oe,backend:Z}=Se,{input:fe}=Oe,H=Z.data.get(fe.dataId).complexTensorInfos.imag,ce=Z.data.get(H.dataId).values;return Z.makeTensorInfo(H.shape,H.dtype,ce)}const Vs={kernelName:n.Imag,backendName:"cpu",kernelFunc:ys};var Us=t(26);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{axis:H}=fe,ce=n.util.parseAxisParam(H,Oe[0].shape)[0];let Ce=n.backend_util.computeOutShape(Oe.map(lt=>lt.shape),ce);if(n.util.sizeFromShape(Ce)===0)return Z.makeTensorInfo(Ce,Oe[0].dtype,[]);const De=Oe.filter(lt=>n.util.sizeFromShape(lt.shape)>0);if(De.length===1)return Object(d.a)({inputs:{x:De[0]},backend:Z});const Fe=De.map(lt=>lt.shape);if(n.backend_util.assertParamsConsistent(Fe,ce),De[0].dtype==="complex64"){const lt=De.map(G=>Object(Us.a)({inputs:{input:G},backend:Z})),ft=De.map(G=>ys({inputs:{input:G},backend:Z})),yt=jt({inputs:lt,backend:Z,attrs:{axis:ce}}),$t=jt({inputs:ft,backend:Z,attrs:{axis:ce}}),Bt=Object(ts.a)({inputs:{real:yt,imag:$t},backend:Z});return lt.forEach(G=>Z.disposeIntermediateTensorInfo(G)),ft.forEach(G=>Z.disposeIntermediateTensorInfo(G)),Z.disposeIntermediateTensorInfo(yt),Z.disposeIntermediateTensorInfo($t),Bt}const Ie=De.map(lt=>{const ft=n.util.sizeFromShape(lt.shape.slice(ce));return Y({inputs:{x:lt},backend:Z,attrs:{shape:[-1,ft]}})}),Te=Ie.map(lt=>({vals:Z.data.get(lt.dataId).values,shape:lt.shape}));Ce=n.backend_util.computeOutShape(Ie.map(lt=>lt.shape),1);const Ye=Ie[0].shape[0]===1,Le=Object(Ns.a)(Te,Ce,Oe[0].dtype,Ye),Je=n.backend_util.computeOutShape(De.map(lt=>lt.shape),ce),gt=Z.makeTensorInfo(Je,Oe[0].dtype,Le);return Ie.forEach(lt=>Z.disposeIntermediateTensorInfo(lt)),gt}const re={kernelName:n.Concat,backendName:"cpu",kernelFunc:jt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,filter:ce}=Oe,{strides:Ce,pad:De,dataFormat:Fe,dilations:Ie,dimRoundingMode:Te}=fe;Object(r.a)([H,ce],"conv2d");const Ye=n.backend_util.convertConv2DDataFormat(Fe),Le=n.backend_util.computeConv2DInfo(H.shape,ce.shape,Ce,Ie,De,Te,!1,Ye),Je=Le.filterHeight,gt=Le.filterWidth,lt=Le.dilationHeight,ft=Le.dilationWidth,yt=Le.padInfo.left,$t=Le.padInfo.top,Bt=Le.dataFormat==="channelsLast",G=new n.TensorBuffer(Le.outShape,H.dtype),A=n.util.computeStrides(H.shape),R=n.util.computeStrides(ce.shape),q=A[0],j=Bt?A[1]:A[2],te=Bt?A[2]:1,ie=Bt?1:A[1],he=G.strides[0],xe=Bt?G.strides[1]:G.strides[2],_e=Bt?G.strides[2]:1,Ue=Bt?1:G.strides[1],nt=Z.data.get(H.dataId).values,it=Z.data.get(ce.dataId).values,et=G.values;for(let dt=0;dt<Le.batchSize;++dt){const ut=dt*q,Et=dt*he;for(let Tt=0;Tt<Le.outHeight;++Tt){const Dt=Et+Tt*xe,Wt=Tt*Le.strideHeight-$t;for(let qt=0;qt<Je;++qt){const cn=Wt+qt*lt;if(cn<0||cn>=Le.inHeight)continue;const rn=qt*R[0],yn=ut+cn*j;for(let Fn=0;Fn<Le.outWidth;++Fn){const _n=Dt+Fn*_e,ss=Fn*Le.strideWidth-yt;for(let zn=0;zn<gt;++zn){const Kn=ss+zn*ft;if(Kn<0||Kn>=Le.inWidth)continue;const us=yn+Kn*te;let ps=rn+zn*R[1];for(let es=0;es<Le.inChannels;++es){const ks=nt[us+es*ie];for(let Ks=0;Ks<Le.outChannels;++Ks)et[_n+Ks*Ue]+=ks*it[ps+Ks];ps+=Le.outChannels}}}}}}return Z.makeTensorInfo(G.shape,G.dtype,et)}const ot={kernelName:n.Conv2D,backendName:"cpu",kernelFunc:de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ct={kernelName:n.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,dy:ce}=Oe,{strides:Ce,pad:De,dataFormat:Fe,dimRoundingMode:Ie,filterShape:Te}=fe;Object(r.a)([H,ce],"conv2dBackpropFilter");const Ye=n.backend_util.convertConv2DDataFormat(Fe),Le=n.backend_util.computeConv2DInfo(H.shape,Te,Ce,1,De,Ie,!1,Ye),{strideHeight:Je,strideWidth:gt,filterHeight:lt,filterWidth:ft}=Le,yt=Le.dataFormat==="channelsLast",$t=new n.TensorBuffer(Le.filterShape,"float32"),Bt=Le.padInfo.left,G=Le.padInfo.top,A=Z.data.get(H.dataId).values,R=Z.data.get(ce.dataId).values,q=new n.TensorBuffer(H.shape,H.dtype,A),j=new n.TensorBuffer(ce.shape,ce.dtype,R);for(let te=0;te<lt;++te){const ie=Math.max(0,Math.ceil((G-te)/Je)),he=Math.min(Le.outHeight,(Le.inHeight+G-te)/Je);for(let xe=0;xe<ft;++xe){const _e=Math.max(0,Math.ceil((Bt-xe)/gt)),Ue=Math.min(Le.outWidth,(Le.inWidth+Bt-xe)/gt);for(let nt=0;nt<Le.inChannels;++nt)for(let it=0;it<Le.outChannels;++it){let et=0;for(let dt=0;dt<Le.batchSize;++dt)for(let ut=ie;ut<he;++ut){const Et=te+ut*Je-G;for(let Tt=_e;Tt<Ue;++Tt){const Dt=xe+Tt*gt-Bt;et+=yt?q.get(dt,Et,Dt,nt)*j.get(dt,ut,Tt,it):q.get(dt,nt,Et,Dt)*j.get(dt,it,ut,Tt)}}$t.set(et,te,xe,nt,it)}}}return Z.makeTensorInfo($t.shape,$t.dtype,$t.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt={kernelName:n.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,filter:ce}=Oe,{inputShape:Ce,strides:De,pad:Fe,dataFormat:Ie,dimRoundingMode:Te}=fe;Object(r.a)([H,ce],"conv2dBackpropInput");const Ye=n.util.computeStrides(ce.shape),Le=n.util.computeStrides(H.shape);let Je=n.backend_util.convertConv2DDataFormat(Ie);const gt=n.backend_util.computeConv2DInfo(Ce,ce.shape,De,1,Fe,Te,!1,Je),lt=new n.TensorBuffer(gt.inShape,"float32"),ft=lt.values,yt=Z.data.get(H.dataId).values,$t=Z.data.get(ce.dataId).values,[Bt,G,A]=Ye,{batchSize:R,filterHeight:q,filterWidth:j,inChannels:te,inHeight:ie,inWidth:he,outChannels:xe,outHeight:_e,outWidth:Ue,strideHeight:nt,strideWidth:it}=gt;Je=gt.dataFormat;const et=q-1-gt.padInfo.top,dt=j-1-gt.padInfo.left,ut=Je==="channelsLast",Et=lt.strides[0],Tt=ut?lt.strides[1]:lt.strides[2],Dt=ut?lt.strides[2]:1,Wt=ut?1:lt.strides[1],qt=Le[0],cn=ut?Le[1]:Le[2],rn=ut?Le[2]:1,yn=ut?1:Le[1];for(let Fn=0;Fn<R;++Fn)for(let _n=0;_n<te;++_n)for(let ss=0;ss<ie;++ss){const zn=ss-et,Kn=Math.max(0,Math.ceil(zn/nt)),us=Math.min(_e,(q+zn)/nt);for(let ps=0;ps<he;++ps){const es=ps-dt,ks=Math.max(0,Math.ceil(es/it)),Ks=Math.min(Ue,(j+es)/it);let sa=0;for(let or=Kn;or<us;++or){const _r=or*nt-zn;for(let yr=ks;yr<Ks;++yr){const Ga=qt*Fn+cn*or+rn*yr,ma=Bt*(q-1-_r)+G*(j-1-(yr*it-es))+A*_n;for(let Ha=0;Ha<xe;++Ha)sa+=yt[Ga+yn*Ha]*$t[ma+Ha]}}ft[Et*Fn+Tt*ss+Dt*ps+Wt*_n]=sa}}return Z.makeTensorInfo(lt.shape,lt.dtype,lt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const on={kernelName:n.Conv3D,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,filter:ce}=Oe,{strides:Ce,pad:De,dilations:Fe}=fe;Object(r.a)([H,ce],"conv3d");const Ie=n.backend_util.computeConv3DInfo(H.shape,ce.shape,Ce,Fe,De),{filterDepth:Te,filterHeight:Ye,filterWidth:Le,dilationDepth:Je,dilationHeight:gt,dilationWidth:lt,padInfo:ft}=Ie,yt=ft.front,$t=ft.left,Bt=ft.top,G=new n.TensorBuffer(Ie.outShape,H.dtype),A=Z.data.get(H.dataId).values,R=Z.data.get(ce.dataId).values,q=G.values,j=n.util.computeStrides(H.shape),te=n.util.computeStrides(ce.shape);for(let ie=0;ie<Ie.batchSize;++ie){const he=ie*j[0],xe=ie*G.strides[0];for(let _e=0;_e<Ie.outDepth;++_e){const Ue=xe+_e*G.strides[1],nt=_e*Ie.strideDepth-yt;for(let it=0;it<Te;++it){const et=nt+it*Je;if(et<0||et>=Ie.inDepth)continue;const dt=it*te[0],ut=he+et*j[1];for(let Et=0;Et<Ie.outHeight;++Et){const Tt=Ue+Et*G.strides[2],Dt=Et*Ie.strideHeight-Bt;for(let Wt=0;Wt<Ye;++Wt){const qt=Dt+Wt*gt;if(qt<0||qt>=Ie.inHeight)continue;const cn=dt+Wt*te[1],rn=ut+qt*j[2];for(let yn=0;yn<Ie.outWidth;++yn){const Fn=Tt+yn*Ie.outChannels,_n=yn*Ie.strideWidth-$t;for(let ss=0;ss<Le;++ss){const zn=_n+ss*lt;if(zn<0||zn>=Ie.inWidth)continue;const Kn=cn+ss*te[2],us=rn+zn*Ie.inChannels;let ps=Kn;for(let es=0;es<Ie.inChannels;++es){const ks=A[us+es];for(let Ks=0;Ks<Ie.outChannels;++Ks)q[Fn+Ks]+=ks*R[ps+Ks];ps+=Ie.outChannels}}}}}}}}return Z.makeTensorInfo(G.shape,G.dtype,G.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tn={kernelName:n.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,dy:ce}=Oe,{strides:Ce,pad:De,filterShape:Fe}=fe;Object(r.a)([H,ce],"conv3dBackpropFilterV2");const Ie=n.util.computeStrides(H.shape),Te=n.util.computeStrides(ce.shape),Ye=n.backend_util.computeConv3DInfo(H.shape,Fe,Ce,1,De),Le=Ye.strideDepth,Je=Ye.strideHeight,gt=Ye.strideWidth,lt=Ye.filterDepth,ft=Ye.filterHeight,yt=Ye.filterWidth,$t=new n.TensorBuffer(Ye.filterShape,"float32"),Bt=$t.values,[G,A,R,q]=$t.strides,j=Z.data.get(ce.dataId).values,[te,ie,he,xe]=Te,_e=Z.data.get(H.dataId).values,[Ue,nt,it,et]=Ie,dt=Ye.padInfo.front,ut=Ye.padInfo.left,Et=Ye.padInfo.top;for(let Tt=0;Tt<lt;++Tt){const Dt=Math.max(0,Math.ceil((dt-Tt)/Le)),Wt=Math.min(Ye.outDepth,(Ye.inDepth+dt-Tt)/Le),qt=Tt*G;for(let cn=0;cn<ft;++cn){const rn=Math.max(0,Math.ceil((Et-cn)/Je)),yn=Math.min(Ye.outHeight,(Ye.inHeight+Et-cn)/Je),Fn=cn*A+qt;for(let _n=0;_n<yt;++_n){const ss=Math.max(0,Math.ceil((ut-_n)/gt)),zn=Math.min(Ye.outWidth,(Ye.inWidth+ut-_n)/gt),Kn=_n*R+Fn;for(let us=0;us<Ye.inChannels;++us){const ps=us*q+Kn;for(let es=0;es<Ye.outChannels;++es){let ks=0;for(let Ks=0;Ks<Ye.batchSize;++Ks){const sa=Ks*Ue,or=Ks*te;for(let _r=Dt;_r<Wt;++_r){const yr=(Tt+_r*Le-dt)*nt+sa,Ga=_r*ie+or;for(let ma=rn;ma<yn;++ma){const Ha=(cn+ma*Je-Et)*it+yr,vo=ma*he+Ga;for(let pi=ss;pi<zn;++pi){const fi=pi*xe+vo;ks+=_e[(_n+pi*gt-ut)*et+Ha+us]*j[fi+es]}}}}Bt[ps+es]=ks}}}}}return Z.makeTensorInfo($t.shape,$t.dtype,$t.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bn={kernelName:n.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,filter:ce}=Oe,{pad:Ce,strides:De,inputShape:Fe}=fe;Object(r.a)([H],"conv3dBackpropInputV2");const Ie=n.util.computeStrides(H.shape),Te=n.util.computeStrides(ce.shape),Ye=n.backend_util.computeConv3DInfo(Fe,ce.shape,De,1,Ce),Le=new n.TensorBuffer(Ye.inShape,"float32"),Je=Le.values,[gt,lt,ft,yt]=Le.strides,$t=Z.data.get(H.dataId).values,[Bt,G,A,R]=Ie,q=Z.data.get(ce.dataId).values,[j,te,ie,he]=Te,{batchSize:xe,filterDepth:_e,filterHeight:Ue,filterWidth:nt,inChannels:it,inDepth:et,inHeight:dt,inWidth:ut,outChannels:Et,outDepth:Tt,outHeight:Dt,outWidth:Wt,strideDepth:qt,strideHeight:cn,strideWidth:rn}=Ye,yn=_e-1-Ye.padInfo.front,Fn=Ue-1-Ye.padInfo.top,_n=nt-1-Ye.padInfo.left;for(let ss=0;ss<xe;++ss)for(let zn=0;zn<it;++zn)for(let Kn=0;Kn<et;++Kn){const us=Kn-yn,ps=Math.max(0,Math.ceil(us/qt)),es=Math.min(Tt,(_e+us)/qt);for(let ks=0;ks<dt;++ks){const Ks=ks-Fn,sa=Math.max(0,Math.ceil(Ks/cn)),or=Math.min(Dt,(Ue+Ks)/cn);for(let _r=0;_r<ut;++_r){const yr=_r-_n,Ga=Math.max(0,Math.ceil(yr/rn)),ma=Math.min(Wt,(nt+yr)/rn);let Ha=0;for(let vo=ps;vo<es;++vo){const pi=vo*qt-us;for(let fi=sa;fi<or;++fi){const Ac=fi*cn-Ks;for(let tl=Ga;tl<ma;++tl){const nl=Bt*ss+G*vo+A*fi+R*tl,Pd=j*(_e-1-pi)+te*(Ue-1-Ac)+ie*(nt-1-(tl*rn-yr))+he*zn;for(let mi=0;mi<Et;++mi)Ha+=$t[nl+mi]*q[Pd+mi]}}}Je[gt*ss+lt*Kn+ft*ks+yt*_r+zn]=Ha}}}return Z.makeTensorInfo(Le.shape,Le.dtype,Le.values)}},On=Object(i.a)(n.Cos,Se=>Math.cos(Se)),Mn={kernelName:n.Cos,backendName:"cpu",kernelFunc:On},wn=Object(i.a)(n.Cosh,Se=>Math.cosh(Se)),gs={kernelName:n.Cosh,backendName:"cpu",kernelFunc:wn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hs={kernelName:n.CropAndResize,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{image:H,boxes:ce,boxInd:Ce}=Oe,{cropSize:De,method:Fe,extrapolationValue:Ie}=fe,[Te,Ye,Le,Je]=H.shape,gt=ce.shape[0],[lt,ft]=De,yt=Object(n.buffer)([gt,lt,ft,Je],"float32"),$t=Z.data.get(ce.dataId).values,Bt=Z.data.get(Ce.dataId).values,G=Z.data.get(H.dataId).values,A=n.util.computeStrides(H.shape),R=n.util.computeStrides(yt.shape);for(let q=0;q<gt;q++){const j=4*q,te=$t[j],ie=$t[j+1],he=$t[j+2],xe=$t[j+3],_e=Bt[q];if(_e>=Te)continue;const Ue=lt>1?(he-te)*(Ye-1)/(lt-1):0,nt=ft>1?(xe-ie)*(Le-1)/(ft-1):0;for(let it=0;it<lt;it++){const et=lt>1?te*(Ye-1)+it*Ue:.5*(te+he)*(Ye-1);if(et<0||et>Ye-1)for(let dt=0;dt<ft;dt++)for(let ut=0;ut<Je;ut++){const Et=ut+dt*R[2]+it*R[1]+q*R[0];yt.values[Et]=Ie}else if(Fe==="bilinear"){const dt=Math.floor(et),ut=Math.ceil(et),Et=et-dt;for(let Tt=0;Tt<ft;Tt++){const Dt=ft>1?ie*(Le-1)+Tt*nt:.5*(ie+xe)*(Le-1);if(Dt<0||Dt>Le-1){for(let rn=0;rn<Je;rn++){const yn=rn+Tt*R[2]+it*R[1]+q*R[0];yt.values[yn]=Ie}continue}const Wt=Math.floor(Dt),qt=Math.ceil(Dt),cn=Dt-Wt;for(let rn=0;rn<Je;rn++){let yn=rn+Wt*A[2]+dt*A[1]+_e*A[0];const Fn=G[yn];yn=rn+qt*A[2]+dt*A[1]+_e*A[0];const _n=G[yn];yn=rn+Wt*A[2]+ut*A[1]+_e*A[0];const ss=G[yn];yn=rn+qt*A[2]+ut*A[1]+_e*A[0];const zn=Fn+(_n-Fn)*cn,Kn=ss+(G[yn]-ss)*cn;yn=rn+Tt*R[2]+it*R[1]+q*R[0],yt.values[yn]=zn+(Kn-zn)*Et}}}else for(let dt=0;dt<ft;++dt){const ut=ft>1?ie*(Le-1)+dt*nt:.5*(ie+xe)*(Le-1);if(ut<0||ut>Le-1){for(let Dt=0;Dt<Je;Dt++){const Wt=Dt+dt*R[2]+it*R[1]+q*R[0];yt.values[Wt]=Ie}continue}const Et=Math.round(ut),Tt=Math.round(et);for(let Dt=0;Dt<Je;Dt++){const Wt=Dt+Et*A[2]+Tt*A[1]+_e*A[0],qt=Dt+dt*R[2]+it*R[1]+q*R[0];yt.values[qt]=G[Wt]}}}}return Z.makeTensorInfo(yt.shape,yt.dtype,yt.values)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xr={kernelName:n.Cumprod,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,exclusive:Ce,reverse:De}=fe;Object(r.a)(H,"cumprod");const Fe=n.backend_util.getAxesPermutation([ce],H.shape.length);let Ie=H;Fe!=null&&(Ie=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:Fe}}));const Te=n.backend_util.getInnerMostAxes(1,H.shape.length)[0];if(Te!==Ie.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${Ie.shape.length-1} but got axis=${Te}`);const Ye=Object(n.upcastType)(Ie.dtype,"int32"),Le=n.util.makeOnesTypedArray(n.util.sizeFromShape(Ie.shape),Ye),Je=Z.data.get(Ie.dataId).values,gt=Ie.shape[Ie.shape.length-1],lt=De?(yt,$t)=>yt+gt-$t-1:(yt,$t)=>yt+$t;for(let yt=0;yt<Je.length;yt+=gt)for(let $t=0;$t<gt;$t++){const Bt=lt(yt,$t);if($t===0)Le[Bt]=Ce?1:Je[Bt];else{const G=lt(yt,$t-1);Le[Bt]=Ce?Je[G]*Le[G]:Je[Bt]*Le[G]}}const ft=Z.makeTensorInfo(Ie.shape,Ye,Le);if(Fe!=null){const yt=n.backend_util.getUndoAxesPermutation(Fe),$t=Object(tt.a)({inputs:{x:ft},backend:Z,attrs:{perm:yt}});return Z.disposeIntermediateTensorInfo(ft),Z.disposeIntermediateTensorInfo(Ie),$t}return ft}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ir={kernelName:n.Cumsum,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,exclusive:Ce,reverse:De}=fe;Object(r.a)(H,"cumsum");const Fe=n.backend_util.getAxesPermutation([ce],H.shape.length);let Ie=H;Fe!=null&&(Ie=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:Fe}}));const Te=n.backend_util.getInnerMostAxes(1,H.shape.length)[0];if(Te!==Ie.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${Ie.shape.length-1} but got axis=${Te}`);const Ye=Object(n.upcastType)(Ie.dtype,"int32"),Le=n.util.makeZerosTypedArray(n.util.sizeFromShape(Ie.shape),Ye),Je=Z.data.get(Ie.dataId).values,gt=Ie.shape[Ie.shape.length-1],lt=De?(yt,$t)=>yt+gt-$t-1:(yt,$t)=>yt+$t;for(let yt=0;yt<Je.length;yt+=gt)for(let $t=0;$t<gt;$t++){const Bt=lt(yt,$t);if($t===0)Le[Bt]=Ce?0:Je[Bt];else{const G=lt(yt,$t-1);Le[Bt]=Ce?Je[G]+Le[G]:Je[Bt]+Le[G]}}const ft=Z.makeTensorInfo(Ie.shape,Ye,Le);if(Fe!=null){const yt=n.backend_util.getUndoAxesPermutation(Fe),$t=Object(tt.a)({inputs:{x:ft},backend:Z,attrs:{perm:yt}});return Z.disposeIntermediateTensorInfo(ft),Z.disposeIntermediateTensorInfo(Ie),$t}return ft}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qs={kernelName:n.DenseBincount,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,weights:ce}=Oe,{size:Ce,binaryOutput:De}=fe;if(H.shape.length===1){const Fe=Z.data.get(H.dataId).values,Ie=Z.data.get(ce.dataId).values,Te=Object(Gs.a)(Fe,Ie,ce.dtype,ce.shape,Ce);return Z.makeTensorInfo([Ce],ce.dtype,Te)}if(H.shape.length===2){const Fe=Z.bufferSync(H),Ie=Z.bufferSync(ce),Te=Object(Gs.b)(Fe,Ie,Ce,De);return Z.makeTensorInfo(Te.shape,ce.dtype,Te.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${H.shape.length}.`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ta={kernelName:n.DepthToSpace,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{blockSize:ce,dataFormat:Ce}=fe;n.util.assert(Ce==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${Ce}`);const De=H.shape[0],Fe=H.shape[1],Ie=H.shape[2],Te=H.shape[3],Ye=Fe*ce,Le=Ie*ce,Je=Te/(ce*ce),gt=Z.data.get(H.dataId).values,lt=new Float32Array(De*Ye*Le*Je);let ft=0;for(let yt=0;yt<De;++yt)for(let $t=0;$t<Ye;++$t){const Bt=Math.floor($t/ce),G=$t%ce;for(let A=0;A<Le;++A){const R=Math.floor(A/ce),q=(G*ce+A%ce)*Je;for(let j=0;j<Je;++j){const te=j+q+Te*(R+Ie*(Bt+Fe*yt));lt[ft++]=gt[te]}}}return Z.makeTensorInfo([De,Ye,Le,Je],H.dtype,lt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,filter:ce}=Oe,{strides:Ce,pad:De,dilations:Fe,dimRoundingMode:Ie}=fe;Object(r.a)([H,ce],"depthwiseConv2DNative");const Te=n.util.computeStrides(H.shape),Ye=n.util.computeStrides(ce.shape);let Le=Fe;Le==null&&(Le=[1,1]),n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(Ce,Le),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${Ce} and dilations '${Le}'`);const Je=n.backend_util.computeConv2DInfo(H.shape,ce.shape,Ce,Le,De,Ie,!0),{filterHeight:gt,filterWidth:lt,dilationHeight:ft,dilationWidth:yt,padInfo:$t}=Je,Bt=$t.left,G=$t.top,A=Je.outChannels/Je.inChannels,R=new n.TensorBuffer(Je.outShape,H.dtype),q=Z.data.get(H.dataId).values,j=Z.data.get(ce.dataId).values,te=R.values;for(let ie=0;ie<Je.batchSize;++ie){const he=ie*Te[0],xe=ie*R.strides[0];for(let _e=0;_e<Je.outHeight;++_e){const Ue=xe+_e*R.strides[1],nt=_e*Je.strideHeight-G;for(let it=0;it<gt;++it){const et=nt+it*ft;if(et<0||et>=Je.inHeight)continue;const dt=it*Ye[0],ut=he+et*Te[1];for(let Et=0;Et<Je.outWidth;++Et){const Tt=Ue+Et*R.strides[2],Dt=Et*Je.strideWidth-Bt;for(let Wt=0;Wt<lt;++Wt){const qt=Dt+Wt*yt;if(qt<0||qt>=Je.inWidth)continue;const cn=dt+Wt*Ye[1],rn=ut+qt*Je.inChannels;let yn=Tt,Fn=cn;for(let _n=0;_n<Je.inChannels;++_n){const ss=q[rn+_n];for(let zn=0;zn<A;++zn)te[yn+zn]+=ss*j[Fn+zn];yn+=A,Fn+=A}}}}}}return Z.makeTensorInfo(R.shape,R.dtype,R.values)}const rr={kernelName:n.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:pa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eo={kernelName:n.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,dy:ce}=Oe,{strides:Ce,dilations:De,pad:Fe,dimRoundingMode:Ie,filterShape:Te}=fe;Object(r.a)([H,ce],"depthwiseConv2dNativeBackpropFilter");const Ye=n.backend_util.computeConv2DInfo(H.shape,Te,Ce,De,Fe,Ie,!0),{strideHeight:Le,strideWidth:Je,filterHeight:gt,filterWidth:lt}=Ye,ft=new n.TensorBuffer(Ye.filterShape,"float32"),yt=Ye.padInfo.left,$t=Ye.padInfo.top,Bt=Ye.outChannels/Ye.inChannels,G=Z.data.get(H.dataId).values,A=new n.TensorBuffer(H.shape,H.dtype,G),R=Z.data.get(ce.dataId).values,q=new n.TensorBuffer(ce.shape,ce.dtype,R);for(let j=0;j<gt;++j){const te=Math.max(0,Math.ceil(($t-j)/Le)),ie=Math.min(Ye.outHeight,(Ye.inHeight+$t-j)/Le);for(let he=0;he<lt;++he){const xe=Math.max(0,Math.ceil((yt-he)/Je)),_e=Math.min(Ye.outWidth,(Ye.inWidth+yt-he)/Je);for(let Ue=0;Ue<Ye.outChannels;++Ue){const nt=Math.trunc(Ue/Bt),it=Ue%Bt;let et=0;for(let dt=0;dt<Ye.batchSize;++dt)for(let ut=te;ut<ie;++ut){const Et=j+ut*Le-$t;for(let Tt=xe;Tt<_e;++Tt){const Dt=he+Tt*Je-yt;et+=A.get(dt,Et,Dt,nt)*q.get(dt,ut,Tt,Ue)}}ft.set(et,j,he,nt,it)}}}return Z.makeTensorInfo(ft.shape,ft.dtype,ft.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qs={kernelName:n.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,filter:ce}=Oe,{strides:Ce,dilations:De,pad:Fe,dimRoundingMode:Ie,inputShape:Te}=fe;Object(r.a)([H,ce],"depthwiseConv2DNativeBackpropInput");const Ye=n.util.computeStrides(H.shape),Le=n.util.computeStrides(ce.shape),Je=n.backend_util.computeConv2DInfo(Te,ce.shape,Ce,De,Fe,Ie,!0),gt=new n.TensorBuffer(Je.inShape,"float32"),lt=gt.values,[ft,yt,$t]=gt.strides,Bt=Z.data.get(H.dataId).values,[G,A,R]=Ye,q=Z.data.get(ce.dataId).values,[j,te,ie]=Le,{batchSize:he,filterHeight:xe,filterWidth:_e,inChannels:Ue,inHeight:nt,inWidth:it,outChannels:et,outHeight:dt,outWidth:ut,strideHeight:Et,strideWidth:Tt}=Je,Dt=xe-1-Je.padInfo.top,Wt=_e-1-Je.padInfo.left,qt=et/Ue;for(let cn=0;cn<he;++cn)for(let rn=0;rn<Ue;++rn)for(let yn=0;yn<nt;++yn){const Fn=yn-Dt,_n=Math.max(0,Math.ceil(Fn/Et)),ss=Math.min(dt,(xe+Fn)/Et);for(let zn=0;zn<it;++zn){const Kn=zn-Wt,us=Math.max(0,Math.ceil(Kn/Tt)),ps=Math.min(ut,(_e+Kn)/Tt);let es=0;for(let ks=_n;ks<ss;++ks){const Ks=ks*Et-Fn;for(let sa=us;sa<ps;++sa){const or=G*cn+A*ks+R*sa,_r=j*(xe-1-Ks)+te*(_e-1-(sa*Tt-Kn))+ie*rn;for(let yr=0;yr<qt;++yr)es+=Bt[or+(rn*qt+yr)]*q[_r+yr]}}lt[ft*cn+yt*yn+$t*zn+rn]=es}}return Z.makeTensorInfo(gt.shape,gt.dtype,gt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mr={kernelName:n.Diag,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{x:fe}=Oe,H=n.util.sizeFromShape(fe.shape),ce=Z.data.get(fe.dataId).values,Ce=Object(n.buffer)([H,H],fe.dtype),De=Ce.values;for(let Ie=0;Ie<ce.length;Ie++)De[Ie*H+Ie]=ce[Ie];const Fe=[...fe.shape,...fe.shape];return Z.makeTensorInfo(Fe,Ce.dtype,Ce.values)}},$r={kernelName:n.Dilation2D,backendName:"cpu",kernelFunc:({inputs:Se,backend:Oe,attrs:Z})=>{const{x:fe,filter:H}=Se,{strides:ce,pad:Ce,dilations:De}=Z,Fe=Oe,Ie=Fe.data.get(fe.dataId).values,Te=fe.shape.length,Ye=Fe.data.get(H.dataId).values,Le=H.shape.length,{batchSize:Je,inHeight:gt,inWidth:lt,inChannels:ft,outHeight:yt,outWidth:$t,padInfo:Bt,strideHeight:G,strideWidth:A,filterHeight:R,filterWidth:q,dilationHeight:j,dilationWidth:te,outShape:ie}=n.backend_util.computeDilation2DInfo(fe.shape,H.shape,ce,Ce,"NHWC",De),he=n.util.sizeFromShape(ie),xe=ie.length,_e=n.util.getArrayFromDType(fe.dtype,he);for(let Ue=0;Ue<Je;++Ue)for(let nt=0;nt<yt;++nt){const it=nt*G-Bt.top;for(let et=0;et<$t;++et){const dt=et*A-Bt.left;for(let ut=0;ut<ft;++ut){let Et=Number.MIN_SAFE_INTEGER;for(let Tt=0;Tt<R;++Tt){const Dt=it+Tt*j;if(Dt>=0&&Dt<gt)for(let Wt=0;Wt<q;++Wt){const qt=dt+Wt*te;if(qt>=0&&qt<lt){const cn=n.util.locToIndex([Ue,Dt,qt,ut],Te,n.util.computeStrides(fe.shape)),rn=n.util.locToIndex([Tt,Wt,ut],Le,n.util.computeStrides(H.shape)),yn=Ie[cn]+Ye[rn];yn>Et&&(Et=yn)}}}_e[n.util.locToIndex([Ue,nt,et,ut],xe,n.util.computeStrides(ie))]=Et}}}return{dataId:Fe.write(n.util.toTypedArray(_e,fe.dtype),ie,fe.dtype),shape:ie,dtype:fe.dtype}}},ia={kernelName:n.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:Se,backend:Oe,attrs:Z})=>{const{x:fe,filter:H,dy:ce}=Se,{strides:Ce,pad:De,dilations:Fe}=Z,Ie=Oe,Te=n.util.toNestedArray(fe.shape,Ie.data.get(fe.dataId).values),Ye=n.util.toNestedArray(H.shape,Ie.data.get(H.dataId).values),{batchSize:Le,inHeight:Je,inWidth:gt,inChannels:lt,outHeight:ft,outWidth:yt,padInfo:$t,strideHeight:Bt,strideWidth:G,filterHeight:A,filterWidth:R,dilationHeight:q,dilationWidth:j,outShape:te}=n.backend_util.computeDilation2DInfo(fe.shape,H.shape,Ce,De,"NHWC",Fe);n.util.assert(ce.rank===te.length,()=>`Error in ${n.Dilation2DBackpropFilter}, dy must have the same rank as output ${te.length}, but got ${ce.rank}`);const ie=n.util.toNestedArray(te,Ie.data.get(ce.dataId).values),he=n.util.makeZerosNestedTypedArray(H.shape,H.dtype);for(let xe=0;xe<Le;++xe)for(let _e=0;_e<ft;++_e){const Ue=_e*Bt-$t.top;for(let nt=0;nt<yt;++nt){const it=nt*G-$t.left;for(let et=0;et<lt;++et){let dt=Number.MIN_SAFE_INTEGER,ut=0,Et=0;for(let Tt=0;Tt<A;++Tt){const Dt=Ue+Tt*q;if(Dt>=0&&Dt<Je)for(let Wt=0;Wt<R;++Wt){const qt=it+Wt*j;if(qt>=0&&qt<gt){const cn=Te[xe][Dt][qt][et]+Ye[Tt][Wt][et];cn>dt&&(dt=cn,ut=Tt,Et=Wt)}}}he[ut][Et][et]+=ie[xe][_e][nt][et]}}}return{dataId:Ie.write(n.util.toTypedArray(he,fe.dtype),H.shape,H.dtype),shape:H.shape,dtype:H.dtype}}},Pr={kernelName:n.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:Se,backend:Oe,attrs:Z})=>{const{x:fe,filter:H,dy:ce}=Se,{strides:Ce,pad:De,dilations:Fe}=Z,Ie=Oe,Te=n.util.toNestedArray(fe.shape,Ie.data.get(fe.dataId).values),Ye=n.util.toNestedArray(H.shape,Ie.data.get(H.dataId).values),{batchSize:Le,inHeight:Je,inWidth:gt,inChannels:lt,outHeight:ft,outWidth:yt,padInfo:$t,strideHeight:Bt,strideWidth:G,filterHeight:A,filterWidth:R,dilationHeight:q,dilationWidth:j,outShape:te}=n.backend_util.computeDilation2DInfo(fe.shape,H.shape,Ce,De,"NHWC",Fe);n.util.assert(ce.rank===te.length,()=>`Error in ${n.Dilation2DBackpropInput}, dy must have the same rank as output ${te.length}, but got ${ce.rank}`);const ie=n.util.toNestedArray(te,Ie.data.get(ce.dataId).values),he=n.util.makeZerosNestedTypedArray(fe.shape,fe.dtype);for(let xe=0;xe<Le;++xe)for(let _e=0;_e<ft;++_e){const Ue=_e*Bt-$t.top;for(let nt=0;nt<yt;++nt){const it=nt*G-$t.left;for(let et=0;et<lt;++et){let dt=Number.MIN_SAFE_INTEGER,ut=Ue<0?0:Ue,Et=it<0?0:it;for(let Tt=0;Tt<A;++Tt){const Dt=Ue+Tt*q;if(Dt>=0&&Dt<Je)for(let Wt=0;Wt<R;++Wt){const qt=it+Wt*j;if(qt>=0&&qt<gt){const cn=Te[xe][Dt][qt][et]+Ye[Tt][Wt][et];cn>dt&&(dt=cn,ut=Dt,Et=qt)}}}he[xe][ut][Et][et]+=ie[xe][_e][nt][et]}}}return{dataId:Ie.write(n.util.toTypedArray(he,fe.dtype),fe.shape,fe.dtype),shape:fe.shape,dtype:fe.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Cr=t(29),Ba=t(89);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function za(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,keepDims:Ce}=fe;let De;Object(r.a)(H,"sum"),De=H.dtype==="bool"?Object(ds.a)({inputs:{x:H},backend:Z,attrs:{dtype:"int32"}}):Object(d.a)({inputs:{x:H},backend:Z});const Fe=De.shape.length,Ie=n.util.parseAxisParam(ce,De.shape),Te=n.backend_util.getAxesPermutation(Ie,Fe);let Ye=Ie,Le=De;Te!=null&&(Le=Object(tt.a)({inputs:{x:De},backend:Z,attrs:{perm:Te}}),Ye=n.backend_util.getInnerMostAxes(Ye.length,Fe)),n.backend_util.assertAxesAreInnerMostDims("sum",Ye,Le.shape.length);const[Je,gt]=n.backend_util.computeOutAndReduceShapes(Le.shape,Ye),lt=n.backend_util.upcastType(Le.dtype,"int32");let ft=Object(Ba.a)(Z,Je,lt);const yt=n.util.sizeFromShape(gt),$t=Z.data.get(ft.dataId).values,Bt=Z.data.get(Le.dataId).values;for(let G=0;G<$t.length;++G){const A=G*yt;let R=0;for(let q=0;q<yt;++q)R+=Bt[A+q];$t[G]=R}if(Ce){const G=ft;ft=Y({inputs:{x:ft},backend:Z,attrs:{shape:n.backend_util.expandShapeToKeepDim(ft.shape,Ie)}}),Z.disposeIntermediateTensorInfo(G)}return Z.disposeIntermediateTensorInfo(De),Te!=null&&Z.disposeIntermediateTensorInfo(Le),ft}const to={kernelName:n.Sum,backendName:"cpu",kernelFunc:za};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wo={kernelName:n.Einsum,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{equation:H}=fe,ce=Oe,{allDims:Ce,summedDims:De,idDims:Fe}=n.backend_util.decodeEinsumEquation(H,ce.length);n.backend_util.checkEinsumDimSizes(Ce.length,Fe,ce);const{path:Ie,steps:Te}=n.backend_util.getEinsumComputePath(De,Fe),Ye=Te.length;let Le=null,Je=Ce.length;const gt=[];for(let lt=0;lt<Ye;++lt){for(const ft of Te[lt]){const{permutationIndices:yt,expandDims:$t}=n.backend_util.getEinsumPermutation(Je,Fe[ft]);let Bt;n.backend_util.isIdentityPermutation(yt)?Bt=ce[ft]:(Bt=Object(tt.a)({inputs:{x:ce[ft]},backend:Z,attrs:{perm:yt}}),gt.push(Bt));const G=Bt.shape.slice();for(let A=0;A<$t.length;++A)G.splice($t[A],0,1);n.util.arraysEqual(Bt.shape,G)||(Bt=Y({inputs:{x:Bt},backend:Z,attrs:{shape:G}}),gt.push(Bt)),Le===null?Le=Bt:(Le=Object(Cr.a)({inputs:{a:Bt,b:Le},backend:Z}),gt.push(Le))}lt<Ye-1&&(Ie[lt]>=0&&(Le=za({inputs:{x:Le},backend:Z,attrs:{axis:Ie[lt]-(Ce.length-Je),keepDims:!1}}),gt.push(Le)),Je--)}for(const lt of gt)lt!==Le&&Z.disposeIntermediateTensorInfo(lt);return Le}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const si={kernelName:n.EluGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{dy:fe,y:H}=Oe;Object(r.a)([fe,H],"eluGrad");const ce=new Float32Array(n.util.sizeFromShape(H.shape)),Ce=Z.data.get(H.dataId).values,De=Z.data.get(fe.dataId).values;for(let Fe=0;Fe<Ce.length;++Fe){const Ie=Ce[Fe];ce[Fe]=Ie>=1?De[Fe]:De[Fe]*(Ie+1)}return Z.makeTensorInfo(H.shape,"float32",ce)}};var fo=t(44);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const no=n.backend_util.ERF_P,Ta=n.backend_util.ERF_A1,mo=n.backend_util.ERF_A2,Ar=n.backend_util.ERF_A3,Na=n.backend_util.ERF_A4,Ea=n.backend_util.ERF_A5,Vo=Object(i.a)(n.Erf,Se=>{const Oe=Math.sign(Se),Z=Math.abs(Se),fe=1/(1+no*Z);return Oe*(1-((((Ea*fe+Na)*fe+Ar)*fe+mo)*fe+Ta)*fe*Math.exp(-Z*Z))}),So={kernelName:n.Erf,backendName:"cpu",kernelFunc:Vo};var so=t(45);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{input:H}=Oe,{dim:ce}=fe,Ce=H.shape.length,De=H.shape.slice();let Fe=ce;return ce<0&&(n.util.assert(-(Ce+1)<=ce,()=>`Axis must be in the interval [${-(Ce+1)}, ${Ce}]`),Fe=Ce+ce+1),De.splice(Fe,0,1),Y({inputs:{x:H},backend:Z,attrs:{shape:De}})}const Kr={kernelName:n.ExpandDims,backendName:"cpu",kernelFunc:Zs};var Ra=t(59);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa=Object(p.a)((Se,Oe)=>Se/Oe),na=Object(se.a)(n.RealDiv,fa),$o={kernelName:n.RealDiv,backendName:"cpu",kernelFunc:na};var We=t(36);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function It(Se,Oe,Z){const fe=Se.shape,H=fe[0],ce=fe[1],Ce=Z.data.get(Se.dataId),De=Ce.complexTensorInfos.real,Fe=Ce.complexTensorInfos.imag,Ie=[H,ce],Te=n.util.sizeFromShape(Ie),Ye=n.util.getTypedArrayFromDType("float32",Te),Le=n.util.getTypedArrayFromDType("float32",Te);for(let ft=0;ft<H;ft++){const yt=Object(Un.a)({inputs:{x:De},backend:Z,attrs:{begin:[ft,0],size:[1,ce]}}),$t=Object(Un.a)({inputs:{x:Fe},backend:Z,attrs:{begin:[ft,0],size:[1,ce]}}),Bt=Object(ts.a)({inputs:{real:yt,imag:$t},backend:Z}),{real:G,imag:A}=Ut(Bt,Oe,Z),R=n.backend_util.mergeRealAndImagArrays(G,A);for(let q=0;q<ce;q++){const j=n.backend_util.getComplexWithIndex(R,q);Ye[ft*ce+q]=j.real,Le[ft*ce+q]=j.imag}Z.disposeIntermediateTensorInfo(yt),Z.disposeIntermediateTensorInfo($t),Z.disposeIntermediateTensorInfo(Bt)}const Je=Z.makeTensorInfo(Ie,"float32",Ye),gt=Z.makeTensorInfo(Ie,"float32",Le),lt=Object(ts.a)({inputs:{real:Je,imag:gt},backend:Z});return Z.disposeIntermediateTensorInfo(Je),Z.disposeIntermediateTensorInfo(gt),lt}function Ut(Se,Oe,Z){const fe=n.util.sizeFromShape(Se.shape),H=Z.data.get(Se.dataId),ce=Z.data.get(H.complexTensorInfos.real.dataId).values,Ce=Z.data.get(H.complexTensorInfos.imag.dataId).values;if(((De=fe)&De-1)==0){const Fe=sn(ce,Ce,fe,Oe,Z),Ie=[Se.shape[0],Se.shape[1]];if(Oe){const Te=Z.makeTensorInfo(Ie,"float32",Fe.real),Ye=Z.makeTensorInfo(Ie,"float32",Fe.imag),Le=Z.makeTensorInfo([],"float32",n.util.createScalarValue(fe,"float32")),Je=Object(d.a)({inputs:{x:Le},backend:Z}),gt=$o.kernelFunc({inputs:{a:Te,b:Le},backend:Z}),lt=$o.kernelFunc({inputs:{a:Ye,b:Je},backend:Z}),ft=Z.data.get(gt.dataId).values,yt=Z.data.get(lt.dataId).values;return Z.disposeIntermediateTensorInfo(Te),Z.disposeIntermediateTensorInfo(Ye),Z.disposeIntermediateTensorInfo(Le),Z.disposeIntermediateTensorInfo(Je),Z.disposeIntermediateTensorInfo(gt),Z.disposeIntermediateTensorInfo(lt),{real:ft,imag:yt}}return Fe}{const Fe=function(Ie,Te,Ye){const Le=new Float32Array(2*Te);for(let Je=0;Je<Te;Je++){let gt=0,lt=0;for(let ft=0;ft<Te;ft++){const yt=n.backend_util.exponent(Je*ft,Te,Ye),$t=n.backend_util.getComplexWithIndex(Ie,ft);gt+=$t.real*yt.real-$t.imag*yt.imag,lt+=$t.real*yt.imag+$t.imag*yt.real}Ye&&(gt/=Te,lt/=Te),n.backend_util.assignToTypedArray(Le,gt,lt,Je)}return Le}(n.backend_util.mergeRealAndImagArrays(ce,Ce),fe,Oe);return n.backend_util.splitRealAndImagArrays(Fe)}var De}function sn(Se,Oe,Z,fe,H){if(Z===1)return{real:Se,imag:Oe};const ce=n.backend_util.mergeRealAndImagArrays(Se,Oe),Ce=Z/2,De=n.backend_util.complexWithEvenIndex(ce),Fe=De.real,Ie=De.imag,Te=[Fe.length],Ye=H.makeTensorInfo(Te,"float32",Fe),Le=H.makeTensorInfo(Te,"float32",Ie),Je=Object(ts.a)({inputs:{real:Ye,imag:Le},backend:H}),gt=n.backend_util.complexWithOddIndex(ce),lt=gt.real,ft=gt.imag,yt=[lt.length],$t=H.makeTensorInfo(yt,"float32",lt),Bt=H.makeTensorInfo(yt,"float32",ft),G=Object(ts.a)({inputs:{real:$t,imag:Bt},backend:H}),A=sn(Fe,Ie,Ce,fe,H),R=A.real,q=A.imag,j=[R.length],te=H.makeTensorInfo(j,"float32",R),ie=H.makeTensorInfo(j,"float32",q),he=Object(ts.a)({inputs:{real:te,imag:ie},backend:H}),xe=sn(lt,ft,Ce,fe,H),_e=xe.real,Ue=xe.imag,nt=[_e.length],it=H.makeTensorInfo(nt,"float32",_e),et=H.makeTensorInfo(nt,"float32",Ue),dt=Object(ts.a)({inputs:{real:it,imag:et},backend:H}),ut=n.backend_util.exponents(Z,fe),Et=[ut.real.length],Tt=H.makeTensorInfo(Et,"float32",ut.real),Dt=H.makeTensorInfo(Et,"float32",ut.imag),Wt=Object(ts.a)({inputs:{real:Tt,imag:Dt},backend:H}),qt=Object(Cr.a)({inputs:{a:Wt,b:dt},backend:H}),cn=Object(L.a)({inputs:{a:he,b:qt},backend:H}),rn=Object(We.a)({inputs:{a:he,b:qt},backend:H}),yn=Object(Us.a)({inputs:{input:cn},backend:H}),Fn=Object(Us.a)({inputs:{input:rn},backend:H}),_n=ys({inputs:{input:cn},backend:H}),ss=ys({inputs:{input:rn},backend:H}),zn=jt({inputs:[yn,Fn],backend:H,attrs:{axis:0}}),Kn=jt({inputs:[_n,ss],backend:H,attrs:{axis:0}}),us=H.data.get(zn.dataId).values,ps=H.data.get(Kn.dataId).values;return H.disposeIntermediateTensorInfo(Ye),H.disposeIntermediateTensorInfo(Le),H.disposeIntermediateTensorInfo(Je),H.disposeIntermediateTensorInfo($t),H.disposeIntermediateTensorInfo(Bt),H.disposeIntermediateTensorInfo(G),H.disposeIntermediateTensorInfo(te),H.disposeIntermediateTensorInfo(ie),H.disposeIntermediateTensorInfo(he),H.disposeIntermediateTensorInfo(it),H.disposeIntermediateTensorInfo(et),H.disposeIntermediateTensorInfo(dt),H.disposeIntermediateTensorInfo(Tt),H.disposeIntermediateTensorInfo(Dt),H.disposeIntermediateTensorInfo(Wt),H.disposeIntermediateTensorInfo(qt),H.disposeIntermediateTensorInfo(cn),H.disposeIntermediateTensorInfo(rn),H.disposeIntermediateTensorInfo(yn),H.disposeIntermediateTensorInfo(_n),H.disposeIntermediateTensorInfo(Fn),H.disposeIntermediateTensorInfo(ss),H.disposeIntermediateTensorInfo(zn),H.disposeIntermediateTensorInfo(Kn),{real:us,imag:ps}}const vn={kernelName:n.FFT,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{input:fe}=Oe,H=n.util.sizeFromShape(fe.shape),ce=fe.shape[fe.shape.length-1],Ce=Y({inputs:{x:fe},backend:Z,attrs:{shape:[H/ce,ce]}}),De=It(Ce,!1,Z),Fe=Y({inputs:{x:De},backend:Z,attrs:{shape:fe.shape}});return Z.disposeIntermediateTensorInfo(Ce),Z.disposeIntermediateTensorInfo(De),Fe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(Se){const{backend:Oe,attrs:Z}=Se,{shape:fe,value:H,dtype:ce}=Z,Ce=ce||n.util.inferDtype(H),De=n.util.getArrayFromDType(Ce,n.util.sizeFromShape(fe));return function(Fe,Ie,Te){Fe.fill(Ie)}(De,H),Oe.makeTensorInfo(fe,Ce,De)}const Vn={kernelName:n.Fill,backendName:"cpu",kernelFunc:fn},hs={kernelName:n.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:Se,attrs:Oe,backend:Z})=>{const{image:fe}=Se,H=Z,ce=n.util.getTypedArrayFromDType(fe.dtype,n.util.sizeFromShape(fe.shape)),[Ce,De,Fe,Ie]=fe.shape,Te=H.data.get(fe.dataId).values;for(let Ye=0;Ye<Ce;Ye++){const Le=Ye*Fe*De*Ie;for(let Je=0;Je<De;Je++){const gt=Je*(Fe*Ie);for(let lt=0;lt<Fe;lt++){const ft=lt*Ie;for(let yt=0;yt<Ie;yt++){const $t=Math.round(Fe-lt-1),Bt=Le+gt+ft+yt;let G=Te[Bt];$t>=0&&$t<Fe&&(G=Te[Le+gt+$t*Ie+yt]),ce[Bt]=G}}}}return{dataId:H.write(ce,fe.shape,fe.dtype),shape:fe.shape,dtype:fe.dtype}}};var Es=t(60);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dr=Object(p.a)((Se,Oe)=>Math.floor(Se/Oe)),Js=Object(se.a)(n.FloorDiv,dr,null,"int32"),ga={kernelName:n.FloorDiv,backendName:"cpu",kernelFunc:Js},ur={kernelName:n.FusedConv2D,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,filter:ce,bias:Ce,preluActivationWeights:De}=Oe,{strides:Fe,pad:Ie,dataFormat:Te,dilations:Ye,dimRoundingMode:Le,activation:Je,leakyreluAlpha:gt}=fe;let lt=de({inputs:{x:H,filter:ce},backend:Z,attrs:{strides:Fe,pad:Ie,dataFormat:Te,dilations:Ye,dimRoundingMode:Le}});if(Ce){const ft=lt;if(Te==="NCHW"&&Ce.shape.length===1&&Ce.shape[0]!==1){const yt=Y({inputs:{x:Ce},backend:Z,attrs:{shape:[Ce.shape[0],1,1]}});lt=Object(L.a)({inputs:{a:lt,b:yt},backend:Z}),Z.disposeIntermediateTensorInfo(yt)}else lt=Object(L.a)({inputs:{a:lt,b:Ce},backend:Z});Z.disposeIntermediateTensorInfo(ft)}if(Je){const ft=lt;if(Te==="NCHW"&&Je==="prelu"&&De.shape.length===1&&De.shape[0]!==1){const yt=Y({inputs:{x:De},backend:Z,attrs:{shape:[De.shape[0],1,1]}});lt=U(Z,lt,Je,yt,gt),Z.disposeIntermediateTensorInfo(yt)}else lt=U(Z,lt,Je,De,gt);Z.disposeIntermediateTensorInfo(ft)}return lt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Or={kernelName:n.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,filter:ce,bias:Ce,preluActivationWeights:De}=Oe,{strides:Fe,pad:Ie,dataFormat:Te,dilations:Ye,dimRoundingMode:Le,activation:Je,leakyreluAlpha:gt}=fe;let lt=pa({inputs:{x:H,filter:ce},backend:Z,attrs:{strides:Fe,pad:Ie,dataFormat:Te,dilations:Ye,dimRoundingMode:Le}});if(Ce){const ft=lt;lt=Object(L.a)({inputs:{a:lt,b:Ce},backend:Z}),Z.disposeIntermediateTensorInfo(ft)}if(Je){const ft=lt;lt=U(Z,lt,Je,De,gt),Z.disposeIntermediateTensorInfo(ft)}return lt}};var ro=t(61);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa={kernelName:n.GatherNd,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{params:fe,indices:H}=Oe,ce=n.util.sizeFromShape(fe.shape),Ce=H.shape,De=Ce[Ce.length-1],[Fe,Ie,Te,Ye]=n.backend_util.prepareAndValidate(fe,H);if(Ie===0)return Z.makeTensorInfo(Fe,fe.dtype,[]);const Le=Z.data.get(H.dataId).values,Je=Z.bufferSync(fe),gt=Object(ro.a)(Le,Je,fe.dtype,Ie,De,Te,Ye,fe.shape,ce);return Z.makeTensorInfo(Fe,fe.dtype,gt.values)}};var Va=t(62);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qi={kernelName:n.GatherV2,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,indices:ce}=Oe,{axis:Ce,batchDims:De}=fe;Object(r.a)([H,ce],"gatherV2");const Fe=n.util.parseAxisParam(Ce,H.shape)[0],Ie=Z.data.get(ce.dataId).values,Te=H.shape[Fe];for(let G=0;G<Ie.length;++G){const A=Ie[G];n.util.assert(A<=Te-1&&A>=0,()=>`GatherV2: the index value ${A} is not in [0, ${Te-1}]`)}let Ye=De;De==null&&(Ye=0);const Le=n.util.sizeFromShape(ce.shape),Je=n.backend_util.segment_util.collectGatherOpShapeInfo(H,ce,Fe,Ye),gt=Y({inputs:{x:H},backend:Z,attrs:{shape:[Je.batchSize,Je.outerSize,Je.dimSize,Je.sliceSize]}}),lt=Y({inputs:{x:ce},backend:Z,attrs:{shape:[Je.batchSize,Le/Je.batchSize]}}),ft=[Je.batchSize,Je.outerSize,Le/Je.batchSize,Je.sliceSize],yt=Z.bufferSync(lt),$t=Z.bufferSync(gt),Bt=Object(Va.a)($t,yt,ft);return Z.disposeIntermediateTensorInfo(gt),Z.disposeIntermediateTensorInfo(lt),Z.makeTensorInfo(Je.outputShape,Bt.dtype,Bt.values)}};var _i=t(63),ri=t(64);const $u={kernelName:n.IFFT,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{input:fe}=Oe,H=n.util.sizeFromShape(fe.shape),ce=fe.shape[fe.shape.length-1],Ce=Y({inputs:{x:fe},backend:Z,attrs:{shape:[H/ce,ce]}}),De=It(Ce,!0,Z),Fe=Y({inputs:{x:De},backend:Z,attrs:{shape:fe.shape}});return Z.disposeIntermediateTensorInfo(Ce),Z.disposeIntermediateTensorInfo(De),Fe}},go=Object(i.a)(n.IsFinite,Se=>Number.isFinite(Se)?1:0,"bool"),bo={kernelName:n.IsFinite,backendName:"cpu",kernelFunc:go},Ua=Object(i.a)(n.IsInf,Se=>Math.abs(Se)===1/0?1:0,"bool"),Wr={kernelName:n.IsInf,backendName:"cpu",kernelFunc:Ua},Ji=Object(i.a)(n.IsNan,Se=>Number.isNaN(Se)?1:0,"bool"),Xr={kernelName:n.IsNan,backendName:"cpu",kernelFunc:Ji};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ja=t(65),To=t(66),ai=t(67);const Tu={kernelName:n.LinSpace,backendName:"cpu",kernelFunc:function(Se){const{backend:Oe,attrs:Z}=Se,{start:fe,stop:H,num:ce}=Z,Ce=Object(ai.a)(fe,H,ce);return Oe.makeTensorInfo([Ce.length],"float32",Ce)}};var oi=t(68);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uo=Object(i.a)(n.Log1p,Se=>Math.log1p(Se)),Nu={kernelName:n.Log1p,backendName:"cpu",kernelFunc:Uo},Ls=Object(p.a)((Se,Oe)=>Se&&Oe),Lr=Object(se.a)(n.LogicalAnd,Ls,null,"bool"),ao={kernelName:n.LogicalAnd,backendName:"cpu",kernelFunc:Lr},Si=Object(i.a)(n.LogicalNot,Se=>Se?0:1,"bool"),eu={kernelName:n.LogicalNot,backendName:"cpu",kernelFunc:Si},No=Object(p.a)((Se,Oe)=>Se||Oe),$i=Object(se.a)(n.LogicalOr,No,null,"bool"),Ti={kernelName:n.LogicalOr,backendName:"cpu",kernelFunc:$i},ii={kernelName:n.LRN,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{depthRadius:ce,bias:Ce,alpha:De,beta:Fe}=fe;Object(r.a)(H,"LRN");const Ie=H.shape[3],Te=Ie-1,Ye=Z.data.get(H.dataId).values,Le=n.util.sizeFromShape(H.shape),Je=new Float32Array(Le);function gt(lt){const ft=lt%Ie;let yt=lt-ft+Math.max(0,ft-ce);const $t=lt-ft+Math.min(ft+ce,Te);let Bt=0;for(;yt<=$t;yt++){const G=Ye[yt];Bt+=G*G}return Bt}for(let lt=0;lt<Le;lt++){const ft=gt(lt),yt=Ye[lt]*Math.pow(Ce+De*ft,-Fe);Je[lt]=yt}return Z.makeTensorInfo(H.shape,H.dtype,Je)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bs={kernelName:n.LRNGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,y:ce,dy:Ce}=Oe,{depthRadius:De,bias:Fe,alpha:Ie,beta:Te}=fe;Object(r.a)(Ce,"LRNGrad");const Ye=n.util.sizeFromShape(Ce.shape),Le=Ce.shape[3],Je=Z.data.get(Ce.dataId).values,gt=Z.data.get(H.dataId).values,lt=Z.data.get(ce.dataId).values,ft=new Float32Array(Ye),yt=Ye;for(let $t=0;$t<yt;$t++){const Bt=$t%Le,G=$t-Bt+Math.max(0,Bt-De),A=$t-Bt+Math.min(Le,Bt+De+1);let R=0;for(let q=G;q<A;q++)R+=Math.pow(gt[q],2);R=Ie*R+Fe;for(let q=G;q<A;q++){let j=-2*Ie*Te*gt[q]*lt[$t]/R;$t===q&&(j+=Math.pow(R,-Te)),j*=Je[$t],ft[q]+=j}}return Z.makeTensorInfo(Ce.shape,H.dtype,ft)}};var jn=t(69),hr=t(46);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gn(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{reductionIndices:ce,keepDims:Ce}=fe,De=Z;let Fe=H.shape;const Ie=Fe.length,Te=n.util.parseAxisParam(ce,Fe);let Ye=Te;const Le=n.backend_util.getAxesPermutation(Ye,Ie);let Je=De.data.get(H.dataId).values;if(Le!=null){const G=new Array(Ie);for(let A=0;A<G.length;A++)G[A]=Fe[Le[A]];Je=Object(hr.a)(Je,Fe,H.dtype,Le,G),Ye=n.backend_util.getInnerMostAxes(Ye.length,Ie),Fe=G}Object(r.a)(H,"max"),n.backend_util.assertAxesAreInnerMostDims("max",Ye,Ie);const[gt,lt]=n.backend_util.computeOutAndReduceShapes(Fe,Ye),ft=n.util.sizeFromShape(lt),yt=Object(jn.a)(Je,ft,gt,H.dtype),$t=De.write(yt,gt,H.dtype);let Bt=gt;return Ce&&(Bt=n.backend_util.expandShapeToKeepDim(gt,Te)),{dataId:$t,shape:Bt,dtype:H.dtype}}const Aa={kernelName:n.Max,backendName:"cpu",kernelFunc:Gn};var Vr=t(70);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua={kernelName:n.MaxPool,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe;Object(r.a)(H,"maxPool");const{filterSize:ce,strides:Ce,pad:De,dimRoundingMode:Fe}=fe;n.util.assert(n.backend_util.eitherStridesOrDilationsAreOne(Ce,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${Ce} and dilations '1'`);const Ie=n.backend_util.computePool2DInfo(H.shape,ce,Ce,1,De,Fe);let Te;if(Ie.filterWidth===1&&Ie.filterHeight===1&&n.util.arraysEqual(Ie.inShape,Ie.outShape))Te=Object(d.a)({inputs:{x:H},backend:Z});else{const Ye=Z.data.get(H.dataId).values,Le=n.util.computeStrides(H.shape),Je=ht(Ye,H.shape,H.dtype,Le,Ie,"max");Te=Z.makeTensorInfo(Ie.outShape,H.dtype,Je.values)}return Te}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tu={kernelName:n.MaxPool3D,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{filterSize:ce,strides:Ce,pad:De,dimRoundingMode:Fe,dataFormat:Ie}=fe;Object(r.a)(H,"maxPool3d");const Te=n.backend_util.computePool3DInfo(H.shape,ce,Ce,1,De,Fe,Ie),Ye=Ot(Z.data.get(H.dataId).values,H.shape,H.dtype,n.util.computeStrides(H.shape),Te,"max");return Z.makeTensorInfo(Ye.shape,"float32",Ye.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ui={kernelName:n.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,input:ce}=Oe,{filterSize:Ce,strides:De,pad:Fe,dimRoundingMode:Ie}=fe;Object(r.a)([H,ce],"maxPool3DGrad");const Te=n.backend_util.computePool3DInfo(ce.shape,Ce,De,1,Fe,Ie),Ye=function(ie,he){const xe=Object(n.buffer)(he.outShape,"int32"),_e=he.strideDepth,Ue=he.strideHeight,nt=he.strideWidth,it=he.dilationDepth,et=he.dilationHeight,dt=he.dilationWidth,ut=he.effectiveFilterDepth,Et=he.effectiveFilterHeight,Tt=he.effectiveFilterWidth,Dt=he.padInfo.front,Wt=he.padInfo.top,qt=he.padInfo.left;for(let cn=0;cn<he.batchSize;++cn)for(let rn=0;rn<he.inChannels;++rn)for(let yn=0;yn<he.outDepth;++yn){const Fn=yn*_e-Dt;let _n=Fn;for(;_n<0;)_n+=it;const ss=Math.min(he.inDepth,ut+Fn);for(let zn=0;zn<he.outHeight;++zn){const Kn=zn*Ue-Wt;let us=Kn;for(;us<0;)us+=et;const ps=Math.min(he.inHeight,Et+Kn);for(let es=0;es<he.outWidth;++es){const ks=es*nt-qt;let Ks=ks;for(;Ks<0;)Ks+=dt;const sa=Math.min(he.inWidth,Tt+ks);let or=Number.NEGATIVE_INFINITY,_r=-1;for(let yr=_n;yr<ss;yr+=it){const Ga=yr-Fn;for(let ma=us;ma<ps;ma+=et){const Ha=ma-Kn;for(let vo=Ks;vo<sa;vo+=dt){const pi=vo-ks,fi=ie.get(cn,yr,ma,vo,rn);fi>=or&&(or=fi,_r=Ga*Et*Tt+Ha*Et+pi)}}}xe.set(_r,cn,yn,zn,es,rn)}}}return xe}(Z.bufferSync(ce),Te),Le=Te.strideDepth,Je=Te.strideHeight,gt=Te.strideWidth,lt=Te.dilationDepth,ft=Te.dilationHeight,yt=Te.dilationWidth,$t=Te.effectiveFilterDepth,Bt=Te.effectiveFilterHeight,G=Te.effectiveFilterWidth,A=$t-1-Te.padInfo.front,R=G-1-Te.padInfo.left,q=Bt-1-Te.padInfo.top,j=Object(n.buffer)(ce.shape,"float32"),te=Z.bufferSync(H);for(let ie=0;ie<Te.batchSize;++ie)for(let he=0;he<Te.inChannels;++he)for(let xe=0;xe<Te.inDepth;++xe)for(let _e=0;_e<Te.inHeight;++_e)for(let Ue=0;Ue<Te.inWidth;++Ue){const nt=xe-A,it=_e-q,et=Ue-R;let dt=0;for(let ut=0;ut<$t;ut+=lt){const Et=(nt+ut)/Le;if(!(Et<0||Et>=Te.outDepth||Math.floor(Et)!==Et))for(let Tt=0;Tt<Bt;Tt+=ft){const Dt=(it+Tt)/Je;if(!(Dt<0||Dt>=Te.outHeight||Math.floor(Dt)!==Dt))for(let Wt=0;Wt<G;Wt+=yt){const qt=(et+Wt)/gt;if(qt<0||qt>=Te.outWidth||Math.floor(qt)!==qt)continue;const cn=$t*Bt*G-1-Ye.get(ie,Et,Dt,qt,he)===ut*Bt*G+Tt*G+Wt?1:0;cn!==0&&(dt+=te.get(ie,Et,Dt,qt,he)*cn)}}}j.set(dt,ie,xe,_e,Ue,he)}return Z.makeTensorInfo(j.shape,j.dtype,j.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jo={kernelName:n.MaxPoolGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{dy:H,input:ce,output:Ce}=Oe,De=ce;Object(r.a)([ce,Ce],"maxPoolGrad");const{filterSize:Fe,strides:Ie,pad:Te,dimRoundingMode:Ye}=fe,Le=n.backend_util.computePool2DInfo(De.shape,Fe,Ie,1,Te,Ye),Je=Z.data.get(De.dataId).values,gt=Object(n.buffer)(Le.outShape,De.dtype,Pt(Je,De.shape,De.dtype,Le).values),lt=Le.strideHeight,ft=Le.strideWidth,yt=Le.dilationHeight,$t=Le.dilationWidth,Bt=Le.effectiveFilterHeight,G=Le.effectiveFilterWidth,A=G-1-Le.padInfo.left,R=Bt-1-Le.padInfo.top,q=Object(n.buffer)(De.shape,"float32"),j=Z.data.get(H.dataId).values,te=Object(n.buffer)(H.shape,"float32",j);for(let ie=0;ie<Le.batchSize;++ie)for(let he=0;he<Le.inChannels;++he)for(let xe=0;xe<Le.inHeight;++xe)for(let _e=0;_e<Le.inWidth;++_e){const Ue=xe-R,nt=_e-A;let it=0;for(let et=0;et<Bt;et+=yt){const dt=(Ue+et)/lt;if(!(dt<0||dt>=Le.outHeight||Math.floor(dt)!==dt))for(let ut=0;ut<G;ut+=$t){const Et=(nt+ut)/ft;if(Et<0||Et>=Le.outWidth||Math.floor(Et)!==Et)continue;const Tt=Bt*G-1-gt.get(ie,dt,Et,he)===et*G+ut?1:0;Tt!==0&&(it+=te.get(ie,dt,Et,he)*Tt)}}q.set(it,ie,xe,_e,he)}return Z.makeTensorInfo(q.shape,q.dtype,q.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ku={kernelName:n.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:Se,attrs:Oe,backend:Z})=>{const{x:fe}=Se,{filterSize:H,strides:ce,pad:Ce,includeBatchInIndex:De}=Oe,Fe=Z;Object(r.a)(fe,"MaxPoolWithArgmax");const Ie=Fe.data.get(fe.dataId).values,Te=n.backend_util.computePool2DInfo(fe.shape,H,ce,[1,1],Ce),[Ye,Le]=function(lt,ft,yt,$t,Bt){const G=ht(lt,0,yt,n.util.computeStrides(ft),Bt,"max"),A=Pt(lt,ft,yt,Bt,!0,$t);return[G.values,A.values]}(Ie,fe.shape,fe.dtype,De,Te),Je=Fe.write(Ye,Te.outShape,fe.dtype),gt=Fe.write(Le,Te.outShape,fe.dtype);return[{dataId:Je,shape:Te.outShape,dtype:fe.dtype},{dataId:gt,shape:Te.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ur={kernelName:n.Mean,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,keepDims:Ce}=fe,De=n.util.parseAxisParam(ce,H.shape),Fe=n.backend_util.computeOutAndReduceShapes(H.shape,De)[1],Ie=n.util.sizeFromShape(Fe),Te=[],Ye=Z.makeTensorInfo([],"float32",new Float32Array([Ie]));Te.push(Ye);const Le=Object(ds.a)({inputs:{x:H},backend:Z,attrs:{dtype:"float32"}});Te.push(Le);const Je=na({inputs:{a:Le,b:Ye},backend:Z});Te.push(Je);const gt=za({inputs:{x:Je},backend:Z,attrs:{axis:ce,keepDims:Ce}});return Te.forEach(lt=>Z.disposeIntermediateTensorInfo(lt)),gt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo={kernelName:n.Min,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{axis:ce,keepDims:Ce}=fe;Object(r.a)(H,"min");const De=n.util.parseAxisParam(ce,H.shape);let Fe=De;const Ie=n.backend_util.getAxesPermutation(Fe,H.shape.length);let Te=H;Ie!=null&&(Te=Object(tt.a)({inputs:{x:H},backend:Z,attrs:{perm:Ie}}),Fe=n.backend_util.getInnerMostAxes(Fe.length,H.shape.length)),n.backend_util.assertAxesAreInnerMostDims("min",Fe,Te.shape.length);const[Ye,Le]=n.backend_util.computeOutAndReduceShapes(Te.shape,Fe),Je=n.util.sizeFromShape(Le),gt=n.util.makeZerosTypedArray(n.util.sizeFromShape(Ye),Te.dtype),lt=Z.data.get(Te.dataId).values;for(let yt=0;yt<gt.length;++yt){const $t=yt*Je;let Bt=lt[$t];for(let G=0;G<Je;++G){const A=lt[$t+G];(Number.isNaN(A)||A<Bt)&&(Bt=A)}gt[yt]=Bt}Ie!=null&&Z.disposeIntermediateTensorInfo(Te);const ft=Z.makeTensorInfo(Ye,Te.dtype,gt);if(Ce){const yt=Y({inputs:{x:ft},backend:Z,attrs:{shape:n.backend_util.expandShapeToKeepDim(Ye,De)}});return Z.disposeIntermediateTensorInfo(ft),yt}return ft}};var Go=t(71);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ar={kernelName:n.MirrorPad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{paddings:ce,mode:Ce}=fe;Object(r.a)(H,"mirrorPad");const De=ce.map(($t,Bt)=>$t[0]+H.shape[Bt]+$t[1]),Fe=ce.map($t=>$t[0]),Ie=ce.map(($t,Bt)=>$t[0]+H.shape[Bt]),Te=Ce==="reflect"?0:1,Ye=Z.data.get(H.dataId).values,Le=H.shape.length,Je=n.util.computeStrides(H.shape),gt=n.util.sizeFromShape(De),lt=De.length,ft=n.util.computeStrides(De),yt=n.util.getTypedArrayFromDType(H.dtype,gt);for(let $t=0;$t<gt;$t++){let Bt=n.util.indexToLoc($t,lt,ft);for(let A=0;A<lt;A++)Bt[A]<Fe[A]?Bt[A]=2*Fe[A]-Bt[A]-Te:Bt[A]>=Ie[A]&&(Bt[A]=2*(Ie[A]-1)-Bt[A]+Te);Bt=Bt.map((A,R)=>A-Fe[R]);const G=n.util.locToIndex(Bt,Le,Je);yt[$t]=Ye[G]}return{dataId:Z.write(yt,De,H.dtype),shape:De,dtype:H.dtype}}},xo=Object(p.a)((Se,Oe)=>{const Z=Se%Oe;return Se<0&&Oe<0||Se>=0&&Oe>=0?Z:(Z+Oe)%Oe}),Ni=Object(se.a)(n.Mod,xo),nu={kernelName:n.Mod,backendName:"cpu",kernelFunc:Ni};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ci=t(49);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function li(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{logits:H}=Oe,{dim:ce}=fe,Ce=H.shape.length;let De=ce;if(De===-1&&(De=Ce-1),De!==Ce-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${Ce} and dim was ${De}`);const Fe=n.util.parseAxisParam([De],H.shape),Ie=Gn({inputs:{x:H},backend:Z,attrs:{reductionIndices:Fe,keepDims:!1}}),Te=n.backend_util.expandShapeToKeepDim(Ie.shape,Fe),Ye=Y({inputs:{x:Ie},backend:Z,attrs:{shape:Te}}),Le=Object(We.a)({inputs:{a:H,b:Ye},backend:Z}),Je=Object(so.a)({inputs:{x:Le},backend:Z}),gt=za({inputs:{x:Je},backend:Z,attrs:{axis:Fe,keepDims:!1}}),lt=Y({inputs:{x:gt},backend:Z,attrs:{shape:Te}}),ft=na({inputs:{a:Je,b:lt},backend:Z});return Z.disposeIntermediateTensorInfo(Ie),Z.disposeIntermediateTensorInfo(Ye),Z.disposeIntermediateTensorInfo(Le),Z.disposeIntermediateTensorInfo(Je),Z.disposeIntermediateTensorInfo(gt),Z.disposeIntermediateTensorInfo(lt),ft}const Os={kernelName:n.Softmax,backendName:"cpu",kernelFunc:li};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ei={kernelName:n.Multinomial,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{logits:H}=Oe,{numSamples:ce,seed:Ce,normalized:De}=fe;Object(r.a)(H,"multinomial");const Fe=De?H:li({inputs:{logits:H},backend:Z,attrs:{dim:-1}}),Ie=Fe.shape[0],Te=Fe.shape[1],Ye=Z.data.get(Fe.dataId).values,Le=[Ie,ce],Je=n.util.makeZerosTypedArray(n.util.sizeFromShape(Le),"int32");for(let gt=0;gt<Ie;++gt){const lt=gt*Te,ft=new Float32Array(Te-1);ft[0]=Ye[lt];for(let Bt=1;Bt<ft.length;++Bt)ft[Bt]=ft[Bt-1]+Ye[lt+Bt];const yt=ci.alea(Ce.toString()),$t=gt*ce;for(let Bt=0;Bt<ce;++Bt){const G=yt();Je[$t+Bt]=ft.length;for(let A=0;A<ft.length;A++)if(G<ft[A]){Je[$t+Bt]=A;break}}}return De||Z.disposeIntermediateTensorInfo(Fe),Z.makeTensorInfo(Le,"int32",Je)}};var Ia=t(72);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const su=n.kernel_impls.nonMaxSuppressionV3Impl,Ri={kernelName:n.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{boxes:H,scores:ce}=Oe,{maxOutputSize:Ce,iouThreshold:De,scoreThreshold:Fe}=fe;Object(r.a)(H,"NonMaxSuppression");const Ie=Z.data.get(H.dataId).values,Te=Z.data.get(ce.dataId).values,{selectedIndices:Ye}=su(Ie,Te,Ce,De,Fe);return Z.makeTensorInfo([Ye.length],"int32",new Int32Array(Ye))}},Ai=n.kernel_impls.nonMaxSuppressionV4Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ru={kernelName:n.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{boxes:H,scores:ce}=Oe,{maxOutputSize:Ce,iouThreshold:De,scoreThreshold:Fe,padToMaxOutputSize:Ie}=fe;Object(r.a)(H,"NonMaxSuppressionPadded");const Te=Z.data.get(H.dataId).values,Ye=Z.data.get(ce.dataId).values,{selectedIndices:Le,validOutputs:Je}=Ai(Te,Ye,Ce,De,Fe,Ie);return[Z.makeTensorInfo([Le.length],"int32",new Int32Array(Le)),Z.makeTensorInfo([],"int32",new Int32Array([Je]))]}},Oi=n.kernel_impls.nonMaxSuppressionV5Impl;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo={kernelName:n.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{boxes:H,scores:ce}=Oe,{maxOutputSize:Ce,iouThreshold:De,scoreThreshold:Fe,softNmsSigma:Ie}=fe;Object(r.a)(H,"NonMaxSuppressionWithScore");const Te=Z.data.get(H.dataId).values,Ye=Z.data.get(ce.dataId).values,Le=Ce,Je=De,gt=Fe,lt=Ie,{selectedIndices:ft,selectedScores:yt}=Oi(Te,Ye,Le,Je,gt,lt);return[Z.makeTensorInfo([ft.length],"int32",new Int32Array(ft)),Z.makeTensorInfo([yt.length],"float32",new Float32Array(yt))]}};var Fi=t(73);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cc={kernelName:n.OneHot,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{indices:H}=Oe,{dtype:ce,depth:Ce,onValue:De,offValue:Fe}=fe;Object(r.a)(H,"oneHot");const Ie=n.util.sizeFromShape(H.shape),Te=new Float32Array(Ie*Ce);Te.fill(Fe);const Ye=Z.data.get(H.dataId).values;for(let Le=0;Le<Ie;++Le)Ye[Le]>=0&&Ye[Le]<Ce&&(Te[Le*Ce+Ye[Le]]=De);return Z.makeTensorInfo([...H.shape,Ce],ce,Te)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(Se){const{inputs:Oe,backend:Z}=Se,{x:fe}=Oe;if(fe.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(fe.dtype==="complex64"){const H=Object(Us.a)({inputs:{input:fe},backend:Z}),ce=Di({inputs:{x:H},backend:Z}),Ce=ys({inputs:{input:fe},backend:Z}),De=Di({inputs:{x:Ce},backend:Z}),Fe=Object(ts.a)({inputs:{real:ce,imag:De},backend:Z});return Z.disposeIntermediateTensorInfo(H),Z.disposeIntermediateTensorInfo(ce),Z.disposeIntermediateTensorInfo(Ce),Z.disposeIntermediateTensorInfo(De),Fe}return fn({backend:Z,attrs:{shape:fe.shape,value:0,dtype:fe.dtype}})}const Ro={kernelName:n.ZerosLike,backendName:"cpu",kernelFunc:Di};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const au={kernelName:n.OnesLike,backendName:"cpu",kernelFunc:function Se(Oe){const{inputs:Z,backend:fe}=Oe,{x:H}=Z;if(H.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(H.dtype==="complex64"){const ce=Object(Us.a)({inputs:{input:H},backend:fe}),Ce=Se({inputs:{x:ce},backend:fe}),De=ys({inputs:{input:H},backend:fe}),Fe=Di({inputs:{x:De},backend:fe}),Ie=Object(ts.a)({inputs:{real:Ce,imag:Fe},backend:fe});return fe.disposeIntermediateTensorInfo(ce),fe.disposeIntermediateTensorInfo(Ce),fe.disposeIntermediateTensorInfo(De),fe.disposeIntermediateTensorInfo(Fe),Ie}return fn({backend:fe,attrs:{shape:H.shape,value:1,dtype:H.dtype}})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{axis:H}=fe;if(Oe.length===1)return Zs({inputs:{input:Oe[0]},backend:Z,attrs:{dim:H}});const ce=Oe[0].shape,Ce=Oe[0].dtype;Oe.forEach(Ie=>{n.util.assertShapesMatch(ce,Ie.shape,"All tensors passed to stack must have matching shapes"),n.util.assert(Ce===Ie.dtype,()=>"All tensors passed to stack must have matching dtypes")});const De=[],Fe=jt({inputs:Oe.map(Ie=>{const Te=Zs({inputs:{input:Ie},backend:Z,attrs:{dim:H}});return De.push(Te),Te}),backend:Z,attrs:{axis:H}});return De.forEach(Ie=>Z.disposeIntermediateTensorInfo(Ie)),Fe}const _c={kernelName:n.Pack,backendName:"cpu",kernelFunc:Mi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const di={kernelName:n.PadV2,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{paddings:ce,constantValue:Ce}=fe;Object(r.a)(H,"pad");const De=ce.map((yt,$t)=>yt[0]+H.shape[$t]+yt[1]),Fe=ce.map(yt=>yt[0]),Ie=Z.data.get(H.dataId).values,Te=n.util.sizeFromShape(H.shape),Ye=H.shape.length,Le=n.util.computeStrides(H.shape),Je=n.util.sizeFromShape(De),gt=De.length,lt=n.util.computeStrides(De),ft=n.util.getTypedArrayFromDType(H.dtype,Je);Ce!==0&&ft.fill(Ce);for(let yt=0;yt<Te;yt++){const $t=n.util.indexToLoc(yt,Ye,Le).map((Bt,G)=>Bt+Fe[G]);ft[n.util.locToIndex($t,gt,lt)]=Ie[yt]}return{dataId:Z.write(ft,De,H.dtype),shape:De,dtype:H.dtype}}},Pi=Object(p.a)((Se,Oe)=>Math.pow(Se,Oe)),ou=Object(se.a)(n.Pow,Pi),Xu={kernelName:n.Pow,backendName:"cpu",kernelFunc:ou};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Sc=t(74),$c=t(75);const Yu={kernelName:n.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{shape:H,values:ce,defaultValue:Ce,rowPartitionTensors:De}=Oe,{rowPartitionTypes:Fe}=fe,Ie=Z.data.get(H.dataId).values,Te=Z.data.get(ce.dataId).values,Ye=Z.data.get(Ce.dataId).values,Le=De.map(ft=>Z.data.get(ft.dataId).values),Je=De.map(ft=>ft.shape),[gt,lt]=Object($c.a)(Ie,H.shape,Te,ce.shape,ce.dtype,Ye,Ce.shape,Le,Je,Fe);return Z.makeTensorInfo(gt,ce.dtype,lt)}};var Pe=t(76);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const me={kernelName:n.Range,backendName:"cpu",kernelFunc:function(Se){const{backend:Oe,attrs:Z}=Se,{start:fe,stop:H,dtype:ce,step:Ce}=Z,De=Object(Pe.a)(fe,H,Ce,ce);return Oe.makeTensorInfo([De.length],ce,De)}},He=Object(i.a)(n.Reciprocal,Se=>1/Se),st={kernelName:n.Reciprocal,backendName:"cpu",kernelFunc:He};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ae={kernelName:n.ResizeBilinear,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{images:H}=Oe,{alignCorners:ce,halfPixelCenters:Ce,size:De}=fe;Object(r.a)(H,"resizeBilinear");const Fe=n.util.computeStrides(H.shape),[Ie,Te]=De,[Ye,Le,Je,gt]=H.shape,lt=Z.data.get(H.dataId).values,ft=new Float32Array(n.util.sizeFromShape([Ye,Ie,Te,gt])),yt=[ce&&Ie>1?Le-1:Le,ce&&Te>1?Je-1:Je],$t=[ce&&Ie>1?Ie-1:Ie,ce&&Te>1?Te-1:Te];let Bt=0;const G=yt[0]/$t[0],A=yt[1]/$t[1];for(let R=0;R<Ye;R++)for(let q=0;q<Ie;q++){let j;j=Ce?G*(q+.5)-.5:G*q;const te=Math.max(0,Math.floor(j)),ie=j-te,he=Math.min(Le-1,Math.ceil(j)),xe=R*Fe[0]+te*Fe[1],_e=R*Fe[0]+he*Fe[1];for(let Ue=0;Ue<Te;Ue++){let nt;nt=Ce?A*(Ue+.5)-.5:A*Ue;const it=Math.max(0,Math.floor(nt)),et=nt-it,dt=Math.min(Je-1,Math.ceil(nt)),ut=xe+it*Fe[2],Et=_e+it*Fe[2],Tt=xe+dt*Fe[2],Dt=_e+dt*Fe[2];for(let Wt=0;Wt<gt;Wt++){const qt=lt[ut+Wt],cn=lt[Et+Wt],rn=qt+(lt[Tt+Wt]-qt)*et,yn=rn+(cn+(lt[Dt+Wt]-cn)*et-rn)*ie;ft[Bt++]=yn}}}return Z.makeTensorInfo([Ye,Ie,Te,gt],"float32",ft)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rt={kernelName:n.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{images:H,dy:ce}=Oe,{alignCorners:Ce}=fe;Object(r.a)([ce,H],"resizeBilinearGrad");const De=n.util.computeStrides(H.shape),[Fe,Ie,Te,Ye]=H.shape,[,Le,Je]=ce.shape,gt=new Float32Array(Fe*Ie*Te*Ye),lt=[Ce&&Le>1?Ie-1:Ie,Ce&&Je>1?Te-1:Te],ft=[Ce&&Le>1?Le-1:Le,Ce&&Je>1?Je-1:Je],yt=lt[0]/ft[0],$t=lt[1]/ft[1],Bt=Z.data.get(ce.dataId).values;let G=0;for(let A=0;A<Fe;A++){const R=A*De[0];for(let q=0;q<Le;q++){const j=q*yt,te=Math.floor(j),ie=Math.min(Math.ceil(j),Ie-1),he=R+te*De[1],xe=R+ie*De[1],_e=j-te,Ue=1-_e;for(let nt=0;nt<Je;nt++){const it=nt*$t,et=Math.floor(it),dt=Math.min(Math.ceil(it),Te-1),ut=it-et,Et=1-ut,Tt=he+et*De[2],Dt=he+dt*De[2],Wt=xe+et*De[2],qt=xe+dt*De[2],cn=Ue*Et,rn=Ue*ut,yn=_e*Et,Fn=_e*ut;for(let _n=0;_n<Ye;_n++){const ss=Bt[G++];gt[Tt+_n]+=ss*cn,gt[Dt+_n]+=ss*rn,gt[Wt+_n]+=ss*yn,gt[qt+_n]+=ss*Fn}}}}return Z.makeTensorInfo([Fe,Te,Ie,Ye],"float32",gt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt={kernelName:n.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{images:H}=Oe,{alignCorners:ce,halfPixelCenters:Ce,size:De}=fe;Object(r.a)(H,"resizeNearestNeighbor");const Fe=n.util.computeStrides(H.shape),[Ie,Te]=De,[Ye,Le,Je,gt]=H.shape,lt=Z.data.get(H.dataId).values,ft=new Float32Array(Ye*Ie*Te*gt),yt=[ce&&Ie>1?Le-1:Le,ce&&Te>1?Je-1:Je],$t=[ce&&Ie>1?Ie-1:Ie,ce&&Te>1?Te-1:Te],Bt=yt[0]/$t[0],G=yt[1]/$t[1];let A=0;for(let R=0;R<Ye;R++){const q=R*Fe[0];for(let j=0;j<Ie;j++){const te=Ce?Bt*(j+.5):Bt*j;let ie=Math.min(Le-1,ce?Math.round(te):Math.floor(te));Ce&&(ie=Math.max(0,ie));const he=q+ie*Fe[1];for(let xe=0;xe<Te;xe++){const _e=Ce?G*(xe+.5):G*xe;let Ue=Math.min(Je-1,ce?Math.round(_e):Math.floor(_e));Ce&&(Ue=Math.max(0,Ue));const nt=he+Ue*Fe[2];for(let it=0;it<gt;it++){const et=lt[nt+it];ft[A++]=et}}}}return Z.makeTensorInfo([Ye,Ie,Te,gt],H.dtype,ft)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nt={kernelName:n.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{images:H,dy:ce}=Oe,{alignCorners:Ce}=fe;Object(r.a)([ce,H],"resizeNearestNeighborGrad");const De=n.util.computeStrides(H.shape),Fe=n.util.computeStrides(ce.shape),[Ie,Te,Ye,Le]=H.shape,[,Je,gt]=ce.shape,lt=new Float32Array(Ie*Te*Ye*Le),ft=Z.data.get(ce.dataId).values,yt=[Ce&&Je>1?Te-1:Te,Ce&&gt>1?Ye-1:Ye],$t=[Ce&&Je>1?Je-1:Je,Ce&&gt>1?gt-1:gt],Bt=yt[0]/$t[0],G=yt[1]/$t[1],A=1/Bt,R=1/G,q=2*Math.ceil(A)+2,j=2*Math.ceil(R)+2;for(let te=0;te<Ie;te++){const ie=te*De[0];for(let he=0;he<Te;he++){const xe=ie+he*De[1],_e=Math.floor(he*A),Ue=Math.floor(_e-q/2);for(let nt=0;nt<Ye;nt++){const it=xe+nt*De[2],et=Math.floor(nt*R),dt=Math.floor(et-j/2);for(let ut=0;ut<Le;ut++){let Et=0;for(let Tt=0;Tt<q;Tt++){const Dt=Tt+Ue;if(Dt<0||Dt>=Je)continue;const Wt=ie+Dt*Fe[1],qt=Dt*Bt;if(he===Math.min(Te-1,Ce?Math.round(qt):Math.floor(qt)))for(let cn=0;cn<j;cn++){const rn=cn+dt;if(rn<0||rn>=gt)continue;const yn=Wt+rn*Fe[2],Fn=rn*G;nt===Math.min(Ye-1,Ce?Math.round(Fn):Math.floor(Fn))&&(Et+=ft[yn+ut])}}lt[it+ut]=Et}}}}return Z.makeTensorInfo(H.shape,H.dtype,lt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vt={kernelName:n.Reverse,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{dims:ce}=fe;Object(r.a)(H,"reverse");const Ce=H.shape.length,De=n.util.parseAxisParam(ce,H.shape);if(Ce===0)return Object(d.a)({inputs:{x:H},backend:Z});const Fe=new n.TensorBuffer(H.shape,H.dtype),Ie=Z.bufferSync(H);for(let Te=0;Te<Fe.size;Te++){const Ye=Fe.indexToLoc(Te),Le=Ye.slice();De.forEach(Je=>Le[Je]=H.shape[Je]-1-Le[Je]),Fe.set(Ie.get(...Le),...Ye)}return Z.makeTensorInfo(Fe.shape,Fe.dtype,Fe.values)}},St={kernelName:n.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:Se,attrs:Oe,backend:Z})=>{const{image:fe}=Se,{radians:H,fillValue:ce,center:Ce}=Oe,De=Z,Fe=n.util.getTypedArrayFromDType(fe.dtype,n.util.sizeFromShape(fe.shape)),[Ie,Te,Ye,Le]=fe.shape,[Je,gt]=n.backend_util.getImageCenter(Ce,Te,Ye),lt=Math.sin(H),ft=Math.cos(H),yt=De.data.get(fe.dataId).values;for(let $t=0;$t<Ie;$t++){const Bt=$t*Ye*Te*Le;for(let G=0;G<Te;G++){const A=G*(Ye*Le);for(let R=0;R<Ye;R++){const q=R*Le;for(let j=0;j<Le;j++){const te=[Ie,G,R,j],ie=te[2],he=te[1];let xe=(ie-Je)*ft-(he-gt)*lt,_e=(ie-Je)*lt+(he-gt)*ft;xe=Math.round(xe+Je),_e=Math.round(_e+gt);let Ue=ce;typeof ce!="number"&&(Ue=j===3?255:ce[j]),xe>=0&&xe<Ye&&_e>=0&&_e<Te&&(Ue=yt[Bt+_e*(Ye*Le)+xe*Le+j]),Fe[Bt+A+q+j]=Ue}}}}return{dataId:De.write(Fe,fe.shape,fe.dtype),shape:fe.shape,dtype:fe.dtype}}},_t=Object(i.a)(n.Round,Se=>{const Oe=Math.floor(Se);return Se-Oe<.5?Math.floor(Se):Se-Oe>.5?Math.ceil(Se):Oe%2==0?Oe:Oe+1}),en={kernelName:n.Round,backendName:"cpu",kernelFunc:_t};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Kt=t(77),Ze=t(33);const Lt={kernelName:n.ScatterNd,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{indices:H,updates:ce}=Oe,{shape:Ce}=fe,{sliceRank:De,numUpdates:Fe,sliceSize:Ie,strides:Te,outputSize:Ye}=n.backend_util.calculateShapes(ce,H,Ce),Le=Z.bufferSync(H),Je=Z.bufferSync(ce),gt=Object(Ze.a)(Le,Je,Ce,Ye,Ie,Fe,De,Te,0,!0);return Z.makeTensorInfo(Ce,gt.dtype,gt.values)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jt(Se,Oe){let Z=0,fe=Se.length,H=0;for(;Z<fe;)H=Math.floor((Z+fe)/2),Se[H]<Oe?Z=H+1:fe=H;return fe}function un(Se,Oe){let Z=0,fe=Se.length,H=0;for(;Z<fe;)H=Math.floor((Z+fe)/2),Se[H]<=Oe?Z=H+1:fe=H;return fe}const In={kernelName:n.SearchSorted,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{sortedSequence:H,values:ce}=Oe,{side:Ce}=fe,De=function(Fe,Ie,Te,Ye,Le,Je){const gt=n.util.getArrayFromDType("int32",Te*Le);for(let lt=0;lt<Te;++lt){const ft=Fe.slice(lt*Ye,(lt+1)*Ye),yt=lt*Le;for(let $t=0;$t<Le;++$t)gt[yt+$t]=Je==="left"?Jt(ft,Ie[$t+yt]):un(ft,Ie[$t+yt])}return gt}(Z.data.get(H.dataId).values,Z.data.get(ce.dataId).values,H.shape[0],H.shape[1],ce.shape[1],Ce);return Z.makeTensorInfo(ce.shape,"int32",De)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xt={kernelName:n.Select,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{condition:fe,t:H,e:ce}=Oe;Object(r.a)([fe,H,ce],"select");const Ce=fe.shape.length,De=Z.data.get(fe.dataId).values,Fe=Z.data.get(H.dataId).values,Ie=Z.data.get(ce.dataId).values,Te=Object(n.upcastType)(H.dtype,ce.dtype),Ye=n.util.makeZerosTypedArray(n.util.sizeFromShape(H.shape),Te);let Le=0;const Je=Ce===0||Ce>1||H.shape.length===1?1:n.util.sizeFromShape(H.shape.slice(1));for(let gt=0;gt<De.length;gt++)for(let lt=0;lt<Je;lt++)De[gt]===1?Ye[Le++]=Fe[gt]:Ye[Le++]=Ie[gt];return Z.makeTensorInfo(H.shape,Te,Ye)}},$n=n.backend_util.SELU_SCALEALPHA,Jn=n.backend_util.SELU_SCALE,Ss=Object(i.a)(n.Selu,Se=>Se>=0?Jn*Se:$n*(Math.exp(Se)-1)),Ms={kernelName:n.Selu,backendName:"cpu",kernelFunc:Ss},Ps=Object(i.a)(n.Sign,Se=>Se<0?-1:Se>0?1:0),Fs={kernelName:n.Sign,backendName:"cpu",kernelFunc:Ps},pr=Object(i.a)(n.Sin,Se=>Math.sin(Se)),er={kernelName:n.Sin,backendName:"cpu",kernelFunc:pr},fr=Object(i.a)(n.Sinh,Se=>Math.sinh(Se)),cr={kernelName:n.Sinh,backendName:"cpu",kernelFunc:fr},jr=Math.log(11920928955078125e-23)+2,Ca=Object(i.a)(n.Softplus,Se=>{const Oe=Se>-jr,Z=Se<jr,fe=Math.exp(Se);let H;return H=Z?fe:Oe?Se:Math.log(1+fe),H}),yo={kernelName:n.Softplus,backendName:"cpu",kernelFunc:Ca};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ao={kernelName:n.SpaceToBatchND,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{blockShape:ce,paddings:Ce}=fe;Object(r.a)([H],"spaceToBatchND");const De=n.util.sizeFromShape(ce),Fe=[[0,0]];Fe.push(...Ce);for(let $t=1+ce.length;$t<H.shape.length;++$t)Fe.push([0,0]);const Ie=di.kernelFunc({inputs:{x:H},backend:Z,attrs:{paddings:Fe,constantValue:0}}),Te=n.backend_util.getReshaped(Ie.shape,ce,De,!1),Ye=n.backend_util.getPermuted(Te.length,ce.length,!1),Le=n.backend_util.getReshapedPermuted(Ie.shape,ce,De,!1),Je=Y({inputs:{x:Ie},backend:Z,attrs:{shape:Te}}),gt={x:Je},lt={perm:Ye},ft=Object(tt.a)({inputs:gt,backend:Z,attrs:lt}),yt=Y({inputs:{x:ft},backend:Z,attrs:{shape:Le}});return Z.disposeIntermediateTensorInfo(Ie),Z.disposeIntermediateTensorInfo(Je),Z.disposeIntermediateTensorInfo(ft),yt}};var Li=t(78);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hi={kernelName:n.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{indices:fe,values:H,denseShape:ce,defaultValue:Ce}=Oe;if(ce.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${ce.shape}`);if(fe.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${fe.shape}`);if(H.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${H.shape}`);if(Ce.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${Ce.shape}`);const De=Z.data.get(fe.dataId).values,Fe=Z.data.get(H.dataId).values,Ie=Z.data.get(ce.dataId).values,Te=Z.data.get(Ce.dataId).values[0],[Ye,Le,Je,gt,lt]=Object(Li.a)(De,fe.shape,fe.dtype,Fe,H.dtype,Ie,Te);return[Z.makeTensorInfo(Le,fe.dtype,Ye),Z.makeTensorInfo([Le[0]],H.dtype,Je),Z.makeTensorInfo([gt.length],"bool",new Uint8Array(gt.map(ft=>Number(ft)))),Z.makeTensorInfo([lt.length],fe.dtype,new Int32Array(lt))]}};var wo=t(79);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ho={kernelName:n.SparseReshape,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{inputIndices:fe,inputShape:H,newShape:ce}=Oe;if(fe.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${fe.shape}`);if(H.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${H.shape}`);if(ce.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${ce.shape}`);const Ce=Array.from(Z.data.get(H.dataId).values),De=Z.data.get(fe.dataId).values,Fe=Array.from(Z.data.get(ce.dataId).values),[Ie,Te,Ye]=Object(wo.a)(De,fe.shape,fe.dtype,Ce,Fe);return[Z.makeTensorInfo(Te,fe.dtype,Ie),Z.makeTensorInfo([Ye.length],ce.dtype,new Int32Array(Ye))]}};var qo=t(48);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bi={kernelName:n.SparseSegmentMean,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{data:fe,indices:H,segmentIds:ce}=Oe;if(fe.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(H.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${H.shape}`);if(ce.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${ce.shape}`);if(H.shape[0]!==ce.shape[0])throw new Error("segmentIds and indices should have same size.");const Ce=Z.data.get(fe.dataId).values,De=Z.data.get(H.dataId).values,Fe=Z.data.get(ce.dataId).values,[Ie,Te]=Object(qo.a)(Ce,fe.shape,fe.dtype,De,Fe,!0);return Z.makeTensorInfo(Te,fe.dtype,Ie)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ca={kernelName:n.SparseSegmentSum,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z}=Se,{data:fe,indices:H,segmentIds:ce}=Oe;if(fe.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(H.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${H.shape}`);if(ce.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${ce.shape}`);if(H.shape[0]!==ce.shape[0])throw new Error("segmentIds and indices should have same size.");const Ce=Z.data.get(fe.dataId).values,De=Z.data.get(H.dataId).values,Fe=Z.data.get(ce.dataId).values,[Ie,Te]=Object(qo.a)(Ce,fe.shape,fe.dtype,De,Fe);return Z.makeTensorInfo(Te,fe.dtype,Ie)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zi={kernelName:n.SparseToDense,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{sparseIndices:H,sparseValues:ce,defaultValue:Ce}=Oe,{outputShape:De}=fe,{sliceRank:Fe,numUpdates:Ie,sliceSize:Te,strides:Ye,outputSize:Le}=n.backend_util.calculateShapes(ce,H,De),Je=!1,gt=Z.bufferSync(H);let lt;switch(ce.dtype){case"bool":{const ft=Z.bufferSync(ce),yt=Boolean(Z.data.get(Ce.dataId).values[0]);lt=Object(Ze.a)(gt,ft,De,Le,Te,Ie,Fe,Ye,yt,Je);break}case"float32":{const ft=Z.bufferSync(ce),yt=Z.data.get(Ce.dataId).values[0];lt=Object(Ze.a)(gt,ft,De,Le,Te,Ie,Fe,Ye,yt,Je);break}case"int32":{const ft=Z.bufferSync(ce),yt=Z.data.get(Ce.dataId).values[0];lt=Object(Ze.a)(gt,ft,De,Le,Te,Ie,Fe,Ye,yt,Je);break}case"string":{const ft=Z.bufferSync(ce),yt=n.util.decodeString(Z.data.get(Ce.dataId).values[0]);lt=Object(Ze.a)(gt,ft,De,Le,Te,Ie,Fe,Ye,yt,Je);break}default:throw new Error(`Unsupported type ${ce.dtype}`)}return Z.makeTensorInfo(De,lt.dtype,lt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zu={kernelName:n.SplitV,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{numOrSizeSplits:ce,axis:Ce}=fe,De=n.util.parseAxisParam(Ce,H.shape)[0],Fe=n.backend_util.prepareSplitSize(H,ce,De),Ie=new Array(H.shape.length).fill(0),Te=H.shape.slice();return Fe.map(Ye=>{const Le=[...Te];Le[De]=Ye;const Je=Object(Un.a)({inputs:{x:H},backend:Z,attrs:{begin:Ie,size:Le}});return Ie[De]+=Ye,Je})}};var Wi=t(80);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qu={kernelName:n.Square,backendName:"cpu",kernelFunc:({inputs:Se,backend:Oe})=>{const{x:Z}=Se,fe=Oe;Object(r.a)(Z,"square");const H=fe.data.get(Z.dataId).values,ce=new Float32Array(H.length);for(let Ce=0;Ce<H.length;++Ce){const De=H[Ce];ce[Ce]=De*De}return{dataId:fe.write(ce,Z.shape,Z.dtype),shape:Z.shape,dtype:Z.dtype}}};var Ol=t(81);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kc=Object(i.a)(n.Step,(Se,Oe)=>{const Z=Oe;return isNaN(Se)?NaN:Se>0?1:Z.alpha}),Fl={kernelName:n.Step,backendName:"cpu",kernelFunc:Kc};var Xc=t(82);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc={kernelName:n.StridedSlice,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{begin:ce,end:Ce,strides:De,beginMask:Fe,endMask:Ie,ellipsisMask:Te,newAxisMask:Ye,shrinkAxisMask:Le}=fe;Object(r.a)(H,"stridedSlice");const{finalShapeSparse:Je,finalShape:gt,isIdentity:lt,sliceDim0:ft,isSimpleSlice:yt,begin:$t,end:Bt,strides:G}=n.slice_util.sliceInfo(H.shape,ce,Ce,De,Fe,Ie,Te,Ye,Le);let A;if(lt)A=Y({inputs:{x:H},backend:Z,attrs:{shape:gt}});else if(ft||yt){n.util.assert(H.shape.length>=1,()=>`Input must have rank at least 1, got: ${H.shape.length}`);const R=n.slice_util.computeOutShape($t,Bt,G),q=Object(Un.a)({inputs:{x:H},backend:Z,attrs:{begin:$t,size:R}});A=Y({inputs:{x:q},backend:Z,attrs:{shape:gt}}),Z.disposeIntermediateTensorInfo(q)}else{const R=Z.bufferSync(H),q=Object(Xc.a)(Je,R,G,$t);A=Z.makeTensorInfo(gt,q.dtype,q.values)}return A}};var Ju=t(83);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yc={kernelName:n.StringNGrams,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{separator:H,nGramWidths:ce,leftPad:Ce,rightPad:De,padWidth:Fe,preserveShortSequences:Ie}=fe,{data:Te,dataSplits:Ye}=Oe,Le=Z.data.get(Te.dataId).values,Je=Z.data.get(Ye.dataId).values,[gt,lt]=Object(Ju.a)(Le,Je,H,ce,Ce,De,Fe,Ie);return[Z.makeTensorInfo([gt.length],"string",gt),Z.makeTensorInfo(Ye.shape,"int32",lt)]}};var Nc=t(84);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iu={kernelName:n.StringSplit,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{skipEmpty:H}=fe,{input:ce,delimiter:Ce}=Oe;if(ce.dtype!=="string")throw new Error("Input must be of datatype string");if(ce.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${ce.shape}`);if(Ce.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${Ce.shape}`);const De=Z.data.get(ce.dataId).values,Fe=Z.data.get(Ce.dataId).values[0],[Ie,Te,Ye]=Object(Nc.a)(De,Fe,H),Le=Te.length;return[Z.makeTensorInfo([Le,2],"int32",Ie),Z.makeTensorInfo([Le],"string",Te),Z.makeTensorInfo([2],"int32",new Int32Array(Ye))]}};var Dl=t(85);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ml={kernelName:n.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{numBuckets:H}=fe,{input:ce}=Oe;if(ce.dtype!=="string")throw new Error("Input must be of datatype string");if(H<=0)throw new Error("Number of buckets must be at least 1");const Ce=Z.data.get(ce.dataId).values,De=Object(Dl.a)(Ce,H);return Z.makeTensorInfo(ce.shape,"int32",De)}},Pl=Object(i.a)(n.Tan,Se=>Math.tan(Se)),Zc={kernelName:n.Tan,backendName:"cpu",kernelFunc:Pl},ec=Object(i.a)(n.Tanh,Se=>Math.tanh(Se)),Ec={kernelName:n.Tanh,backendName:"cpu",kernelFunc:ec};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Qc=t(86);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ll={kernelName:n.Tile,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{reps:ce}=fe;Object(r.a)(H,"tile");const Ce=Object(Qc.a)(Z.bufferSync(H),ce);return Z.makeTensorInfo(Ce.shape,Ce.dtype,Ce.values)}};var Eu=t(87);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl={kernelName:n.TopK,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H}=Oe,{k:ce,sorted:Ce}=fe;Object(r.a)(H,"topk");const De=Z.data.get(H.dataId).values,[Fe,Ie]=Object(Eu.a)(De,H.shape,H.dtype,ce,Ce);return[Z.makeTensorInfo(Fe.shape,Fe.dtype,Fe.values),Z.makeTensorInfo(Ie.shape,Ie.dtype,Ie.values)]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl={kernelName:n.Transform,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,attrs:Z,backend:fe}=Se,{image:H,transforms:ce}=Oe,{interpolation:Ce,fillMode:De,fillValue:Fe,outputShape:Ie}=Z,[Te,Ye,Le,Je]=H.shape,[gt,lt]=Ie!=null?Ie:[Ye,Le],ft=[Te,gt,lt,Je],yt=n.util.computeStrides(H.shape),$t=yt[0],Bt=yt[1],G=yt[2],A=n.util.computeStrides(ft),R=A[0],q=A[1],j=A[2],te=n.util.getTypedArrayFromDType(H.dtype,n.util.sizeFromShape(ft));te.fill(Fe);const ie=fe.data.get(H.dataId).values,he=fe.data.get(ce.dataId).values;for(let xe=0;xe<Te;++xe){const _e=ce.shape[0]===1?he:he.subarray(8*xe,8*xe+8);for(let Ue=0;Ue<gt;++Ue)for(let nt=0;nt<lt;++nt)for(let it=0;it<Je;++it){let et;const dt=_e[6]*nt+_e[7]*Ue+1;if(dt===0)continue;const ut=(_e[0]*nt+_e[1]*Ue+_e[2])/dt,Et=(_e[3]*nt+_e[4]*Ue+_e[5])/dt,Tt=Jc(ut,Le,De),Dt=Jc(Et,Ye,De);switch(Ce){case"nearest":et=uu(ie,Ye,Le,$t,Bt,G,xe,Dt,Tt,it,Fe);break;case"bilinear":et=tc(ie,Ye,Le,$t,Bt,G,xe,Dt,Tt,it,Fe);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${Ce}`)}te[xe*R+Ue*q+nt*j+it]=et}return fe.makeTensorInfo(ft,H.dtype,te)}return{dataId:fe.write(te,ft,H.dtype),shape:H.shape,dtype:H.dtype}}};function Jc(Se,Oe,Z){switch(Z){case"reflect":return function(fe,H){let ce=fe;if(ce<0)if(H<=1)ce=0;else{const Ce=2*H;ce<Ce&&(ce=Ce*Math.trunc(-ce/Ce)+ce),ce=ce<-H?ce+Ce:-ce-1}else if(ce>H-1)if(H<=1)ce=0;else{const Ce=2*H;ce-=Ce*Math.trunc(ce/Ce),ce>=H&&(ce=Ce-ce-1)}return n.util.clamp(0,ce,H-1)}(Se,Oe);case"wrap":return function(fe,H){let ce=fe;if(ce<0)if(H<=1)ce=0;else{const Ce=H-1;ce+=H*(Math.trunc(-ce/Ce)+1)}else if(ce>H-1)if(H<=1)ce=0;else{const Ce=H-1;ce-=H*Math.trunc(ce/Ce)}return n.util.clamp(0,ce,H-1)}(Se,Oe);case"nearest":return function(fe,H){return n.util.clamp(0,fe,H-1)}(Se,Oe);default:return function(fe,H){return fe}(Se)}}function Ru(Se,Oe,Z,fe,H,ce,Ce,De,Fe,Ie,Te){return 0<=De&&De<Oe&&0<=Fe&&Fe<Z?Se[Ce*fe+De*H+Fe*ce+Ie]:Te}function uu(Se,Oe,Z,fe,H,ce,Ce,De,Fe,Ie,Te){return Ru(Se,Oe,Z,fe,H,ce,Ce,Math.round(De),Math.round(Fe),Ie,Te)}function tc(Se,Oe,Z,fe,H,ce,Ce,De,Fe,Ie,Te){const Ye=Math.floor(De),Le=Math.floor(Fe),Je=Ye+1,gt=Le+1;return(Je-De)*((gt-Fe)*Ru(Se,Oe,Z,fe,H,ce,Ce,Ye,Le,Ie,Te)+(Fe-Le)*Ru(Se,Oe,Z,fe,H,ce,Ce,Ye,gt,Ie,Te))+(De-Ye)*((gt-Fe)*Ru(Se,Oe,Z,fe,H,ce,Ce,Je,Le,Ie,Te)+(Fe-Le)*Ru(Se,Oe,Z,fe,H,ce,Ce,Je,gt,Ie,Te))}var gr=t(88);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rc={kernelName:n.Unique,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,attrs:Z,backend:fe}=Se,{axis:H}=Z,{x:ce}=Oe;Object(r.a)(ce,"unique");const Ce=fe.data.get(ce.dataId).values,{outputValues:De,outputShape:Fe,indices:Ie}=Object(gr.a)(Ce,H,ce.shape,ce.dtype);return[fe.makeTensorInfo(Fe,ce.dtype,De),fe.makeTensorInfo([Ie.length],"int32",Ie)]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Au={kernelName:n.Unpack,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{value:H}=Oe;let{axis:ce}=fe;ce<0&&(ce+=H.shape.length);const Ce=H.shape.length,De=H.shape[ce],Fe=new Array(Ce-1);let Ie=0;for(let Je=0;Je<Ce;Je++)Je!==ce&&(Fe[Ie++]=H.shape[Je]);const Te=new Array(Ce).fill(0),Ye=H.shape.slice();Ye[ce]=1;const Le=new Array(De);for(let Je=0;Je<Le.length;Je++){Te[ce]=Je;const gt=Object(Un.a)({inputs:{x:H},backend:Z,attrs:{begin:Te,size:Ye}});Le[Je]=Y({inputs:{x:gt},backend:Z,attrs:{shape:Fe}}),Z.disposeIntermediateTensorInfo(gt)}return Le}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el={kernelName:n.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(Se){const{inputs:Oe,backend:Z,attrs:fe}=Se,{x:H,segmentIds:ce}=Oe,{numSegments:Ce}=fe;Object(r.a)(H,"unsortedSegmentSum");const De=[],Fe=[],Ie=H.shape.length-ce.shape.length;let Te=ce;for(let Le=0;Le<Ie;++Le){const Je=Zs({inputs:{input:Te},backend:Z,attrs:{dim:Le+1}});Te=Je,Fe.push(Je)}for(let Le=0;Le<Ce;++Le){const Je=n.util.createScalarValue(Le,"int32"),gt=Z.makeTensorInfo([],"int32",Je),lt=Object(fo.a)({inputs:{a:gt,b:Te},backend:Z}),ft=Object(ds.a)({inputs:{x:lt},backend:Z,attrs:{dtype:"float32"}}),yt=Object(Cr.a)({inputs:{a:ft,b:H},backend:Z}),$t=za({inputs:{x:yt},backend:Z,attrs:{axis:0,keepDims:!1}});De.push($t),Fe.push(gt),Fe.push(lt),Fe.push(ft),Fe.push(yt),Fe.push($t)}const Ye=Mi({inputs:De,backend:Z,attrs:{axis:0}});return Fe.forEach(Le=>Z.disposeIntermediateTensorInfo(Le)),Ye}},Ko=[ne,ge.a,Ee,je,L.b,Be,ct,Me,wt,at,Ht,mn,ee,bt,$e,xn,Dn,pe,be,oe,Qe,Ws,As,xs,ds.b,Ys.a,Nn,ts.b,$s,re,ot,Ct,Yt,on,tn,bn,Mn,gs,Hs,xr,Ir,qs,ta,rr,eo,Qs,mr,$r,ia,Pr,Wo,c,si,fo.b,So,so.b,Kr,Ra.a,vn,Vn,hs,Es.a,ga,ur,Or,Wa,Qi,_i.a,ri.a,d.b,$u,Vs,bo,Wr,Xr,l,ja.a,To.a,Tu,oi.a,Nu,ao,eu,Ti,ii,bs,Aa,Vr.a,ua,tu,ui,jo,Ku,Ur,oo,Go.a,ar,nu,Ei,Cr.b,Ia.a,Ri,ru,Eo,Fi.a,Cc,au,_c,di,Xu,b,Sc.a,Yu,me,Us.b,$o,st,I,E,V,Ae,rt,xt,Nt,vt,St,en,Kt.a,Lt,In,Xt,Ms,D.b,Fs,er,cr,Un.b,Os,yo,Ao,hi,Ho,Bi,ca,zi,Zu,Wi.a,Qu,Ol.a,Fl,Tc,Yc,iu,Ml,We.b,to,Zc,Ec,Ll,Bl,zl,tt.b,Rc,Au,el,Ro];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const Se of Ko)Object(n.registerKernel)(Se);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(s,e){s.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`},,,function(s,e,t){s.exports=t(104)},function(s,e,t){t.r(e),function(n){var r=t(91),a=t(37),o=t(53),i=t(39),u=t(11);typeof navigator=="undefined"&&(n.navigator={}),navigator.ml==null&&(navigator.ml=new r.a),n.ML==null&&(n.ML=r.a),n.MLContext==null&&(n.MLContext=a.a),n.MLGraphBuilder==null&&(n.MLGraphBuilder=i.d),n.MLGraph==null&&(n.MLGraph=o.a),n.MLOperand==null&&(n.MLOperand=u.c)}.call(this,t(40))},function(s,e,t){(function(n){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */var r=t(106),a=t(107),o=t(108);function i(){return c.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function u(ee,se){if(i()<se)throw new RangeError("Invalid typed array length");return c.TYPED_ARRAY_SUPPORT?(ee=new Uint8Array(se)).__proto__=c.prototype:(ee===null&&(ee=new c(se)),ee.length=se),ee}function c(ee,se,we){if(!(c.TYPED_ARRAY_SUPPORT||this instanceof c))return new c(ee,se,we);if(typeof ee=="number"){if(typeof se=="string")throw new Error("If encoding is specified then the first argument must be a string");return l(this,ee)}return d(this,ee,se,we)}function d(ee,se,we,pt){if(typeof se=="number")throw new TypeError('"value" argument must not be a number');return typeof ArrayBuffer!="undefined"&&se instanceof ArrayBuffer?function(bt,At,$e,ht){if(At.byteLength,$e<0||At.byteLength<$e)throw new RangeError("'offset' is out of bounds");if(At.byteLength<$e+(ht||0))throw new RangeError("'length' is out of bounds");return At=$e===void 0&&ht===void 0?new Uint8Array(At):ht===void 0?new Uint8Array(At,$e):new Uint8Array(At,$e,ht),c.TYPED_ARRAY_SUPPORT?(bt=At).__proto__=c.prototype:bt=p(bt,At),bt}(ee,se,we,pt):typeof se=="string"?function(bt,At,$e){if(typeof $e=="string"&&$e!==""||($e="utf8"),!c.isEncoding($e))throw new TypeError('"encoding" must be a valid string encoding');var ht=0|x(At,$e),Pt=(bt=u(bt,ht)).write(At,$e);return Pt!==ht&&(bt=bt.slice(0,Pt)),bt}(ee,se,we):function(bt,At){if(c.isBuffer(At)){var $e=0|f(At.length);return(bt=u(bt,$e)).length===0||At.copy(bt,0,0,$e),bt}if(At){if(typeof ArrayBuffer!="undefined"&&At.buffer instanceof ArrayBuffer||"length"in At)return typeof At.length!="number"||(ht=At.length)!=ht?u(bt,0):p(bt,At);if(At.type==="Buffer"&&o(At.data))return p(bt,At.data)}var ht;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(ee,se)}function h(ee){if(typeof ee!="number")throw new TypeError('"size" argument must be a number');if(ee<0)throw new RangeError('"size" argument must not be negative')}function l(ee,se){if(h(se),ee=u(ee,se<0?0:0|f(se)),!c.TYPED_ARRAY_SUPPORT)for(var we=0;we<se;++we)ee[we]=0;return ee}function p(ee,se){var we=se.length<0?0:0|f(se.length);ee=u(ee,we);for(var pt=0;pt<we;pt+=1)ee[pt]=255&se[pt];return ee}function f(ee){if(ee>=i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|ee}function x(ee,se){if(c.isBuffer(ee))return ee.length;if(typeof ArrayBuffer!="undefined"&&typeof ArrayBuffer.isView=="function"&&(ArrayBuffer.isView(ee)||ee instanceof ArrayBuffer))return ee.byteLength;typeof ee!="string"&&(ee=""+ee);var we=ee.length;if(we===0)return 0;for(var pt=!1;;)switch(se){case"ascii":case"latin1":case"binary":return we;case"utf8":case"utf-8":case void 0:return dn(ee).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*we;case"hex":return we>>>1;case"base64":return mn(ee).length;default:if(pt)return dn(ee).length;se=(""+se).toLowerCase(),pt=!0}}function b(ee,se,we){var pt=!1;if((se===void 0||se<0)&&(se=0),se>this.length||((we===void 0||we>this.length)&&(we=this.length),we<=0)||(we>>>=0)<=(se>>>=0))return"";for(ee||(ee="utf8");;)switch(ee){case"hex":return Ee(this,se,we);case"utf8":case"utf-8":return oe(this,se,we);case"ascii":return ge(this,se,we);case"latin1":case"binary":return ye(this,se,we);case"base64":return P(this,se,we);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return X(this,se,we);default:if(pt)throw new TypeError("Unknown encoding: "+ee);ee=(ee+"").toLowerCase(),pt=!0}}function m(ee,se,we){var pt=ee[se];ee[se]=ee[we],ee[we]=pt}function I(ee,se,we,pt,bt){if(ee.length===0)return-1;if(typeof we=="string"?(pt=we,we=0):we>2147483647?we=2147483647:we<-2147483648&&(we=-2147483648),we=+we,isNaN(we)&&(we=bt?0:ee.length-1),we<0&&(we=ee.length+we),we>=ee.length){if(bt)return-1;we=ee.length-1}else if(we<0){if(!bt)return-1;we=0}if(typeof se=="string"&&(se=c.from(se,pt)),c.isBuffer(se))return se.length===0?-1:N(ee,se,we,pt,bt);if(typeof se=="number")return se&=255,c.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf=="function"?bt?Uint8Array.prototype.indexOf.call(ee,se,we):Uint8Array.prototype.lastIndexOf.call(ee,se,we):N(ee,[se],we,pt,bt);throw new TypeError("val must be string, number or Buffer")}function N(ee,se,we,pt,bt){var At,$e=1,ht=ee.length,Pt=se.length;if(pt!==void 0&&((pt=String(pt).toLowerCase())==="ucs2"||pt==="ucs-2"||pt==="utf16le"||pt==="utf-16le")){if(ee.length<2||se.length<2)return-1;$e=2,ht/=2,Pt/=2,we/=2}function Ot(be,Qe){return $e===1?be[Qe]:be.readUInt16BE(Qe*$e)}if(bt){var xn=-1;for(At=we;At<ht;At++)if(Ot(ee,At)===Ot(se,xn===-1?0:At-xn)){if(xn===-1&&(xn=At),At-xn+1===Pt)return xn*$e}else xn!==-1&&(At-=At-xn),xn=-1}else for(we+Pt>ht&&(we=ht-Pt),At=we;At>=0;At--){for(var Dn=!0,pe=0;pe<Pt;pe++)if(Ot(ee,At+pe)!==Ot(se,pe)){Dn=!1;break}if(Dn)return At}return-1}function E(ee,se,we,pt){we=Number(we)||0;var bt=ee.length-we;pt?(pt=Number(pt))>bt&&(pt=bt):pt=bt;var At=se.length;if(At%2!=0)throw new TypeError("Invalid hex string");pt>At/2&&(pt=At/2);for(var $e=0;$e<pt;++$e){var ht=parseInt(se.substr(2*$e,2),16);if(isNaN(ht))return $e;ee[we+$e]=ht}return $e}function D(ee,se,we,pt){return Rn(dn(se,ee.length-we),ee,we,pt)}function U(ee,se,we,pt){return Rn(function(bt){for(var At=[],$e=0;$e<bt.length;++$e)At.push(255&bt.charCodeAt($e));return At}(se),ee,we,pt)}function L(ee,se,we,pt){return U(ee,se,we,pt)}function Y(ee,se,we,pt){return Rn(mn(se),ee,we,pt)}function V(ee,se,we,pt){return Rn(function(bt,At){for(var $e,ht,Pt,Ot=[],xn=0;xn<bt.length&&!((At-=2)<0);++xn)ht=($e=bt.charCodeAt(xn))>>8,Pt=$e%256,Ot.push(Pt),Ot.push(ht);return Ot}(se,ee.length-we),ee,we,pt)}function P(ee,se,we){return se===0&&we===ee.length?r.fromByteArray(ee):r.fromByteArray(ee.slice(se,we))}function oe(ee,se,we){we=Math.min(ee.length,we);for(var pt=[],bt=se;bt<we;){var At,$e,ht,Pt,Ot=ee[bt],xn=null,Dn=Ot>239?4:Ot>223?3:Ot>191?2:1;if(bt+Dn<=we)switch(Dn){case 1:Ot<128&&(xn=Ot);break;case 2:(192&(At=ee[bt+1]))==128&&(Pt=(31&Ot)<<6|63&At)>127&&(xn=Pt);break;case 3:At=ee[bt+1],$e=ee[bt+2],(192&At)==128&&(192&$e)==128&&(Pt=(15&Ot)<<12|(63&At)<<6|63&$e)>2047&&(Pt<55296||Pt>57343)&&(xn=Pt);break;case 4:At=ee[bt+1],$e=ee[bt+2],ht=ee[bt+3],(192&At)==128&&(192&$e)==128&&(192&ht)==128&&(Pt=(15&Ot)<<18|(63&At)<<12|(63&$e)<<6|63&ht)>65535&&Pt<1114112&&(xn=Pt)}xn===null?(xn=65533,Dn=1):xn>65535&&(xn-=65536,pt.push(xn>>>10&1023|55296),xn=56320|1023&xn),pt.push(xn),bt+=Dn}return function(pe){var be=pe.length;if(be<=ne)return String.fromCharCode.apply(String,pe);for(var Qe="",Un=0;Un<be;)Qe+=String.fromCharCode.apply(String,pe.slice(Un,Un+=ne));return Qe}(pt)}e.Buffer=c,e.SlowBuffer=function(ee){return+ee!=ee&&(ee=0),c.alloc(+ee)},e.INSPECT_MAX_BYTES=50,c.TYPED_ARRAY_SUPPORT=n.TYPED_ARRAY_SUPPORT!==void 0?n.TYPED_ARRAY_SUPPORT:function(){try{var ee=new Uint8Array(1);return ee.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},ee.foo()===42&&typeof ee.subarray=="function"&&ee.subarray(1,1).byteLength===0}catch{return!1}}(),e.kMaxLength=i(),c.poolSize=8192,c._augment=function(ee){return ee.__proto__=c.prototype,ee},c.from=function(ee,se,we){return d(null,ee,se,we)},c.TYPED_ARRAY_SUPPORT&&(c.prototype.__proto__=Uint8Array.prototype,c.__proto__=Uint8Array,typeof Symbol!="undefined"&&Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0})),c.alloc=function(ee,se,we){return function(pt,bt,At,$e){return h(bt),bt<=0?u(pt,bt):At!==void 0?typeof $e=="string"?u(pt,bt).fill(At,$e):u(pt,bt).fill(At):u(pt,bt)}(null,ee,se,we)},c.allocUnsafe=function(ee){return l(null,ee)},c.allocUnsafeSlow=function(ee){return l(null,ee)},c.isBuffer=function(ee){return!(ee==null||!ee._isBuffer)},c.compare=function(ee,se){if(!c.isBuffer(ee)||!c.isBuffer(se))throw new TypeError("Arguments must be Buffers");if(ee===se)return 0;for(var we=ee.length,pt=se.length,bt=0,At=Math.min(we,pt);bt<At;++bt)if(ee[bt]!==se[bt]){we=ee[bt],pt=se[bt];break}return we<pt?-1:pt<we?1:0},c.isEncoding=function(ee){switch(String(ee).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(ee,se){if(!o(ee))throw new TypeError('"list" argument must be an Array of Buffers');if(ee.length===0)return c.alloc(0);var we;if(se===void 0)for(se=0,we=0;we<ee.length;++we)se+=ee[we].length;var pt=c.allocUnsafe(se),bt=0;for(we=0;we<ee.length;++we){var At=ee[we];if(!c.isBuffer(At))throw new TypeError('"list" argument must be an Array of Buffers');At.copy(pt,bt),bt+=At.length}return pt},c.byteLength=x,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var ee=this.length;if(ee%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var se=0;se<ee;se+=2)m(this,se,se+1);return this},c.prototype.swap32=function(){var ee=this.length;if(ee%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var se=0;se<ee;se+=4)m(this,se,se+3),m(this,se+1,se+2);return this},c.prototype.swap64=function(){var ee=this.length;if(ee%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var se=0;se<ee;se+=8)m(this,se,se+7),m(this,se+1,se+6),m(this,se+2,se+5),m(this,se+3,se+4);return this},c.prototype.toString=function(){var ee=0|this.length;return ee===0?"":arguments.length===0?oe(this,0,ee):b.apply(this,arguments)},c.prototype.equals=function(ee){if(!c.isBuffer(ee))throw new TypeError("Argument must be a Buffer");return this===ee||c.compare(this,ee)===0},c.prototype.inspect=function(){var ee="",se=e.INSPECT_MAX_BYTES;return this.length>0&&(ee=this.toString("hex",0,se).match(/.{2}/g).join(" "),this.length>se&&(ee+=" ... ")),"<Buffer "+ee+">"},c.prototype.compare=function(ee,se,we,pt,bt){if(!c.isBuffer(ee))throw new TypeError("Argument must be a Buffer");if(se===void 0&&(se=0),we===void 0&&(we=ee?ee.length:0),pt===void 0&&(pt=0),bt===void 0&&(bt=this.length),se<0||we>ee.length||pt<0||bt>this.length)throw new RangeError("out of range index");if(pt>=bt&&se>=we)return 0;if(pt>=bt)return-1;if(se>=we)return 1;if(this===ee)return 0;for(var At=(bt>>>=0)-(pt>>>=0),$e=(we>>>=0)-(se>>>=0),ht=Math.min(At,$e),Pt=this.slice(pt,bt),Ot=ee.slice(se,we),xn=0;xn<ht;++xn)if(Pt[xn]!==Ot[xn]){At=Pt[xn],$e=Ot[xn];break}return At<$e?-1:$e<At?1:0},c.prototype.includes=function(ee,se,we){return this.indexOf(ee,se,we)!==-1},c.prototype.indexOf=function(ee,se,we){return I(this,ee,se,we,!0)},c.prototype.lastIndexOf=function(ee,se,we){return I(this,ee,se,we,!1)},c.prototype.write=function(ee,se,we,pt){if(se===void 0)pt="utf8",we=this.length,se=0;else if(we===void 0&&typeof se=="string")pt=se,we=this.length,se=0;else{if(!isFinite(se))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");se|=0,isFinite(we)?(we|=0,pt===void 0&&(pt="utf8")):(pt=we,we=void 0)}var bt=this.length-se;if((we===void 0||we>bt)&&(we=bt),ee.length>0&&(we<0||se<0)||se>this.length)throw new RangeError("Attempt to write outside buffer bounds");pt||(pt="utf8");for(var At=!1;;)switch(pt){case"hex":return E(this,ee,se,we);case"utf8":case"utf-8":return D(this,ee,se,we);case"ascii":return U(this,ee,se,we);case"latin1":case"binary":return L(this,ee,se,we);case"base64":return Y(this,ee,se,we);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return V(this,ee,se,we);default:if(At)throw new TypeError("Unknown encoding: "+pt);pt=(""+pt).toLowerCase(),At=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var ne=4096;function ge(ee,se,we){var pt="";we=Math.min(ee.length,we);for(var bt=se;bt<we;++bt)pt+=String.fromCharCode(127&ee[bt]);return pt}function ye(ee,se,we){var pt="";we=Math.min(ee.length,we);for(var bt=se;bt<we;++bt)pt+=String.fromCharCode(ee[bt]);return pt}function Ee(ee,se,we){var pt=ee.length;(!se||se<0)&&(se=0),(!we||we<0||we>pt)&&(we=pt);for(var bt="",At=se;At<we;++At)bt+=Ht(ee[At]);return bt}function X(ee,se,we){for(var pt=ee.slice(se,we),bt="",At=0;At<pt.length;At+=2)bt+=String.fromCharCode(pt[At]+256*pt[At+1]);return bt}function je(ee,se,we){if(ee%1!=0||ee<0)throw new RangeError("offset is not uint");if(ee+se>we)throw new RangeError("Trying to access beyond buffer length")}function Be(ee,se,we,pt,bt,At){if(!c.isBuffer(ee))throw new TypeError('"buffer" argument must be a Buffer instance');if(se>bt||se<At)throw new RangeError('"value" argument is out of bounds');if(we+pt>ee.length)throw new RangeError("Index out of range")}function tt(ee,se,we,pt){se<0&&(se=65535+se+1);for(var bt=0,At=Math.min(ee.length-we,2);bt<At;++bt)ee[we+bt]=(se&255<<8*(pt?bt:1-bt))>>>8*(pt?bt:1-bt)}function ct(ee,se,we,pt){se<0&&(se=4294967295+se+1);for(var bt=0,At=Math.min(ee.length-we,4);bt<At;++bt)ee[we+bt]=se>>>8*(pt?bt:3-bt)&255}function Me(ee,se,we,pt,bt,At){if(we+pt>ee.length)throw new RangeError("Index out of range");if(we<0)throw new RangeError("Index out of range")}function wt(ee,se,we,pt,bt){return bt||Me(ee,0,we,4),a.write(ee,se,we,pt,23,4),we+4}function at(ee,se,we,pt,bt){return bt||Me(ee,0,we,8),a.write(ee,se,we,pt,52,8),we+8}c.prototype.slice=function(ee,se){var we,pt=this.length;if((ee=~~ee)<0?(ee+=pt)<0&&(ee=0):ee>pt&&(ee=pt),(se=se===void 0?pt:~~se)<0?(se+=pt)<0&&(se=0):se>pt&&(se=pt),se<ee&&(se=ee),c.TYPED_ARRAY_SUPPORT)(we=this.subarray(ee,se)).__proto__=c.prototype;else{var bt=se-ee;we=new c(bt,void 0);for(var At=0;At<bt;++At)we[At]=this[At+ee]}return we},c.prototype.readUIntLE=function(ee,se,we){ee|=0,se|=0,we||je(ee,se,this.length);for(var pt=this[ee],bt=1,At=0;++At<se&&(bt*=256);)pt+=this[ee+At]*bt;return pt},c.prototype.readUIntBE=function(ee,se,we){ee|=0,se|=0,we||je(ee,se,this.length);for(var pt=this[ee+--se],bt=1;se>0&&(bt*=256);)pt+=this[ee+--se]*bt;return pt},c.prototype.readUInt8=function(ee,se){return se||je(ee,1,this.length),this[ee]},c.prototype.readUInt16LE=function(ee,se){return se||je(ee,2,this.length),this[ee]|this[ee+1]<<8},c.prototype.readUInt16BE=function(ee,se){return se||je(ee,2,this.length),this[ee]<<8|this[ee+1]},c.prototype.readUInt32LE=function(ee,se){return se||je(ee,4,this.length),(this[ee]|this[ee+1]<<8|this[ee+2]<<16)+16777216*this[ee+3]},c.prototype.readUInt32BE=function(ee,se){return se||je(ee,4,this.length),16777216*this[ee]+(this[ee+1]<<16|this[ee+2]<<8|this[ee+3])},c.prototype.readIntLE=function(ee,se,we){ee|=0,se|=0,we||je(ee,se,this.length);for(var pt=this[ee],bt=1,At=0;++At<se&&(bt*=256);)pt+=this[ee+At]*bt;return pt>=(bt*=128)&&(pt-=Math.pow(2,8*se)),pt},c.prototype.readIntBE=function(ee,se,we){ee|=0,se|=0,we||je(ee,se,this.length);for(var pt=se,bt=1,At=this[ee+--pt];pt>0&&(bt*=256);)At+=this[ee+--pt]*bt;return At>=(bt*=128)&&(At-=Math.pow(2,8*se)),At},c.prototype.readInt8=function(ee,se){return se||je(ee,1,this.length),128&this[ee]?-1*(255-this[ee]+1):this[ee]},c.prototype.readInt16LE=function(ee,se){se||je(ee,2,this.length);var we=this[ee]|this[ee+1]<<8;return 32768&we?4294901760|we:we},c.prototype.readInt16BE=function(ee,se){se||je(ee,2,this.length);var we=this[ee+1]|this[ee]<<8;return 32768&we?4294901760|we:we},c.prototype.readInt32LE=function(ee,se){return se||je(ee,4,this.length),this[ee]|this[ee+1]<<8|this[ee+2]<<16|this[ee+3]<<24},c.prototype.readInt32BE=function(ee,se){return se||je(ee,4,this.length),this[ee]<<24|this[ee+1]<<16|this[ee+2]<<8|this[ee+3]},c.prototype.readFloatLE=function(ee,se){return se||je(ee,4,this.length),a.read(this,ee,!0,23,4)},c.prototype.readFloatBE=function(ee,se){return se||je(ee,4,this.length),a.read(this,ee,!1,23,4)},c.prototype.readDoubleLE=function(ee,se){return se||je(ee,8,this.length),a.read(this,ee,!0,52,8)},c.prototype.readDoubleBE=function(ee,se){return se||je(ee,8,this.length),a.read(this,ee,!1,52,8)},c.prototype.writeUIntLE=function(ee,se,we,pt){ee=+ee,se|=0,we|=0,pt||Be(this,ee,se,we,Math.pow(2,8*we)-1,0);var bt=1,At=0;for(this[se]=255&ee;++At<we&&(bt*=256);)this[se+At]=ee/bt&255;return se+we},c.prototype.writeUIntBE=function(ee,se,we,pt){ee=+ee,se|=0,we|=0,pt||Be(this,ee,se,we,Math.pow(2,8*we)-1,0);var bt=we-1,At=1;for(this[se+bt]=255&ee;--bt>=0&&(At*=256);)this[se+bt]=ee/At&255;return se+we},c.prototype.writeUInt8=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,1,255,0),c.TYPED_ARRAY_SUPPORT||(ee=Math.floor(ee)),this[se]=255&ee,se+1},c.prototype.writeUInt16LE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[se]=255&ee,this[se+1]=ee>>>8):tt(this,ee,se,!0),se+2},c.prototype.writeUInt16BE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[se]=ee>>>8,this[se+1]=255&ee):tt(this,ee,se,!1),se+2},c.prototype.writeUInt32LE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[se+3]=ee>>>24,this[se+2]=ee>>>16,this[se+1]=ee>>>8,this[se]=255&ee):ct(this,ee,se,!0),se+4},c.prototype.writeUInt32BE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[se]=ee>>>24,this[se+1]=ee>>>16,this[se+2]=ee>>>8,this[se+3]=255&ee):ct(this,ee,se,!1),se+4},c.prototype.writeIntLE=function(ee,se,we,pt){if(ee=+ee,se|=0,!pt){var bt=Math.pow(2,8*we-1);Be(this,ee,se,we,bt-1,-bt)}var At=0,$e=1,ht=0;for(this[se]=255&ee;++At<we&&($e*=256);)ee<0&&ht===0&&this[se+At-1]!==0&&(ht=1),this[se+At]=(ee/$e>>0)-ht&255;return se+we},c.prototype.writeIntBE=function(ee,se,we,pt){if(ee=+ee,se|=0,!pt){var bt=Math.pow(2,8*we-1);Be(this,ee,se,we,bt-1,-bt)}var At=we-1,$e=1,ht=0;for(this[se+At]=255&ee;--At>=0&&($e*=256);)ee<0&&ht===0&&this[se+At+1]!==0&&(ht=1),this[se+At]=(ee/$e>>0)-ht&255;return se+we},c.prototype.writeInt8=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,1,127,-128),c.TYPED_ARRAY_SUPPORT||(ee=Math.floor(ee)),ee<0&&(ee=255+ee+1),this[se]=255&ee,se+1},c.prototype.writeInt16LE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[se]=255&ee,this[se+1]=ee>>>8):tt(this,ee,se,!0),se+2},c.prototype.writeInt16BE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[se]=ee>>>8,this[se+1]=255&ee):tt(this,ee,se,!1),se+2},c.prototype.writeInt32LE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,4,2147483647,-2147483648),c.TYPED_ARRAY_SUPPORT?(this[se]=255&ee,this[se+1]=ee>>>8,this[se+2]=ee>>>16,this[se+3]=ee>>>24):ct(this,ee,se,!0),se+4},c.prototype.writeInt32BE=function(ee,se,we){return ee=+ee,se|=0,we||Be(this,ee,se,4,2147483647,-2147483648),ee<0&&(ee=4294967295+ee+1),c.TYPED_ARRAY_SUPPORT?(this[se]=ee>>>24,this[se+1]=ee>>>16,this[se+2]=ee>>>8,this[se+3]=255&ee):ct(this,ee,se,!1),se+4},c.prototype.writeFloatLE=function(ee,se,we){return wt(this,ee,se,!0,we)},c.prototype.writeFloatBE=function(ee,se,we){return wt(this,ee,se,!1,we)},c.prototype.writeDoubleLE=function(ee,se,we){return at(this,ee,se,!0,we)},c.prototype.writeDoubleBE=function(ee,se,we){return at(this,ee,se,!1,we)},c.prototype.copy=function(ee,se,we,pt){if(we||(we=0),pt||pt===0||(pt=this.length),se>=ee.length&&(se=ee.length),se||(se=0),pt>0&&pt<we&&(pt=we),pt===we||ee.length===0||this.length===0)return 0;if(se<0)throw new RangeError("targetStart out of bounds");if(we<0||we>=this.length)throw new RangeError("sourceStart out of bounds");if(pt<0)throw new RangeError("sourceEnd out of bounds");pt>this.length&&(pt=this.length),ee.length-se<pt-we&&(pt=ee.length-se+we);var bt,At=pt-we;if(this===ee&&we<se&&se<pt)for(bt=At-1;bt>=0;--bt)ee[bt+se]=this[bt+we];else if(At<1e3||!c.TYPED_ARRAY_SUPPORT)for(bt=0;bt<At;++bt)ee[bt+se]=this[bt+we];else Uint8Array.prototype.set.call(ee,this.subarray(we,we+At),se);return At},c.prototype.fill=function(ee,se,we,pt){if(typeof ee=="string"){if(typeof se=="string"?(pt=se,se=0,we=this.length):typeof we=="string"&&(pt=we,we=this.length),ee.length===1){var bt=ee.charCodeAt(0);bt<256&&(ee=bt)}if(pt!==void 0&&typeof pt!="string")throw new TypeError("encoding must be a string");if(typeof pt=="string"&&!c.isEncoding(pt))throw new TypeError("Unknown encoding: "+pt)}else typeof ee=="number"&&(ee&=255);if(se<0||this.length<se||this.length<we)throw new RangeError("Out of range index");if(we<=se)return this;var At;if(se>>>=0,we=we===void 0?this.length:we>>>0,ee||(ee=0),typeof ee=="number")for(At=se;At<we;++At)this[At]=ee;else{var $e=c.isBuffer(ee)?ee:dn(new c(ee,pt).toString()),ht=$e.length;for(At=0;At<we-se;++At)this[At+se]=$e[At%ht]}return this};var Gt=/[^+\/0-9A-Za-z-_]/g;function Ht(ee){return ee<16?"0"+ee.toString(16):ee.toString(16)}function dn(ee,se){var we;se=se||1/0;for(var pt=ee.length,bt=null,At=[],$e=0;$e<pt;++$e){if((we=ee.charCodeAt($e))>55295&&we<57344){if(!bt){if(we>56319){(se-=3)>-1&&At.push(239,191,189);continue}if($e+1===pt){(se-=3)>-1&&At.push(239,191,189);continue}bt=we;continue}if(we<56320){(se-=3)>-1&&At.push(239,191,189),bt=we;continue}we=65536+(bt-55296<<10|we-56320)}else bt&&(se-=3)>-1&&At.push(239,191,189);if(bt=null,we<128){if((se-=1)<0)break;At.push(we)}else if(we<2048){if((se-=2)<0)break;At.push(we>>6|192,63&we|128)}else if(we<65536){if((se-=3)<0)break;At.push(we>>12|224,we>>6&63|128,63&we|128)}else{if(!(we<1114112))throw new Error("Invalid code point");if((se-=4)<0)break;At.push(we>>18|240,we>>12&63|128,we>>6&63|128,63&we|128)}}return At}function mn(ee){return r.toByteArray(function(se){if((se=function(we){return we.trim?we.trim():we.replace(/^\s+|\s+$/g,"")}(se).replace(Gt,"")).length<2)return"";for(;se.length%4!=0;)se+="=";return se}(ee))}function Rn(ee,se,we,pt){for(var bt=0;bt<pt&&!(bt+we>=se.length||bt>=ee.length);++bt)se[bt+we]=ee[bt];return bt}}).call(this,t(40))},function(s,e,t){e.byteLength=function(h){var l=c(h),p=l[0],f=l[1];return 3*(p+f)/4-f},e.toByteArray=function(h){var l,p,f=c(h),x=f[0],b=f[1],m=new a(function(E,D,U){return 3*(D+U)/4-U}(0,x,b)),I=0,N=b>0?x-4:x;for(p=0;p<N;p+=4)l=r[h.charCodeAt(p)]<<18|r[h.charCodeAt(p+1)]<<12|r[h.charCodeAt(p+2)]<<6|r[h.charCodeAt(p+3)],m[I++]=l>>16&255,m[I++]=l>>8&255,m[I++]=255&l;return b===2&&(l=r[h.charCodeAt(p)]<<2|r[h.charCodeAt(p+1)]>>4,m[I++]=255&l),b===1&&(l=r[h.charCodeAt(p)]<<10|r[h.charCodeAt(p+1)]<<4|r[h.charCodeAt(p+2)]>>2,m[I++]=l>>8&255,m[I++]=255&l),m},e.fromByteArray=function(h){for(var l,p=h.length,f=p%3,x=[],b=16383,m=0,I=p-f;m<I;m+=b)x.push(d(h,m,m+b>I?I:m+b));return f===1?(l=h[p-1],x.push(n[l>>2]+n[l<<4&63]+"==")):f===2&&(l=(h[p-2]<<8)+h[p-1],x.push(n[l>>10]+n[l>>4&63]+n[l<<2&63]+"=")),x.join("")};for(var n=[],r=[],a=typeof Uint8Array!="undefined"?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,u=o.length;i<u;++i)n[i]=o[i],r[o.charCodeAt(i)]=i;function c(h){var l=h.length;if(l%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var p=h.indexOf("=");return p===-1&&(p=l),[p,p===l?0:4-p%4]}function d(h,l,p){for(var f,x,b=[],m=l;m<p;m+=3)f=(h[m]<<16&16711680)+(h[m+1]<<8&65280)+(255&h[m+2]),b.push(n[(x=f)>>18&63]+n[x>>12&63]+n[x>>6&63]+n[63&x]);return b.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},function(s,e){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */e.read=function(t,n,r,a,o){var i,u,c=8*o-a-1,d=(1<<c)-1,h=d>>1,l=-7,p=r?o-1:0,f=r?-1:1,x=t[n+p];for(p+=f,i=x&(1<<-l)-1,x>>=-l,l+=c;l>0;i=256*i+t[n+p],p+=f,l-=8);for(u=i&(1<<-l)-1,i>>=-l,l+=a;l>0;u=256*u+t[n+p],p+=f,l-=8);if(i===0)i=1-h;else{if(i===d)return u?NaN:1/0*(x?-1:1);u+=Math.pow(2,a),i-=h}return(x?-1:1)*u*Math.pow(2,i-a)},e.write=function(t,n,r,a,o,i){var u,c,d,h=8*i-o-1,l=(1<<h)-1,p=l>>1,f=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,x=a?0:i-1,b=a?1:-1,m=n<0||n===0&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(c=isNaN(n)?1:0,u=l):(u=Math.floor(Math.log(n)/Math.LN2),n*(d=Math.pow(2,-u))<1&&(u--,d*=2),(n+=u+p>=1?f/d:f*Math.pow(2,1-p))*d>=2&&(u++,d/=2),u+p>=l?(c=0,u=l):u+p>=1?(c=(n*d-1)*Math.pow(2,o),u+=p):(c=n*Math.pow(2,p-1)*Math.pow(2,o),u=0));o>=8;t[r+x]=255&c,x+=b,c/=256,o-=8);for(u=u<<o|c,h+=o;h>0;t[r+x]=255&u,x+=b,u/=256,h-=8);t[r+x-b]|=128*m}},function(s,e){var t={}.toString;s.exports=Array.isArray||function(n){return t.call(n)=="[object Array]"}},function(s,e,t){(function(n){var r=t(9);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a=()=>t(110);let o;class i{constructor(){this.util=t(111),this.textEncoder=new this.util.TextEncoder}fetch(c,d){return Object(r.c)().global.fetch!=null?Object(r.c)().global.fetch(c,d):(o==null&&(o=a()),o(c,d))}now(){const c=n.hrtime();return 1e3*c[0]+c[1]/1e6}encode(c,d){if(d!=="utf-8"&&d!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${d}`);return this.textEncoder.encode(c)}decode(c,d){return c.length===0?"":new this.util.TextDecoder(d).decode(c)}}Object(r.c)().get("IS_NODE")&&!Object(r.c)().get("IS_BROWSER")&&Object(r.c)().setPlatform("node",new i)}).call(this,t(41))},function(s,e){},function(s,e){},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l,p=this,f=(l=4022871197,function(x){x=String(x);for(var b=0;b<x.length;b++){var m=.02519603282416938*(l+=x.charCodeAt(b));m-=l=m>>>0,l=(m*=l)>>>0,l+=4294967296*(m-=l)}return 23283064365386963e-26*(l>>>0)});p.next=function(){var x=2091639*p.s0+23283064365386963e-26*p.c;return p.s0=p.s1,p.s1=p.s2,p.s2=x-(p.c=0|x)},p.c=1,p.s0=f(" "),p.s1=f(" "),p.s2=f(" "),p.s0-=f(h),p.s0<0&&(p.s0+=1),p.s1-=f(h),p.s1<0&&(p.s1+=1),p.s2-=f(h),p.s2<0&&(p.s2+=1),f=null}function c(h,l){return l.c=h.c,l.s0=h.s0,l.s1=h.s1,l.s2=h.s2,l}function d(h,l){var p=new u(h),f=l&&l.state,x=p.next;return x.int32=function(){return 4294967296*p.next()|0},x.double=function(){return x()+11102230246251565e-32*(2097152*x()|0)},x.quick=x,f&&(typeof f=="object"&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.alea=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l=this,p="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var x=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^x^x>>>8},h===(0|h)?l.x=h:p+=h;for(var f=0;f<p.length+64;f++)l.x^=0|p.charCodeAt(f),l.next()}function c(h,l){return l.x=h.x,l.y=h.y,l.z=h.z,l.w=h.w,l}function d(h,l){var p=new u(h),f=l&&l.state,x=function(){return(p.next()>>>0)/4294967296};return x.double=function(){do var b=((p.next()>>>11)+(p.next()>>>0)/4294967296)/2097152;while(b===0);return b},x.int32=p.next,x.quick=x,f&&(typeof f=="object"&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.xor128=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l=this,p="";l.next=function(){var x=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^x^x<<1)|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,h===(0|h)?l.x=h:p+=h;for(var f=0;f<p.length+64;f++)l.x^=0|p.charCodeAt(f),f==p.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function c(h,l){return l.x=h.x,l.y=h.y,l.z=h.z,l.w=h.w,l.v=h.v,l.d=h.d,l}function d(h,l){var p=new u(h),f=l&&l.state,x=function(){return(p.next()>>>0)/4294967296};return x.double=function(){do var b=((p.next()>>>11)+(p.next()>>>0)/4294967296)/2097152;while(b===0);return b},x.int32=p.next,x.quick=x,f&&(typeof f=="object"&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.xorwow=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l=this;l.next=function(){var p,f,x=l.x,b=l.i;return p=x[b],f=(p^=p>>>7)^p<<24,f^=(p=x[b+1&7])^p>>>10,f^=(p=x[b+3&7])^p>>>3,f^=(p=x[b+4&7])^p<<7,p=x[b+7&7],f^=(p^=p<<13)^p<<9,x[b]=f,l.i=b+1&7,f},function(p,f){var x,b=[];if(f===(0|f))b[0]=f;else for(f=""+f,x=0;x<f.length;++x)b[7&x]=b[7&x]<<15^f.charCodeAt(x)+b[x+1&7]<<13;for(;b.length<8;)b.push(0);for(x=0;x<8&&b[x]===0;++x);for(x==8?b[7]=-1:b[x],p.x=b,p.i=0,x=256;x>0;--x)p.next()}(l,h)}function c(h,l){return l.x=h.x.slice(),l.i=h.i,l}function d(h,l){h==null&&(h=+new Date);var p=new u(h),f=l&&l.state,x=function(){return(p.next()>>>0)/4294967296};return x.double=function(){do var b=((p.next()>>>11)+(p.next()>>>0)/4294967296)/2097152;while(b===0);return b},x.int32=p.next,x.quick=x,f&&(f.x&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.xorshift7=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l=this;l.next=function(){var p,f,x=l.w,b=l.X,m=l.i;return l.w=x=x+1640531527|0,f=b[m+34&127],p=b[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=b[m]=f^p,l.i=m,f+(x^x>>>16)|0},function(p,f){var x,b,m,I,N,E=[],D=128;for(f===(0|f)?(b=f,f=null):(f+="\0",b=0,D=Math.max(D,f.length)),m=0,I=-32;I<D;++I)f&&(b^=f.charCodeAt((I+32)%f.length)),I===0&&(N=b),b^=b<<10,b^=b>>>15,b^=b<<4,b^=b>>>13,I>=0&&(N=N+1640531527|0,m=(x=E[127&I]^=b+N)==0?m+1:0);for(m>=128&&(E[127&(f&&f.length||0)]=-1),m=127,I=512;I>0;--I)b=E[m+34&127],x=E[m=m+1&127],b^=b<<13,x^=x<<17,b^=b>>>15,x^=x>>>12,E[m]=b^x;p.w=N,p.X=E,p.i=m}(l,h)}function c(h,l){return l.i=h.i,l.w=h.w,l.X=h.X.slice(),l}function d(h,l){h==null&&(h=+new Date);var p=new u(h),f=l&&l.state,x=function(){return(p.next()>>>0)/4294967296};return x.double=function(){do var b=((p.next()>>>11)+(p.next()>>>0)/4294967296)/2097152;while(b===0);return b},x.int32=p.next,x.quick=x,f&&(f.X&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.xor4096=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){(function(n){var r;(function(a,o,i){function u(h){var l=this,p="";l.next=function(){var x=l.b,b=l.c,m=l.d,I=l.a;return x=x<<25^x>>>7^b,b=b-m|0,m=m<<24^m>>>8^I,I=I-x|0,l.b=x=x<<20^x>>>12^b,l.c=b=b-m|0,l.d=m<<16^b>>>16^I,l.a=I-x|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,h===Math.floor(h)?(l.a=h/4294967296|0,l.b=0|h):p+=h;for(var f=0;f<p.length+20;f++)l.b^=0|p.charCodeAt(f),l.next()}function c(h,l){return l.a=h.a,l.b=h.b,l.c=h.c,l.d=h.d,l}function d(h,l){var p=new u(h),f=l&&l.state,x=function(){return(p.next()>>>0)/4294967296};return x.double=function(){do var b=((p.next()>>>11)+(p.next()>>>0)/4294967296)/2097152;while(b===0);return b},x.int32=p.next,x.quick=x,f&&(typeof f=="object"&&c(f,p),x.state=function(){return c(p,{})}),x}o&&o.exports?o.exports=d:t(27)&&t(43)?(r=function(){return d}.call(e,t,e,o))===void 0||(o.exports=r):this.tychei=d})(0,n,t(27))}).call(this,t(42)(s))},function(s,e,t){var n;(function(r,a,o){var i,u=256,c=o.pow(u,6),d=o.pow(2,52),h=2*d,l=255;function p(N,E,D){var U=[],L=m(b((E=E==1?{entropy:!0}:E||{}).entropy?[N,I(a)]:N==null?function(){try{var P;return i&&(P=i.randomBytes)?P=P(u):(P=new Uint8Array(u),(r.crypto||r.msCrypto).getRandomValues(P)),I(P)}catch{var oe=r.navigator,ne=oe&&oe.plugins;return[+new Date,r,ne,r.screen,I(a)]}}():N,3),U),Y=new f(U),V=function(){for(var P=Y.g(6),oe=c,ne=0;P<d;)P=(P+ne)*u,oe*=u,ne=Y.g(1);for(;P>=h;)P/=2,oe/=2,ne>>>=1;return(P+ne)/oe};return V.int32=function(){return 0|Y.g(4)},V.quick=function(){return Y.g(4)/4294967296},V.double=V,m(I(Y.S),a),(E.pass||D||function(P,oe,ne,ge){return ge&&(ge.S&&x(ge,Y),P.state=function(){return x(Y,{})}),ne?(o.random=P,oe):P})(V,L,"global"in E?E.global:this==o,E.state)}function f(N){var E,D=N.length,U=this,L=0,Y=U.i=U.j=0,V=U.S=[];for(D||(N=[D++]);L<u;)V[L]=L++;for(L=0;L<u;L++)V[L]=V[Y=l&Y+N[L%D]+(E=V[L])],V[Y]=E;(U.g=function(P){for(var oe,ne=0,ge=U.i,ye=U.j,Ee=U.S;P--;)oe=Ee[ge=l&ge+1],ne=ne*u+Ee[l&(Ee[ge]=Ee[ye=l&ye+oe])+(Ee[ye]=oe)];return U.i=ge,U.j=ye,ne})(u)}function x(N,E){return E.i=N.i,E.j=N.j,E.S=N.S.slice(),E}function b(N,E){var D,U=[],L=typeof N;if(E&&L=="object")for(D in N)try{U.push(b(N[D],E-1))}catch{}return U.length?U:L=="string"?N:N+"\0"}function m(N,E){for(var D,U=N+"",L=0;L<U.length;)E[l&L]=l&(D^=19*E[l&L])+U.charCodeAt(L++);return I(E)}function I(N){return String.fromCharCode.apply(0,N)}if(m(o.random(),a),s.exports){s.exports=p;try{i=t(119)}catch{}}else(n=function(){return p}.call(e,t,e,s))===void 0||(s.exports=n)})(typeof self!="undefined"?self:this,[],Math)},function(s,e){},function(s,e,t){(function(n){var r=typeof n!="undefined"&&n||typeof self!="undefined"&&self||window,a=Function.prototype.apply;function o(i,u){this._id=i,this._clearFn=u}e.setTimeout=function(){return new o(a.call(setTimeout,r,arguments),clearTimeout)},e.setInterval=function(){return new o(a.call(setInterval,r,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(i){i&&i.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(r,this._id)},e.enroll=function(i,u){clearTimeout(i._idleTimeoutId),i._idleTimeout=u},e.unenroll=function(i){clearTimeout(i._idleTimeoutId),i._idleTimeout=-1},e._unrefActive=e.active=function(i){clearTimeout(i._idleTimeoutId);var u=i._idleTimeout;u>=0&&(i._idleTimeoutId=setTimeout(function(){i._onTimeout&&i._onTimeout()},u))},t(121),e.setImmediate=typeof self!="undefined"&&self.setImmediate||typeof n!="undefined"&&n.setImmediate||this&&this.setImmediate,e.clearImmediate=typeof self!="undefined"&&self.clearImmediate||typeof n!="undefined"&&n.clearImmediate||this&&this.clearImmediate}).call(this,t(40))},function(s,e,t){(function(n,r){(function(a,o){if(!a.setImmediate){var i,u,c,d,h,l=1,p={},f=!1,x=a.document,b=Object.getPrototypeOf&&Object.getPrototypeOf(a);b=b&&b.setTimeout?b:a,{}.toString.call(a.process)==="[object process]"?i=function(N){r.nextTick(function(){I(N)})}:function(){if(a.postMessage&&!a.importScripts){var N=!0,E=a.onmessage;return a.onmessage=function(){N=!1},a.postMessage("","*"),a.onmessage=E,N}}()?(d="setImmediate$"+Math.random()+"$",h=function(N){N.source===a&&typeof N.data=="string"&&N.data.indexOf(d)===0&&I(+N.data.slice(d.length))},a.addEventListener?a.addEventListener("message",h,!1):a.attachEvent("onmessage",h),i=function(N){a.postMessage(d+N,"*")}):a.MessageChannel?((c=new MessageChannel).port1.onmessage=function(N){I(N.data)},i=function(N){c.port2.postMessage(N)}):x&&"onreadystatechange"in x.createElement("script")?(u=x.documentElement,i=function(N){var E=x.createElement("script");E.onreadystatechange=function(){I(N),E.onreadystatechange=null,u.removeChild(E),E=null},u.appendChild(E)}):i=function(N){setTimeout(I,0,N)},b.setImmediate=function(N){typeof N!="function"&&(N=new Function(""+N));for(var E=new Array(arguments.length-1),D=0;D<E.length;D++)E[D]=arguments[D+1];var U={callback:N,args:E};return p[l]=U,i(l),l++},b.clearImmediate=m}function m(N){delete p[N]}function I(N){if(f)setTimeout(I,0,N);else{var E=p[N];if(E){f=!0;try{(function(D){var U=D.callback,L=D.args;switch(L.length){case 0:U();break;case 1:U(L[0]);break;case 2:U(L[0],L[1]);break;case 3:U(L[0],L[1],L[2]);break;default:U.apply(void 0,L)}})(E)}finally{m(N),f=!1}}}}})(typeof self=="undefined"?typeof n=="undefined"?this:n:self)}).call(this,t(40),t(41))},function(s,e){},function(s,e){},function(s,e){}]);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE=1e-7,lE=1e-4;class W2{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class J0{refCount(e){return bi("refCount")}incRef(e){return bi("incRef")}timerAvailable(){return!0}time(e){return bi("time")}read(e){return bi("read")}readSync(e){return bi("readSync")}readToGPU(e,t){return bi("readToGPU")}numDataIds(){return bi("numDataIds")}disposeData(e,t){return bi("disposeData")}write(e,t,n){return bi("write")}move(e,t,n,r,a){return bi("move")}createTensorFromGPUData(e,t,n){return bi("createTensorFromGPUData")}memory(){return bi("memory")}floatPrecision(){return bi("floatPrecision")}epsilon(){return this.floatPrecision()===32?cE:lE}dispose(){return bi("dispose")}}function bi(s){throw new Error(`'${s}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(s){let e=s.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Gd(s,e,t)}function ld(s,e,t){return Math.max(s,Math.min(e,t))}function ey(s){return s%2===0?s:s+1}function Gd(s,e,t){const n=s[e];s[e]=s[t],s[t]=n}function hE(s){let e=0;for(let t=0;t<s.length;t++)e+=s[t];return e}function ze(s,e){if(!s)throw new Error(typeof e=="string"?e:e())}function ty(s,e,t=""){ze(Er(s,e),()=>t+` Shapes ${s} and ${e} must match`)}function V2(s){ze(s!=null,()=>"The input to the tensor constructor must be a non-null value.")}function hn(s){if(s.length===0)return 1;let e=s[0];for(let t=1;t<s.length;t++)e*=s[t];return e}function Er(s,e){if(s===e)return!0;if(s==null||e==null||s.length!==e.length)return!1;for(let t=0;t<s.length;t++)if(s[t]!==e[t])return!1;return!0}function th(s){return s%1===0}function c0(s){const e=Math.ceil(Math.sqrt(s));return[e,Math.ceil(s/e)]}function Xd(s,e){return e<=s.length?s:s+" ".repeat(e-s.length)}function jv(s,e=r=>0,t,n){return new Promise((r,a)=>{let o=0;const i=()=>{if(s()){r();return}o++;const u=e(o);if(t!=null&&o>=t){a();return}n!=null?n(i,u):setTimeout(i,u)};i()})}function U2(s,e){let t=1,n=-1;for(let a=0;a<s.length;++a)if(s[a]>=0)t*=s[a];else if(s[a]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${a}`);n=a}else if(s[a]<0)throw Error(`Shapes can not be < 0. Found ${s[a]} at dim ${a}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${s}`);return s}if(t===0)throw Error(`Cannot infer the missing size in [${s}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=s.slice();return r[n]=e/t,r}function nr(s,e){const t=e.length;return s=s==null?e.map((n,r)=>r):[].concat(s),ze(s.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${s}`),ze(s.every(n=>th(n)),()=>`All values in axis param must be integers but got axis ${s}`),s.map(n=>n<0?t+n:n)}function Cl(s,e){const t=[],n=[],r=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||r?null:nr(e,s).sort();let o=0;for(let i=0;i<s.length;++i){if(a!=null){if(a[o]===i&&s[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${s[i]}' is not 1`);(a[o]==null||a[o]>i)&&s[i]===1&&(t.push(s[i]),n.push(i)),a[o]<=i&&o++}s[i]!==1&&(t.push(s[i]),n.push(i))}return{newShape:t,keptDims:n}}function ko(s,e){return ba(s,e)}function ba(s,e){let t=null;if(s==null||s==="float32")t=new Float32Array(e);else if(s==="int32")t=new Int32Array(e);else if(s==="bool")t=new Uint8Array(e);else if(s==="string")t=new Array(e);else throw new Error(`Unknown data type ${s}`);return t}function pE(s,e){for(let t=0;t<s.length;t++){const n=s[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function fE(s){return s==="bool"||s==="complex64"||s==="float32"||s==="int32"||s==="string"}function j2(s,e){return!(e==="complex64"||e==="float32"&&s!=="complex64"||e==="int32"&&s!=="float32"&&s!=="complex64"||e==="bool"&&s==="bool")}function Sm(s){if(s==="float32"||s==="int32")return 4;if(s==="complex64")return 8;if(s==="bool")return 1;throw new Error(`Unknown dtype ${s}`)}function mE(s){if(s==null)return 0;let e=0;return s.forEach(t=>e+=t.length),e}function mp(s){return typeof s=="string"||s instanceof String}function gE(s){return typeof s=="boolean"}function l0(s){return typeof s=="number"}function bh(s){return Array.isArray(s)?bh(s[0]):s instanceof Float32Array?"float32":s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray?"int32":l0(s)?"float32":mp(s)?"string":gE(s)?"bool":"float32"}function d0(s){return!!(s&&s.constructor&&s.call&&s.apply)}function h0(s,e){for(let t=e;t<s;++t)if(s%t===0)return t;return s}function ws(s){const e=s.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=s[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*s[n+1];return t}function G2(s,e,t,n=!1){const r=new Array;if(e.length===1){const a=e[0]*(n?2:1);for(let o=0;o<a;o++)r[o]=t[s+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,c)=>u*c)*(n?2:1);for(let u=0;u<a;u++)r[u]=G2(s+u*i,o,t,n)}return r}function Bu(s,e,t=!1){if(s.length===0)return e[0];const n=s.reduce((r,a)=>r*a)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${s}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return G2(0,s,e,t)}function bE(s,e){if(Array.isArray(s))return s;if(e==="float32")return s instanceof Float32Array?s:new Float32Array(s);if(e==="int32")return s instanceof Int32Array?s:new Int32Array(s);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(s));throw new Error(`Unknown dtype ${e}`)}function ny(s,e){const t=Io(s,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function Io(s,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(s);if(e==="int32")return new Int32Array(s);if(e==="bool")return new Uint8Array(s);throw new Error(`Unknown data type ${e}`)}function H2(s,e){const t=s.reduce((n,r)=>n*r,1);if(e==null||e==="float32")return Bu(s,new Float32Array(t));if(e==="int32")return Bu(s,new Int32Array(t));if(e==="bool")return Bu(s,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function jc(s){s.forEach(e=>{ze(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${s}].`)})}function fc(s,e,t){if(e===0)return 0;if(e===1)return s[0];let n=s[s.length-1];for(let r=0;r<s.length-1;++r)n+=t[r]*s[r];return n}function xh(s,e,t){if(e===0)return[];if(e===1)return[s];const n=new Array(e);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(s/t[r]),s-=n[r]*t[r];return n[n.length-1]=s,n}function sy(s){return s&&s.then&&typeof s.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gv="tfjsflags";class xE{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=yE,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(nn().getBool("IS_TEST")||nn().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const r=this.urlFlags[e];nn().getBool("IS_TEST")||nn().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(sy(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);Gv in e&&e[Gv].split(",").forEach(n=>{const[r,a]=n.split(":");this.urlFlags[r]=vE(r,a)})}}function yE(s){const e={};return s.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(wE(e,n[0],n[1]),n.join("="))),e}function wE(s,e,t){s[decodeURIComponent(e)]=decodeURIComponent(t||"")}function vE(s,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function nn(){return q2}let q2=null;function kE(s){q2=s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let z1;function K2(){if(z1==null){let s;if(typeof window!="undefined")s=window;else if(typeof global!="undefined")s=global;else if(typeof process!="undefined")s=process;else if(typeof self!="undefined")s=self;else throw new Error("Could not find a global object");z1=s}return z1}function IE(){const s=K2();return s._tfGlobals==null&&(s._tfGlobals=new Map),s._tfGlobals}function ry(s,e){const t=IE();if(t.has(s))return t.get(s);{const n=e();return t.set(s,n),t.get(s)}}const sg="Abs",gp="Acos",bp="Acosh",yh="Add",ay="AddN",oy="All",iy="Any",rg="ArgMax",ag="ArgMin",xp="Asin",yp="Asinh",wp="Atan",vp="Atanh",kp="Atan2",og="AvgPool",uy="AvgPoolGrad",ig="AvgPool3D",cy="AvgPool3DGrad",ug="BatchMatMul",cg="BatchToSpaceND",ly="Bincount",X2="BitwiseAnd",CE="BroadcastTo",Y2="BroadcastArgs",Ip="Cast",Cp="Ceil",_p="ClipByValue",dy="Complex",lg="ComplexAbs",dg="Concat",hg="Conv2D",hy="Conv2DBackpropFilter",pg="Conv2DBackpropInput",fg="Conv3D",py="Conv3DBackpropFilterV2",fy="Conv3DBackpropInputV2",Sp="Cos",$p="Cosh",my="Cumprod",mg="Cumsum",gy="CropAndResize",by="DenseBincount",xy="DepthToSpace",gg="DepthwiseConv2dNative",yy="DepthwiseConv2dNativeBackpropFilter",wy="DepthwiseConv2dNativeBackpropInput",Z2="Diag",bg="Dilation2D",p0="Dilation2DBackpropInput",f0="Dilation2DBackpropFilter",Tp="RealDiv",Q2="Einsum",Np="Elu",vy="EluGrad",Ep="Erf",xg="Equal",Rp="Exp",yg="ExpandDims",Ap="Expm1",ky="FFT",Iy="Fill",Cy="FlipLeftRight",Op="Floor",Fp="FloorDiv",wg="FusedBatchNorm",vg="GatherV2",J2="GatherNd",kg="Greater",Dp="GreaterEqual",Mp="Identity",_y="IFFT",Sy="Imag",Pp="IsFinite",Lp="IsInf",Bp="IsNan",Ig="LeakyRelu",Cg="Less",_g="LessEqual",eI="LinSpace",zp="Log",Wp="Log1p",Sg="LogicalAnd",$g="LogicalNot",Tg="LogicalOr",_E="LogSoftmax",Ng="LRN",$y="LRNGrad",Eg="Max",Vp="Maximum",Rg="MaxPool",Ty="MaxPoolGrad",Ag="MaxPool3D",Ny="MaxPool3DGrad",tI="MaxPoolWithArgmax",Og="Mean",Fg="Min",Up="Minimum",Dg="MirrorPad",jp="Mod",nI="Multinomial",Gp="Multiply",Mg="Neg",Pg="NotEqual",Ey="NonMaxSuppressionV3",Ry="NonMaxSuppressionV4",Ay="NonMaxSuppressionV5",Lg="OnesLike",Bg="OneHot",zg="Pack",Wg="PadV2",Hp="Pow",Vg="Prelu",Ug="Prod",sI="RaggedGather",rI="RaggedRange",aI="RaggedTensorToTensor",Oy="Range",Fy="Real",qp="Reciprocal",Kp="Relu",jg="Reshape",Gg="ResizeNearestNeighbor",Dy="ResizeNearestNeighborGrad",Hg="ResizeBilinear",My="ResizeBilinearGrad",Xp="Relu6",qg="Reverse",Yp="Round",Zp="Rsqrt",oI="ScatterNd",iI="TensorScatterUpdate",uI="SearchSorted",Kg="Select",Qp="Selu",Xg="Slice",Jp="Sin",ef="Sinh",tf="Sign",nf="Sigmoid",sf="Softplus",rf="Sqrt",Yg="Sum",Zg="SpaceToBatchND",Qg="SplitV",Jg="Softmax",cI="SparseFillEmptyRows",lI="SparseReshape",dI="SparseSegmentMean",hI="SparseSegmentSum",pI="SparseToDense",af="SquaredDifference",Py="Square",Ly="StaticRegexReplace",By="StridedSlice",fI="StringNGrams",mI="StringSplit",gI="StringToHashBucketFast",of="Sub",uf="Tan",cf="Tanh",lf="Tile",zy="TopK",Wy="Transform",Yd="Transpose",Vy="Unique",eb="Unpack",tb="UnsortedSegmentSum",nb="ZerosLike",df="Step",SE="FromPixels",Uy="RotateWithOffset",$m="_FusedMatMul",Tm="FusedConv2D",bI="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gi(...s){nn().getBool("IS_TEST")||nn().getBool("PROD")||console.warn(...s)}function $E(...s){nn().getBool("IS_TEST")||nn().getBool("PROD")||console.log(...s)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nm=ry("kernelRegistry",()=>new Map),m0=ry("gradRegistry",()=>new Map);function Hv(s,e){const t=yI(s,e);return Nm.get(t)}function qv(s){return m0.get(s)}function Kv(s){const e=Nm.entries(),t=[];for(;;){const{done:n,value:r}=e.next();if(n)break;const[a,o]=r,[i]=a.split("_");i===s&&t.push(o)}return t}function xI(s){const{kernelName:e,backendName:t}=s,n=yI(e,t);Nm.has(n)&&Gi(`The kernel '${e}' for backend '${t}' is already registered`),Nm.set(n,s)}function TE(s){const{kernelName:e}=s;m0.has(e)&&nn().getBool("DEBUG")&&Gi(`Overriding the gradient for '${e}'`),m0.set(e,s)}function yI(s,e){return`${e}_${s}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(s){return s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array||s instanceof Uint8ClampedArray}var g0=Jr,bu=null;try{bu=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Jr(s,e,t){this.low=s|0,this.high=e|0,this.unsigned=!!t}Jr.prototype.__isLong__;Object.defineProperty(Jr.prototype,"__isLong__",{value:!0});function Ci(s){return(s&&s.__isLong__)===!0}Jr.isLong=Ci;var Xv={},Yv={};function Cd(s,e){var t,n,r;return e?(s>>>=0,(r=0<=s&&s<256)&&(n=Yv[s],n)?n:(t=ea(s,(s|0)<0?-1:0,!0),r&&(Yv[s]=t),t)):(s|=0,(r=-128<=s&&s<128)&&(n=Xv[s],n)?n:(t=ea(s,s<0?-1:0,!1),r&&(Xv[s]=t),t))}Jr.fromInt=Cd;function xu(s,e){if(isNaN(s))return e?rd:yu;if(e){if(s<0)return rd;if(s>=vI)return CI}else{if(s<=-Qv)return wi;if(s+1>=Qv)return II}return s<0?xu(-s,e).neg():ea(s%nh|0,s/nh|0,e)}Jr.fromNumber=xu;function ea(s,e,t){return new Jr(s,e,t)}Jr.fromBits=ea;var Em=Math.pow;function jy(s,e,t){if(s.length===0)throw Error("empty string");if(s==="NaN"||s==="Infinity"||s==="+Infinity"||s==="-Infinity")return yu;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=s.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return jy(s.substring(1),e,t).neg();for(var r=xu(Em(t,8)),a=yu,o=0;o<s.length;o+=8){var i=Math.min(8,s.length-o),u=parseInt(s.substring(o,o+i),t);if(i<8){var c=xu(Em(t,i));a=a.mul(c).add(xu(u))}else a=a.mul(r),a=a.add(xu(u))}return a.unsigned=e,a}Jr.fromString=jy;function Hu(s,e){return typeof s=="number"?xu(s,e):typeof s=="string"?jy(s,e):ea(s.low,s.high,typeof e=="boolean"?e:s.unsigned)}Jr.fromValue=Hu;var Zv=1<<16,NE=1<<24,nh=Zv*Zv,vI=nh*nh,Qv=vI/2,Jv=Cd(NE),yu=Cd(0);Jr.ZERO=yu;var rd=Cd(0,!0);Jr.UZERO=rd;var Kd=Cd(1);Jr.ONE=Kd;var kI=Cd(1,!0);Jr.UONE=kI;var b0=Cd(-1);Jr.NEG_ONE=b0;var II=ea(-1,2147483647,!1);Jr.MAX_VALUE=II;var CI=ea(-1,-1,!0);Jr.MAX_UNSIGNED_VALUE=CI;var wi=ea(0,-2147483648,!1);Jr.MIN_VALUE=wi;var Zn=Jr.prototype;Zn.toInt=function(){return this.unsigned?this.low>>>0:this.low};Zn.toNumber=function(){return this.unsigned?(this.high>>>0)*nh+(this.low>>>0):this.high*nh+(this.low>>>0)};Zn.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(wi)){var t=xu(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=xu(Em(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),c=o.sub(u.mul(a)).toInt()>>>0,d=c.toString(e);if(o=u,o.isZero())return d+i;for(;d.length<6;)d="0"+d;i=""+d+i}};Zn.getHighBits=function(){return this.high};Zn.getHighBitsUnsigned=function(){return this.high>>>0};Zn.getLowBits=function(){return this.low};Zn.getLowBitsUnsigned=function(){return this.low>>>0};Zn.getNumBitsAbs=function(){if(this.isNegative())return this.eq(wi)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Zn.isZero=function(){return this.high===0&&this.low===0};Zn.eqz=Zn.isZero;Zn.isNegative=function(){return!this.unsigned&&this.high<0};Zn.isPositive=function(){return this.unsigned||this.high>=0};Zn.isOdd=function(){return(this.low&1)===1};Zn.isEven=function(){return(this.low&1)===0};Zn.equals=function(e){return Ci(e)||(e=Hu(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Zn.eq=Zn.equals;Zn.notEquals=function(e){return!this.eq(e)};Zn.neq=Zn.notEquals;Zn.ne=Zn.notEquals;Zn.lessThan=function(e){return this.comp(e)<0};Zn.lt=Zn.lessThan;Zn.lessThanOrEqual=function(e){return this.comp(e)<=0};Zn.lte=Zn.lessThanOrEqual;Zn.le=Zn.lessThanOrEqual;Zn.greaterThan=function(e){return this.comp(e)>0};Zn.gt=Zn.greaterThan;Zn.greaterThanOrEqual=function(e){return this.comp(e)>=0};Zn.gte=Zn.greaterThanOrEqual;Zn.ge=Zn.greaterThanOrEqual;Zn.compare=function(e){if(Ci(e)||(e=Hu(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Zn.comp=Zn.compare;Zn.negate=function(){return!this.unsigned&&this.eq(wi)?wi:this.not().add(Kd)};Zn.neg=Zn.negate;Zn.add=function(e){Ci(e)||(e=Hu(e));var t=this.high>>>16,n=this.high&65535,r=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,u=e.low>>>16,c=e.low&65535,d=0,h=0,l=0,p=0;return p+=a+c,l+=p>>>16,p&=65535,l+=r+u,h+=l>>>16,l&=65535,h+=n+i,d+=h>>>16,h&=65535,d+=t+o,d&=65535,ea(l<<16|p,d<<16|h,this.unsigned)};Zn.subtract=function(e){return Ci(e)||(e=Hu(e)),this.add(e.neg())};Zn.sub=Zn.subtract;Zn.multiply=function(e){if(this.isZero())return yu;if(Ci(e)||(e=Hu(e)),bu){var t=bu.mul(this.low,this.high,e.low,e.high);return ea(t,bu.get_high(),this.unsigned)}if(e.isZero())return yu;if(this.eq(wi))return e.isOdd()?wi:yu;if(e.eq(wi))return this.isOdd()?wi:yu;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Jv)&&e.lt(Jv))return xu(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,u=e.high&65535,c=e.low>>>16,d=e.low&65535,h=0,l=0,p=0,f=0;return f+=o*d,p+=f>>>16,f&=65535,p+=a*d,l+=p>>>16,p&=65535,p+=o*c,l+=p>>>16,p&=65535,l+=r*d,h+=l>>>16,l&=65535,l+=a*c,h+=l>>>16,l&=65535,l+=o*u,h+=l>>>16,l&=65535,h+=n*d+r*c+a*u+o*i,h&=65535,ea(p<<16|f,h<<16|l,this.unsigned)};Zn.mul=Zn.multiply;Zn.divide=function(e){if(Ci(e)||(e=Hu(e)),e.isZero())throw Error("division by zero");if(bu){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?bu.div_u:bu.div_s)(this.low,this.high,e.low,e.high);return ea(t,bu.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?rd:yu;var n,r,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return rd;if(e.gt(this.shru(1)))return kI;a=rd}else{if(this.eq(wi)){if(e.eq(Kd)||e.eq(b0))return wi;if(e.eq(wi))return Kd;var o=this.shr(1);return n=o.div(e).shl(1),n.eq(yu)?e.isNegative()?Kd:b0:(r=this.sub(e.mul(n)),a=n.add(r.div(e)),a)}else if(e.eq(wi))return this.unsigned?rd:yu;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=yu}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:Em(2,i-48),c=xu(n),d=c.mul(e);d.isNegative()||d.gt(r);)n-=u,c=xu(n,this.unsigned),d=c.mul(e);c.isZero()&&(c=Kd),a=a.add(c),r=r.sub(d)}return a};Zn.div=Zn.divide;Zn.modulo=function(e){if(Ci(e)||(e=Hu(e)),bu){var t=(this.unsigned?bu.rem_u:bu.rem_s)(this.low,this.high,e.low,e.high);return ea(t,bu.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Zn.mod=Zn.modulo;Zn.rem=Zn.modulo;Zn.not=function(){return ea(~this.low,~this.high,this.unsigned)};Zn.and=function(e){return Ci(e)||(e=Hu(e)),ea(this.low&e.low,this.high&e.high,this.unsigned)};Zn.or=function(e){return Ci(e)||(e=Hu(e)),ea(this.low|e.low,this.high|e.high,this.unsigned)};Zn.xor=function(e){return Ci(e)||(e=Hu(e)),ea(this.low^e.low,this.high^e.high,this.unsigned)};Zn.shiftLeft=function(e){return Ci(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ea(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ea(0,this.low<<e-32,this.unsigned)};Zn.shl=Zn.shiftLeft;Zn.shiftRight=function(e){return Ci(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ea(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ea(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Zn.shr=Zn.shiftRight;Zn.shiftRightUnsigned=function(e){if(Ci(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return ea(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ea(t,0,this.unsigned):ea(t>>>e-32,0,this.unsigned)};Zn.shru=Zn.shiftRightUnsigned;Zn.shr_u=Zn.shiftRightUnsigned;Zn.toSigned=function(){return this.unsigned?ea(this.low,this.high,!1):this};Zn.toUnsigned=function(){return this.unsigned?this:ea(this.low,this.high,!0)};Zn.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Zn.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Zn.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Jr.fromBytes=function(e,t,n){return n?Jr.fromBytesLE(e,t):Jr.fromBytesBE(e,t)};Jr.fromBytesLE=function(e,t){return new Jr(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Jr.fromBytesBE=function(e,t){return new Jr(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var EE=uE({__proto__:null,default:g0},[g0]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const td=g0||EE;function sb(s){return td.fromString(s,!0,16)}const _I=sb("c3a5c85c97cb3127"),ed=sb("b492b66fbe98f273"),Do=sb("9ae16a3b2f90404f");function x0(s){return s.xor(s.shru(47))}function SI(s,e,t){const n=s.slice(e,e+t);return td.fromBytes(Array.from(n),!0,!0)}function Gr(s,e){return SI(s,e,8)}function ek(s,e){return SI(s,e,4)}function Xa(s,e){return e===0?s:s.shru(e).or(s.shl(64-e))}function pl(s,e,t=sb("9ddfea08eb382d69")){let n=s.xor(e).mul(t);n=n.xor(n.shru(47));let r=e.xor(n).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function RE(s,e,t,n,r,a){r=r.add(s),a=Xa(a.add(r).add(n),21);const o=r;return r=r.add(e),r=r.add(t),a=a.add(Xa(r,44)),[r.add(n),a.add(o)]}function am(s,e,t,n){return RE(Gr(s,e),Gr(s,e+8),Gr(s,e+16),Gr(s,e+24),t,n)}function AE(s,e=s.length){if(e>=8){const t=Do.add(e*2),n=Gr(s,0).add(Do),r=Gr(s,e-8),a=Xa(r,37).mul(t).add(n),o=Xa(n,25).add(r).mul(t);return pl(a,o,t)}if(e>=4){const t=Do.add(e*2),n=ek(s,0);return pl(n.shl(3).add(e),ek(s,e-4),t)}if(e>0){const t=s[0],n=s[e>>1],r=s[e-1],a=t+(n<<8),o=e+(r<<2);return x0(Do.mul(a).xor(_I.mul(o))).mul(Do)}return Do}function OE(s,e=s.length){const t=Do.add(e*2),n=Gr(s,0).mul(ed),r=Gr(s,8),a=Gr(s,e-8).mul(t),o=Gr(s,e-16).mul(Do);return pl(Xa(n.add(r),43).add(Xa(a,30)).add(o),n.add(Xa(r.add(Do),18)).add(a),t)}function FE(s,e=s.length){const t=Do.add(e*2),n=Gr(s,0).mul(Do),r=Gr(s,8),a=Gr(s,e-8).mul(t),o=Gr(s,e-16).mul(Do),i=Xa(n.add(r),43).add(Xa(a,30)).add(o),u=pl(i,n.add(Xa(r.add(Do),18)).add(a),t),c=Gr(s,16).mul(t),d=Gr(s,24),h=i.add(Gr(s,e-32)).mul(t),l=u.add(Gr(s,e-24)).mul(t);return pl(Xa(c.add(d),43).add(Xa(h,30)).add(l),c.add(Xa(d.add(n),18)).add(h),t)}function DE(s,e=s.length){const t=td.fromNumber(81,!0);if(e<=32)return e<=16?AE(s,e):OE(s,e);if(e<=64)return FE(s,e);let n=t,r=t.mul(ed).add(113),a=x0(r.mul(Do).add(113)).mul(Do),o=[td.UZERO,td.UZERO],i=[td.UZERO,td.UZERO];n=n.mul(Do).add(Gr(s,0));let u=0;const c=(e-1>>6)*64,d=c+(e-1&63)-63;do n=Xa(n.add(r).add(o[0]).add(Gr(s,u+8)),37).mul(ed),r=Xa(r.add(o[1]).add(Gr(s,u+48)),42).mul(ed),n=n.xor(i[1]),r=r.add(o[0]).add(Gr(s,u+40)),a=Xa(a.add(i[0]),33).mul(ed),o=am(s,u,o[1].mul(ed),n.add(i[0])),i=am(s,u+32,a.add(i[1]),r.add(Gr(s,u+16))),[a,n]=[n,a],u+=64;while(u!==c);const h=ed.add(a.and(255).shl(1));return u=d,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),n=Xa(n.add(r).add(o[0]).add(Gr(s,u+8)),37).mul(h),r=Xa(r.add(o[1]).add(Gr(s,u+48)),42).mul(h),n=n.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(Gr(s,u+40))),a=Xa(a.add(i[0]),33).mul(h),o=am(s,u,o[1].mul(h),n.add(i[0])),i=am(s,u+32,a.add(i[1]),r.add(Gr(s,u+16))),[a,n]=[n,a],pl(pl(o[0],i[0],h).add(x0(r).mul(_I)).add(a),pl(o[1],i[1],h).add(n),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _l(s,e){return e==="string"?fl(s):_d([s],e)}function ME(s,e){return s instanceof Float32Array&&e==="float32"||s instanceof Int32Array&&e==="int32"||s instanceof Uint8Array&&e==="bool"}function _d(s,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(s)&&(s=dd(s)),nn().getBool("DEBUG")&&pE(s,e),ME(s,e))return s;if(e==null||e==="float32"||e==="complex64")return new Float32Array(s);if(e==="int32")return new Int32Array(s);if(e==="bool"){const t=new Uint8Array(s.length);for(let n=0;n<t.length;++n)Math.round(s[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Yo(){return nn().platform.now()}function fl(s,e="utf-8"){return e=e||"utf-8",nn().platform.encode(s,e)}function bl(s,e="utf-8"){return e=e||"utf-8",nn().platform.decode(s,e)}function Vu(s){return nn().platform.isTypedArray!=null?nn().platform.isTypedArray(s):wI(s)}function dd(s,e=[],t=!1){if(e==null&&(e=[]),typeof s=="boolean"||typeof s=="number"||typeof s=="string"||sy(s)||s==null||Vu(s)&&t)e.push(s);else if(Array.isArray(s)||Vu(s))for(let n=0;n<s.length;++n)dd(s[n],e,t);else{let n=-1;for(const r of Object.keys(s))/^([1-9]+[0-9]*|0)$/.test(r)&&(n=Math.max(n,Number(r)));for(let r=0;r<=n;r++)dd(s[r],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PE{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new BE)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let o;const i=Yo();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:Yo()-i})}if(nn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const d=r[c];d.data().then(h=>{LE(h,d.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:o}=e;n.forEach(i=>{Promise.all([i.data(),r,o]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],a,u[2])})})}}function LE(s,e,t){if(e!=="float32")return!1;for(let n=0;n<s.length;n++){const r=s[n];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class BE{logKernelProfile(e,t,n,r,a,o){const i=typeof r=="number"?Xd(`${r}ms`,9):r.error,u=Xd(e,25),c=t.rank,d=t.size,h=Xd(t.shape.toString(),14);let l="";for(const p in a){const f=a[p];if(f!=null){const x=f.shape||t.shape,b=x.length;l+=`${p}: ${b}D ${b>0?x:""} `}}console.log(`%c${u}	%c${i}	%c${c}D ${h}	%c${d}	%c${l}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zE(s,e,t){const n={},r={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<s.length;u++){const c=s[u],d=c.inputs;for(const h in d){const l=d[h];let p=!1;for(let f=0;f<e.length;f++)if(n[l.id]){c.outputs.forEach(x=>n[x.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const a={};a[t.id]=!0;const o={};for(let u=s.length-1;u>=0;u--){const c=s[u],d=c.inputs;for(let h=0;h<c.outputs.length;h++)if(a[c.outputs[h].id]){for(const l in d)a[d[l].id]=!0,o[c.id]=!0;break}}const i=[];for(let u=0;u<s.length;u++){const c=s[u];if(r[c.id]&&o[c.id]){const d={};for(const l in c.inputs){const p=c.inputs[l];n[p.id]&&(d[l]=p)}const h=Object.assign({},c);h.inputs=d,h.outputs=c.outputs,i.push(h)}}return i}function WE(s,e,t,n){for(let r=e.length-1;r>=0;r--){const a=e[r],o=[];if(a.outputs.forEach(u=>{const c=s[u.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const c=t(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const d=a.inputs[u];if(!Er(c.shape,d.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(s[d.id]==null)s[d.id]=c;else{const h=s[d.id];s[d.id]=n(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tk=20,jh=3,W1=7;function VE(s,e,t,n){const r=ws(e),a=UE(s,e,t,r),o=e.length,i=wm(s,e,t,r,a),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function UE(s,e,t,n){const r=hn(e),a=n[n.length-1],o=new Array(a).fill(0),i=e.length,u=t==="complex64"?Xh(s):s;if(i>1)for(let c=0;c<r/a;c++){const d=c*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Kh(u[d+h],0,t).length)}return o}function Kh(s,e,t){let n;return Array.isArray(s)?n=`${parseFloat(s[0].toFixed(W1))} + ${parseFloat(s[1].toFixed(W1))}j`:mp(s)?n=`'${s}'`:t==="bool"?n=$I(s):n=parseFloat(s.toFixed(W1)).toString(),Xd(n,e)}function $I(s){return s===0?"false":"true"}function wm(s,e,t,n,r,a=!0){const o=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){const x=Xh(s);return[Kh(x[0],0,t)]}return t==="bool"?[$I(s[0])]:[s[0].toString()]}if(u===1){if(i>tk){const b=jh*o;let m=Array.from(s.slice(0,b)),I=Array.from(s.slice((i-jh)*o,i*o));return t==="complex64"&&(m=Xh(m),I=Xh(I)),["["+m.map((N,E)=>Kh(N,r[E],t)).join(", ")+", ..., "+I.map((N,E)=>Kh(N,r[i-jh+E],t)).join(", ")+"]"]}const x=t==="complex64"?Xh(s):Array.from(s);return["["+x.map((b,m)=>Kh(b,r[m],t)).join(", ")+"]"]}const c=e.slice(1),d=n.slice(1),h=n[0]*o,l=[];if(i>tk){for(let x=0;x<jh;x++){const b=x*h,m=b+h;l.push(...wm(s.slice(b,m),c,t,d,r,!1))}l.push("...");for(let x=i-jh;x<i;x++){const b=x*h,m=b+h;l.push(...wm(s.slice(b,m),c,t,d,r,x===i-1))}}else for(let x=0;x<i;x++){const b=x*h,m=b+h;l.push(...wm(s.slice(b,m),c,t,d,r,x===i-1))}const p=u===2?",":"";l[0]="["+(i>0?l[0]+p:"");for(let x=1;x<l.length-1;x++)l[x]=" "+l[x]+p;let f=`,
`;for(let x=2;x<u;x++)f+=`
`;return l[l.length-1]=" "+l[l.length-1]+"]"+(a?"":f),l}function Xh(s){const e=[];for(let t=0;t<s.length;t+=2)e.push([s[t],s[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class co{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=hn(e),n!=null){const r=n.length;ze(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ba(t,this.size),this.strides=ws(e)}set(e,...t){t.length===0&&(t=[0]),ze(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Mu().makeTensor(this.values,this.shape,this.dtype)}}let Mu=null,Hd=null;function jE(s){Mu=s}function GE(s){Hd=s}class _a{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=hn(e),this.strides=ws(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Hd.buffer(this.shape,this.dtype,e)}bufferSync(){return Hd.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Bu(this.shape,e,this.dtype==="complex64")}arraySync(){return Bu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Mu().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>bl(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Mu().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Mu().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>bl(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Mu().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Mu().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Hd.print(this,e)}clone(){return this.throwIfDisposed(),Hd.clone(this)}toString(e=!1){const t=this.dataSync();return VE(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Hd.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Mu().makeVariable(this,e,t,n)}}Object.defineProperty(_a,Symbol.hasInstance,{value:s=>!!s&&s.data!=null&&s.dataSync!=null&&s.throwIfDisposed!=null});function ln(){return ry("Tensor",()=>_a)}ln();class Rm extends _a{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Er(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Mu().disposeTensor(this),this.dataId=e.dataId,Mu().incRef(this,null)}dispose(){Mu().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Rm,Symbol.hasInstance,{value:s=>s instanceof _a&&s.assign!=null&&s.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nk;(function(s){s.R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6"})(nk||(nk={}));var y0;(function(s){s.float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64"})(y0||(y0={}));var w0;(function(s){s.float32="float32",s.int32="int32",s.bool="bool",s.complex64="complex64"})(w0||(w0={}));var v0;(function(s){s.float32="float32",s.int32="float32",s.bool="float32",s.complex64="complex64"})(v0||(v0={}));var k0;(function(s){s.float32="complex64",s.int32="complex64",s.bool="complex64",s.complex64="complex64"})(k0||(k0={}));const HE={float32:v0,int32:y0,bool:w0,complex64:k0};function vi(s,e){if(s==="string"||e==="string"){if(s==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${s} with ${e}`)}return HE[s][e]}function Gy(s){return vi(s,"int32")}function TI(s){return s!=null&&typeof s=="object"&&"texture"in s&&s.texture instanceof WebGLTexture}function NI(s){return typeof GPUBuffer!="undefined"&&s!=null&&typeof s=="object"&&"buffer"in s&&s.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(s,e){if(s.dtype===e.dtype)return[s,e];const t=vi(s.dtype,e.dtype);return[s.cast(t),e.cast(t)]}function EI(s){const e=[];return RI(s,e,new Set),e}function RI(s,e,t){if(s==null)return;if(s instanceof _a){e.push(s);return}if(!qE(s))return;const n=s;for(const r in n){const a=n[r];t.has(a)||(t.add(a),RI(a,e,t))}}function qE(s){return Array.isArray(s)||typeof s=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(s){return s.kernelName!=null}class sk{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class sh{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sk}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Gi(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new PE(this.backendInstance),!0}setupRegisteredKernels(){Kv(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Kv(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(n&&!(n instanceof J0)&&typeof n.then=="function"){const r=++this.pendingBackendInitId,a=n.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Gi(`Initialization of backend ${e} failed`),Gi(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return Gi(`Initialization of backend ${e} failed`),Gi(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,n){e();try{const r=n();return t(),r}catch(r){throw t(),r}}nextTensorId(){return sh.nextTensorId++}nextVariableId(){return sh.nextVariableId++}clone(e){const t=Mt.runKernel(Mp,{x:e}),n={x:e},r=o=>({x:()=>{const i="float32",u={x:o},c={dtype:i};return Mt.runKernel(Ip,u,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Hv(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const c=V1(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(V1(e)){const{kernelName:f,inputs:x,attrs:b}=e;this.backendName==null&&this.backend;const m=Hv(f,this.backendName);ze(m!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const I=this.backend.numDataIds();u=m.kernelFunc({inputs:x,attrs:b,backend:this.backend});const N=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,I,N);const E=N.map(D=>D.rank!=null?D:this.makeTensorFromTensorInfo(D));if(r){const D=this.getTensorsForGradient(f,x,E);n=this.saveTensorsForBackwardMode(D)}return E}}else{const{forwardFunc:f}=e,x=b=>{!r||(n=b.map(m=>this.keep(this.clone(m))))};i=()=>{const b=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,x));const m=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,b,m),m}}const{inputs:d,attrs:h}=e,l=V1(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(p=this.profiler.profileKernel(c,d,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(c,d,t,l,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(f=>d[f]!=null?d[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){const r=qv(e);if(r!=null){const a=r.inputsToSave||[],o=r.outputsToSave||[];let i;r.saveAllInputs?(ze(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(c=>t[c])):i=a.map(c=>t[c]);const u=n.filter((c,d)=>o[d]);return i.concat(u)}return[]}makeTensor(e,t,n,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;n==="string"&&mp(e[0])&&(a=e.map(u=>fl(u)));const o=r.write(a,t,n),i=new _a(t,n,o,this.nextTensorId());if(this.trackTensor(i,r),n==="string"){const u=this.state.tensorInfo.get(o),c=mE(a);this.state.numBytes+=c-u.bytes,u.bytes=c}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";const a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,o=new _a(r,a,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const a=new Rm(e,t,n,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Sm(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Rm||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*Sm(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},u=qv(e);u!=null&&(r=u.gradFunc),r!=null&&(i.gradient=c=>(c=c.map((d,h)=>{if(d==null){const l=n[h],p=Io(l.size,l.dtype);return this.makeTensor(p,l.shape,l.dtype)}return d}),r(c.length>1?c:c[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=EI(e),n=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!n.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,t,n,r=!1){if(ze(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ze(a instanceof _a,()=>"The result y returned by f() must be a tensor.");const o=zE(this.state.activeTape,t,a);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=n==null?KE(a.shape):n,WE(i,o,c=>this.tidy(c),XE);const u=t.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return ze(d0(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{ze(t.every(i=>i instanceof _a),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const r={};t.forEach((i,u)=>{r[u]=i});const a=(i,u)=>(n=e(...t,u),ze(n.value instanceof _a,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ze(d0(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),o=(i,u)=>{const c=n.gradFunc(i,u),d=Array.isArray(c)?c:[c];ze(d.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ze(d.every(l=>l instanceof _a),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((l,p)=>{h[p]=()=>l}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Yo(),n=await this.backend.time(e);return n.wallMs=Yo()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sk;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}sh.nextTensorId=0;sh.nextVariableId=0;function KE(s){const e=ny(hn(s),"float32");return Mt.makeTensor(e,s,"float32")}function AI(){const s=K2();if(s._tfengine==null){const e=new xE(s);s._tfengine=new sh(e)}return kE(s._tfengine.ENV),jE(()=>s._tfengine),s._tfengine}const Mt=AI();function XE(s,e){const t={a:s,b:e};return Mt.runKernel(yh,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YE(){return typeof navigator!="undefined"&&navigator!=null}function OI(s){if(s||YE()){if(s||(s=navigator),s.product==="ReactNative")return!0;const e=s.userAgent||s.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=s;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function FI(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jo=nn();Jo.registerFlag("DEBUG",()=>!1,s=>{s&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Jo.registerFlag("IS_BROWSER",()=>FI());Jo.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Jo.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Jo.registerFlag("IS_SAFARI",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Jo.registerFlag("PROD",()=>!1);Jo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Jo.getBool("DEBUG"));Jo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Jo.registerFlag("IS_TEST",()=>!1);Jo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Jo.getBool("DEBUG"));Jo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Jo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Jo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(s,e){let t=s;if(Vu(s))return e==="string"?[]:[s.length];if(TI(s)){const r=s.channels||"RGBA";return[s.height,s.width*r.length]}else if(NI(s))return[s.buffer.size/(e==null?4:Sm(e))];if(!Array.isArray(s))return[];const n=[];for(;Array.isArray(t)||Vu(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(s)&&nn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&DI(s,n,[]),n}function DI(s,e,t){if(t=t||[],!Array.isArray(s)&&!Vu(s)){ze(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}ze(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${s.length} elements`),ze(s.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${s.length} elements`);const n=e.slice(1);for(let r=0;r<s.length;++r)DI(s[r],n,t.concat(r))}function rk(s,e,t,n){if(s!=="string_or_numeric"){if(s==null)throw new Error("Expected dtype cannot be null.");if(s!=="numeric"&&s!==e||s==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${s} tensor, but got ${e} tensor`)}}function mt(s,e,t,n="numeric"){if(s instanceof _a)return rk(n,s.dtype,e,t),s;let r=bh(s);if(r!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(r=n),rk(n,r,e,t),s==null||!Vu(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string"){const u=s==null?"null":s.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const a=rb(s,r);!Vu(s)&&!Array.isArray(s)&&(s=[s]);const i=r!=="string"?_d(s,r):dd(s,[],!0);return Mt.makeTensor(i,a,r)}function MI(s,e,t,n="numeric"){if(!Array.isArray(s))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return s.map((a,o)=>mt(a,`${e}[${o}]`,t,n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZE="__op";function Vt(s){const e=Object.keys(s);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const n=s[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+ZE;const r=(...a)=>{Mt.startScope(t);try{const o=n(...a);return sy(o)&&console.error("Cannot return a Promise inside of tidy."),Mt.endScope(o),o}catch(o){throw Mt.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(s,e){const t=mt(s,"real","complex"),n=mt(e,"imag","complex");ty(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);const r={real:t,imag:n};return Mt.runKernel(dy,r)}const rh=Vt({complex_:QE});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(s,e,t,n){if(n==null)n=bh(s);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(NI(s)||TI(s)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return Mt.backend.createTensorFromGPUData(s,e||t,n)}if(!Vu(s)&&!Array.isArray(s)&&typeof s!="number"&&typeof s!="boolean"&&typeof s!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){jc(e);const r=hn(e),a=hn(t);ze(r===a,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${a}`);for(let o=0;o<t.length;++o){const i=t[o],u=o===t.length-1?i!==hn(e.slice(o)):!0;ze(t[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Vu(s)&&!Array.isArray(s)&&(s=[s]),e=e||t,s=n!=="string"?_d(s,n):dd(s,[],!0),Mt.makeTensor(s,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Am(s,e,t){const n=rb(s,t);return ab(s,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ak=4;async function ok(s,e){const t=[],n=[],r=Array.isArray(s)?s.map(o=>o.name):Object.keys(s);for(let o=0;o<r.length;++o){const i=r[o],u=Array.isArray(s)?s[o].tensor:s[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const c={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const d=new Promise(async h=>{const l=await u.bytes(),p=l.reduce((b,m)=>b+m.length,0)+ak*l.length,f=new Uint8Array(p);let x=0;for(let b=0;b<l.length;b++){const m=l[b],I=new Uint8Array(new Uint32Array([m.length]).buffer);f.set(I,x),x+=ak,f.set(m,x),x+=m.length}h(f)});n.push(d)}else n.push(u.data());e!=null&&(c.group=e),t.push(c)}const a=await Promise.all(n);return{data:JE(a),specs:t}}function JE(s){if(s===null)throw new Error(`Invalid input value: ${JSON.stringify(s)}`);let e=0;const t=[];s.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const n=new Uint8Array(e);let r=0;return t.forEach(a=>{n.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),n.buffer}const Hy=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function ik(s){return Hy?Buffer.byteLength(s):new Blob([s]).size}function eR(s){if(Hy)return Buffer.from(s).toString("base64");const e=new Uint8Array(s);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function tR(s){if(Hy){const n=Buffer.from(s,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(s),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function PI(s){if(s.length===1)return s[0];let e=0;s.forEach(r=>{e+=r.byteLength});const t=new Uint8Array(e);let n=0;return s.forEach(r=>{t.set(new Uint8Array(r),n),n+=r.byteLength}),t.buffer}function LI(s,e){const t={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy,weightsManifest:e};return s.signature!=null&&(t.signature=s.signature),s.userDefinedMetadata!=null&&(t.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(t.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(t.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(t.trainingConfig=s.trainingConfig),t}function nR(s,e,t){const n={modelTopology:s.modelTopology,format:s.format,generatedBy:s.generatedBy,convertedBy:s.convertedBy};if(s.trainingConfig!=null&&(n.trainingConfig=s.trainingConfig),s.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return s.signature!=null&&(n.signature=s.signature),s.userDefinedMetadata!=null&&(n.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(n.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(n.initializerSignature=s.initializerSignature),n}async function sR(s,e){let t,n;return s.weightsManifest!=null&&([t,n]=await e(s.weightsManifest)),nR(s,t,n)}function ob(s){if(s.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:s.modelTopology==null?0:ik(JSON.stringify(s.modelTopology)),weightSpecsBytes:s.weightSpecs==null?0:ik(JSON.stringify(s.weightSpecs)),weightDataBytes:s.weightData==null?0:s.weightData.byteLength}}function rR(s){const e=[];for(const t of s)e.push(...t.weights);return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ka{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ka.instance==null&&(Ka.instance=new Ka),Ka.instance}static registerSaveRouter(e){Ka.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ka.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ka.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ka.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return(t==="load"?Ka.getInstance().loadRouters:Ka.getInstance().saveRouters).forEach(o=>{const i=o(e,n);i!==null&&r.push(i)}),r}}const aR=s=>Ka.getSaveHandlers(s);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I0="tensorflowjs",C0=1,ad="models_store",ll="model_info_store";function BI(){if(!nn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window=="undefined"?self:window,e=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function _0(s){const e=s.result;e.createObjectStore(ad,{keyPath:"modelPath"}),e.createObjectStore(ll,{keyPath:"modelPath"})}class hd{constructor(e){if(this.indexedDB=BI(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{const a=this.indexedDB.open(I0,C0);a.onupgradeneeded=()=>_0(a),a.onsuccess=()=>{const o=a.result;if(t==null){const i=o.transaction(ad,"readonly"),c=i.objectStore(ad).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(c.result.modelArtifacts)},c.onerror=d=>(o.close(),r(c.error)),i.oncomplete=()=>o.close()}else{const i=ob(t),u=o.transaction(ll,"readwrite");let c=u.objectStore(ll),d;try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(l){return r(l)}let h;d.onsuccess=()=>{h=o.transaction(ad,"readwrite");const l=h.objectStore(ad);let p;try{p=l.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(f){return r(f)}p.onsuccess=()=>n({modelArtifactsInfo:i}),p.onerror=f=>{c=u.objectStore(ll);const x=c.delete(this.modelPath);x.onsuccess=()=>(o.close(),r(p.error)),x.onerror=b=>(o.close(),r(p.error))}},d.onerror=l=>(o.close(),r(d.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>r(a.error)})}}hd.URL_SCHEME="indexeddb://";const zI=s=>nn().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(hd.URL_SCHEME)?oR(s.slice(hd.URL_SCHEME.length)):null;Ka.registerSaveRouter(zI);Ka.registerLoadRouter(zI);function oR(s){return new hd(s)}function iR(s){return s.startsWith(hd.URL_SCHEME)?s.slice(hd.URL_SCHEME.length):s}class uR{constructor(){this.indexedDB=BI()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(I0,C0);n.onupgradeneeded=()=>_0(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(ll,"readonly"),i=a.objectStore(ll).getAll();i.onsuccess=()=>{const u={};for(const c of i.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},i.onerror=u=>(r.close(),t(i.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=iR(e),new Promise((t,n)=>{const r=this.indexedDB.open(I0,C0);r.onupgradeneeded=()=>_0(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(ll,"readwrite"),i=o.objectStore(ll),u=i.get(e);let c;u.onsuccess=()=>{if(u.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=i.delete(e),h=()=>{c=a.transaction(ad,"readwrite");const p=c.objectStore(ad).delete(e);p.onsuccess=()=>t(u.result.modelArtifactsInfo),p.onerror=f=>n(u.error)};d.onsuccess=h,d.onerror=l=>(h(),a.close(),n(u.error))}},u.onerror=d=>(a.close(),n(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mc="/",qd="tensorflowjs_models",WI="info",cR="model_topology",lR="weight_specs",dR="weight_data",hR="model_metadata";function VI(s){return{info:[qd,s,WI].join(Mc),topology:[qd,s,cR].join(Mc),weightSpecs:[qd,s,lR].join(Mc),weightData:[qd,s,dR].join(Mc),modelMetadata:[qd,s,hR].join(Mc)}}function UI(s){for(const e of Object.values(s))window.localStorage.removeItem(e)}function pR(s){const e=s.split(Mc);if(e.length<3)throw new Error(`Invalid key format: ${s}`);return e.slice(1,e.length-1).join(Mc)}function fR(s){return s.startsWith(pd.URL_SCHEME)?s.slice(pd.URL_SCHEME.length):s}class pd{constructor(e){if(!nn().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=VI(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=ob(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,eR(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw UI(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=tR(o),t}}pd.URL_SCHEME="localstorage://";const jI=s=>nn().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(pd.URL_SCHEME)?mR(s.slice(pd.URL_SCHEME.length)):null;Ka.registerSaveRouter(jI);Ka.registerLoadRouter(jI);function mR(s){return new pd(s)}class gR{constructor(){ze(nn().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ze(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=qd+Mc,n=Mc+WI;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){const o=pR(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=fR(e);const t=VI(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return UI(t),n}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk="://";class ic{constructor(){this.managers={}}static getInstance(){return ic.instance==null&&(ic.instance=new ic),ic.instance}static registerManager(e,t){ze(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(uk)&&(e=e.slice(0,e.indexOf(uk))),ze(e.length>0,()=>"scheme must not be an empty string.");const n=ic.getInstance();ze(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=ic.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ic.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bR{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window=="undefined"||!nn().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{n.source===window&&n.data.name===this.messageName&&(n.stopPropagation(),this.functionRefs[n.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))}isTypedArray(e){return wI(e)}}if(nn().get("IS_BROWSER")){nn().setPlatform("browser",new bR);try{ic.registerManager(pd.URL_SCHEME,new gR)}catch{}try{ic.registerManager(hd.URL_SCHEME,new uR)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xR={importFetch:()=>require("node-fetch")};let U1;class yR{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return nn().global.fetch!=null?nn().global.fetch(e,t):(U1==null&&(U1=xR.importFetch()),U1(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}nn().get("IS_NODE")&&!nn().get("IS_BROWSER")&&nn().setPlatform("node",new yR);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tr(s,e="float32",t){return e=e||"float32",jc(s),new co(s,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(s,e){const t=mt(s,"x","cast");if(!fE(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},r={dtype:e};return Mt.runKernel(Ip,n,r)}const as=Vt({cast_:wR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(s){const t={x:mt(s,"x","clone","string_or_numeric")};return Mt.runKernel(Mp,t)}const id=Vt({clone_:vR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kR(s,e=!1){console.log(s.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */AI();const IR={buffer:tr,cast:as,clone:id,print:kR};GE(IR);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(){return Mt}function S0(){return Mt.memory()}function Qt(s,e){return Mt.tidy(s,e)}function ir(s){EI(s).forEach(t=>t.dispose())}function mc(s){return Mt.keep(s)}function GI(s,e,t=1){return Mt.registerBackend(s,e,t)}function CR(){return Mt.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(s,e){let t=mt(s,"a","add"),n=mt(e,"b","add");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(yh,r)}const Bn=Vt({add_:_R});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SR(s,e){let t=mt(s,"a","floorDiv"),n=mt(e,"b","floorDiv");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(Fp,r)}const HI=Vt({floorDiv_:SR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(s,e){let t=mt(s,"a","div"),n=mt(e,"b","div");if([t,n]=ya(t,n),t.dtype==="int32"&&n.dtype==="int32")return HI(t,n);const r={a:t,b:n},a={};return Mt.runKernel(Tp,r,a)}const _s=Vt({div_:$R});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(s,e){let t=mt(s,"a","mul"),n=mt(e,"b","mul");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(Gp,r)}const Ft=Vt({mul_:TR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(s){const e=mt(s,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Mt.runKernel(lg,t)}else{const t={x:e};return Mt.runKernel(sg,t)}}const Fo=Vt({abs_:NR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(s){const t={x:mt(s,"x","acos")};return Mt.runKernel(gp,t)}const RR=Vt({acos_:ER});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AR(s){const t={x:mt(s,"x","acosh")};return Mt.runKernel(bp,t)}const OR=Vt({acosh_:AR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(s,e=null,t=!1){const r={x:mt(s,"x","all","bool")},a={axis:e,keepDims:t};return Mt.runKernel(oy,r,a)}const qI=Vt({all_:FR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(s,e=null,t=!1){const r={x:mt(s,"x","any","bool")},a={axis:e,keepDims:t};return Mt.runKernel(iy,r,a)}const $0=Vt({any_:DR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(s,e=0){const n={x:mt(s,"x","argMax")},r={axis:e};return Mt.runKernel(rg,n,r)}const ah=Vt({argMax_:MR});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(s,e=0){const n={x:mt(s,"x","argMin")},r={axis:e};return Mt.runKernel(ag,n,r)}const LR=Vt({argMin_:PR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(s){const t={x:mt(s,"x","asin")};return Mt.runKernel(xp,t)}const zR=Vt({asin_:BR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(s){const t={x:mt(s,"x","asinh")};return Mt.runKernel(yp,t)}const VR=Vt({asinh_:WR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(s){const t={x:mt(s,"x","atan")};return Mt.runKernel(wp,t)}const jR=Vt({atan_:UR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(s,e){let t=mt(s,"a","atan2"),n=mt(e,"b","atan2");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(kp,r)}const HR=Vt({atan2_:GR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(s){const t={x:mt(s,"x","atanh")};return Mt.runKernel(vp,t)}const KR=Vt({atanh_:qR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hf(s,e,t,n,r="NHWC",a){const o=s[3],i=[...e,o],u=Hc(r);return lo(s,i,t,a,n,null,null,u)}function Cu(s,e,t,n,r,a,o="channelsLast"){const[i,u]=np(e);let c;if(o==="channelsLast")c=[i,u,s[3],s[3]];else if(o==="channelsFirst")c=[i,u,s[1],s[1]];else throw new Error(`Unknown dataFormat ${o}`);return lo(s,c,t,n,r,a,!1,o)}function Gc(s,e,t,n,r,a,o="NDHWC"){const[i,u,c]=T0(e);let d,h;if(o==="NDHWC")h="channelsLast",d=[i,u,c,s[4],s[4]];else if(o==="NCDHW")h="channelsFirst",d=[i,u,c,s[1],s[1]];else throw new Error(`Unknown dataFormat ${o}`);return Sl(s,d,t,n,r,!1,h,a)}function lo(s,e,t,n,r,a,o=!1,i="channelsLast"){let[u,c,d,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,d,h]=s;else if(i==="channelsFirst")[u,h,c,d]=s;else throw new Error(`Unknown dataFormat ${i}`);const[l,p,,f]=e,[x,b]=np(t),[m,I]=np(n),N=Zd(l,m),E=Zd(p,I),{padInfo:D,outHeight:U,outWidth:L}=ZR(r,c,d,x,b,N,E,a,i),Y=o?f*h:f;let V;return i==="channelsFirst"?V=[u,Y,U,L]:i==="channelsLast"&&(V=[u,U,L,Y]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:d,inChannels:h,outHeight:U,outWidth:L,outChannels:Y,padInfo:D,strideHeight:x,strideWidth:b,filterHeight:l,filterWidth:p,effectiveFilterHeight:N,effectiveFilterWidth:E,dilationHeight:m,dilationWidth:I,inShape:s,outShape:V,filterShape:e}}function Sl(s,e,t,n,r,a=!1,o="channelsLast",i){let[u,c,d,h,l]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,c,d,h,l]=s;else if(o==="channelsFirst")[u,l,c,d,h]=s;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,x,,b]=e,[m,I,N]=T0(t),[E,D,U]=T0(n),L=Zd(p,E),Y=Zd(f,D),V=Zd(x,U),{padInfo:P,outDepth:oe,outHeight:ne,outWidth:ge}=QR(r,c,d,h,m,I,N,L,Y,V,i),ye=a?b*l:b;let Ee;return o==="channelsFirst"?Ee=[u,ye,oe,ne,ge]:o==="channelsLast"&&(Ee=[u,oe,ne,ge,ye]),{batchSize:u,dataFormat:o,inDepth:c,inHeight:d,inWidth:h,inChannels:l,outDepth:oe,outHeight:ne,outWidth:ge,outChannels:ye,padInfo:P,strideDepth:m,strideHeight:I,strideWidth:N,filterDepth:p,filterHeight:f,filterWidth:x,effectiveFilterDepth:L,effectiveFilterHeight:Y,effectiveFilterWidth:V,dilationDepth:E,dilationHeight:D,dilationWidth:U,inShape:s,outShape:Ee,filterShape:e}}function XR(s,e,t,n,r){n==null&&(n=qy(s,e,t));const a=s[0],o=s[1],i=sp((a-e+2*n)/t+1,r),u=sp((o-e+2*n)/t+1,r);return[i,u]}function YR(s,e,t,n,r,a){r==null&&(r=qy(s,e[0],n[0]));const o=[0,0,0,t];for(let i=0;i<3;i++)s[i]+2*r>=e[i]&&(o[i]=sp((s[i]-e[i]+2*r)/n[i]+1,a));return o}function qy(s,e,t,n=1){const r=Zd(e,n);return Math.floor((s[0]*(t-1)-t+r)/2)}function np(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function T0(s){return typeof s=="number"?[s,s,s]:s}function Zd(s,e){return e<=1?s:s+(s-1)*(e-1)}function ZR(s,e,t,n,r,a,o,i,u){let c,d,h;if(typeof s=="number"){c={top:s,bottom:s,left:s,right:s,type:s===0?"VALID":"NUMBER"};const p=XR([e,t],a,n,s,i);d=p[0],h=p[1]}else if(s==="same"){d=Math.ceil(e/n),h=Math.ceil(t/r);const l=Math.max(0,(d-1)*n+a-e),p=Math.max(0,(h-1)*r+o-t),f=Math.floor(l/2),x=l-f,b=Math.floor(p/2),m=p-b;c={top:f,bottom:x,left:b,right:m,type:"SAME"}}else if(s==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((e-a+1)/n),h=Math.ceil((t-o+1)/r);else if(typeof s=="object"){const l=u==="channelsLast"?s[1][0]:s[2][0],p=u==="channelsLast"?s[1][1]:s[2][1],f=u==="channelsLast"?s[2][0]:s[3][0],x=u==="channelsLast"?s[2][1]:s[3][1];c={top:l,bottom:p,left:f,right:x,type:l===0&&p===0&&f===0&&x===0?"VALID":"EXPLICIT"},d=sp((e-a+l+p)/n+1,i),h=sp((t-o+f+x)/r+1,i)}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:c,outHeight:d,outWidth:h}}function QR(s,e,t,n,r,a,o,i,u,c,d){let h,l,p,f;if(s==="valid"&&(s=0),typeof s=="number"){h={top:s,bottom:s,left:s,right:s,front:s,back:s,type:s===0?"VALID":"NUMBER"};const b=YR([e,t,n,1],[i,u,c],1,[r,a,o],s,d);l=b[0],p=b[1],f=b[2]}else if(s==="same"){l=Math.ceil(e/r),p=Math.ceil(t/a),f=Math.ceil(n/o);const x=(l-1)*r+i-e,b=(p-1)*a+u-t,m=(f-1)*o+c-n,I=Math.floor(x/2),N=x-I,E=Math.floor(b/2),D=b-E,U=Math.floor(m/2),L=m-U;h={top:E,bottom:D,left:U,right:L,front:I,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${s}`);return{padInfo:h,outDepth:l,outHeight:p,outWidth:f}}function sp(s,e){if(!e)return Math.trunc(s);switch(e){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error(`Unknown roundingMode ${e}`)}}function fd(s){const[e,t,n]=np(s);return e===1&&t===1&&n===1}function Co(s,e){return fd(s)||fd(e)}function md(s){return np(s).every(e=>e>0)}function Hc(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${s}`)}function ti(s,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")ze(th(e),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(r=>{ze(th(r),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${s}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JR(s,e){const n={x:mt(s,"x","reshape","string_or_numeric")},r={shape:e};return Mt.runKernel(jg,n,r)}const zt=Vt({reshape_:JR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(s,e,t,n,r){const a=mt(s,"x","avgPool","float32"),o=1;ze(Co(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=zt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ze(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ti("avgPool",n,r);const c={x:i},d={filterSize:e,strides:t,pad:n,dimRoundingMode:r};let h=Mt.runKernel(og,c,d);return h=as(h,a.dtype),u?zt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ky=Vt({avgPool_:eA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(s,e,t,n,r,a="NDHWC"){const o=mt(s,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=zt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ze(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),ze(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ze(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ti("avgPool3d",n,r);const c={x:i},d={filterSize:e,strides:t,pad:n,dimRoundingMode:r,dataFormat:a};let h=Mt.runKernel(ig,c,d);return h=as(h,i.dtype),u?zt(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const nA=Vt({avgPool3d_:tA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(s,e=0){ze(s.length>=1,()=>"Pass at least one tensor to concat");const t=MI(s,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return id(t[0]);const n=t,r={axis:e};return Mt.runKernel(dg,n,r)}const Qo=Vt({concat_:sA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rA(s,e,t=!1,n=!1){let r=mt(s,"a","matMul"),a=mt(e,"b","matMul");[r,a]=ya(r,a);const o={a:r,b:a},i={transposeA:t,transposeB:n};return Mt.runKernel(ug,o,i)}const Nr=Vt({matMul_:rA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA(s){const t={x:mt(s,"x","sigmoid","float32")};return Mt.runKernel(nf,t)}const wh=Vt({sigmoid_:aA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(s,e,t){const n=mt(s,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const r={x:n},a={begin:e,size:t};return Mt.runKernel(Xg,r,a)}const Hr=Vt({slice_:oA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(s){const t={x:mt(s,"x","tanh","float32")};return Mt.runKernel(cf,t)}const Xy=Vt({tanh_:iA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uA(s,e,t){const n=mt(s,"x","batchToSpaceND"),r=e.reduce((i,u)=>i*u);ze(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),ze(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),ze(n.shape[0]%r===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:n},o={blockShape:e,crops:t};return Mt.runKernel(cg,a,o)}const Yy=Vt({batchToSpaceND_:uA});function cA(s){let e;return s.rank===0||s.rank===1?e=zt(s,[1,1,1,s.size]):s.rank===2?e=zt(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?e=zt(s,[1,s.shape[0],s.shape[1],s.shape[2]]):e=s,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(s,e,t,n,r,a){a==null&&(a=.001);const o=mt(s,"x","batchNorm"),i=mt(e,"mean","batchNorm"),u=mt(t,"variance","batchNorm");let c;r!=null&&(c=mt(r,"scale","batchNorm"));let d;n!=null&&(d=mt(n,"offset","batchNorm")),ze(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ze(d==null||i.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ze(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const l={x:cA(o),scale:c,offset:d,mean:i,variance:u},p={varianceEpsilon:a},f=Mt.runKernel(wg,l,p);return zt(f,o.shape)}const ib=Vt({batchNorm_:lA});function dA(s,e,t,n,r,a){const o=mt(s,"x","batchNorm"),i=mt(e,"mean","batchNorm"),u=mt(t,"variance","batchNorm");let c;r!=null&&(c=mt(r,"scale","batchNorm"));let d;return n!=null&&(d=mt(n,"offset","batchNorm")),ze(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),ze(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),ze(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&ze(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),d!=null&&ze(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${d.rank}.`),ib(o,i,u,d,c,a)}const hA=Vt({batchNorm2d_:dA});function pA(s,e,t,n,r,a){const o=mt(s,"x","batchNorm"),i=mt(e,"mean","batchNorm"),u=mt(t,"variance","batchNorm");let c;r!=null&&(c=mt(r,"scale","batchNorm"));let d;return n!=null&&(d=mt(n,"offset","batchNorm")),ze(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),ze(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),ze(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&ze(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),d!=null&&ze(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${d.rank}.`),ib(o,i,u,d,c,a)}const fA=Vt({batchNorm3d_:pA});function mA(s,e,t,n,r,a){const o=mt(s,"x","batchNorm"),i=mt(e,"mean","batchNorm"),u=mt(t,"variance","batchNorm");let c;r!=null&&(c=mt(r,"scale","batchNorm"));let d;return n!=null&&(d=mt(n,"offset","batchNorm")),ze(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),ze(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),ze(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&ze(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),d!=null&&ze(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${d.rank}.`),ib(o,i,u,d,c,a)}const gA=Vt({batchNorm4d_:mA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bA(s,e,t){const n=mt(s,"x","bincount"),r=mt(e,"weights","bincount");ze(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),ze(t>=0,()=>`size must be non-negative, but got ${t}.`),ze(r.size===n.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${r.shape}.`);const a={x:n,weights:r},o={size:t};return Mt.runKernel(ly,a,o)}const xA=Vt({bincount_:bA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(s,e){let t=mt(s,"broadcastTo","x");const n=t.shape;if(jc(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=zt(t,c)}const r=t.shape,a=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])a[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(a.map((c,d)=>c>1?d:-1).filter(c=>c>=0).length===0)return id(t);const i={x:t},u={reps:a};return Mt.runKernel(lf,i,u)}const ep=Vt({broadcastTo_:yA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wA(s){const t={x:mt(s,"x","ceil","float32")};return Mt.runKernel(Cp,t)}const vA=Vt({ceil_:wA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(s,e,t){jc(s),t=t||bh(e);const n={shape:s,value:e,dtype:t};return Mt.runKernel(Iy,{},n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kA(s,e,t){const n=mt(s,"x","clipByValue");if(ze(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return ub(n.shape,e,n.dtype);const r={x:n},a={clipValueMin:e,clipValueMax:t};return Mt.runKernel(_p,r,a)}const Xi=Vt({clipByValue_:kA});function IA(s){return Qo(s,0)}const CA=Vt({concat1d_:IA});function _A(s,e){return Qo(s,e)}const SA=Vt({concat2d_:_A});function $A(s,e){return Qo(s,e)}const TA=Vt({concat3d_:$A});function NA(s,e){return Qo(s,e)}const EA=Vt({concat4d_:NA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(s,e,t,n,r="NHWC",a=[1,1],o){const i=mt(s,"x","conv2d","float32"),u=mt(e,"filter","conv2d","float32");let c=i,d=!1;i.rank===3&&(d=!0,c=zt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ze(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),ze(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ti("conv2d",n,o);const h=r==="NHWC"?c.shape[3]:c.shape[1];ze(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),ze(Co(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ze(md(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),ze(md(t),()=>"Error in conv2D: Strides should be larger than 0.");const l={x:c,filter:u},p={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o},f=Mt.runKernel(hg,l,p);return d?zt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gd=Vt({conv2d_:RA});function AA(s,e,t,n,r="NWC",a=1,o){const i=mt(s,"x","conv1d"),u=mt(e,"filter","conv1d");let c=i,d=!1;i.rank===2&&(d=!0,c=zt(i,[1,i.shape[0],i.shape[1]])),ze(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),ze(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ti("conv1d",n,o),ze(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),ze(Co(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),ze(md(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),ze(md(t),()=>"Error in conv1D: Stride should be larger than 0."),ze(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=zt(u,[1,u.shape[0],u.shape[1],u.shape[2]]),l=zt(c,[c.shape[0],1,c.shape[1],c.shape[2]]),b=gd(l,h,[1,t],n,"NHWC",[1,a],o);return d?zt(b,[b.shape[2],b.shape[3]]):zt(b,[b.shape[0],b.shape[2],b.shape[3]])}const KI=Vt({conv1d_:AA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA(s,e,t,n,r,a="NHWC",o){ze(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let i=s,u=e,c=!1;e.rank===3&&(c=!0,u=zt(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,s[0],s[1],s[2]]),ze(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),ze(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),ze(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const d=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];ze(d===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${t.shape[2]}.`),ze(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),ti("conv2dDerInput",r,o);const l={dy:u,filter:t},p={strides:n,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i},f=Mt.runKernel(pg,l,p);return c?zt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Zy=Vt({conv2DBackpropInput_:OA});function FA(s,e,t,n,r,a){const o=mt(s,"x","conv2dTranspose"),i=mt(e,"filter","conv2dTranspose");return Zy(t,o,i,n,r,"NHWC",a)}const XI=Vt({conv2dTranspose_:FA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DA(s,e,t,n,r="NDHWC",a=[1,1,1]){const o=mt(s,"x","conv3d"),i=mt(e,"filter","conv3d");let u=o,c=!1;o.rank===4&&(c=!0,u=zt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ze(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),ze(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),ze(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),ze(Co(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ze(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),ze(md(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),ze(md(t),()=>"Error in conv3D: Strides should be larger than 0.");const d={x:u,filter:i},h={strides:t,pad:n,dataFormat:r,dilations:a},l=Mt.runKernel(fg,d,h);return c?zt(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}const MA=Vt({conv3d_:DA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(s,e,t,n,r){ze(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let a=s,o=e,i=!1;e.rank===4&&(i=!0,o=zt(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,s[0],s[1],s[2],s[3]]);const u=a[4],c=o.shape[4];ze(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),ze(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),ze(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),ze(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),ze(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const d={dy:o,filter:t},h={pad:r,strides:n,inputShape:a},l=Mt.runKernel(fy,d,h);return i?zt(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}const YI=Vt({conv3DBackpropInput_:PA});function LA(s,e,t,n,r){const a=mt(s,"x","conv3dTranspose"),o=mt(e,"filter","conv3dTranspose");return YI(t,a,o,n,r)}const BA=Vt({conv3dTranspose_:LA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(s){const t={x:mt(s,"x","cos","float32")};return Mt.runKernel(Sp,t)}const Qy=Vt({cos_:zA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(s){const t={x:mt(s,"x","cosh","float32")};return Mt.runKernel($p,t)}const ZI=Vt({cosh_:WA});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VA(s,e=0,t=!1,n=!1){const a={x:mt(s,"x","cumprod")},o={axis:e,exclusive:t,reverse:n};return Mt.runKernel(my,a,o)}const N0=Vt({cumprod_:VA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(s,e=0,t=!1,n=!1){const a={x:mt(s,"x","cumsum")},o={axis:e,exclusive:t,reverse:n};return Mt.runKernel(mg,a,o)}const QI=Vt({cumsum_:UA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(s,e,t,n=!1){const r=mt(s,"x","denseBincount"),a=mt(e,"weights","denseBincount");ze(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),ze(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),ze(t>=0,()=>`size must be non-negative, but got ${t}.`),ze(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const o={x:r,weights:a},i={size:t,binaryOutput:n};return Mt.runKernel(by,o,i)}const ck=Vt({denseBincount_:jA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(s,e,t="NHWC"){const n=mt(s,"x","depthToSpace","float32"),r=t==="NHWC"?n.shape[1]:n.shape[2],a=t==="NHWC"?n.shape[2]:n.shape[3],o=t==="NHWC"?n.shape[3]:n.shape[1];ze(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),ze(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${n.shape}`),ze(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${n.shape}`),ze(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${n.shape}`);const i={x:n},u={blockSize:e,dataFormat:t};return Mt.runKernel(xy,i,u)}const HA=Vt({depthToSpace_:GA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qA(s,e,t,n,r="NHWC",a=[1,1],o){const i=mt(s,"x","depthwiseConv2d","float32"),u=mt(e,"filter","depthwiseConv2d","float32");let c=i,d=!1;i.rank===3&&(d=!0,c=zt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ze(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),ze(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=r==="NHWC"?c.shape[3]:c.shape[1];ze(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),ti("depthwiseConv2d",n,o);const l={x:c,filter:u},p={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o},f=Mt.runKernel(gg,l,p);return d?zt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Jy=Vt({depthwiseConv2d_:qA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(s,e,t,n,r=[1,1],a="NHWC"){const o=mt(s,"x","dilation2d"),i=mt(e,"filter","dilation2d");ze(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),ze(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),ze(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,c=!1;o.rank===3&&(u=zt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),ze(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const d={x:u,filter:i},h={strides:t,pad:n,dilations:r},l=Mt.runKernel(bg,d,h);return c?zt(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const XA=Vt({dilation2d_:KA});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oh(s,e){const t=s.length,n=[];for(let r=0;r<t;r++){const a=t-1-r,o=s[a]||1;(e[e.length-1-r]||1)>1&&o===1&&n.unshift(a)}return n}function Pa(s,e){const t=[];for(let n=0;n<e.length;n++){const r=s[s.length-n-1],a=e.length-n-1,o=e[a];(r==null||r===1&&o>1)&&t.unshift(a)}return t}function js(s,e){const t=Math.max(s.length,e.length),n=new Array(t);for(let r=0;r<t;r++){let a=s[s.length-r-1];a==null&&(a=1);let o=e[e.length-r-1];if(o==null&&(o=1),a===1)n[t-r-1]=o;else if(o===1)n[t-r-1]=a;else if(a!==o){const i=`Operands could not be broadcast together with shapes ${s} and ${e}.`;throw Error(i)}else n[t-r-1]=a}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(s,e){let t=mt(s,"a","equal","string_or_numeric"),n=mt(e,"b","equal","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(xg,r)}const yc=Vt({equal_:YA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZA(s,e,t){const n=mt(e,"a","where"),r=mt(t,"b","where"),a=mt(s,"condition","where","bool"),o=js(js(a.shape,n.shape),r.shape),i=ep(a,o),u=ep(n,o),c=ep(r,o),d={condition:i,t:u,e:c};return Mt.runKernel(Kg,d)}const Po=Vt({where_:ZA});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(s){const t={x:mt(s,"x","zerosLike")};return Mt.runKernel(nb,t)}const wr=Vt({zerosLike_:QA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(s,e){let t=mt(s,"a","div"),n=mt(e,"b","div");[t,n]=ya(t,n);const r=_s(t,n),a=wr(r),o=yc(n,a);return Po(o,a,r)}const eO=Vt({divNoNan_:JA});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tO(s,e){const t=mt(s,"t1","dot"),n=mt(e,"t2","dot");ze((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);const r=t.rank===1?t.size:t.shape[1],a=n.rank===1?n.size:n.shape[0];if(ze(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),t.rank===1&&n.rank===1){const o=zt(t,[1,-1]),i=zt(n,[-1,1]),u=Nr(o,i);return zt(u,[])}else if(t.rank===1&&n.rank===2){const o=zt(t,[1,-1]),i=zt(n,[n.shape[0],n.shape[1]]),u=Nr(o,i);return zt(u,[u.size])}else if(t.rank===2&&n.rank===1){const o=zt(n,[-1,1]),i=Nr(t,o);return zt(i,[i.size])}else{const o=zt(n,[n.shape[0],n.shape[1]]);return Nr(t,o)}}const nO=Vt({dot_:tO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(s){const t={x:mt(s,"x","elu","float32")};return Mt.runKernel(Np,t)}const cb=Vt({elu_:sO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rO(s){let e=mt(s,"x","erf");ze(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=as(e,"float32"));const t={x:e};return Mt.runKernel(Ep,t)}const aO=Vt({erf_:rO});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(s,e){for(let t=0;t<s.length;++t)if(s[s.length-t-1]!==e-1-t)return!1;return!0}function JI(s,e,t){const n=s.length+e.length,r=[];let a=0,o=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?r.push(s[a++]):r.push(e[o++]);return r}function Ja(s,e){const t=[],n=s.length;for(let a=0;a<n;a++)e.indexOf(a)===-1&&t.push(s[a]);const r=e.map(a=>s[a]);return[t,r]}function $a(s,e){const t=e.map(n=>1);return JI(s,t,e)}function ho(s,e,t){ze(ew(e,t),()=>`${s} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ha(s,e){if(ew(s,e))return null;const t=[];for(let n=0;n<e;++n)s.indexOf(n)===-1&&t.push(n);return s.forEach(n=>t.push(n)),t}function $l(s){return s.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function wa(s,e){const t=[];for(let n=e-s;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(s,e=null,t=!1){const r={x:mt(s,"x","max")},a={reductionIndices:e,keepDims:t};return Mt.runKernel(Eg,r,a)}const zu=Vt({max_:oO});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(s,e=null,t=!1){const r={x:mt(s,"x","min")},a={axis:e,keepDims:t};return Mt.runKernel(Fg,r,a)}const Om=Vt({min_:iO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(s,e){let t=mt(s,"base","pow"),n=mt(e,"exp","pow");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(Hp,r)}const ih=Vt({pow_:uO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rr(s,e){if((Vu(s)&&e!=="string"||Array.isArray(s))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Vu(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ab(s,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(s){const t={x:mt(s,"x","sqrt","float32")};return Mt.runKernel(rf,t)}const Lo=Vt({sqrt_:cO});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(s){const e=mt(s,"x","square"),t={};return Mt.runKernel("Square",{x:e},t)}const Qr=Vt({square_:lO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dO(s,e=null,t=!1){let n=mt(s,"x","sum");n.dtype==="bool"&&(n=as(n,"int32"));const r={x:n},a={axis:e,keepDims:t};return Mt.runKernel(Yg,r,a)}const Cs=Vt({sum_:dO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(s,e="euclidean",t=null,n=!1){s=mt(s,"x","norm");const r=eC(s,e,t);let a=r.shape;if(n){const o=nr(t,s.shape);a=$a(r.shape,o)}return zt(r,a)}function eC(s,e,t=null){if(s.rank===0)return Fo(s);if(s.rank!==1&&t===null)return eC(zt(s,[-1]),e,t);if(s.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Cs(Fo(s),t);if(e===1/0)return zu(Fo(s),t);if(e===-1/0)return Om(Fo(s),t);if(e==="euclidean"||e===2)return Lo(Cs(ih(Fo(s),Rr(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return zu(Cs(Fo(s),t[0]),t[1]-1);if(e===1/0)return zu(Cs(Fo(s),t[1]),t[0]);if(e===-1/0)return Om(Cs(Fo(s),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Lo(Cs(Qr(s),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const lb=Vt({norm_:hO});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(s,e=null,t=!1){return lb(s,"euclidean",e,t)}const fO=Vt({euclideanNorm_:pO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mO(s){const t={x:mt(s,"x","exp")};return Mt.runKernel(Rp,t)}const zc=Vt({exp_:mO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(s,e=0){const t=mt(s,"x","expandDims","string_or_numeric");ze(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},r={dim:e};return Mt.runKernel(yg,n,r)}const xi=Vt({expandDims_:gO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bO(s){const t={x:mt(s,"x","expm1")};return Mt.runKernel(Ap,t)}const xO=Vt({expm1_:bO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yO(s,e){const t=mt(s,"x","tile","string_or_numeric");ze(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},r={reps:e};return Mt.runKernel(lf,n,r)}const Lu=Vt({tile_:yO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(s,e,t,n="float32"){e==null&&(e=s);const r=tr([s,e],n),a=s<=e?s:e;for(let i=0;i<a;++i)r.set(1,i,i);const o=zt(r.toTensor(),[s,e]);if(t==null)return o;if(t.length===1)return Lu(xi(o,0),[t[0],1,1]);if(t.length===2)return Lu(xi(xi(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Lu(xi(xi(xi(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const tC=Vt({eye_:wO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vO(s){const t={x:mt(s,"x","floor","float32")};return Mt.runKernel(Op,t)}const db=Vt({floor_:vO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(s,e,t=0,n=0){const r=mt(s,"x","gather"),a=mt(e,"indices","gather","int32"),o={x:r,indices:a},i={axis:t,batchDims:n};return Mt.runKernel(vg,o,i)}const tw=Vt({gather_:kO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(s,e){let t=mt(s,"a","greater","string_or_numeric"),n=mt(e,"b","greater","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(kg,r)}const Yi=Vt({greater_:IO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(s,e){let t=mt(s,"a","greaterEqual","string_or_numeric"),n=mt(e,"b","greaterEqual","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Dp,r)}const Sd=Vt({greaterEqual_:CO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(s){const t={input:mt(s,"input","imag")};return Mt.runKernel(Sy,t)}const nw=Vt({imag_:_O});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SO(s){const t={x:mt(s,"x","isFinite")};return Mt.runKernel(Pp,t)}const $O=Vt({isFinite_:SO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TO(s){const t={x:mt(s,"x","isInf")};return Mt.runKernel(Lp,t)}const NO=Vt({isInf_:TO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(s){const t={x:mt(s,"x","isNaN")};return Mt.runKernel(Bp,t)}const RO=Vt({isNaN_:EO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(s,e=.2){const n={x:mt(s,"x","leakyRelu")},r={alpha:e};return Mt.runKernel(Ig,n,r)}const sw=Vt({leakyRelu_:AO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OO(s,e){let t=mt(s,"a","less","string_or_numeric"),n=mt(e,"b","less","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Cg,r)}const Fm=Vt({less_:OO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FO(s,e){let t=mt(s,"a","lessEqual","string_or_numeric"),n=mt(e,"b","lessEqual","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(_g,r)}const vh=Vt({lessEqual_:FO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(s,e=5,t=1,n=1,r=.5){const a=mt(s,"x","localResponseNormalization");ze(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),ze(th(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=zt(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},c={depthRadius:e,bias:t,alpha:n,beta:r},d=Mt.runKernel(Ng,u,c);return i?zt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const MO=Vt({localResponseNormalization_:DO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(s){const t={x:mt(s,"x","log","float32")};return Mt.runKernel(zp,t)}const wc=Vt({log_:PO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LO(s){const t={x:mt(s,"x","log1p")};return Mt.runKernel(Wp,t)}const nC=Vt({log1p_:LO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BO(s,e){ze(d0(s),()=>"The f passed in variableGrads(f) must be a function"),ze(e==null||Array.isArray(e)&&e.every(c=>c instanceof Rm),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in Mt.registeredVariables)e.push(Mt.registeredVariables[c])}const n=t?e.filter(c=>!c.trainable):null,r=e.length;e=e.filter(c=>c.trainable),ze(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:o,grads:i}=Mt.gradients(s,e,null,a);ze(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ze(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((c,d)=>{i[d]!=null&&(u[c.name]=i[d])}),n!=null&&n.forEach(c=>u[c.name]=null),{value:o,grads:u}}function uh(s){return Mt.customGrad(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zO(s){const t={x:mt(s,"x","neg")};return Mt.runKernel(Mg,t)}const xa=Vt({neg_:zO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WO(s){const t={x:mt(s,"x","softplus")};return Mt.runKernel(sf,t)}const pf=Vt({softplus_:WO});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VO(s){const e=mt(s,"x","logSigmoid");return uh(n=>({value:xa(pf(xa(n))),gradFunc:o=>Ft(o,wh(xa(n)))}))(e)}const UO=Vt({logSigmoid_:VO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jO(s,e){let t=mt(s,"a","sub"),n=mt(e,"b","sub");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(of,r)}const Ds=Vt({sub_:jO});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GO(s,e=-1){const t=mt(s,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return uh((r,a)=>{const i=zu(r,e,!0),u=Ds(r,i),c=Ds(as(u,"float32"),wc(Cs(zc(u),e,!0)));return a([c]),{value:c,gradFunc:(h,l)=>{const[p]=l,f=!0,x=zc(p);return Ds(h,Ft(Cs(h,e,f),x))}}})(t)}const sC=Vt({logSoftmax_:GO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HO(s,e=null,t=!1){const n=mt(s,"x","logSumExp"),r=nr(e,n.shape),a=zu(n,r,!0),o=Ds(n,a),i=zc(o),u=Cs(i,r),c=wc(u),d=Bn(zt(a,c.shape),c);if(t){const h=$a(d.shape,r);return zt(d,h)}return d}const qO=Vt({logSumExp_:HO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KO(s,e){const t=mt(s,"a","logicalAnd","bool"),n=mt(e,"b","logicalAnd","bool");js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Sg,r)}const Wc=Vt({logicalAnd_:KO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XO(s){const t={x:mt(s,"x","logicalNot","bool")};return Mt.runKernel($g,t)}const rw=Vt({logicalNot_:XO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YO(s,e){const t=mt(s,"a","logicalOr","bool"),n=mt(e,"b","logicalOr","bool");js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Tg,r)}const rC=Vt({logicalOr_:YO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZO(s,e){const t=mt(s,"a","logicalXor","bool"),n=mt(e,"b","logicalXor","bool");return js(t.shape,n.shape),Wc(rC(s,e),rw(Wc(s,e)))}const QO=Vt({logicalXor_:ZO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(s,e,t,n,r){const a=mt(s,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=zt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ze(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),ze(Co(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ti("maxPool",n,r);const c={x:i},d={filterSize:e,strides:t,pad:n,dimRoundingMode:r},h=Mt.runKernel(Rg,c,d);return u?zt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const aw=Vt({maxPool_:JO});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eF(s,e=[1,1,1],t,n,r,a="NDHWC"){const o=mt(s,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=zt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ze(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),ze(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ti("maxPool3d",n,r);const c={x:i},d={filterSize:e,strides:t,pad:n,dimRoundingMode:r,dataFormat:a},h=Mt.runKernel(Ag,c,d);return u?zt(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const tF=Vt({maxPool3d_:eF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nF(s,e){let t=mt(s,"a","maximum"),n=mt(e,"b","maximum");[t,n]=ya(t,n),t.dtype==="bool"&&(t=as(t,"int32"),n=as(n,"int32")),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Vp,r)}const Tl=Vt({maximum_:nF});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(s,e=null,t=!1){const r={x:mt(s,"x","mean")},a={axis:e,keepDims:t};return Mt.runKernel(Og,r,a)}const Sa=Vt({mean_:sF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(s,e="float32"){if(jc(s),e==="complex64"){const n=Ya(s,"float32"),r=Ya(s,"float32");return rh(n,r)}const t=Io(hn(s),e);return Mt.makeTensor(t,s,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(s,e="float32"){if(jc(s),e==="complex64"){const n=$d(s,"float32"),r=Ya(s,"float32");return rh(n,r)}const t=ny(hn(s),e);return Mt.makeTensor(t,s,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(s,e){let t=mt(s,"a","minimum"),n=mt(e,"b","minimum");[t,n]=ya(t,n),t.dtype==="bool"&&(t=as(t,"int32"),n=as(n,"int32")),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Up,r)}const rp=Vt({minimum_:rF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(s,e,t){ze(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=mt(s,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ze(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)ze(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ze(e[i][0]>=0&&e[i][0]<=n.shape[i]-r&&e[i][1]>=0&&e[i][1]<=n.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-r} or less than 0 for input of shape ${n.shape}`);const a={paddings:e,mode:t},o={x:n};return Mt.runKernel(Dg,o,a)}const oF=Vt({mirrorPad_:aF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iF(s,e){let t=mt(s,"a","mod"),n=mt(e,"b","mod");[t,n]=ya(t,n);const r={a:t,b:n};return Mt.runKernel(jp,r)}const uF=Vt({mod_:iF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cF(s,e=null,t=!1){s=mt(s,"x","moments");const n=nr(e,s.shape),r=Sa(s,n,t);let a=r.shape;t||(a=$a(r.shape,n));const o=Qr(Ds(as(s,"float32"),zt(r,a))),i=Sa(o,n,t);return{mean:r,variance:i}}const ow=Vt({moments_:cF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(s,e){let t=mt(s,"a","notEqual","string_or_numeric"),n=mt(e,"b","notEqual","string_or_numeric");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n};return Mt.runKernel(Pg,r)}const Dm=Vt({notEqual_:lF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dF(s,e,t=1,n=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:mt(s,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:t,offValue:n};return Mt.runKernel(Bg,o,i)}const aC=Vt({oneHot_:dF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(s){const t={x:mt(s,"x","onesLike")};return Mt.runKernel(Lg,t)}const Iu=Vt({onesLike_:hF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(s,e,t=0){const n=mt(s,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},a={x:n};return Mt.runKernel(Wg,a,r)}const iw=Vt({pad_:pF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(s,e,t){const n=mt(s,"x","spaceToBatchND");ze(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),ze(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),ze(n.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:n},a={blockShape:e,paddings:t};return Mt.runKernel(Zg,r,a)}const uw=Vt({spaceToBatchND_:fF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(s,e,t,n,r,a,o){r==null&&(r=[1,1]),a==null&&(a=1),n===0&&(n="valid");const i=mt(s,"x","maxPool");let u=i,c=!1;i.rank===3&&(c=!0,u=zt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ze(Co(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const d=Cu(u.shape,e,a,r,n),h=[d.dilationHeight,d.dilationWidth];let l;n==="same"?l=bF([d.filterHeight,d.filterWidth],h):l=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,x]=gF([d.inHeight,d.inWidth],h,l),b=p?n:"valid",m=p?u:uw(u,h,f),N=(t==="avg"?()=>Ky(m,e,a,b,o):()=>aw(m,e,a,b,o))(),E=p?N:Yy(N,h,x);return c?zt(E,[E.shape[1],E.shape[2],E.shape[3]]):E}function gF(s,e,t){const n=t.map(d=>d[0]),r=t.map(d=>d[1]),a=s.concat(n,r),o=e.map((d,h)=>(d-a[h]%d)%d),i=r.map((d,h)=>d+o[h]),u=e.map((d,h)=>[n[h],i[h]]),c=e.map((d,h)=>[0,o[h]]);return[u,c]}function bF(s,e){const n=s.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),r=n.map(o=>Math.floor(o/2)),a=n.map((o,i)=>o-r[i]);return n.map((o,i)=>[r[i],a[i]])}const xF=Vt({pool_:mF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yF(s,e){const t=mt(s,"x","prelu"),n=mt(e,"alpha","prelu"),r={x:t,alpha:n};return Mt.runKernel(Vg,r)}const cw=Vt({prelu_:yF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wF(s,e=null,t=!1){let n=mt(s,"x","prod");n.dtype==="bool"&&(n=as(n,"int32"));const r={x:n},a={axis:e,keepDims:t};return Mt.runKernel(Ug,r,a)}const vF=Vt({prod_:wF});var oC={exports:{}};(function(s){(function(e,t,n){function r(u){var c=this,d=i();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function a(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var d=new r(u),h=c&&c.state,l=d.next;return l.int32=function(){return d.next()*4294967296|0},l.double=function(){return l()+(l()*2097152|0)*11102230246251565e-32},l.quick=l,h&&(typeof h=="object"&&a(h,d),l.state=function(){return a(d,{})}),l}function i(){var u=4022871197,c=function(d){d=String(d);for(var h=0;h<d.length;h++){u+=d.charCodeAt(h);var l=.02519603282416938*u;u=l>>>0,l-=u,l*=u,u=l>>>0,l-=u,u+=l*4294967296}return(u>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.alea=o})(Id,s,!1)})(oC);var iC={exports:{}};(function(s){(function(e,t,n){function r(i){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},i===(i|0)?u.x=i:c+=i;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var c=new r(i),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var l=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(l+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor128=o})(Id,s,!1)})(iC);var uC={exports:{}};(function(s){(function(e,t,n){function r(i){var u=this,c="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:c+=i;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var c=new r(i),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var l=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(l+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorwow=o})(Id,s,!1)})(uC);var cC={exports:{}};(function(s){(function(e,t,n){function r(i){var u=this;u.next=function(){var d=u.x,h=u.i,l,p;return l=d[h],l^=l>>>7,p=l^l<<24,l=d[h+1&7],p^=l^l>>>10,l=d[h+3&7],p^=l^l>>>3,l=d[h+4&7],p^=l^l<<7,l=d[h+7&7],l=l^l<<13,p^=l^l<<9,d[h]=p,u.i=h+1&7,p};function c(d,h){var l,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,l=0;l<h.length;++l)p[l&7]=p[l&7]<<15^h.charCodeAt(l)+p[l+1&7]<<13;for(;p.length<8;)p.push(0);for(l=0;l<8&&p[l]===0;++l);for(l==8?p[7]=-1:p[l],d.x=p,d.i=0,l=256;l>0;--l)d.next()}c(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var c=new r(i),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var l=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(l+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,d&&(d.x&&a(d,c),h.state=function(){return a(c,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xorshift7=o})(Id,s,!1)})(cC);var lC={exports:{}};(function(s){(function(e,t,n){function r(i){var u=this;u.next=function(){var d=u.w,h=u.X,l=u.i,p,f;return u.w=d=d+1640531527|0,f=h[l+34&127],p=h[l=l+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[l]=f^p,u.i=l,f+(d^d>>>16)|0};function c(d,h){var l,p,f,x,b,m=[],I=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,I=Math.max(I,h.length)),f=0,x=-32;x<I;++x)h&&(p^=h.charCodeAt((x+32)%h.length)),x===0&&(b=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,x>=0&&(b=b+1640531527|0,l=m[x&127]^=p+b,f=l==0?f+1:0);for(f>=128&&(m[(h&&h.length||0)&127]=-1),f=127,x=4*128;x>0;--x)p=m[f+34&127],l=m[f=f+1&127],p^=p<<13,l^=l<<17,p^=p>>>15,l^=l>>>12,m[f]=p^l;d.w=b,d.X=m,d.i=f}c(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var c=new r(i),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var l=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(l+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,d&&(d.X&&a(d,c),h.state=function(){return a(c,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.xor4096=o})(Id,s,!1)})(lC);var dC={exports:{}};(function(s){(function(e,t,n){function r(i){var u=this,c="";u.next=function(){var h=u.b,l=u.c,p=u.d,f=u.a;return h=h<<25^h>>>7^l,l=l-p|0,p=p<<24^p>>>8^f,f=f-h|0,u.b=h=h<<20^h>>>12^l,u.c=l=l-p|0,u.d=p<<16^l>>>16^f,u.a=f-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):c+=i;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var c=new r(i),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var l=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(l+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}t&&t.exports?t.exports=o:n&&n.amd?n(function(){return o}):this.tychei=o})(Id,s,!1)})(dC);var hC={exports:{}};(function(s){(function(e,t,n){var r=256,a=6,o=52,i="random",u=n.pow(r,a),c=n.pow(2,o),d=c*2,h=r-1,l;function p(E,D,U){var L=[];D=D==!0?{entropy:!0}:D||{};var Y=m(b(D.entropy?[E,N(t)]:E==null?I():E,3),L),V=new f(L),P=function(){for(var oe=V.g(a),ne=u,ge=0;oe<c;)oe=(oe+ge)*r,ne*=r,ge=V.g(1);for(;oe>=d;)oe/=2,ne/=2,ge>>>=1;return(oe+ge)/ne};return P.int32=function(){return V.g(4)|0},P.quick=function(){return V.g(4)/4294967296},P.double=P,m(N(V.S),t),(D.pass||U||function(oe,ne,ge,ye){return ye&&(ye.S&&x(ye,V),oe.state=function(){return x(V,{})}),ge?(n[i]=oe,ne):oe})(P,Y,"global"in D?D.global:this==n,D.state)}function f(E){var D,U=E.length,L=this,Y=0,V=L.i=L.j=0,P=L.S=[];for(U||(E=[U++]);Y<r;)P[Y]=Y++;for(Y=0;Y<r;Y++)P[Y]=P[V=h&V+E[Y%U]+(D=P[Y])],P[V]=D;(L.g=function(oe){for(var ne,ge=0,ye=L.i,Ee=L.j,X=L.S;oe--;)ne=X[ye=h&ye+1],ge=ge*r+X[h&(X[ye]=X[Ee=h&Ee+ne])+(X[Ee]=ne)];return L.i=ye,L.j=Ee,ge})(r)}function x(E,D){return D.i=E.i,D.j=E.j,D.S=E.S.slice(),D}function b(E,D){var U=[],L=typeof E,Y;if(D&&L=="object")for(Y in E)try{U.push(b(E[Y],D-1))}catch{}return U.length?U:L=="string"?E:E+"\0"}function m(E,D){for(var U=E+"",L,Y=0;Y<U.length;)D[h&Y]=h&(L^=D[h&Y]*19)+U.charCodeAt(Y++);return N(D)}function I(){try{var E;return l&&(E=l.randomBytes)?E=E(r):(E=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(E)),N(E)}catch{var D=e.navigator,U=D&&D.plugins;return[+new Date,e,U,e.screen,N(t)]}}function N(E){return String.fromCharCode.apply(0,E)}if(m(n.random(),t),s.exports){s.exports=p;try{l=require("crypto")}catch{}}else n["seed"+i]=p})(typeof self!="undefined"?self:Id,[],Math)})(hC);var kF=oC.exports,IF=iC.exports,CF=uC.exports,_F=cC.exports,SF=lC.exports,$F=dC.exports,Td=hC.exports;Td.alea=kF;Td.xor128=IF;Td.xorwow=CF;Td.xorshift7=_F;Td.xor4096=SF;Td.tychei=$F;var lw=Td;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pC{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=lw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,o;do r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class TF{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=lw.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NF(s,e=0,t=1,n,r){if(jc(s),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const a=new pC(e,t,n,!1,r),o=tr(s,n);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const EF=Vt({randomNormal_:NF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RF(s,e=0,t=1,n="float32",r){jc(s);const a=tr(s,n),o=new TF(e,t,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ff=Vt({randomUniform_:RF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ap(s,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:s,stop:e,step:t,dtype:n};return Mt.runKernel(Oy,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AF(s){const t={input:mt(s,"input","real")};return Mt.runKernel(Fy,t)}const Mm=Vt({real_:AF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(s){const t={x:mt(s,"x","reciprocal")};return Mt.runKernel(qp,t)}const FF=Vt({reciprocal_:OF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(s){const t={x:mt(s,"x","relu")};return Mt.runKernel(Kp,t)}const Nd=Vt({relu_:DF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(s){const t={x:mt(s,"x","relu6")};return Mt.runKernel(Xp,t)}const fC=Vt({relu6_:MF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(s,e){const n={x:mt(s,"x","reverse")},r={dims:e};return Mt.runKernel(qg,n,r)}const bd=Vt({reverse_:PF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(s){const t={x:mt(s,"x","round")};return Mt.runKernel(Yp,t)}const mC=Vt({round_:LF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(s){const t={x:mt(s,"x","rsqrt","float32")};return Mt.runKernel(Zp,t)}const gC=Vt({rsqrt_:BF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(s){const t={x:mt(s,"x","selu")};return Mt.runKernel(Qp,t)}const bC=Vt({selu_:zF});function WF(s,e,t,n,r,a=[1,1],o="NHWC"){const i=mt(s,"x","separableConv2d"),u=mt(e,"depthwiseFilter","separableConv2d"),c=mt(t,"pointwiseFilter","separableConv2d");let d=i,h=!1;if(i.rank===3&&(h=!0,d=zt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ze(d.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`),ze(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),ze(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),ze(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),ze(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const l=u.shape[2],p=u.shape[3];ze(c.shape[2]===l*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${l*p}, but got ${c.shape[2]}.`);const f=Jy(d,u,n,r,o,a),b=gd(f,c,1,"valid",o);return h?zt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const xC=Vt({separableConv2d_:WF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(s){const t={x:mt(s,"x","sign")};return Mt.runKernel(tf,t)}const UF=Vt({sign_:VF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(s){const t={x:mt(s,"x","sin","float32")};return Mt.runKernel(Jp,t)}const yC=Vt({sin_:jF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(s){const t={x:mt(s,"x","sinh")};return Mt.runKernel(ef,t)}const wC=Vt({sinh_:GF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HF(s,e,t){const n=mt(s,"x","slice1d");return ze(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Hr(n,[e],[t])}const dw=Vt({slice1d_:HF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(s,e,t){const n=mt(s,"x","slice2d");return ze(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Hr(n,e,t)}const vC=Vt({slice2d_:qF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KF(s,e,t){const n=mt(s,"x","slice3d");return ze(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Hr(n,e,t)}const hw=Vt({slice3d_:KF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(s,e,t){const n=mt(s,"x","slice4d");return ze(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Hr(n,e,t)}const Pm=Vt({slice4d_:XF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(s,e=-1){const t=mt(s,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},r={dim:e};return Mt.runKernel(Jg,n,r)}const pw=Vt({softmax_:YF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(s){ze(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const e={input:s};return Mt.runKernel(ky,e)}const kC=Vt({fft_:ZF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QF(s){ze(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const e={input:s};return Mt.runKernel(_y,e)}const E0=Vt({ifft_:QF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(s){const e=s.shape[s.shape.length-1],t=s.size/e;let n;if(e<=2){const r=zt(s,[t,e]);n=E0(r)}else{const r=[t,2*(e-1)],a=zt(Mm(s),[t,e]),o=zt(nw(s),[t,e]),i=bd(Hr(a,[0,1],[t,e-2]),1),u=Ft(bd(Hr(o,[0,1],[t,e-2]),1),Rr(-1)),c=Qo([a,i],1),d=Qo([o,u],1),h=zt(rh(c,d),[r[0],r[1]]);n=E0(h)}if(n=Mm(n),s.rank===3&&s.shape[0]!==0){const r=n,a=s.shape[0];n=zt(n,[a,n.shape[0]/a,n.shape[1]]),r.dispose()}return n}const e3=Vt({irfft_:JF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(s,e,t=0){const r={x:mt(s,"x","split")},a={numOrSizeSplits:e,axis:t};return Mt.runKernel(Qg,r,a)}const Ki=Vt({split_:t3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3(s,e){ze(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let t=s.shape[s.shape.length-1];const n=s.size/t;let r;if(e!=null&&e<t){const f=s.shape.map(b=>0),x=s.shape.map(b=>b);x[s.shape.length-1]=e,r=Hr(s,f,x),t=e}else if(e!=null&&e>t){const f=s.shape.map(x=>x);f[s.shape.length-1]=e-t,r=Qo([s,Ya(f)],s.shape.length-1),t=e}else r=s;const a=wr(r),o=zt(rh(r,a),[n,t]),i=kC(o),u=Math.floor(t/2)+1,c=Mm(i),d=nw(i),h=Ki(c,[u,t-u],c.shape.length-1),l=Ki(d,[u,t-u],d.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,zt(rh(h[0],l[0]),p)}const s3=Vt({rfft_:n3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r3(s,e){let t=mt(s,"a","squaredDifference"),n=mt(e,"b","squaredDifference");[t,n]=ya(t,n),js(t.shape,n.shape);const r={a:t,b:n},a={};return Mt.runKernel(af,r,a)}const a3=Vt({squaredDifference_:r3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3(s,e){const t=mt(s,"x","squeeze","string_or_numeric");return zt(t,Cl(t.shape,e).newShape)}const mf=Vt({squeeze_:o3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(s,e=0){const t=MI(s,"tensors","stack","string_or_numeric");ze(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&ze(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,r={axis:e};return Mt.runKernel(zg,n,r)}const xl=Vt({stack_:i3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3(s,e=0){const n={x:mt(s,"x","step")},r={alpha:e};return Mt.runKernel(df,n,r)}const gf=Vt({step_:u3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(s,e,t,n,r=0,a=0,o=0,i=0,u=0){const d={x:mt(s,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:n,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return Mt.runKernel(By,d,h)}const l3=Vt({stridedSlice_:c3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(s){const t={x:mt(s,"x","tan","float32")};return Mt.runKernel(uf,t)}const h3=Vt({tan_:d3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hi(s,e){V2(s);const t=rb(s,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ab(s,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1(s,e,t){if(V2(s),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=rb(s,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ab(s,e,n,t)}function IC(s,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${s}, sliceDim: ${n}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(a+` update.rank < ${r}. `);if(s.length<n+(t.rank-r))throw new Error(a+` Output shape length < ${n+(t.rank-r)}`);if(t.rank!==r+s.length-n)throw new Error(a+` update.rank != ${r+s.length-n}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==s[o+n])throw new Error(a+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${s[o+r]})`)}function p3(s,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(s.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${s.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(s.size===0)throw new Error(`Updates specified for empty output. updates shape: ${s.shape}`)}IC(t,e,s)}function Ed(s,e,t){const n=e.shape.length,r=n>1?e.shape[n-1]:1,a=t.length;let o=1;for(let h=r;h<a;++h)o*=t[h];const i=r<1?1:r,u=hn(e.shape)/i,c=[...ws(t.slice(0,r)),1],d=hn(t);return{sliceRank:r,numUpdates:u,sliceSize:o,strides:c,outputSize:d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f3(s,e=1,t=!0){const n=mt(s,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:n},o={k:e,sorted:t},[i,u]=Mt.runKernel(zy,a,o);return{values:i,indices:u}}const m3=Vt({topk_:f3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3(s,e=0,t=1,n,r){if(jc(s),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new pC(e,t,n,!0,r),o=tr(s,n);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const CC=Vt({truncatedNormal_:g3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b3(s,e=0){const t=mt(s,"x","unique","string_or_numeric");ze(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},r={axis:e},[a,o]=Mt.runKernel(Vy,n,r);return{values:a,indices:o}}const x3=Vt({unique_:b3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3(s,e,t){const n=mt(s,"x","unsortedSegmentSum"),r=mt(e,"segmentIds","unsortedSegmentSum","int32");ze(th(t),()=>"numSegments must be of dtype int");const a={x:n,segmentIds:r},o={numSegments:t};return Mt.runKernel(tb,a,o)}const _C=Vt({unsortedSegmentSum_:y3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(s,e=0){const t=mt(s,"x","unstack","string_or_numeric");ze(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},r={axis:e};return Mt.runKernel(eb,n,r)}const xd=Vt({unstack_:w3});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(s,e=!0,t,n){return Mt.makeVariable(s,e,t,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SC(s,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const n=tr(s,"int32"),r=tr([t.length,s.length],"int32");for(let a=0;a<t.length;a++){const o=n.indexToLoc(t[a]),i=a*s.length;r.values.set(o,i)}return r.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(s,e,t){const n=mt(s,"x","transpose");if(e==null&&(e=n.shape.map((o,i)=>i).reverse()),ze(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(o=>{ze(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const r={x:n},a={perm:e};return n.dtype==="complex64"?Qt(()=>{let o=Mm(n),i=nw(n);return o=Mt.runKernel(Yd,{x:o},a),i=Mt.runKernel(Yd,{x:i},a),t&&(i=xa(i)),rh(o,i)}):Mt.runKernel(Yd,r,a)}const br=Vt({transpose_:k3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(s,e){if(e==null)return s.shape.slice();if(Er(s.shape,e))return e;if(s.shape.length===e.length){const t=[];for(let n=0;n<s.shape.length;n++)e[n]==null&&s.shape[n]!=null?t.push(s.shape[n]):t.push(e[n]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(s,e,t,n){const r=mt(s,"x","dropout");if(ze(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),ze(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return s instanceof _a?r.clone():r;const a=I3(r,t),o=1-e,i=_s(db(Bn(ff(a,0,1,"float32",n),o)),o);return Ft(r,i)}const _3=Vt({dropout_:C3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(s,e,t,n,r,a="NHWC",o){let i=s;s.rank===3&&(i=zt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u=e;u.rank===3&&(u=zt(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ze(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),ze(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),ze(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=a==="NHWC"?i.shape[3]:i.shape[1],d=a==="NHWC"?u.shape[3]:u.shape[1];ze(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),ze(d===t[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${t[3]}).`),ti("conv2dDerFilter",r,o);const h={x:i,dy:u},l={strides:n,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:t};return Mt.runKernel(hy,h,l)}const fw=Vt({conv2DBackpropFilter_:S3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(s,e,t){if(t==null||t==="linear")return s;if(t==="relu")return Ft(s,gf(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function gw(s,e){let t=e;const n=Pa(s.shape,e.shape);return n.length>0&&(t=Cs(t,n)),zt(t,s.shape)}function bw(s,e,t,n){if(e==="linear")return s;if(e==="relu")return Nd(s);if(e==="elu")return cb(s);if(e==="relu6")return fC(s);if(e==="prelu")return cw(s,t);if(e==="leakyrelu")return sw(s,n);if(e==="sigmoid")return wh(s);throw new Error(`Unknown fused activation ${e}.`)}const xw=(s,e)=>!(s>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3({x:s,filter:e,strides:t,pad:n,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}){if(u=u||"linear",xw(Mt.state.gradientDepth,u)===!1){ze(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let U=gd(s,e,t,n,r,a,o);return i!=null&&(U=Bn(U,i)),bw(U,u,c,d)}const h=mt(s,"x","conv2d","float32"),l=mt(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=zt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),ze(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),ze(l.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${l.rank}.`),ti("fused conv2d",n,o);const x=r==="NHWC"?p.shape[3]:p.shape[1];ze(l.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${l.shape[2]}.`),ze(Co(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const b=lo(p.shape,l.shape,t,a,n,o);let m;i!=null&&(m=mt(i,"bias","fused conv2d"),[m]=ya(m,h),r==="NHWC"?js(b.outShape,m.shape):(ze(m.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`),ze(m.shape.length===0||m.shape[0]===b.outChannels||m.shape[0]===1,()=>`Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let I;if(c!=null){const U=c.shape;if(ze(U.length<=1||U.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${U.length}.`),U.length===1)ze(U[0]===1||U[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${U}) is not compatible with the number of output channels (${b.outChannels}).`);else if(U.length===3)try{js(U,b.outShape)}catch{const Y=`Error in fused conv2d: PReLU activation weights (${U}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(Y)}I=mt(c,"prelu weights","fused conv2d")}const N=(U,L)=>{ze(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[Y,V,P,oe]=L,ne=mw(U,P,u);ze(fd(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const ge=Zy(V.shape,ne,Y,t,n),ye=fw(V,ne,Y.shape,t,n),Ee=[ge,ye];if(oe!=null){const X=gw(oe,ne);Ee.push(X)}return Ee},E={x:p,filter:l,bias:m,preluActivationWeights:I},D={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return i==null?uh((L,Y,V)=>{let P=Mt.runKernel(Tm,E,D);return V([Y,L,P]),f&&(P=zt(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:N}})(p,l):uh((L,Y,V,P)=>{let oe=Mt.runKernel(Tm,E,D);return P([Y,L,oe,V]),f&&(oe=zt(oe,[oe.shape[1],oe.shape[2],oe.shape[3]])),{value:oe,gradFunc:N}})(p,l,m)}const T3=Vt({fusedConv2d_:$3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(s,e,t,n,r,a=[1,1],o){let i=s;s.rank===3&&(i=zt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u=e;u.rank===3&&(u=zt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:i,dy:u},d={strides:n,pad:r,dimRoundingMode:o,dilations:a,filterShape:t};return Mt.runKernel(yy,c,d)}const E3=Vt({depthwiseConv2dNativeBackpropFilter_:N3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R3(s,e,t,n,r,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=zt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:i,filter:t},d={strides:n,pad:r,dimRoundingMode:o,dilations:a,inputShape:s},h=Mt.runKernel(wy,c,d);return u?zt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const A3=Vt({depthwiseConv2dNativeBackpropInput_:R3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3({a:s,b:e,transposeA:t=!1,transposeB:n=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(xw(Mt.state.gradientDepth,a)===!1){let oe=Nr(s,e,t,n);return r!=null&&(oe=Bn(oe,r)),bw(oe,a,o,i)}let u=mt(s,"a","fused matMul"),c=mt(e,"b","fused matMul");[u,c]=ya(u,c);const d=t?u.shape[u.rank-2]:u.shape[u.rank-1],h=n?c.shape[c.rank-1]:c.shape[c.rank-2],l=t?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?c.shape[c.rank-2]:c.shape[c.rank-1],f=u.shape.slice(0,-2),x=c.shape.slice(0,-2),b=hn(f),m=hn(x);ze(d===h,()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${t} and transposeB=${n} must match.`);const N=js(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([l,p]),E=t?zt(u,[b,d,l]):zt(u,[b,l,d]),D=n?zt(c,[m,p,h]):zt(c,[m,h,p]);let U;r!=null&&(U=mt(r,"bias","fused matMul"),[U]=ya(U,u),js(N,U.shape));let L;o!=null&&(L=mt(o,"prelu weights","fused matMul"));const Y=(oe,ne)=>{const[ge,ye,Ee,X]=ne,je=mw(zt(oe,Ee.shape),Ee,a);let Be,tt;if(!t&&!n?(Be=Nr(je,ye,!1,!0),tt=Nr(ge,je,!0,!1)):!t&&n?(Be=Nr(je,ye,!1,!1),tt=Nr(je,ge,!0,!1)):t&&!n?(Be=Nr(ye,je,!1,!0),tt=Nr(ge,je,!1,!1)):(Be=Nr(ye,je,!0,!0),tt=Nr(je,ge,!0,!0)),r!=null){const ct=gw(X,je);return[Be,tt,ct]}else return[Be,tt]},V={a:E,b:D,bias:U,preluActivationWeights:L},P={transposeA:t,transposeB:n,activation:a,leakyreluAlpha:i};return r==null?uh((ne,ge,ye)=>{const Ee=Mt.runKernel($m,V,P);return ye([ne,ge,Ee]),{value:zt(Ee,N),gradFunc:Y}})(E,D):uh((ne,ge,ye,Ee)=>{const X=Mt.runKernel($m,V,P);return Ee([ne,ge,X,ye]),{value:zt(X,N),gradFunc:Y}})(E,D,U)}const lk=Vt({fusedMatMul_:O3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F3(s,e,t,n,r="bilinear",a=0){const o=mt(s,"image","cropAndResize"),i=mt(e,"boxes","cropAndResize","float32"),u=mt(t,"boxInd","cropAndResize","int32"),c=i.shape[0];ze(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),ze(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),ze(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),ze(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),ze(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),ze(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const d={image:o,boxes:i,boxInd:u},h={method:r,extrapolationValue:a,cropSize:n};return Mt.runKernel(gy,d,h)}const D3=Vt({cropAndResize_:F3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3(s){const e=mt(s,"image","flipLeftRight","float32");ze(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Mt.runKernel(Cy,t,{})}const P3=Vt({flipLeftRight_:M3});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(s){const e=mt(s,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];ze(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),ze(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Lu(e,r)}const B3=Vt({grayscaleToRGB_:L3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3(s,e,t=0,n=.5){const r=mt(s,"image","rotateWithOffset","float32");ze(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},o={radians:e,fillValue:t,center:n};return Mt.runKernel(Uy,a,o)}const W3=Vt({rotateWithOffset_:z3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kh(s,e,t,n,r,a){n==null&&(n=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=s.shape[0];return t=Math.min(t,o),ze(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),ze(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),ze(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),ze(e.rank===1,()=>"scores must be a 1D tensor"),ze(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),ze(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:r,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY){const a=mt(s,"boxes","nonMaxSuppression","float32"),o=mt(e,"scores","nonMaxSuppression","float32"),i=kh(a,o,t,n,r);t=i.maxOutputSize,n=i.iouThreshold,r=i.scoreThreshold;const u={maxOutputSize:t,iouThreshold:n,scoreThreshold:r};return Mt.runKernel(Ey,{boxes:a,scores:o},u)}const U3=Vt({nonMaxSuppression_:V3});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(s,e,t){const n=G3(s,e,t),r=n<0?-(n+1):n;s.splice(r,0,e)}function G3(s,e,t){return q3(s,e,t||H3)}function H3(s,e){return s>e?1:s<e?-1:0}function q3(s,e,t){let n=0,r=s.length,a=0,o=!1;for(;n<r;){a=n+(r-n>>>1);const i=t(e,s[a]);i>0?n=a+1:(r=a,o=!i)}return o?n:-n-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(s,e,t,n,r){return kw(s,e,t,n,r,0)}function ww(s,e,t,n,r,a){return kw(s,e,t,n,r,0,!1,a,!0)}function vw(s,e,t,n,r,a){return kw(s,e,t,n,r,a,!0)}function kw(s,e,t,n,r,a,o=!1,i=!1,u=!1){const c=[];for(let b=0;b<e.length;b++)e[b]>r&&c.push({score:e[b],boxIndex:b,suppressBeginIndex:0});c.sort(dk);const d=a>0?-.5/a:0,h=[],l=[];for(;h.length<t&&c.length>0;){const b=c.pop(),{score:m,boxIndex:I,suppressBeginIndex:N}=b;if(m<r)break;let E=!1;for(let D=h.length-1;D>=N;--D){const U=K3(s,I,h[D]);if(U>=n){E=!0;break}if(b.score=b.score*X3(n,d,U),b.score<=r)break}b.suppressBeginIndex=h.length,E||(b.score===m?(h.push(I),l.push(b.score)):b.score>r&&j3(c,b,dk))}const p=h.length,f=t-p;i&&f>0&&(h.push(...new Array(f).fill(0)),l.push(...new Array(f).fill(0)));const x={selectedIndices:h};return o&&(x.selectedScores=l),u&&(x.validOutputs=p),x}function K3(s,e,t){const n=s.subarray(e*4,e*4+4),r=s.subarray(t*4,t*4+4),a=Math.min(n[0],n[2]),o=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),c=Math.min(r[0],r[2]),d=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),p=(i-a)*(u-o),f=(h-c)*(l-d);if(p<=0||f<=0)return 0;const x=Math.max(a,c),b=Math.max(o,d),m=Math.min(i,h),I=Math.min(u,l),N=Math.max(m-x,0)*Math.max(I-b,0);return N/(p+f-N)}function X3(s,e,t){const n=Math.exp(e*t*t);return t<=s?n:0}function dk(s,e){return s.score-e.score||s.score===e.score&&e.boxIndex-s.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Y3(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY){const a=mt(s,"boxes","nonMaxSuppressionAsync"),o=mt(e,"scores","nonMaxSuppressionAsync"),i=kh(a,o,t,n,r);t=i.maxOutputSize,n=i.iouThreshold,r=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h}=yw(c,d,t,n,r);return a!==s&&a.dispose(),o!==e&&o.dispose(),Hi(h,"int32")}const Z3=Y3;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=mt(s,"boxes","nonMaxSuppression"),i=mt(e,"scores","nonMaxSuppression"),u=kh(o,i,t,n,r,a);t=u.maxOutputSize,n=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c={boxes:o,scores:i},d={maxOutputSize:t,iouThreshold:n,scoreThreshold:r,softNmsSigma:a},h=Mt.runKernel(Ay,c,d);return{selectedIndices:h[0],selectedScores:h[1]}}const J3=Vt({nonMaxSuppressionWithScore_:Q3});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function eD(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=mt(s,"boxes","nonMaxSuppressionAsync"),i=mt(e,"scores","nonMaxSuppressionAsync"),u=kh(o,i,t,n,r,a);t=u.maxOutputSize,n=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),d=c[0],h=c[1],{selectedIndices:l,selectedScores:p}=vw(d,h,t,n,r,a);return o!==s&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Hi(l,"int32"),selectedScores:Hi(p)}}const tD=eD;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nD(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=mt(s,"boxes","nonMaxSuppression"),i=mt(e,"scores","nonMaxSuppression"),u=kh(o,i,t,n,r,null),c=u.maxOutputSize,d=u.iouThreshold,h=u.scoreThreshold,l={boxes:o,scores:i},p={maxOutputSize:c,iouThreshold:d,scoreThreshold:h,padToMaxOutputSize:a},f=Mt.runKernel(Ry,l,p);return{selectedIndices:f[0],validOutputs:f[1]}}const sD=Vt({nonMaxSuppressionPadded_:nD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rD(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=mt(s,"boxes","nonMaxSuppressionAsync"),i=mt(e,"scores","nonMaxSuppressionAsync"),u=kh(o,i,t,n,r,null),c=u.maxOutputSize,d=u.iouThreshold,h=u.scoreThreshold,[l,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:x}=ww(l,p,c,d,h,a);return o!==s&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Hi(f,"int32"),validOutputs:Rr(x,"int32")}}const aD=rD;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oD(s,e,t=!1,n=!1){const r=mt(s,"images","resizeBilinear");ze(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),ze(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),ze(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=zt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:n,size:e},c=Mt.runKernel(Hg,i,u);return o?zt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const $C=Vt({resizeBilinear_:oD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(s,e,t=!1,n=!1){const r=mt(s,"images","resizeNearestNeighbor");ze(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),ze(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),ze(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ze(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=zt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:n,size:e},c=Mt.runKernel(Gg,i,u);return o?zt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const TC=Vt({resizeNearestNeighbor_:iD});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(s,e="binary",t=!1,n=.5){const r=mt(s,"image","threshold"),a=.2989,o=.587,i=.114,u=r.shape[0]*r.shape[1];let c=Ft(Hi([n]),255),d,h,l,p;if(ze(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),ze(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),ze(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),ze(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[d,h,l]=Ki(r,[1,1,1],-1);const b=Ft(d,a),m=Ft(h,o),I=Ft(l,i);p=Bn(Bn(b,m),I)}else p=s;if(e==="otsu"){const b=xA(as(mC(p),"int32"),Am([]),256);c=cD(b,u)}const f=t?vh(p,c):Yi(p,c);return as(Ft(f,255),"int32")}function cD(s,e){let t=Hi([-1]),n=Hi([0]),r=Hi([0]),a,o,i,u,c,d;for(let h=0;h<s.size-1;h++){a=Hr(s,0,h+1),o=Hr(s,h+1),c=_s(Cs(a),e),d=_s(Cs(o),e);const l=Cs(Ft(a,ap(0,a.size)));i=_s(l,Cs(a));const p=ub(o.shape,a.size),f=Bn(ap(0,o.size),p),x=Ft(o,f);u=_s(Cs(x),Cs(o));const b=Ds(i,u),m=Ds(i,u),I=Ft(c,d);r=Ft(Ft(I,b),m);const N=Yi(r,n);n=Po(N,r,n),t=Po(N,Hi([h]),t)}return t}const lD=Vt({threshold_:uD});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(s,e,t="nearest",n="constant",r=0,a){const o=mt(s,"image","transform","float32"),i=mt(e,"transforms","transform","float32");ze(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),ze(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ze(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},c={interpolation:t,fillMode:n,fillValue:r,outputShape:a};return Mt.runKernel(Wy,u,c)}const hD=Vt({transform_:dD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(s,e,t){const n=mt(s,"a","bandPart");ze(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const r=n.shape,[a,o]=n.shape.slice(-2);let i,u;typeof e=="number"?(ze(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ze(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),i=mt(e<0?a:e,"numLower","bandPart")):(ze(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=Po(Fm(e,0),a,rp(e,a))),typeof t=="number"?(ze(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),ze(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),u=mt(t<0?o:t,"numUpper","bandPart")):(ze(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Po(Fm(t,0),o,rp(t,o)));const c=zt(ap(0,a,1,"int32"),[-1,1]),d=ap(0,o,1,"int32"),h=Ds(c,d),l=Wc(vh(h,i),Sd(h,xa(u))),p=Ya([a,o],n.dtype);return zt(xl(xd(zt(n,[-1,a,o])).map(f=>Po(l,f,p))),r)}const fD=Vt({bandPart_:pD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mD(s){let e;if(Array.isArray(s)){e=!1,ze(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=s[0].shape[0];for(let a=1;a<s.length;++a)ze(s[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[a].shape[0]} vs. ${r})`)}else e=!0,s=Ki(s,s.shape[0],0).map(r=>mf(r,[0]));ze(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const t=[],n=s;for(let r=0;r<s.length;++r)t.push(Mt.tidy(()=>{let a=n[r];if(r>0)for(let o=0;o<r;++o){const i=Ft(Cs(Ft(t[o],a)),t[o]);a=Ds(a,i)}return _s(a,lb(a,"euclidean"))}));return e?xl(t,0):t}const gD=Vt({gramSchmidt_:mD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(s,e=!1){if(ze(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return hk(s,e);{const t=s.shape.slice(0,s.shape.length-2).reduce((u,c)=>u*c),n=xd(zt(s,[t,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),r=[],a=[];n.forEach(u=>{const[c,d]=hk(u,e);r.push(c),a.push(d)});const o=zt(xl(r,0),s.shape),i=zt(xl(a,0),s.shape);return[o,i]}}function hk(s,e=!1){return Mt.tidy(()=>{ze(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const t=s.shape[0],n=s.shape[1];let r=tC(t),a=id(s);const o=j1([[1]],[1,1]);let i=id(o);const u=t>=n?n:t;for(let c=0;c<u;++c){const d=a,h=i,l=r;[i,a,r]=Mt.tidy(()=>{const p=Hr(a,[c,c],[t-c,1]),f=lb(p),x=Hr(a,[c,c],[1,1]),b=Po(Yi(x,0),j1([[-1]]),j1([[1]])),m=Ds(x,Ft(b,f)),I=_s(p,m);I.shape[0]===1?i=id(o):i=Qo([o,Hr(I,[1,0],[I.shape[0]-1,I.shape[1]])],0);const N=xa(_s(Nr(b,m),f)),E=Hr(a,[c,0],[t-c,n]),D=Ft(N,i),U=br(i);if(c===0)a=Ds(E,Nr(D,Nr(U,E)));else{const V=Ds(E,Nr(D,Nr(U,E)));a=Qo([Hr(a,[0,0],[c,n]),V],0)}const L=br(D),Y=Hr(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=Ds(Y,Nr(Nr(Y,i),L));else{const V=Ds(Y,Nr(Nr(Y,i),L));r=Qo([Hr(r,[0,0],[t,c]),V],1)}return[i,a,r]}),ir([d,h,l])}return!e&&t>n&&(r=Hr(r,[0,0],[t,n]),a=Hr(a,[0,0],[n,n])),[r,a]})}const xD=Vt({qr_:bD});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pk;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(pk||(pk={}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pc={flipLeftRight:P3,grayscaleToRGB:B3,resizeNearestNeighbor:TC,resizeBilinear:$C,rotateWithOffset:W3,cropAndResize:D3,nonMaxSuppression:U3,nonMaxSuppressionAsync:Z3,nonMaxSuppressionWithScore:J3,nonMaxSuppressionWithScoreAsync:tD,nonMaxSuppressionPadded:sD,nonMaxSuppressionPaddedAsync:aD,threshold:lD,transform:hD},yD={bandPart:fD,gramSchmidt:gD,qr:xD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ih{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class gu{constructor(){this.classNameMap={}}static getMap(){return gu.instance==null&&(gu.instance=new gu),gu.instance}static register(e){gu.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function An(s){ze(s.className!=null,()=>"Class being registered does not have the static className property defined."),ze(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),ze(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),gu.register(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nl extends Ih{minimize(e,t=!1,n){const{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){const o=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return ir(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return BO(e,t)}dispose(){this.iterations_!=null&&ir(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Rr(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Nl,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NC extends Nl{static get className(){return"Adadelta"}constructor(e,t,n=null){super();this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=Mt.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const a=Mt.registeredVariables[n],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accum_grad`,variable:Qt(()=>wr(a).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${n}/accum_var`,variable:Qt(()=>wr(a).variable(o))});const i=Array.isArray(e)?e[r].tensor:e[n];if(i==null)return;const u=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;Qt(()=>{const d=Bn(Ft(u,this.rho),Ft(Qr(i),1-this.rho)),h=Ft(_s(Lo(Bn(c,this.epsilon)),Lo(Bn(u,this.epsilon))),i),l=Bn(Ft(c,this.rho),Ft(Qr(h),1-this.rho));u.assign(d),c.assign(l);const p=Bn(Ft(h,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ir(this.accumulatedGrads.map(e=>e.variable)),ir(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EC extends Nl{static get className(){return"Adagrad"}constructor(e,t=.1){super();this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const a=Mt.registeredVariables[n];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${n}/accumulator`,variable:Qt(()=>ub(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[n];if(o==null)return;const i=this.accumulatedGrads[r].variable;Qt(()=>{const u=Bn(i,Qr(o));i.assign(u);const c=Bn(Ft(_s(o,Lo(Bn(u,Mt.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ir(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RC extends Nl{static get className(){return"Adam"}constructor(e,t,n,r=null){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Qt(()=>{this.accBeta1=Rr(t).variable(),this.accBeta2=Rr(n).variable()}),r==null&&(this.epsilon=Mt.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);Qt(()=>{const n=Ds(1,this.accBeta1),r=Ds(1,this.accBeta2);t.forEach((a,o)=>{const i=Mt.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Qt(()=>wr(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:Qt(()=>wr(i).variable(u))});const c=Array.isArray(e)?e[o].tensor:e[a];if(c==null)return;const d=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,l=Bn(Ft(d,this.beta1),Ft(c,1-this.beta1)),p=Bn(Ft(h,this.beta2),Ft(Qr(c),1-this.beta2)),f=_s(l,n),x=_s(p,r);d.assign(l),h.assign(p);const b=Bn(Ft(_s(f,Bn(Lo(x),this.epsilon)),-this.learningRate),i);i.assign(b)}),this.accBeta1.assign(Ft(this.accBeta1,this.beta1)),this.accBeta2.assign(Ft(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ir(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ir(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Qt(()=>{this.accBeta1.assign(ih(this.beta1,this.iterations_+1)),this.accBeta2.assign(ih(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AC extends Nl{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super();this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Qt(()=>{this.iteration=Rr(0).variable(),this.accBeta1=Rr(t).variable()}),r==null&&(this.epsilon=Mt.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);Qt(()=>{const n=Ds(1,this.accBeta1),r=_s(-this.learningRate,Bn(Ft(this.iteration,this.decay),1));t.forEach((a,o)=>{const i=Mt.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:wr(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:wr(i).variable(u)});const c=Array.isArray(e)?e[o].tensor:e[a];if(c==null)return;const d=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,l=Bn(Ft(d,this.beta1),Ft(c,1-this.beta1)),p=Ft(h,this.beta2),f=Fo(c),x=Tl(p,f);d.assign(l),h.assign(x);const b=Bn(Ft(_s(r,n),_s(l,Bn(x,this.epsilon))),i);i.assign(b)}),this.iteration.assign(Bn(this.iteration,1)),this.accBeta1.assign(Ft(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ir(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ir(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iw extends Nl{static get className(){return"SGD"}constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const a=Array.isArray(e)?e[r].tensor:e[n];if(a==null)return;const o=Mt.registeredVariables[n];Qt(()=>{const i=Bn(Ft(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=mc(Rr(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OC extends Iw{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e);this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Rr(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const a=Mt.registeredVariables[n];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${n}/momentum`,variable:Qt(()=>wr(a).variable(!1))});const o=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[n];i!=null&&Qt(()=>{let u;const c=Bn(Ft(this.m,o),i);this.useNesterov?u=Bn(Ft(this.c,Bn(i,Ft(c,this.m))),a):u=Bn(Ft(this.c,c),a),o.assign(c),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ir(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FC extends Nl{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){super();if(this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=Mt.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,r)=>{const a=Mt.registeredVariables[n],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${n}/rms`,variable:Qt(()=>wr(a).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${n}/momentum`,variable:Qt(()=>wr(a).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${n}/mg`,variable:Qt(()=>wr(a).variable(o))});const i=Array.isArray(e)?e[r].tensor:e[n];if(i==null)return;const u=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;Qt(()=>{const d=Bn(Ft(u,this.decay),Ft(Qr(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,l=Bn(Ft(h,this.decay),Ft(i,1-this.decay)),p=_s(Ft(i,this.learningRate),Lo(Ds(d,Bn(Qr(l),this.epsilon)))),f=Bn(Ft(c,this.momentum),p);u.assign(d),h.assign(l),c.assign(f);const x=Ds(a,f);a.assign(x)}else{const h=Bn(Ft(u,this.decay),Ft(Qr(i),1-this.decay)),l=Bn(Ft(c,this.momentum),_s(Ft(i,this.learningRate),Lo(Bn(h,this.epsilon))));u.assign(h),c.assign(l);const p=Ds(a,l);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ir(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ir(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ir(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wD=[NC,EC,RC,AC,OC,FC,Iw];function vD(){for(const s of wD)An(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kD="model",ID=".json",CD=".weights.bin";function fk(s){return new Promise(e=>setTimeout(e)).then(s)}class yd{constructor(e){if(!nn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(yd.URL_SCHEME)&&(e=e.slice(yd.URL_SCHEME.length)),(e==null||e.length===0)&&(e=kD),this.modelJsonFileName=e+ID,this.weightDataFileName=e+CD}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=LI(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await fk(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await fk(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ob(e)}}}}yd.URL_SCHEME="downloads://";const _D=s=>nn().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(yd.URL_SCHEME)?SD(s.slice(yd.URL_SCHEME.length)):null;Ka.registerSaveRouter(_D);function SD(s="model"){return new yd(s)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mk(s,e,t,n){o(s),t=t==null?0:t,n=n==null?1:n,i(t,n);let r=0;const a=u=>(u.then(c=>{const d=t+ ++r/s.length*(n-t);return e(d),c}),u);function o(u){ze(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){ze(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),ze(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),ze(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(s.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $D(s,e){e==null&&(e={});const t=e.fetchFunc==null?nn().platform.fetch:e.fetchFunc,n=s.map(h=>t(h,e.requestInit,{isBinary:!0})),r=0,a=.5,i=(e.onProgress==null?await Promise.all(n):await mk(n,e.onProgress,r,a)).map(h=>h.arrayBuffer()),u=.5,c=1;return e.onProgress==null?await Promise.all(i):await mk(i,e.onProgress,u,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TD="application/octet-stream",ND="application/json";class Cw{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ze(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=nn().platform.fetch,ze(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&ze(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=LI(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:ND}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:TD}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:ob(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return sR(t,a=>this.loadWeights(a))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=ED(t),a=this.weightPathPrefix||n,o=rR(e),i=[],u=[];for(const d of e)for(const h of d.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):i.push(a+h+r);this.weightUrlConverter&&i.push(...await Promise.all(u));const c=await $D(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,PI(c)]}}Cw.URL_SCHEME_REGEX=/^https?:\/\//;function ED(s){const e=s.lastIndexOf("/"),t=s.lastIndexOf("?"),n=s.substring(0,e),r=t>e?s.substring(t):"";return[n+"/",r]}function gk(s){return s.match(Cw.URL_SCHEME_REGEX)!=null}const DC=(s,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(s)?t=s.every(n=>gk(n)):t=gk(s),t)return RD(s,e)}return null};Ka.registerSaveRouter(DC);Ka.registerLoadRouter(DC);function RD(s,e){return new Cw(s,e)}function _w(s,e){const t=s.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(hn(s.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${s.shape}.`);const r=e.shape,a=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const i=s.shape,u=r.slice();u.pop();let c=1;for(let h=a;h<t;++h)c*=i[h],u.push(i[h]);const d=[...ws(s.shape).map(h=>h/c),1].slice(0,a);return[u,o,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0=-2,AD=-1;function Sw(s,e,t){const n=s.shape.length;ze(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),ze(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let r=0;r<n;++r)ze(e[r]+t[r]<=s.shape[r],()=>`Error in slice${n}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${s.shape[r]})`)}function OD(s){const e=[];let t=0;for(;s>0;)s&1&&e.push(t),s/=2,t++;return e}function $w(s,e,t){const n=[];for(let r=0;r<s.length;r++)n[r]=Math.ceil((e[r]-s[r])/t[r]);return n}function MC(s,e,t,n){const r=[...s];for(let a=r.length;a<n.length;a++)r.push(1);for(let a=0;a<t;a++)a===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function PC(s,e,t){return t<=s?t:t-(e-1)}function LC(s,e){const t=[];for(let n=0;n<s;n++)t.push(e+n);return t}function FD(s,e,t,n,r,a,o,i,u){const c=s.length;let d=new Array(c),h=new Array(c),l=new Array(c);if(e.length&&t>0){const p=e[0],f=t+1;d=BC(o,p,f,n,s),h=zC(i,p,f,r,s),l=MC(a,p,f,s)}else for(let p=0;p<c;p++)d[p]=VC(o,n,a,s,p,u),h[p]=UC(i,r,a,s,p,u),l[p]=WC(a,p,u);return{begin:d,end:h,strides:l}}function BC(s,e,t,n,r){const a=[...r],o=LC(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=PC(e,t,i);let c=n[u];s&1<<u&&(c=0),a[i]=c}return a}function zC(s,e,t,n,r){const a=[...r],o=LC(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=PC(e,t,i);let c=n[u];s&1<<u&&(c=Number.MAX_SAFE_INTEGER),a[i]=c}for(let i=0;i<a.length;i++){const u=r[i];a[i]<0&&(a[i]+=u),a[i]=ld(0,a[i],r[i])}return a}function WC(s,e,t){let n=s[e];return(t&1<<e||n==null)&&(n=1),n}function VC(s,e,t,n,r,a){let o=e[r];const i=t[r]||1;(s&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=n[r];return o<0&&(o+=u),o=ld(0,o,u-1),o}function UC(s,e,t,n,r,a){let o=e[r];const i=t[r]||1;(s&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=n[r];return o<0&&(o+=u),i>0?o=ld(0,o,u):o=ld(-1,o,u-1),o}function Tw(s,e,t){let n=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){n=r;break}for(let r=n+1;r<t.length;r++)if(e[r]>0||t[r]!==s[r])return!1;return!0}function Nw(s,e){let t=s.length>0?s[s.length-1]:1;for(let n=0;n<s.length-1;n++)t+=s[n]*e[n];return t}function hb(s,e,t){let n;const r=s.shape.length;typeof e=="number"?n=[e,...new Array(r-1).fill(0)]:e.length<r?n=e.concat(new Array(r-e.length).fill(0)):n=e.slice(),n.forEach(o=>{ze(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(r).fill(-1):typeof t=="number"?a=[t,...new Array(r-1).fill(-1)]:t.length<r?a=t.concat(new Array(r-t.length).fill(-1)):a=t,a=a.map((o,i)=>o>=0?o:(ze(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),s.shape[i]-n[i])),[n,a]}function Ew(s,e,t,n,r,a,o,i,u){let c;if(n==null?(c=new Array(e.length),c.fill(1)):c=n,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let N=0;N<h.dims;N++)d&&(1<<N&i)!==0&&h.numAddAxisAfterEllipsis++,1<<N&o&&(d=!0);d||(h.ellipsisMask|=1<<h.dims,h.dims++);const l={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};DD(h,l);let p=!0,f=!0,x=!0;const b=[],m=[];for(let N=0;N<s.length;++N){if(l.strides[N]===0)throw Error(`strides[${N}] must be non-zero`);const E=!!(l.shrinkAxisMask&1<<N),D=s[N];if(D===-1){b.push(E?1:-1);continue}const U=[l.beginMask&1<<N,l.endMask&1<<N],L=[l.strides[N]>0?0:-1,l.strides[N]>0?D:D-1];if(E&&l.strides[N]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&l.strides[N]===1;const Y=!!(l.beginMask&1<<N&&l.endMask&1<<N);if(l.beginValid&&l.endValid){if(E){const ne=l.begin[N]<0?D+l.begin[N]:l.begin[N];if(l.begin[N]=ne,l.end[N]=l.begin[N]+1,ne<0||ne>=D)throw Error(`slice index ${l.begin[N]} of dimension ${N} out of bounds.`)}else l.begin[N]=bk(l.begin[N],0,l.strides[N],D,U,L),l.end[N]=bk(l.end[N],1,l.strides[N],D,U,L);const oe=l.strides[N]===1&&l.begin[N]===0&&l.end[N]===D;p=p&&oe,f=f&&(N===0&&l.strides[N]===1||oe)}else p=p&&l.strides[N]===1&&Y,f=f&&(N===0&&l.strides[N]===1||Y);let V,P=!1;if(l.beginValid&&l.endValid?(V=l.end[N]-l.begin[N],P=!0):E?(V=1,P=!0):Y&&D>=0&&(l.strides[N]<0?V=-D:V=D,P=!0),P){let oe;V===0||V<0!=l.strides[N]<0?oe=0:oe=Math.trunc(V/l.strides[N])+(V%l.strides[N]!==0?1:0),b.push(oe)}else b.push(-1)}for(let N=0;N<l.finalShapeGatherIndices.length;++N){const E=l.finalShapeGatherIndices[N];E>=0?m.push(b[E]):E===R0&&m.push(1)}return{finalShapeSparse:m.filter((N,E)=>l.finalShapeGatherIndices[E]!==R0),finalShape:m,isIdentity:p,sliceDim0:f,isSimpleSlice:x,begin:l.begin,end:l.end,strides:l.strides}}function DD(s,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=s.begin!=null,e.endValid=s.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<s.dims;n++)if(1<<n&s.ellipsisMask){const r=Math.min(e.dims-(s.dims-n)+1+s.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&s.newAxisMask)e.finalShapeGatherIndices.push(R0),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);s.begin!=null&&(e.begin[t]=s.begin[n]),s.end!=null&&(e.end[t]=s.end[n]),e.strides[t]=s.strides[n],s.beginMask&1<<n&&(e.beginMask|=1<<t),s.endMask&1<<n&&(e.endMask|=1<<t),s.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(AD),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function bk(s,e,t,n,r,a){if(r[e])return t>0?a[e]:a[e+1&1];{const o=s<0?n+s:s;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var MD=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Sw,maskToAxes:OD,computeOutShape:$w,stridesWithElidedDims:MC,getNormalizedAxes:FD,startIndicesWithElidedDims:BC,stopIndicesWithElidedDims:zC,stridesForAxis:WC,startForAxis:VC,stopForAxis:UC,isSliceContinous:Tw,computeFlatOffset:Nw,parseSliceParams:hb,sliceInfo:Ew},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PD{static sgd(e){return new Iw(e)}static momentum(e,t,n=!1){return new OC(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new FC(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new RC(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new NC(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new AC(e,t,n,r,a)}static adagrad(e,t=.1){return new EC(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vd=PD;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LD=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:s=>s())();function jC(){return new Promise(s=>LD(()=>s()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(s,e){const t=s[0].length;s.forEach((r,a)=>{ze(r.length===t,()=>`Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`)}),ze(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const n=s[0];s.forEach((r,a)=>{for(let o=0;o<t;o++)ze(o===e||r[o]===n[o],()=>`Error in concat${t}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${n}) along the non-concatenated axis ${a}.`)})}function gc(s,e){const t=s[0].slice();for(let n=1;n<s.length;n++)t[e]+=s[n][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Pu;(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(Pu||(Pu={}));function GC(s,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<s+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(s+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${s+t.length}, but shape.rank = ${n.length}`);for(let r=1;r<t.length;++r){const a=t[r],o=n[n.length-t.length+r],i=n[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+s}] = ${a} but shape[${r+s}] = ${i}`)}else n[o]=a}return n}function HC(s){const e={FIRST_DIM_SIZE:Pu.FIRST_DIM_SIZE,VALUE_ROWIDS:Pu.VALUE_ROWIDS,ROW_LENGTHS:Pu.ROW_LENGTHS,ROW_SPLITS:Pu.ROW_SPLITS,ROW_LIMITS:Pu.ROW_LIMITS,ROW_STARTS:Pu.ROW_STARTS},t=[];for(const n of s)if(n in e)t.push(e[n]);else break;return t}function qC(s){return s.length===0?0:s[0]===Pu.FIRST_DIM_SIZE?s.length-1:s.length}function KC(s,e){if(s==null||e==null)return;const t=s.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${s} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let r=0;r<Math.min(t,n-1);++r){const a=s[r],o=e[r+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${s}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-s.length}] = ${a} but ragged tensor input.flatValues.shape[${r-s.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aw=30;function pb(s){return s<=Aw?s:h0(s,Math.floor(Math.sqrt(s)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ow(s,e,t){const n=t*(typeof s=="number"?s:s[0]),r=e*(typeof s=="number"?s:s[1]);return[n,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bf(s,e,t,n=!0){let r=[];if(n)r=r.concat(e.slice(0)),r.push(s[0]/t),r=r.concat(s.slice(1));else{r=r.concat(s[0]);const a=e.length;for(let o=0;o<a;++o)r=r.concat([s[o+1]/e[o],e[o]]);r=r.concat(s.slice(a+1))}return r}function xf(s,e,t=!0){const n=[];if(t){n.push(e);for(let r=e+1;r<s;++r)r<=2*e?(n.push(r),n.push(r-(e+1))):n.push(r)}else{const r=[],a=[];for(let o=1;o<s;++o)o>=e*2+1||o%2===1?a.push(o):r.push(o);n.push(...r),n.push(0),n.push(...a)}return n}function yf(s,e,t,n=!0){const r=[];n?r.push(s[0]/t):r.push(s[0]*t);for(let a=1;a<s.length;++a)a<=e.length?n?r.push(e[a-1]*s[a]):r.push(s[a]/e[a-1]):r.push(s[a]);return r}function Fw(s,e){const t=[0];for(let n=0;n<e;++n)t.push(s[n][0]);return t}function Dw(s,e,t){const n=s.slice(0,1);for(let r=0;r<t;++r)n.push(s[r+1]-e[r][0]-e[r][1]);return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fb=1.7580993408473768,mb=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mw=.3275911,Pw=.254829592,Lw=-.284496736,Bw=1.421413741,zw=-1.453152027,Ww=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vc(s,e){if(s.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${s.length}, imag: ${e.length}.`);const t=new Float32Array(s.length*2);for(let n=0;n<t.length;n+=2)t[n]=s[n/2],t[n+1]=e[n/2];return t}function XC(s){const e=new Float32Array(s.length/2),t=new Float32Array(s.length/2);for(let n=0;n<s.length;n+=2)e[n/2]=s[n],t[n/2]=s[n+1];return{real:e,imag:t}}function YC(s){const e=Math.ceil(s.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let r=0;r<s.length;r+=4)t[Math.floor(r/4)]=s[r],n[Math.floor(r/4)]=s[r+1];return{real:t,imag:n}}function ZC(s){const e=Math.floor(s.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let r=2;r<s.length;r+=4)t[Math.floor(r/4)]=s[r],n[Math.floor(r/4)]=s[r+1];return{real:t,imag:n}}function Vw(s,e){const t=s[e*2],n=s[e*2+1];return{real:t,imag:n}}function QC(s,e,t,n){s[n*2]=e,s[n*2+1]=t}function JC(s,e){const t=new Float32Array(s/2),n=new Float32Array(s/2);for(let r=0;r<Math.ceil(s/2);r++){const a=(e?2:-2)*Math.PI*(r/s);t[r]=Math.cos(a),n[r]=Math.sin(a)}return{real:t,imag:n}}function e_(s,e,t){const n=(t?2:-2)*Math.PI*(s/e),r=Math.cos(n),a=Math.sin(n);return{real:r,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1="->",BD=/->/g,xk=",",yk="...";function Uw(s,e){s=s.replace(/\s/g,"");const t=(s.length-s.replace(BD,"").length)/G1.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${G1}").`);const[n,r]=s.split(G1);ze(n.indexOf(yk)===-1,()=>`The ellipsis notation ("${yk}") is not supported yet.`);const a=n.split(xk),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let l=0;l<r.length;++l){const p=r[l];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);i.indexOf(p)===-1&&i.push(p)}for(let l=0;l<n.length;++l){const p=n[l];i.indexOf(p)===-1&&p!==xk&&i.push(p)}const u=new Array(a.length);for(let l=0;l<o;++l){if(new Set(a[l].split("")).size!==a[l].length)throw new Error(`Found duplicate axes in input component ${a[l]}. Support for duplicate axes in input is not implemented yet.`);u[l]=[];for(let p=0;p<a[l].length;++p)u[l].push(i.indexOf(a[l][p]))}const c=i.length,d=r.length,h=[];for(let l=d;l<c;++l)h.push(l);return{allDims:i,summedDims:h,idDims:u}}function jw(s,e){let t=new Array(s);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const n=[];for(let r=0;r<s;++r)t[r]===-1&&n.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:n}}function Gw(s,e,t){const n=new Array(s);for(let r=0;r<t.length;++r){const a=t[r].shape;for(let o=0;o<e[r].length;++o)n[e[r][o]]===void 0?n[e[r][o]]=a[o]:ze(n[e[r][o]]===a[o],()=>`Expected dimension ${n[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function Hw(s,e){const t=s,n=[];let r=0;s.length===0&&t.push(-1),r=s.length+1;for(let o=0;o<r;++o)n.push([]);const a=[];for(let o=0;o<t.length;++o){const i=t[o],u=zD(e,i);for(const c of u)a.indexOf(c)===-1&&(n[o].push(c),a.push(c))}return{path:t,steps:n}}function qw(s){return s.every((e,t)=>e===t)}function zD(s,e){const t=[];for(let n=0;n<s.length;++n)(s[n].length===0||s[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function Kw(s,e,t=0){let n=[];if(typeof e=="number")ze(s.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(s.shape[t]/e);else{const r=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);ze(r<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,u)=>u>0?i+u:i);e[a]=s.shape[t]-o}ze(s.shape[t]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${s}`}function n_(s,e){return`indices(${s}, 0) is invalid: ${e} < 0`}function s_(s,e,t){return`indices(${s}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r_(s,e){return`only one output dimension may be -1, not both ${s} and ${e}`}function a_(s,e){return`size ${s} must be non-negative, not ${e}`}function o_(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function i_(s,e){const t=hn(s),n=hn(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${s} outputShape= ${e}`}function u_(s,e){const t=hn(s),n=hn(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${s} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(){return"segment ids must be >= 0"}function c_(){return"segment ids are not increasing"}function l_(s,e){return`Segment id ${s} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function d_(s,e,t){return`Bad: indices[${s}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(s,e){let t=!1,n;for(s<=Aw?(n=s,t=!0):n=h0(s,Math.floor(Math.sqrt(s)));!t;)n>e||n===s?t=!0:n=h0(s,n+1);return n}function p_(s,e,t){const n=[],r=s.length;for(let a=0;a<r;a++)a!==e?n.push(s[a]):n.push(t);return n}function Xw(s,e,t,n){const r=e.shape.length,a=s.shape.length;if(n!==0&&(n<-r||n>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${n}`);if(n<0&&(n+=r),n>a)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${a}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let h=0;h<n;++h)if(s.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${s.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=s.shape[t],i=[];let u=1,c=1,d=1;for(let h=0;h<n;++h)i.push(s.shape[h]),u*=s.shape[h];for(let h=n;h<t;h++)i.push(s.shape[h]),c*=s.shape[h];for(let h=n;h<r;h++)i.push(e.shape[h]);for(let h=t+1;h<a;h++)i.push(s.shape[h]),d*=s.shape[h];return{batchSize:u,sliceSize:d,outerSize:c,dimSize:o,outputShape:i}}var WD=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:h_,computeOutShape:p_,collectGatherOpShapeInfo:Xw},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uc(s){try{return s.map(e=>bl(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function f_(s){return s.map(e=>fl(e))}var VD=Object.freeze(Object.defineProperty({__proto__:null,slice_util:MD,segment_util:WD,fromUint8ToStringArray:Uc,fromStringArrayToUint8:f_,upcastType:vi,axesAreInnerMostDims:ew,combineLocations:JI,computeOutAndReduceShapes:Ja,expandShapeToKeepDim:$a,assertAxesAreInnerMostDims:ho,getAxesPermutation:ha,getUndoAxesPermutation:$l,getInnerMostAxes:wa,getBroadcastDims:oh,getReductionAxes:Pa,assertAndGetBroadcastShape:js,assertParamsConsistent:Rw,computeOutShape:gc,computeDilation2DInfo:hf,computePool2DInfo:Cu,computePool3DInfo:Gc,computeConv2DInfo:lo,computeConv3DInfo:Sl,computeDefaultPad:qy,tupleValuesAreOne:fd,eitherStridesOrDilationsAreOne:Co,stridesOrDilationsArePositive:md,convertConv2DDataFormat:Hc,checkPadOnDimRoundingMode:ti,getFusedDyActivation:mw,getFusedBiasGradient:gw,applyActivation:bw,shouldFuse:xw,get RowPartitionType(){return Pu},combineRaggedTensorToTensorShapes:GC,getRowPartitionTypesHelper:HC,getRaggedRank:qC,validateDefaultValueShape:KC,PARALLELIZE_THRESHOLD:Aw,computeOptimalWindowSize:pb,getImageCenter:Ow,getReshaped:bf,getPermuted:xf,getReshapedPermuted:yf,getSliceBeginCoords:Fw,getSliceSize:Dw,prepareAndValidate:_w,validateUpdateShape:IC,validateInput:p3,calculateShapes:Ed,SELU_SCALEALPHA:fb,SELU_SCALE:mb,ERF_P:Mw,ERF_A1:Pw,ERF_A2:Lw,ERF_A3:Bw,ERF_A4:zw,ERF_A5:Ww,warn:Gi,log:$E,mergeRealAndImagArrays:Vc,splitRealAndImagArrays:XC,complexWithEvenIndex:YC,complexWithOddIndex:ZC,getComplexWithIndex:Vw,assignToTypedArray:QC,exponents:JC,exponent:e_,decodeEinsumEquation:Uw,getEinsumPermutation:jw,checkEinsumDimSizes:Gw,getEinsumComputePath:Hw,isIdentityPermutation:qw,prepareSplitSize:Kw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:t_,getSparseFillEmptyRowsNegativeIndexErrorMessage:n_,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:s_,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:r_,getSparseReshapeNegativeOutputDimErrorMessage:a_,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:o_,getSparseReshapeInputOutputMultipleErrorMessage:i_,getSparseReshapeInputOutputMismatchErrorMessage:u_,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:A0,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:c_,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:l_,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:d_},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */vD();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_={kernelName:sg,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,gf(as(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UD={kernelName:gp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Qr(as(t,"float32")),r=Lo(Ds(Rr(1),n));return xa(_s(s,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jD={kernelName:bp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Lo(Ds(Qr(as(t,"float32")),1));return _s(s,n)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD={kernelName:yh,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{let i=s;const u=Pa(t.shape,r);return u.length>0&&(i=Cs(i,u)),zt(i,t.shape)},b:()=>{let i=s;const u=Pa(n.shape,r);return u.length>0&&(i=Cs(i,u)),zt(i,n.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HD={kernelName:ay,saveAllInputs:!0,gradFunc:(s,e)=>{const t={};return e.forEach((n,r)=>{t[r]=()=>s.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qD={kernelName:rg,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>wr(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD={kernelName:ag,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>wr(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XD={kernelName:xp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Lo(Ds(Rr(1),Qr(as(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD={kernelName:yp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Lo(Bn(Rr(1),Qr(as(t,"float32"))));return _s(s,n)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD={kernelName:kp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{const i=Bn(Qr(t),Qr(n));let u=Ft(s,_s(n,i));const c=Pa(t.shape,r);return c.length>0&&(u=Cs(u,c)),zt(u,t.shape)},b:()=>{const i=Bn(Qr(t),Qr(n));let u=xa(Ft(s,_s(t,i)));const c=Pa(n.shape,r);return c.length>0&&(u=Cs(u,c)),zt(u,n.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QD={kernelName:wp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Bn(Qr(as(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JD={kernelName:vp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Ds(Rr(1),Qr(as(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(s,e,t,n,r,a){const o=mt(s,"dy","avgPool3dGrad"),i=mt(e,"input","avgPool3dGrad");let u=o,c=i,d=!1;i.rank===4&&(d=!0,u=zt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=zt(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ze(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),ze(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),ti("avgPool3dGrad",r,a);const h={dy:u,input:c},l={filterSize:t,strides:n,pad:r,dimRoundingMode:a},p=Mt.runKernel(cy,h,l);return d?zt(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const tM=Vt({avgPool3dGrad_:eM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM={kernelName:ig,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:i}=t;return{x:()=>tM(s,n,r,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(s,e,t,n,r){const a=mt(s,"dy","avgPoolGrad"),o=mt(e,"input","avgPoolGrad");ze(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let i=o,u=a,c=!1;o.rank===3&&(c=!0,i=zt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=zt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ze(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),ze(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const d={dy:u,input:i},h={filterSize:t,strides:n,pad:r},l=Mt.runKernel(uy,d,h);return c?zt(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const rM=Vt({avgPoolGrad_:sM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aM={kernelName:og,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{filterSize:r,strides:a,pad:o}=t;return{x:()=>rM(s,n,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oM={kernelName:ug,inputsToSave:["a","b"],gradFunc:(s,e,t)=>{const[n,r]=e,{transposeA:a,transposeB:o}=t;return!a&&!o?{a:()=>Nr(s,r,!1,!0),b:()=>Nr(n,s,!0,!1)}:!a&&o?{a:()=>Nr(s,r,!1,!1),b:()=>Nr(s,n,!0,!1)}:a&&!o?{a:()=>Nr(r,s,!1,!0),b:()=>Nr(n,s,!1,!1)}:{a:()=>Nr(r,s,!0,!0),b:()=>Nr(s,n,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iM={kernelName:cg,gradFunc:(s,e,t)=>{const{blockShape:n,crops:r}=t;return{x:()=>uw(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uM={kernelName:CE,gradFunc:(s,e,t)=>{const n=t,r=n.inputShape,a=n.shape,o=Array.from(a);for(let u=r.length-1;u>=0;u--)if(r[u]===a[u])o[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const i=[];for(let u=0;u<o.length;u++)o[u]>1&&i.push(u);return{x:()=>Cs(s,i,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM={kernelName:Ip,gradFunc:s=>({x:()=>s.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lM={kernelName:Cp,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dM={kernelName:_p,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{clipValueMin:r,clipValueMax:a}=t;return{x:()=>Po(Wc(Sd(n,r),vh(n,a)),s,wr(s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hM={kernelName:lg,inputsToSave:["x"],gradFunc:m_.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pM={kernelName:dg,saveAllInputs:!0,gradFunc:(s,e,t)=>{const n=e.map(u=>u.shape),{axis:r}=t,a=nr(r,e[0].shape)[0],o=n.map(u=>u[a]);return Ki(s,o,a).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fM={kernelName:hg,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const[n,r]=e,{dilations:a,strides:o,pad:i,dataFormat:u}=t;return ze(fd(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>Zy(n.shape,s,r,o,i,u),filter:()=>fw(n,s,r.shape,o,i,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM={kernelName:pg,inputsToSave:["dy","filter"],gradFunc:(s,e,t)=>{const[n,r]=e,{strides:a,pad:o,dataFormat:i,dimRoundingMode:u}=t;return{dy:()=>gd(s,r,a,o,i,1,u),filter:()=>fw(s,n,r.shape,a,o,i,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gM(s,e,t,n,r){let a=s;s.rank===4&&(a=zt(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));let o=e;o.rank===4&&(o=zt(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ze(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),ze(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),ze(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),ze(a.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${t[3]}.`),ze(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const i={x:a,dy:o},u={strides:n,pad:r,filterShape:t};return Mt.runKernel(py,i,u)}const bM=Vt({conv3DBackpropFilter_:gM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xM={kernelName:fg,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const{dilations:n,strides:r,pad:a}=t;ze(fd(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);const[o,i]=e;return{x:()=>YI(o.shape,s,i,r,a),filter:()=>bM(o,s,i.shape,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM={kernelName:Sp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(xa(yC(as(t,"float32"))),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wM={kernelName:$p,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(wC(as(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM={kernelName:mg,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:r,exclusive:a,reverse:o}=t;return{x:()=>{const i=ha([r],n.rank);let u=QI(s,r,a,!o);return i!=null&&(u=br(u,i)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kM={kernelName:gg,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const{dilations:n,strides:r,pad:a,dimRoundingMode:o}=t,i=n==null?[1,1]:n;ze(fd(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[u,c]=e;return ze(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),ze(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),ze(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),ze(Co(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),ti("depthwiseConv2d",a,o),{x:()=>A3(u.shape,s,c,r,a,i,o),filter:()=>E3(u,s,c.shape,r,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IM={kernelName:bg,inputsToSave:["x","filter"],gradFunc:(s,e,t)=>{const[n,r]=e,a={x:n,filter:r,dy:s},o={x:n,filter:r,dy:s};return{x:()=>Mt.runKernel(p0,a,t),filter:()=>Mt.runKernel(f0,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CM={kernelName:Np,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e,n={dy:s,y:t};return{x:()=>Mt.runKernel(vy,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _M={kernelName:Ep,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e,n=Ft(zc(xa(Qr(t))),2/Math.sqrt(Math.PI));return{x:()=>Ft(s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SM={kernelName:Rp,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $M={kernelName:yg,inputsToSave:["input"],gradFunc:(s,e)=>{const[t]=e;return{input:()=>zt(s,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM={kernelName:Ap,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,zc(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM={kernelName:Op,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EM={kernelName:Fp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{const i=_s(s,as(n,"float32")),u=Pa(t.shape,r);return u.length>0?zt(Cs(i,u),t.shape):i},b:()=>{let i=Ft(s,as(t,"float32"));const u=Pa(n.shape,r);u.length>0&&(i=zt(Cs(i,u),n.shape));const c=Qr(n);return xa(_s(i,as(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM={kernelName:wg,inputsToSave:["x","mean","variance","scale"],gradFunc:(s,e,t)=>{const{varianceEpsilon:n}=t,[r,a,o,i]=e,u=i==null?Rr(1):i,c=Pa(a.shape,r.shape),d=[];if(a.rank===1){for(let E=0;E<r.shape.length-1;++E)d.push(r.shape[E]);d.push(1)}const h=Ds(r,a),l=Ft(s,u),p=gC(Bn(o,Rr(n))),f=Ft(Ft(Ft(p,p),p),Rr(-.5));return{x:()=>a.rank===1?zt(Ft(Ft(s,Lu(zt(p,[1,1,1,a.shape[0]]),d)),u),r.shape):zt(Ft(Ft(s,p),u),r.shape),mean:()=>{let E=Ft(Ft(p,Rr(-1)),l);return a.rank===1&&(E=Cs(E,c)),zt(E,a.shape)},variance:()=>{let E=Ft(Ft(f,h),l);return a.rank===1&&(E=Cs(E,c)),zt(E,a.shape)},scale:()=>{const E=Ft(h,p);let D=Ft(s,E);return a.rank===1&&(D=Cs(D,c)),zt(D,a.shape)},offset:()=>{let E=s;return a.rank===1&&(E=Cs(E,c)),zt(E,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM={kernelName:vg,inputsToSave:["x","indices"],gradFunc:(s,e,t)=>{const[n,r]=e,{axis:a}=t,o=nr(a,n.shape)[0];return{x:()=>{const u=n.shape,c=r.size,d=u.slice(0,o),h=d.length,l=u.slice(a,u.length).slice(1),p=l.length,f=wk(0,h),x=wk(h+1,h+1+p),b=vk([d,[c],l]),m=zt(s,b),I=zt(r,[c]),N=vk([[h],f,x]),E=br(m,N);let D=_C(E,I,n.shape[o]);const U=$l(N);return D=br(D,U),D},indices:()=>r}}};function wk(s,e){const t=[];for(let n=s;n<e;++n)t.push(n);return t}function vk(s){const e=[];for(let t=0;t<s.length;++t)for(let n=0;n<s[t].length;++n)e.push(s[t][n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM={kernelName:Dp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>wr(t),b:()=>wr(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM={kernelName:Mp,gradFunc:s=>({x:()=>as(s,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DM={kernelName:Pp,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MM={kernelName:Lp,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PM={kernelName:Bp,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM={kernelName:Ig,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{alpha:r}=t,a=Yi(n,0);return{x:()=>Po(a,s,Ft(s,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BM={kernelName:Wp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Bn(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zM={kernelName:zp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,as(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WM={kernelName:_E,inputsToSave:[],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n]=e,{axis:r}=t;return{logits:()=>{const o=zc(n);return Ds(s,Ft(Cs(s,r,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VM(s,e,t,n=5,r=1,a=1,o=.5){const i={x:s,y:e,dy:t},u={depthRadius:n,bias:r,alpha:a,beta:o};return Mt.runKernel($y,i,u)}const UM=Vt({localResponseNormalizationBackprop_:VM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jM={kernelName:Ng,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,r]=e,{depthRadius:a,bias:o,alpha:i,beta:u}=t;return{x:()=>UM(n,r,s,a,o,i,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(s,e,t,n){return e.rank<t.rank&&(e=zt(e,$a(e.shape,n))),s.rank<t.rank&&(s=zt(s,$a(s.shape,n))),{x:()=>Ft(s,as(yc(t,e),s.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk={kernelName:Eg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const n=t,{reductionIndices:r}=n,a=e[0],o=e[1],i=nr(r,a.shape),u=g_(s,o,a,i);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GM={kernelName:Vp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>Ft(s,as(Sd(t,n),"float32")),b:()=>Ft(s,as(Fm(t,n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HM(s,e,t,n,r,a,o){const i=mt(s,"dy","maxPool3dGrad"),u=mt(e,"input","maxPool3dGrad"),c=mt(t,"output","maxPool3dGrad");let d=i,h=u,l=c,p=!1;u.rank===4&&(p=!0,d=zt(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=zt(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),l=zt(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),ze(d.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),ze(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ze(l.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${l.rank}.`),ti("maxPool3dGrad",a,o);const f={dy:d,input:h,output:l},x={filterSize:n,strides:r,pad:a,dimRoundingMode:o},b=Mt.runKernel(Ny,f,x);return p?zt(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const qM=Vt({maxPool3dGrad_:HM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KM={kernelName:Ag,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,r]=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=t;return{x:()=>qM(s,n,r,a,o,i,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(s,e,t,n,r,a,o){const i=mt(s,"dy","maxPoolGrad"),u=mt(e,"input","maxPoolGrad"),c=mt(t,"output","maxPoolGrad");ze(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),ze(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),ze(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),ti("maxPoolGrad",a,o);const d={dy:i,input:u,output:c},h={filterSize:n,strides:r,pad:a,dimRoundingMode:o};return Mt.runKernel(Ty,d,h)}const YM=Vt({maxPoolGrad_:XM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM={kernelName:Rg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n,r]=e,{filterSize:a,strides:o,pad:i}=t;return{x:()=>YM(s,n,r,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QM={kernelName:Og,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:r}=t,a=nr(r,n.shape),i=Ja(n.shape,a)[1],u=hn(i);return{x:()=>{const d=n.shape.slice();a.forEach(p=>{d[p]=1});const h=zt(s,d);return _s(Ft(h,$d(n.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM={kernelName:Fg,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(s,e,t)=>{const n=t,{axis:r}=n,[a,o]=e,i=nr(r,a.shape),u=g_(s,o,a,i);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eP={kernelName:Up,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e;return{a:()=>Ft(s,as(vh(t,n),"float32")),b:()=>Ft(s,as(Yi(t,n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tP={kernelName:Dg,inputsToSave:["x"],gradFunc:(s,e,t)=>{const n=e[0],{paddings:r}=t,a=r.map(o=>o[0]);return{x:()=>Hr(s,a,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nP={kernelName:jp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{const i=Pa(t.shape,r);return i.length>0?zt(Cs(s,i),t.shape):s},b:()=>{const i=Ft(s,xa(db(_s(t,n)))),u=Pa(n.shape,r);return u.length>0?zt(Cs(i,u),n.shape):i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP={kernelName:Gp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{const i=Ft(s,as(n,"float32")),u=Pa(t.shape,r);return u.length>0?zt(Cs(i,u),t.shape):i},b:()=>{const i=Ft(s,as(t,"float32")),u=Pa(n.shape,r);return u.length>0?zt(Cs(i,u),n.shape):i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rP={kernelName:Mg,gradFunc:s=>({x:()=>xa(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aP={kernelName:Bg,inputsToSave:["indices"],gradFunc:(s,e)=>{const t=e[0];return{indices:()=>Ya(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oP={kernelName:Lg,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iP={kernelName:zg,saveAllInputs:!0,gradFunc:(s,e,t)=>{const{axis:n}=t;return xd(s,n).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik={kernelName:Wg,inputsToSave:["x"],gradFunc:(s,e,t)=>{const n=e[0],{paddings:r}=t,a=r.map(o=>o[0]);return{x:()=>Hr(s,a,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uP={kernelName:Hp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(s,e)=>{const[t,n,r]=e,a=t,o=n,i=js(a.shape,o.shape);return{a:()=>{const d=as(o,"float32");let h=Ft(s,Ft(d,ih(a,Ds(d,Rr(1)))));const l=Pa(a.shape,i);return l.length>0&&(h=Cs(h,l)),zt(h,a.shape)},b:()=>{const d=Yi(a,0),h=Po(d,wc(a),wr(a));let l=Ft(s,Ft(r,h));const p=Pa(o.shape,i);return p.length>0&&(l=Cs(l,p)),zt(l,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cP={kernelName:Vg,inputsToSave:["x","alpha"],gradFunc:(s,e)=>{const[t,n]=e,r=Yi(t,0);return{x:()=>Po(r,s,Ft(s,n)),alpha:()=>{let a=Po(r,wr(s),Ft(s,t));const o=Pa(n.shape,s.shape);return o.length>0&&(a=Cs(a,o)),zt(a,n.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lP(s,e,t){const n=s.shape.slice();n[t]=1;const r=zt(e,n),a=N0(s,t,!0,!1),o=N0(s,t,!0,!0),i=Ft(a,o);return Ft(r,i)}function dP(s,e,t){const n=s.shape.length,r=n-t.length,a=ha(t,n);let o=s;a!=null&&(o=br(s,a));const i=o.shape.slice(),c=i.splice(n-t.length,t.length).reduce((l,p)=>l*p,1);i.push(c);const d=o.reshape(i);let h=lP(d,e,r);if(h=h.reshape(o.shape),a!=null){const l=$l(a);h=br(h,l)}return h}const hP={kernelName:Ug,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{axis:r}=t;let a=[];return r==null?a=n.shape.map((o,i)=>i):typeof r=="number"?a=[r]:a=r,{x:()=>dP(n,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pP={kernelName:Tp,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{const i=_s(s,as(n,"float32")),u=Pa(t.shape,r);return u.length>0?zt(Cs(i,u),t.shape):i},b:()=>{let i=Ft(s,as(t,"float32"));const u=Pa(n.shape,r);u.length>0&&(i=zt(Cs(i,u),n.shape));const c=Qr(n);return xa(_s(i,as(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fP={kernelName:qp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,xa(Qr(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mP={kernelName:Xp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e,n=Ft(vh(t,6),gf(t));return{x:()=>Ft(s,as(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP={kernelName:Kp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,as(gf(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP={kernelName:jg,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>zt(s,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP={kernelName:Hg,inputsToSave:["images"],gradFunc:(s,e,t)=>{const[n]=e,r={dy:s,images:n};return{images:()=>Mt.runKernel(My,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP={kernelName:Gg,inputsToSave:["images"],gradFunc:(s,e,t)=>{const[n]=e,r={dy:s,images:n};return{images:()=>Mt.runKernel(Dy,r,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP={kernelName:qg,gradFunc:(s,e,t)=>{const{dims:n}=t,r=nr(n,s.shape);return{x:()=>bd(s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP={kernelName:Yp,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP={kernelName:Zp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>xa(_s(s,Ft(ih(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP={kernelName:Kg,inputsToSave:["condition"],gradFunc:(s,e)=>{const[t]=e;return{condition:()=>as(wr(t),"float32"),t:()=>Ft(s,as(t,s.dtype)),e:()=>Ft(s,as(rw(t),s.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CP={kernelName:Qp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>{const n=Yi(t,Rr(0)),r=Rr(fb),a=Rr(mb),o=Ft(s,a),i=Ft(Ft(s,r),zc(as(t,"float32")));return Po(n,o,i)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P={kernelName:nf,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,Ft(t,Ds(Rr(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP={kernelName:tf,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P={kernelName:Jp,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(Qy(as(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP={kernelName:ef,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(ZI(as(t,"float32")),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP={kernelName:Xg,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{begin:r,size:a}=t,o=n.shape,[i,u]=hb(n,r,a),c=[];for(let d=0;d<s.rank;d++)c.push([i[d],o[d]-i[d]-u[d]]);return{x:()=>iw(s,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP={kernelName:Jg,outputsToSave:[!0],gradFunc:(s,e,t)=>{const[n]=e,{dim:r}=t,a=!0,o=Ft(s,n);return{logits:()=>Ds(o,Ft(Cs(o,[r],a),n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RP={kernelName:sf,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,wh(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck={kernelName:Zg,gradFunc:(s,e,t)=>{const{blockShape:n,paddings:r}=t;return{x:()=>Yy(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k={kernelName:Qg,gradFunc:(s,e,t)=>{const{axis:n}=t;return{x:()=>Qo(s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AP={kernelName:rf,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Ft(Lo(as(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP={kernelName:Py,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(s,Ft(as(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FP={kernelName:af,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=Rr(2);return{a:()=>Ft(s,Ft(r,Ds(t,n))),b:()=>Ft(s,Ft(r,Ds(n,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DP={kernelName:df,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP={kernelName:of,inputsToSave:["a","b"],gradFunc:(s,e)=>{const[t,n]=e,r=js(t.shape,n.shape);return{a:()=>{let i=s;const u=Pa(t.shape,r);return u.length>0&&(i=Cs(i,u)),zt(i,t.shape)},b:()=>{let i=s;const u=Pa(n.shape,r);return u.length>0&&(i=Cs(i,u)),zt(xa(i),n.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP={kernelName:Yg,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,r=n.shape.slice(),{axis:a}=t;nr(a,n.shape).forEach(c=>{r[c]=1});const i=zt(s,r),u=Ft(i,$d(n.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LP={kernelName:uf,inputsToSave:["x"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>_s(s,Qr(Qy(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BP={kernelName:cf,outputsToSave:[!0],gradFunc:(s,e)=>{const[t]=e;return{x:()=>Ft(Ds(Rr(1),Qr(t)),s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zP={kernelName:lf,inputsToSave:["x"],gradFunc:(s,e,t)=>{const[n]=e,{reps:r}=t;return{x:()=>{let o=wr(n);if(n.rank===1)for(let i=0;i<r[0];++i)o=Bn(o,Hr(s,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<r[0];++i)for(let u=0;u<r[1];++u)o=Bn(o,Hr(s,[i*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<r[0];++i)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)o=Bn(o,Hr(s,[i*n.shape[0],u*n.shape[1],c*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<r[0];++i)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)for(let d=0;d<r[3];++d)o=Bn(o,Hr(s,[i*n.shape[0],u*n.shape[1],c*n.shape[2],d*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WP={kernelName:Yd,gradFunc:(s,e,t)=>{const n=t,{perm:r}=n,a=$l(r);return{x:()=>br(s,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VP={kernelName:eb,gradFunc:(s,e,t)=>{const n=t,{axis:r}=n;return{value:()=>xl(s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP={kernelName:tb,inputsToSave:["segmentIds"],gradFunc:(s,e)=>{const[t]=e;return{x:()=>jP(s,t)}}};function jP(s,e){const t=Tl(e,wr(e)),n=tw(s,t);let r=Sd(e,Rr(0,"int32"));const a=n.rank-r.rank;for(let i=0;i<a;++i)r=xi(r,i+1);r=Wc(r,$d(n.shape,"bool"));const o=wr(n);return Po(r,n,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GP={kernelName:nb,gradFunc:s=>({x:()=>wr(s)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HP=[m_,UD,jD,GD,HD,qD,KD,XD,YD,ZD,QD,JD,nM,aM,oM,iM,uM,cM,lM,dM,hM,pM,mM,fM,xM,yM,wM,vM,kM,IM,pP,CM,_M,SM,$M,TM,EM,NM,RM,AM,OM,FM,DM,MM,PM,LM,BM,zM,WM,jM,kk,kk,GM,KM,ZM,QM,JM,eP,tP,nP,sP,rP,aP,oP,iP,Ik,Ik,uP,cP,hP,fP,mP,gP,bP,xP,yP,wP,vP,kP,IP,CP,_P,SP,$P,TP,NP,EP,RP,Ck,Ck,_k,_k,AP,FP,OP,DP,MP,PP,LP,BP,zP,WP,VP,UP,GP];for(const s of HP)TE(s);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.abs=function(){return this.throwIfDisposed(),Fo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.acos=function(){return this.throwIfDisposed(),RR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.acosh=function(){return this.throwIfDisposed(),OR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.add=function(s){return this.throwIfDisposed(),Bn(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.all=function(s,e){return this.throwIfDisposed(),qI(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.any=function(s,e){return this.throwIfDisposed(),$0(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.argMax=function(s){return this.throwIfDisposed(),ah(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.argMin=function(s){return this.throwIfDisposed(),LR(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.asScalar=function(){return this.throwIfDisposed(),ze(this.size===1,()=>"The array must have only 1 element."),zt(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.asType=function(s){return this.throwIfDisposed(),as(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.as1D=function(){return this.throwIfDisposed(),zt(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.as2D=function(s,e){return this.throwIfDisposed(),zt(this,[s,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.as3D=function(s,e,t){return this.throwIfDisposed(),zt(this,[s,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.as4D=function(s,e,t,n){return this.throwIfDisposed(),zt(this,[s,e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.as5D=function(s,e,t,n,r){return this.throwIfDisposed(),zt(this,[s,e,t,n,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.asin=function(){return this.throwIfDisposed(),zR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.asinh=function(){return this.throwIfDisposed(),VR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.atan=function(){return this.throwIfDisposed(),jR(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.atan2=function(s){return this.throwIfDisposed(),HR(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.atanh=function(){return this.throwIfDisposed(),KR(this)};ln().prototype.avgPool=function(s,e,t,n){return this.throwIfDisposed(),Ky(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.batchToSpaceND=function(s,e){return this.throwIfDisposed(),Yy(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.batchNorm=function(s,e,t,n,r){return this.throwIfDisposed(),ib(this,s,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.broadcastTo=function(s){return this.throwIfDisposed(),ep(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.cast=function(s){return this.throwIfDisposed(),as(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.ceil=function(){return this.throwIfDisposed(),vA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.clipByValue=function(s,e){return this.throwIfDisposed(),Xi(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.concat=function(s,e){return this.throwIfDisposed(),s instanceof _a&&(s=[s]),Qo([this,...s],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.conv1d=function(s,e,t,n,r,a){return this.throwIfDisposed(),KI(this,s,e,t,n,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.conv2dTranspose=function(s,e,t,n,r){return this.throwIfDisposed(),XI(this,s,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.conv2d=function(s,e,t,n,r,a){return this.throwIfDisposed(),gd(this,s,e,t,n,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.cos=function(){return this.throwIfDisposed(),Qy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.cosh=function(){return this.throwIfDisposed(),ZI(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.cumprod=function(s,e,t){return this.throwIfDisposed(),N0(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.cumsum=function(s,e,t){return this.throwIfDisposed(),QI(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.depthToSpace=function(s,e){return this.throwIfDisposed(),HA(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.depthwiseConv2d=function(s,e,t,n,r,a){return this.throwIfDisposed(),Jy(this,s,e,t,n,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.dilation2d=function(s,e,t,n,r){return this.throwIfDisposed(),XA(this,s,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.divNoNan=function(s){return this.throwIfDisposed(),eO(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.div=function(s){return this.throwIfDisposed(),_s(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.dot=function(s){return this.throwIfDisposed(),nO(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.elu=function(){return this.throwIfDisposed(),cb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.equal=function(s){return this.throwIfDisposed(),yc(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.erf=function(){return this.throwIfDisposed(),aO(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.euclideanNorm=function(s,e){return this.throwIfDisposed(),fO(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.exp=function(){return this.throwIfDisposed(),zc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.expandDims=function(s){return this.throwIfDisposed(),xi(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.expm1=function(){return this.throwIfDisposed(),xO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.fft=function(){return this.throwIfDisposed(),kC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.flatten=function(){return this.throwIfDisposed(),zt(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.floor=function(){return this.throwIfDisposed(),db(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.floorDiv=function(s){return this.throwIfDisposed(),HI(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.gather=function(s,e,t){return this.throwIfDisposed(),tw(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.greaterEqual=function(s){return this.throwIfDisposed(),Sd(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.greater=function(s){return this.throwIfDisposed(),Yi(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.ifft=function(){return this.throwIfDisposed(),E0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.irfft=function(){return this.throwIfDisposed(),e3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.isFinite=function(){return this.throwIfDisposed(),$O(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.isInf=function(){return this.throwIfDisposed(),NO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.isNaN=function(){return this.throwIfDisposed(),RO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.leakyRelu=function(s){return this.throwIfDisposed(),sw(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.lessEqual=function(s){return this.throwIfDisposed(),vh(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.less=function(s){return this.throwIfDisposed(),Fm(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.localResponseNormalization=function(s,e,t,n){return this.throwIfDisposed(),MO(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logSigmoid=function(){return this.throwIfDisposed(),UO(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logSoftmax=function(s){return this.throwIfDisposed(),sC(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logSumExp=function(s,e){return this.throwIfDisposed(),qO(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.log=function(){return this.throwIfDisposed(),wc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.log1p=function(){return this.throwIfDisposed(),nC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logicalAnd=function(s){return this.throwIfDisposed(),Wc(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logicalNot=function(){return this.throwIfDisposed(),rw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logicalOr=function(s){return this.throwIfDisposed(),rC(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.logicalXor=function(s){return this.throwIfDisposed(),QO(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.matMul=function(s,e,t){return this.throwIfDisposed(),Nr(this,s,e,t)};ln().prototype.maxPool=function(s,e,t,n){return this.throwIfDisposed(),aw(this,s,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.max=function(s,e){return this.throwIfDisposed(),zu(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.maximum=function(s){return this.throwIfDisposed(),Tl(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.mean=function(s,e){return this.throwIfDisposed(),Sa(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.min=function(s,e){return this.throwIfDisposed(),Om(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.minimum=function(s){return this.throwIfDisposed(),rp(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.mirrorPad=function(s,e){return this.throwIfDisposed(),oF(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.mod=function(s){return this.throwIfDisposed(),uF(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.mul=function(s){return this.throwIfDisposed(),Ft(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.neg=function(){return this.throwIfDisposed(),xa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.norm=function(s,e,t){return this.throwIfDisposed(),lb(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.notEqual=function(s){return this.throwIfDisposed(),Dm(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.oneHot=function(s,e=1,t=0){return this.throwIfDisposed(),aC(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.onesLike=function(){return this.throwIfDisposed(),Iu(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.pad=function(s,e){return this.throwIfDisposed(),iw(this,s,e)};ln().prototype.pool=function(s,e,t,n,r,a){return this.throwIfDisposed(),xF(this,s,e,t,n,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.pow=function(s){return this.throwIfDisposed(),ih(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.prelu=function(s){return this.throwIfDisposed(),cw(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.prod=function(s,e){return this.throwIfDisposed(),vF(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.reciprocal=function(){return this.throwIfDisposed(),FF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.relu=function(){return this.throwIfDisposed(),Nd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.relu6=function(){return this.throwIfDisposed(),fC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.reshapeAs=function(s){return this.throwIfDisposed(),zt(this,s.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.reshape=function(s){return this.throwIfDisposed(),zt(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.resizeBilinear=function(s,e,t){return this.throwIfDisposed(),$C(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.resizeNearestNeighbor=function(s,e,t){return this.throwIfDisposed(),TC(this,s,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.reverse=function(s){return this.throwIfDisposed(),bd(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.rfft=function(){return this.throwIfDisposed(),s3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.round=function(){return this.throwIfDisposed(),mC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.rsqrt=function(){return this.throwIfDisposed(),gC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.selu=function(){return this.throwIfDisposed(),bC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.separableConv2d=function(s,e,t,n,r,a){return this.throwIfDisposed(),xC(this,s,e,t,n,r,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sigmoid=function(){return this.throwIfDisposed(),wh(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sign=function(){return this.throwIfDisposed(),UF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sin=function(){return this.throwIfDisposed(),yC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sinh=function(){return this.throwIfDisposed(),wC(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.slice=function(s,e){return this.throwIfDisposed(),Hr(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.softmax=function(s){return this.throwIfDisposed(),pw(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.softplus=function(){return this.throwIfDisposed(),pf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.spaceToBatchND=function(s,e){return this.throwIfDisposed(),uw(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.split=function(s,e){return this.throwIfDisposed(),Ki(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sqrt=function(){return this.throwIfDisposed(),Lo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.square=function(){return this.throwIfDisposed(),Qr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.squaredDifference=function(s){return this.throwIfDisposed(),a3(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.squeeze=function(s){return this.throwIfDisposed(),mf(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.stack=function(s,e){this.throwIfDisposed();const t=s instanceof _a?[this,s]:[this,...s];return xl(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.step=function(s){return this.throwIfDisposed(),gf(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.stridedSlice=function(s,e,t,n,r,a,o,i){return this.throwIfDisposed(),l3(this,s,e,t,n,r,a,o,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sub=function(s){return this.throwIfDisposed(),Ds(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.sum=function(s,e){return this.throwIfDisposed(),Cs(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.tan=function(){return this.throwIfDisposed(),h3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.tanh=function(){return this.throwIfDisposed(),Xy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.tile=function(s){return this.throwIfDisposed(),Lu(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.toBool=function(){return this.throwIfDisposed(),as(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.toFloat=function(){return this.throwIfDisposed(),as(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.toInt=function(){return this.throwIfDisposed(),as(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.topk=function(s,e){return this.throwIfDisposed(),m3(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.transpose=function(s){return this.throwIfDisposed(),br(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.unique=function(s){return this.throwIfDisposed(),x3(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.unsortedSegmentSum=function(s,e){return this.throwIfDisposed(),_C(this,s,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.unstack=function(s){return this.throwIfDisposed(),xd(this,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.where=function(s,e){return this.throwIfDisposed(),Po(s,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ln().prototype.zerosLike=function(){return this.throwIfDisposed(),wr(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class uc extends Error{constructor(e){super(e);Object.setPrototypeOf(this,uc.prototype)}}class wu extends Error{constructor(e){super(e);Object.setPrototypeOf(this,wu.prototype)}}class Rt extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Rt.prototype)}}class Xs extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Xs.prototype)}}class Yw extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Yw.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class b_{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wd(s,e){if(Array.isArray(s)){let t=[];for(let n=0;n<e;n++)t=t.concat(s);return t}else{const t=new Array(e);return t.fill(s),t}}function cc(s,e){if(!s)throw new Yw(e)}function Sk(s,e){let t=0;for(const n of s)n===e&&t++;return t}function Zo(s){return s.length===1?s[0]:s}function Zr(s){return Array.isArray(s)?s:[s]}function Dc(s){const t=s.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function nd(s){return s.length<=1||s.indexOf("_")===-1?s:s.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let hu={};function Zw(s){if(s==null)return null;const e={};return e.className=s.getClassName(),e.config=s.getConfig(),e}function O0(s){if(!(s==null||typeof s!="object"))if(Array.isArray(s))s.forEach(e=>O0(e));else{const e=Object.keys(s);for(const t of e){const n=s[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?s[t]=n.value:O0(n))}}}function wf(s,e={},t={},n="object",r=!1){if(typeof s=="string"){const a=s;let o;if(a in t)o=t[a];else if(a in hu)o=hu[a];else if(o=e[a],o==null)throw new Rt(`Unknown ${n}: ${s}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const a=s;if(a.className==null||a.config==null)throw new Rt(`${n}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const o=a.className;let i,u;if(o in t?[i,u]=t[o]:o in hu?[i,u]=hu.className:o in e&&([i,u]=e[o]),i==null)throw new Rt(`Unknown ${n}: ${o}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const c={};for(const p of Object.keys(hu))c[p]=hu[p];for(const p of Object.keys(t))c[p]=t[p];const d=a.config;d.customObjects=c;const h=Object.assign({},hu);for(const p of Object.keys(t))hu[p]=t[p];O0(a.config);const l=u(i,a.config,t,r);return hu=Object.assign({},h),l}else{const c=Object.assign({},hu);for(const h of Object.keys(t))hu[h]=t[h];const d=new i(a.config);return hu=Object.assign({},c),d}}}function qP(s,e){return s<e?-1:s>e?1:0}function om(s,e){return-1*qP(s,e)}function ml(s){if(s==null)return s;const e=[];for(const t of s)e.indexOf(t)===-1&&e.push(t);return e}function KP(s){if(s==null)throw new Rt(`Invalid value in obj: ${JSON.stringify(s)}`);for(const e in s)if(s.hasOwnProperty(e))return!1;return!0}function Rd(s,e,t){if(t!=null&&s.indexOf(t)<0)throw new Rt(`${t} is not a valid ${e}.  Valid values are ${s} or null/undefined.`)}function Qw(s,e,t=0,n=1/0){return cc(t>=0),cc(n>=t),Array.isArray(s)&&s.length>=t&&s.length<=n&&s.every(r=>typeof r===e)}function Za(s,e){Array.isArray(s)?(ze(s.length>0,()=>`${e} is unexpectedly an empty array.`),s.forEach((t,n)=>Za(t,`element ${n+1} of ${e}`))):ze(Number.isInteger(s)&&s>0,()=>`Expected ${e} to be a positive integer, but got ${x_(s)}.`)}function x_(s){return s===null?"null":Array.isArray(s)?"["+s.map(e=>x_(e)).join(",")+"]":typeof s=="string"?`"${s}"`:`${s}`}function XP(s,e,t){let n=t!=null?t():Yo(),r;return(...o)=>{const i=t!=null?t():Yo();return i-n<e||(n=i,r=s(...o)),r}}function y_(s){return s==="relu"?"relu":s==="linear"?"linear":s==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let YP=0;function w_(){return YP++}const im={};function gb(s=""){return s in im||(im[s]=0),im[s]+=1,s+im[s].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ZP=["channelsFirst","channelsLast"],QP=["nearest","bilinear"],JP=["valid","same","causal"],eL=["max","avg"],tL=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ud=new Map;function va(s){Rd(ZP,"DataFormat",s)}function nL(s){Rd(QP,"InterpolationFormat",s)}function Zi(s){Rd(JP,"PaddingMode",s)}function v_(s){Rd(eL,"PoolMode",s)}const tp=[],$k="/";function ud(s,e){tp.push(s);try{const t=e();return tp.pop(),t}catch(t){throw tp.pop(),t}}function sL(){return tp.length===0?"":tp.join($k)+$k}function k_(s){if(!C_(s))throw new Error("Not a valid tensor name: '"+s+"'");return sL()+s}function I_(s){if(!C_(s))throw new Error("Not a valid tensor name: '"+s+"'");Ud.has(s)||Ud.set(s,0);const e=Ud.get(s);if(Ud.set(s,Ud.get(s)+1),e>0){const t=`${s}_${e}`;return Ud.set(t,1),t}else return s}const rL=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function C_(s){return!!s.match(rL)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function aL(s){return s===parseInt(s.toString(),10)}function gl(s,e,t){e==null&&(e=0),t==null&&(t=s.length);let n=1;for(let r=e;r<t;++r)n*=s[r];return n}function ch(s){if(s.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<s.length;t++){const n=s[t];n<e&&(e=n)}return e}function yl(s){if(s.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<s.length;t++){const n=s[t];n>e&&(e=n)}return e}function Uu(s,e){if(e<s)throw new Rt(`end (${e}) < begin (${s}) is forbidden.`);const t=[];for(let n=s;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let H1;function Oa(){return H1==null&&(H1=CR().epsilon()),H1}function ju(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bc(s,e){return as(s,e)}function vf(s,e=-1){const t=s.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),zt(s,t)}function oL(s,e){return Qt(()=>{if(s.shape.length!==2)throw new Rt(`repeat() expects a rank-2 tensor, but received a rank-${s.shape.length} tensor.`);const t=vf(s,1);return F0(t,[1,e,1])})}function iL(s){const e=[gl(s.shape)];return zt(s,e)}function uL(s){if(s.rank<=1)throw new Rt(`batchFlatten requires a minimum rank of 2. Got rank: ${s.rank}.`);const e=[s.shape[0],gl(s.shape,1)];return zt(s,e)}function cd(s,e,t){return Qt(()=>{switch(s.rank){case 1:return dw(s,e,t);case 2:return vC(s,[e,0],[t,s.shape[1]]);case 3:return hw(s,[e,0,0],[t,s.shape[1],s.shape[2]]);case 4:return Pm(s,[e,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3]]);case 5:return Hr(s,[e,0,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3],s.shape[4]]);case 6:return Hr(s,[e,0,0,0,0,0],[t,s.shape[1],s.shape[2],s.shape[3],s.shape[4],s.shape[5]]);default:throw new Rt(`sliceAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}})}function q1(s,e,t){return Qt(()=>{switch(s.rank){case 1:return dw(s,e,t);case 2:return vC(s,[0,e],[s.shape[0],t]);case 3:return hw(s,[0,0,e],[s.shape[0],s.shape[1],t]);case 4:return Pm(s,[0,0,0,e],[s.shape[0],s.shape[1],s.shape[2],t]);default:throw new Rt(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function um(s,e,t,n){return Qt(()=>{switch(s.rank){case 1:return dw(s,e,t);case 2:switch(n){case 1:return cd(s,e,t);case 2:return q1(s,e,t);default:throw new Rt(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return cd(s,e,t);case 2:return hw(s,[0,e,0],[s.shape[0],t,s.shape[2]]);case 3:return q1(s,e,t);default:throw new Rt(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return cd(s,e,t);case 2:return Pm(s,[0,e,0,0],[s.shape[0],t,s.shape[2],s.shape[3]]);case 3:return Pm(s,[0,0,e,0],[s.shape[0],s.shape[1],t,s.shape[3]]);case 4:return q1(s,e,t);default:throw new Rt(`The axis is not within the rank of the tensor ${n}`)}default:throw new Rt(`sliceAlongLastAxis() received an unsupported tensor rank: ${s.rank}`)}})}function Jw(s,e=-1){let t;return e<0&&(t=s[0].rank,t!==0?e=t:e=0),e===s[0].rank&&(e=-1),Qo(s,e)}function Tk(s,e){switch(s.rank){case 1:return CA([s,e]);case 2:return SA([s,e],0);case 3:return TA([s,e],0);case 4:return EA([s,e],0);default:throw new Rt(`concatAlongFirstAxis() received an unsupported tensor rank: ${s.rank}`)}}function F0(s,e){if(Array.isArray(e)||(e=[e]),s.rank!==e.length)throw new Rt(`The length of input n (${e.length}) does not match the number of dimensions in input x (${s.rank})`);return Lu(s,e)}function bb(s,e=0,t=1,n,r){return EF(s,e,t,n,r)}function xc(s,e,t,n){if(s.rank<2||e.rank<2)throw new Xs(`dot requires both inputs to be rank >= 2 but got x shape = ${s.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=s.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(r!==a)throw new Xs(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${s.shape} and  y shape = ${e.shape}`)}if(s.rank===2&&e.rank===2)return lk({a:s,b:e,transposeA:!1,transposeB:!1,bias:n?D0(s.rank,n,ju()):null,activation:t});{const r=s.shape.slice(),a=r.pop();s=zt(s,[-1,a]);const o=e.shape.slice(),i=o.pop(),u=o.pop(),c=[...o,i],d=Array.from({length:e.rank},(f,x)=>x===0?e.rank-2:x<=e.rank-2?x-1:x);e=zt(br(e,d),[u,-1]);const h=[...r,...c];return zt(lk({a:s,b:e,transposeA:!1,transposeB:!1,bias:n?D0(s.rank,n,ju()):null,activation:t}),h)}}function __(s,e,t){return Qt(()=>(Array.isArray(e)?e=Hi(e,"int32"):e=as(e,"int32"),tw(s,e,t)))}function kf(s){return Ft(s,s)}function D0(s,e,t){const n=e.shape;if(e.rank!==1&&e.rank!==s)throw new Rt(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${s}`);if(s===5){if(t==="channelsFirst")return n.length===1?zt(e,[1,n[0],1,1,1]):zt(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?zt(e,[1,1,1,1,n[0]]):zt(e,[1].concat(n))}else if(s===4){if(t==="channelsFirst")return n.length===1?zt(e,[1,n[0],1,1]):zt(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?zt(e,[1,1,1,n[0]]):zt(e,[1].concat(n))}else if(s===3){if(t==="channelsFirst")return n.length===1?zt(e,[1,n[0],1]):zt(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?zt(e,[1,1,n[0]]):zt(e,[1].concat(n))}else if(s<3)return e;throw new Rt(`Unsupported input rank by biasAdd: ${e.rank}`)}function qu(s,e,t){return Qt(()=>(t==null&&(t=ju()),va(t),Bn(s,D0(s.rank,e,t))))}function cL(s,e=1){if(e!==1)throw new Xs(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return cb(s)}function lL(s){return Qt(()=>_s(s,Bn(Fo(s),1)))}function S_(s,e,t,n){return Qt(()=>_3(s,e,t,n))}function dL(s){return Qt(()=>{const e=Bn(.5,Ft(.2,s));return Xi(e,0,1)})}function If(s,e,t=!1){return t?s():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hL=["fanIn","fanOut","fanAvg"],pL=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fL(s){Rd(hL,"FanMode",s)}function mL(s){Rd(pL,"Distribution",s)}class _u extends Ih{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class $_ extends _u{apply(e,t){return Ya(e,t)}}$_.className="Zeros";An($_);class ev extends _u{apply(e,t){return $d(e,t)}}ev.className="Ones";An(ev);class T_ extends _u{constructor(e){super();if(typeof e!="object")throw new Rt(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Rt(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Qt(()=>Ft(Rr(this.value),$d(e,t)))}getConfig(){return{value:this.value}}}T_.className="Constant";An(T_);class N_ extends _u{constructor(e){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ff(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}N_.className="RandomUniform";An(N_);class E_ extends _u{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xs(`randomNormal does not support dType ${t}.`);return bb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}E_.className="RandomNormal";An(E_);class R_ extends _u{constructor(e){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xs(`truncatedNormal does not support dType ${t}.`);return CC(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}R_.className="TruncatedNormal";An(R_);class A_ extends _u{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return Qt(()=>{if(e.length!==2||e[0]!==e[1])throw new Rt("Identity matrix initializer can only be used for 2D square matrices.");return Ft(this.gain,tC(e[0]))})}getConfig(){return{gain:this.gain}}}A_.className="Identity";An(A_);function gL(s,e="channelsLast"){let t,n;if(va(e),s.length===2)t=s[0],n=s[1];else if([3,4,5].indexOf(s.length)!==-1){if(e==="channelsFirst"){const r=gl(s,2);t=s[1]*r,n=s[0]*r}else if(e==="channelsLast"){const r=gl(s,0,s.length-2);t=s[s.length-2]*r,n=s[s.length-1]*r}}else{const r=gl(s);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}class ki extends _u{constructor(e){super();if(e.scale<0)throw new Rt(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,fL(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,mL(this.distribution),this.seed=e.seed}apply(e,t){const n=gL(e),r=n[0],a=n[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,r):this.mode==="fanOut"?o/=Math.max(1,a):o/=Math.max(1,(r+a)/2),this.distribution==="normal"){const i=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Xs(`${this.getClassName()} does not support dType ${t}.`);return CC(e,0,i,t,this.seed)}else{const i=Math.sqrt(3*o);return ff(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}ki.className="VarianceScaling";An(ki);class tv extends ki{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ki.className}}tv.className="GlorotUniform";An(tv);class nv extends ki{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ki.className}}nv.className="GlorotNormal";An(nv);class sv extends ki{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ki.className}}sv.className="HeNormal";An(sv);class rv extends ki{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ki.className}}rv.className="HeUniform";An(rv);class av extends ki{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ki.className}}av.className="LeCunNormal";An(av);class ov extends ki{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ki.className}}ov.className="LeCunUniform";An(ov);class O_ extends _u{constructor(e){super();this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Qt(()=>{if(e.length<2)throw new Xs("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const n=hn(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const o=[Math.max(r,n),Math.min(r,n)],i=bb(o,0,1,t,this.seed),u=yD.qr(i,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return c=Ft(c,h.sign()),n<r&&(c=c.transpose()),Ft(Rr(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}O_.className="Orthogonal";An(O_);const Nk={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Ek(s,e={}){return wf(s,gu.getMap().classNameMap,e,"initializer")}function da(s){return Zw(s)}function aa(s){if(typeof s=="string"){const e=s in Nk?Nk[s]:s;if(e==="GlorotNormal")return new nv;if(e==="GlorotUniform")return new tv;if(e==="HeNormal")return new sv;if(e==="HeUniform")return new rv;if(e==="LeCunNormal")return new av;if(e==="LeCunUniform")return new ov;{const t={};return t.className=e,t.config={},Ek(t)}}else return s instanceof _u?s:Ek(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function M0(s){return Array.isArray(s)&&Array.isArray(s[0])}function Lm(s){return s.length===0?[]:Array.isArray(s[0])?s:[s]}function Rs(s){let e;if(Array.isArray(s)){if(s.length!==1)throw new Rt(`Expected Tensor length to be 1; got ${s.length}`);e=s[0]}else e=s;return e}function kr(s){if(Array.isArray(s)&&Array.isArray(s[0])){if(s.length===1)return s=s,s[0];throw new Rt(`Expected exactly 1 Shape; got ${s.length}`)}else return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Bm(s){let e=0;for(const t of s)t.shape.length===0?e+=1:e+=t.shape.reduce((n,r)=>n*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Rk="Variable";class bL{constructor(e,t="float32",n=Rk,r=!0,a=null){this.dtype=t==null?"float32":t,this.shape=e.shape,this.id=w_(),n=n==null?Rk:n,this.originalName=k_(n),this.name=I_(this.originalName),this.trainable_=r,this.constraint=a,this.val=v3(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),xL(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function xL(s,e){if(s.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(s.shape)+" vs. "+JSON.stringify(e.shape))}function P0(s){return s.map(e=>e.read())}function iv(s){s.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Fa{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class dc{constructor(e,t,n,r,a,o,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=w_(),o!=null&&(this.originalName=k_(o),this.name=I_(this.originalName)),this.rank=t.length}}let yL=0;class xb{constructor(e,t){this.callArgs=t,this.id=yL++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let wL=0;class sr extends Ih{constructor(e={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=wL++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const n=this.getClassName();t=Dc(n)+"_"+gb(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new wu(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Rt(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Zo(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Zo(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new uc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new uc(`Layer ${this.name} is not connected, no input to return.`);return Zo(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new uc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new uc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Zo(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Zr(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=Zr(this.inputSpec);if(e.length!==t.length)throw new Rt(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){const r=e[n],a=t[n];if(a==null)continue;const o=r.rank;if(a.ndim!=null&&o!==a.ndim)throw new Rt(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new Rt(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new Rt(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&r.dtype!==a.dtype)throw new Rt(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){const i=r.shape;for(const u in a.axes){const c=Number(u),d=a.axes[u],h=c>=0?i[c]:i[i.length+c];if(d!=null&&[d,null].indexOf(h)===-1)throw new Rt(`Input ${n} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${i}.`)}}if(a.shape!=null)for(let i=0;i<a.shape.length;++i){const u=a.shape[i],c=r.shape[i];if(u!=null&&c!=null&&u!==c)throw new Rt(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Zr(e);let r=!0;for(const o of n)if(!(o instanceof dc)){r=!1;break}let a=!0;for(const o of n)if(o instanceof dc){a=!1;break}if(r===a)throw new Rt("Arguments to apply() must be all SymbolicTensors or all Tensors");return ud(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const i of Zr(e))o.push(i.shape);this.build(Zo(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let o=this.call(e,t);const i=Zr(o),u=[];for(let c of i)n.indexOf(c)!==-1&&(c=c.clone()),u.push(c);if(o=Zo(u),this.activityRegularizer!=null)throw new Xs("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=vL(e),i=this.computeOutputShape(o);let u;const c=kL(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),i!=null&&i.length>0&&Array.isArray(i[0])?u=i.map((d,h)=>new dc(c,d,this,Zr(e),t,this.name,h)):u=new dc(c,i,this,Zr(e),t,this.name),this.addInboundNode(e,u,null,null,o,i,t),this._refCount++,this.activityRegularizer!=null)throw new Xs("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new uc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new uc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new wu(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Bm(this.weights)}build(e){this.built=!0}getWeights(e=!1){return P0(e?this.trainableWeights:this.weights)}setWeights(e){Qt(()=>{const t=this.weights;if(t.length!==e.length)throw new Rt(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const n=[],r=P0(t);for(let a=0;a<r.length;++a){const o=r[a],i=t[a],u=e[a];if(!Er(o.shape,u.shape))throw new Rt(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);n.push([i,u])}iv(n)})}addWeight(e,t,n,r,a,o,i,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new Rt(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():aa("zeros"));const c=r.apply(t,n),d=new bL(c,n,e,o,i);return c.dispose(),a!=null&&this.addLoss(()=>a.apply(d.read())),o==null&&(o=!0),o?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Zr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,r,a,o,i=null){const u=Zr(e);t=Zr(t),n=Zr(n),r=Zr(r),a=Lm(a),o=Lm(o);const c=[],d=[],h=[];for(const l of u)c.push(l.sourceLayer),d.push(l.nodeIndex),h.push(l.tensorIndex);new xb({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:h,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:o},i);for(let l=0;l<t.length;l++)t[l].sourceLayer=this,t[l].nodeIndex=this.inboundNodes.length-1,t[l].tensorIndex=l}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function vL(s){s=Zr(s);const e=[];for(const t of s)e.push(t.shape);return Zo(e)}function kL(s){return"float32"}function F_(s,e,t){if((e==null||t!=null&&t>0)&&(e=s.sourceLayer,t=s.nodeIndex),e.inboundNodes.length===0)return[s];{const n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{const r=[];for(let a=0;a<n.inboundLayers.length;a++){const o=n.inputTensors[a],i=n.inboundLayers[a],u=n.nodeIndices[a],c=F_(o,i,u);for(const d of c)r.indexOf(d)===-1&&r.push(d)}return r}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Cf extends sr{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:gb("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Rt("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Rt("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Rt("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new dc(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new xb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Rt(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Cf.className="InputLayer";An(Cf);function IL(s){if(s.batchShape==null&&s.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(s.batchShape!=null&&s.shape!=null)throw new Rt("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=s.batchShape;s.shape!=null&&e==null&&(e=[null].concat(s.shape));let t=s.dtype;return t==null&&(t="float32"),new Cf({batchInputShape:e,name:s.name,dtype:t,sparse:s.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CL(s,e){if(s.dtype==null||s.dtype===e.dtype)return e;try{return as(e,s.dtype)}catch{throw new Rt(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${s.name}' (${s.dtype}).`)}}class dl{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof dl)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=CL(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new Rt(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof dc){if(this.id2Value[e.id]==null)throw new Rt(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Rt(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof dc){if(this.id2Value[e.id]==null)throw new Rt(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Rt(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&ir(this.id2Mask)}}const zm=new b_,Wm=new b_;function _L(s){zm!=null&&zm.setMaxEntries(s),Wm!=null&&Wm.setMaxEntries(s)}function Yh(s,e,t,n){const r=t==null?!1:t.training,a=Array.isArray(s),o=a?s:[s],i=o.map(f=>f.name),u=[],c=e.names();for(const f of i)c.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);const d=i.join(",")+"|"+e.names().sort().join(",");let h=zm.get(d),l;if(h==null){const f=SL(o,e);h=f.sorted,l=f.recipientCounts,zm.put(d,h),Wm.put(d,l)}l={},r||Object.assign(l,Wm.get(d));const p=new dl(e);for(let f=0;f<h.length;++f){if(n!=null){const V=S0().numTensors;V>n.maxNumTensors&&(n.maxNumTensors=V),V<n.minNumTensors&&(n.minNumTensors=V)}const x=h[f],b=x.sourceLayer;if(b instanceof Cf)continue;const m=[],I=[],N=[];let E=!1;for(const V of x.inputs){const P=p.getValue(V),oe=p.getMask(V);m.push(P),I.push(oe),oe!=null&&(E=!0),r||(l[V.name]--,l[V.name]===0&&!e.hasKey(V)&&i.indexOf(V.name)===-1&&!P.isDisposed&&V.sourceLayer.stateful!==!0&&N.push(P))}E&&(t=t||{},t.mask=I[0]);const D=Zr(b.apply(m,t));let U=null;b.supportsMasking&&(U=b.computeMask(m,I));const L=TL(x),Y=Array.isArray(L)?L:[L];for(let V=0;V<Y.length;++V){p.hasKey(Y[V])||p.add(Y[V],D[V],Array.isArray(U)?U[0]:U);const P=i.indexOf(Y[V].name);P!==-1&&(u[P]=D[V])}r||ir(N)}return p.disposeMasks(),a?u:u[0]}function SL(s,e){ze(s!=null&&s.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(s.length===1){const r=Ak(s[0],e);t=r.sorted,n=r.recipientMap}else{const r=new Set;for(const a of s){const{sorted:o,recipientMap:i}=Ak(a,e);for(const u of o)r.has(u.name)||(t.push(u),r.add(u.name));for(const u in i)n[u]==null&&(n[u]=new Set),i[u].forEach(c=>n[u].add(c))}}return{sorted:t,recipientCounts:$L(n)}}function $L(s){const e={};for(const t in s)e[t]=s[t].size;return e}function Ak(s,e){const t=new Set,n=[],r={};for(const i of e.names())t.add(i);const a=[],o=[];for(a.push(s);a.length>0;){const i=a[a.length-1];if(t.has(i.name)){a.pop();continue}const u=o[o.length-1]===a.length-1;if(i.inputs.length===0||u)a.pop(),n.push(i),t.add(i.name),u&&o.pop();else{o.push(a.length-1);for(const c of i.inputs)r[c.name]==null&&(r[c.name]=new Set),r[c.name].add(i.name),!t.has(c.name)&&a.push(c)}}return{sorted:n,recipientMap:r}}function TL(s){let e;if(s.sourceLayer.inboundNodes.length===1)e=s.sourceLayer.output;else{let t=null;for(let n=0;n<s.sourceLayer.inboundNodes.length;++n)for(const r of s.sourceLayer.inboundNodes[n].outputTensors)if(r.id===s.id){t=n;break}e=s.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NL=nn();NL.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,_L);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uv(s,e){return Qt(()=>Lo(Cs(Ft(s,s),e,!0)))}class _f extends Ih{getConfig(){return{}}}class D_ extends _f{constructor(e){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Qt(()=>{const t=uv(e,this.axis),n=Xi(t,0,this.maxValue);return Ft(e,_s(n,Bn(Oa(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}D_.className="MaxNorm";An(D_);class M_ extends _f{constructor(e){super();this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Qt(()=>_s(e,Bn(Oa(),uv(e,this.axis))))}getConfig(){return{axis:this.axis}}}M_.className="UnitNorm";An(M_);class P_ extends _f{apply(e){return Nd(e)}}P_.className="NonNeg";An(P_);class L_ extends _f{constructor(e){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Qt(()=>{const t=uv(e,this.axis),n=Bn(Ft(this.rate,Xi(t,this.minValue,this.maxValue)),Ft(1-this.rate,t));return Ft(e,_s(n,Bn(Oa(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}L_.className="MinMaxNorm";An(L_);const Ok={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Da(s){return Zw(s)}function Fk(s,e={}){return wf(s,gu.getMap().classNameMap,e,"constraint")}function Ma(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in Ok?Ok[s]:s,config:{}};return Fk(t)}else return s instanceof _f?s:Fk(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Zl(s){if(s==null)return;const e=[],t=[],n=[];for(const r in s){const a=s[r];if(typeof a!="number"){const o=a;e.push(o.data()),t.push(r),n.push(o)}}if(e.length>0){const r=await Promise.all(e);for(let a=0;a<r.length;++a)s[t[a]]=r[a][0];ir(n)}}function B_(s){if(s!=null)for(const e in s){const t=s[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Dk;(function(s){s[s.SILENT=0]="SILENT",s[s.VERBOSE=1]="VERBOSE"})(Dk||(Dk={}));const EL=125;class op{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class RL{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class AL extends op{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const n=t.size==null?0:t.size;this.seen+=n;for(const r in t){const a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let o;r in this.totals?o=this.totals[r]:this.totals[r]=0;const i=Qt(()=>Bn(this.totals[r],Ft(a,n)));this.totals[r]=i,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:Qt(()=>{const r=Ft(_s(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),mc(t[n])}))}}class OL extends op{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const o=this.history[a];for(let i=0;i<o.length;++i)if(typeof o[i]!="number"){const u=o[i];e.push(u.data()),t.push(a),n.push(i)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}class FL extends op{constructor(e,t){super();if(this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||jC,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=EL),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");l0(this.yieldEvery)&&(this.maybeWait=XP(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];this.yield!=null&&(await Zl(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Zl(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];this.epochEnd!=null&&(await Zl(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Zl(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];this.batchEnd!=null&&(await Zl(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):l0(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Zl(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Zl(e),await this.trainEnd(e))}}function z_(s,e){return s==null&&(s={}),s instanceof op?[s]:Array.isArray(s)&&s[0]instanceof op?s:Zr(s).map(n=>new FL(n,e))}class fu{constructor(){}static registerCallbackConstructor(e,t){ze(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),fu.checkForDuplicate(t),fu.constructors[e]==null&&(fu.constructors[e]=[]),fu.constructors[e].push(t)}static checkForDuplicate(e){for(const t in fu.constructors)fu.constructors[+t].forEach(r=>{if(r===e)throw new Rt("Duplicate callback constructor.")})}static clear(){fu.constructors={}}static createCallbacks(e){const t=[];for(const n in fu.constructors){const r=+n;e>=r&&t.push(...fu.constructors[r])}return t.map(n=>new n)}}fu.constructors={};function W_(s,e,t,n,r,a,o,i,u){const c=new OL,d=[new AL,...fu.createCallbacks(e)];s!=null&&d.push(...s),d.push(c);const h=new RL(d);return h.setParams({epochs:t,initialEpoch:n,samples:r,steps:a,batchSize:o,verbose:e,doValidation:i,metrics:u}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lc(s,e={},t=!1){return wf(s,gu.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vm(s,e){return Qt(()=>{s.dtype!=="float32"&&(s=as(s,"float32"));const t=Cs(kf(s),e,!0),n=ub(t.shape,Oa()),r=Lo(Tl(t,n));return _s(s,r)})}function yb(s,e){return Qt(()=>Sa(kf(Ds(e,s)),-1))}function cv(s,e){return Qt(()=>Sa(Fo(Ds(e,s)),-1))}function lv(s,e){return Qt(()=>{const t=Ds(s,e),n=Xi(Fo(s),Oa(),Number.MAX_VALUE),r=Fo(_s(t,n));return Ft(100,Sa(r,-1))})}function DL(s,e){return Qt(()=>{const t=Xi(e,Oa(),Number.MAX_VALUE),n=wc(Bn(1,t)),r=Xi(s,Oa(),Number.MAX_VALUE),a=wc(Bn(1,r));return Sa(kf(Ds(n,a)),-1)})}function ML(s,e){return Qt(()=>{const t=Tl(0,Ds(1,Ft(s,e)));return Sa(kf(t),-1)})}function PL(s,e){return Qt(()=>{const t=Tl(0,Ds(1,Ft(s,e)));return Sa(t,-1)})}function LL(s,e){return Qt(()=>{const t=Cs(Ft(s,e),-1),n=zu(Ft(Ds(1,s),e),-1);return Tl(0,Bn(1,Ds(n,t)))})}function BL(s,e){return Qt(()=>{const t=Math.log(2),n=Ds(e,s),r=Ds(Bn(n,pf(Ft(-2,n))),t);return Sa(r,-1)})}function ip(s,e,t=!1){return Qt(()=>{if(t)e=pw(e);else{const n=Cs(e,e.shape.length-1,!0);e=_s(e,n)}return e=Xi(e,Oa(),1-Oa()),xa(Cs(Ft(as(s,"float32"),wc(e)),e.shape.length-1))})}function Um(s,e,t=!1){return Qt(()=>{const n=as(db(iL(s)),"int32");e=Xi(e,Oa(),1-Oa());const r=e.shape,a=zt(aC(n,r[r.length-1]),r);return ip(a,e,t)})}function zL(s,e){if(!Er(s.shape,e.shape))throw new Rt(`logits and labels must have the same shape, but got shapes ${JSON.stringify(s.shape)} and ${JSON.stringify(e.shape)}`);return Qt(()=>{const t=Nd(e),n=xa(Fo(e));return Bn(Ds(t,Ft(e,s)),nC(zc(n)))})}function wb(s,e){return Qt(()=>{let t;return t=Xi(e,Oa(),1-Oa()),t=wc(_s(t,Ds(1,t))),Sa(zL(s,t),-1)})}function WL(s,e){return Qt(()=>{const t=Xi(s,Oa(),1),n=Xi(e,Oa(),1);return Cs(Ft(s,wc(_s(t,n))),-1)})}function VL(s,e){return Qt(()=>{const t=wc(Bn(Oa(),e));return Sa(Ds(e,Ft(s,t)),-1)})}function V_(s,e){return Qt(()=>{const t=Vm(s,-1),n=Vm(e,-1),r=Ft(t,n);return xa(Cs(r,-1))})}const jm={meanSquaredError:yb,meanAbsoluteError:cv,meanAbsolutePercentageError:lv,meanSquaredLogarithmicError:DL,squaredHinge:ML,hinge:PL,categoricalHinge:LL,logcosh:BL,categoricalCrossentropy:ip,sparseCategoricalCrossentropy:Um,binaryCrossentropy:wb,kullbackLeiblerDivergence:WL,poisson:VL,cosineProximity:V_};function K1(s){if(typeof s=="string"){if(s in jm)return jm[s];let e=`Unknown loss ${s}`;throw s.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${s}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Rt(e)}else return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function U_(s,e){return Qt(()=>{const t=Ft(.5,Iu(e)),n=bc(Yi(e,t),s.dtype);return Sa(yc(s,n),-1)})}function j_(s,e){return Qt(()=>bc(yc(ah(s,-1),ah(e,-1)),"float32"))}function UL(s,e){return Qt(()=>as(Cs(Wc(yc(s,1),yc(e,1))),"float32"))}function jL(s,e){return Qt(()=>as(Cs(Wc(yc(s,0),yc(e,1))),"float32"))}function GL(s,e){return Qt(()=>{const t=UL(s,e),n=jL(s,e),r=Bn(t,n);return as(Po(Yi(r,0),_s(t,r),0),"float32")})}function HL(s,e){return wb(s,e)}function qL(s,e){return s.rank===e.rank&&(s=mf(s,[s.rank-1])),e=ah(e,-1),e.dtype!==s.dtype&&(e=as(e,s.dtype)),as(yc(s,e),"float32")}const KL=yb,XL=yb,YL=cv,ZL=cv,QL=lv,JL=lv,G_=ip,eB=V_,H_=Um,Gm={binaryAccuracy:U_,categoricalAccuracy:j_,precision:GL,categoricalCrossentropy:G_,sparseCategoricalCrossentropy:H_,mse:KL,MSE:XL,mae:YL,MAE:ZL,mape:QL,MAPE:JL,cosine:eB};function tB(s){if(typeof s=="string"&&s in Gm)return Gm[s];if(typeof s!="string"&&s!=null)return s;throw new Rt(`Unknown metric ${s}`)}function cm(s){if(cc(s!==null,`Unknown LossOrMetricFn ${s}`),typeof s=="string")return s;{let e;for(const t of Object.keys(jm))if(jm[t]===s){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Gm))if(Gm[t]===s){e=t;break}return e!==void 0?e:s.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nB(s){const e={Adagrad:()=>Vd.adagrad(.01),Adadelta:()=>Vd.adadelta(1,.95,Oa()),Adam:()=>Vd.adam(.001,.9,.999,Oa()),Adamax:()=>Vd.adamax(.002,.9,.999,Oa(),0),RMSProp:()=>Vd.rmsprop(.001,.9,0,Oa()),SGD:()=>Vd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,s in e)return e[s]();throw new Rt(`Unknown Optimizer ${s}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Mk=1*1024*1024;function Pk(s,e,t=!1){if(s==null||typeof s!="object"||Object.getPrototypeOf(s)!==Object.prototype||!L0(s))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const n=JSON.stringify(s);n.length>Mk&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Mk}.`)}}function L0(s){if(s===null)return!0;if(typeof s=="object")if(Object.getPrototypeOf(s)===Object.prototype){const e=Object.keys(s);for(const t of e)if(typeof t!="string"||!L0(s[t]))return!1;return!0}else if(Array.isArray(s)){for(const e of s)if(!L0(e))return!1;return!0}else return!1;else{const e=typeof s;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sB(s,e,t,n=console.log){const r=aB(s),a=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(d=>Math.floor(e*d)));let o;if(!r){a.push("Receives inputs"),o=[];for(const d in s.nodesByDepth)o.push(...s.nodesByDepth[d])}n("_".repeat(e)),Hm(a,t,n),n("=".repeat(e));const i=s.layers;for(let d=0;d<i.length;++d)r?oB(i[d],t,n):iB(i[d],t,o,n),n((d===i.length-1?"=":"_").repeat(e));s.checkTrainableWeightsConsistency();const u=rB(s),c=Bm(s.nonTrainableWeights);n(`Total params: ${u+c}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${c}`),n("_".repeat(e))}function rB(s){let e;return s.collectedTrainableWeights!=null?e=Bm(s.collectedTrainableWeights):e=Bm(s.trainableWeights),e}function aB(s){let e=!0;const t=[],n=[];for(const r in s.nodesByDepth)t.push(s.nodesByDepth[r]);for(const r of t){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}n.push(...r)}if(e)for(const r of s.layers){let a=!1;for(const o of r.inboundNodes)if(n.indexOf(o)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function Hm(s,e,t=console.log){let n="";for(let r=0;r<s.length;++r)r>0&&(n=n.slice(0,n.length-1)+" "),n+=s[r],n=n.slice(0,e[r]),n+=" ".repeat(e[r]-n.length);t(n)}function oB(s,e,t){let n,r;try{r=s.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{n=JSON.stringify(s.outputShape)}catch{n="multiple"}const a=s.name,o=s.getClassName(),i=[`${a} (${o})`,r,n,s.countParams().toString()];Hm(i,e,t)}function iB(s,e,t,n){let r,a;try{a=s.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(s.outputShape)}catch{r="multiple"}const o=[];for(const h of s.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let l=0;l<h.inboundLayers.length;++l){const p=h.inboundLayers[l].name,f=h.nodeIndices[l],x=h.tensorIndices[l];o.push(`${p}[${f}][${x}]`)}const i=s.name,u=s.getClassName(),c=o.length===0?"":o[0],d=[`${i} (${u})`,a,r,s.countParams().toString(),c];Hm(d,e,n);for(let h=1;h<o.length;++h)Hm(["","","","",o[h]],e,n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function q_(s,e,t){return(s==="inboundNodes"||s==="outputLayers"||s==="inputLayers")&&e===0&&typeof t=="string"}function B0(s,e){if(s===null)return null;if(typeof s=="string")return nd(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const t=[],n=s.length;for(let r=0;r<n;++r){const a=s[r];q_(e,r,a)?t.push(a):t.push(B0(a,e))}return t}else{const t={};for(const n of Object.keys(s)){const r=s[n];if(n==="name"&&typeof r=="string")t[n]=r;else{const a=nd(n);t[a]=B0(r,a)}}return t}}function z0(s,e){if(s==null)return null;if(typeof s=="string")return Dc(s);if(typeof s=="number"||typeof s=="boolean")return s;if(s instanceof Array){const t=[],n=s.length;for(let r=0;r<n;++r){const a=s[r];q_(e,r,a)?t.push(a):t.push(z0(a,e))}return t}else{const t={};for(const n of Object.keys(s)){const r=s[n],a=Dc(n);(n==="name"||n==="className")&&typeof r=="string"?t[a]=r:t[a]=z0(r,n)}return t}}/** @license See the LICENSE file. */const K_="4.5.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Du extends sr{constructor(e){super({});if(this.containerNodes=new Set,this.name=e.name,this.name==null){const I=this.getClassName().toLowerCase();this.name=gb(I)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],ml(this.inputs).length!==this.inputs.length)throw new Rt(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(I=>I.name)}`);ml(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(I=>I.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const I of this.outputs){const N=I.sourceLayer,E=I.nodeIndex,D=I.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(E),this.outputLayersTensorIndices.push(D)}for(const I of this.inputs){const N=I.sourceLayer,E=I.nodeIndex,D=I.tensorIndex;cc(E===0,"input layer has >1 nodes"),cc(D===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(E),this.inputLayersTensorIndices.push(D)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let I=0;I<this.inputLayers.length;I++){const N=this.inputLayers[I];if(!(N instanceof Cf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${I} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(const I of this.outputLayers)this.outputNames.push(I.name);this.internalInputShapes=this.inputs.map(I=>I.shape),this.internalOutputShapes=this.outputs.map(I=>I.shape);const t={},n={},r={},a={},o={},i=[],u=(I,N,E,D,U,L)=>{(D==null||U==null||L==null)&&(D=I.sourceLayer,U=I.nodeIndex,L=I.tensorIndex);const Y=D.inboundNodes[U];if(E.indexOf(Y)!==-1)throw new wu(`The tensor ${I.name} at layer "${D.name}" is part of a cycle.`);if(N.indexOf(Y)!==-1)return;this.containerNodes.add(Du.nodeKey(D,U)),D.id in o||(o[D.id]=Object.keys(o).length),E.indexOf(Y)===-1&&E.push(Y);const V=Y.inboundLayers.length;for(let P=0;P<V;P++){const oe=Y.inputTensors[P],ne=Y.inboundLayers[P],ge=Y.nodeIndices[P],ye=Y.tensorIndices[P];u(oe,N,E,ne,ge,ye)}for(N.push(Y);E.indexOf(Y)>=0;)E.splice(E.indexOf(Y),1);i.push(Y)},c=[],d=[];for(const I of this.outputs)u(I,c,d);const h=i.slice().reverse();for(const I of h){n[I.id]=I,I.id in t||(t[I.id]=0);let N=t[I.id];const E=r[I.outboundLayer.id]==null?0:r[I.outboundLayer.id];N=Math.max(N,E),r[I.outboundLayer.id]=N,a[I.outboundLayer.id]=I.outboundLayer,t[I.id]=N;for(let D=0;D<I.inboundLayers.length;D++){const U=I.inboundLayers[D],L=I.nodeIndices[D],Y=U.inboundNodes[L],V=t[Y.id]==null?0:t[Y.id];t[Y.id]=Math.max(N+1,V),n[Y.id]=Y}}const l={};for(const I in t){const N=t[I];N in l||(l[N]=[]),l[N].push(n[I])}const p={};for(const I in r){const N=r[I];N in p||(p[N]=[]),p[N].push(a[I])}let f=Object.keys(p).map(I=>parseInt(I,10)).sort(om);this.layers=[];for(const I of f){const N=p[I];N.sort((E,D)=>{const U=o[E.id],L=o[D.id];return U<L?-1:U>L?1:0});for(const E of N)E instanceof Du&&this.internalContainerRefs.push(E),this.layers.push(E)}this.layersByDepth=p,f=Object.keys(l).map(I=>parseInt(I,10)).sort(om);const x=this.inputs.slice(),b=[];for(const I of f)for(const N of l[I]){const E=N.outboundLayer;if(E!=null){for(const D of N.inputTensors)if(x.indexOf(D)===-1)throw new wu(`Graph disconnected: cannot obtain value for tensor ${D} at layer "${E.name}". The following previous layers were accessed without issue: ${b}`);for(const D of N.outputTensors)x.push(D);b.push(E.name)}}this.nodesByDepth=l;const m=this.layers.map(I=>I.name);for(const I of m){const N=m.filter(E=>E===I).length;if(N!==1)throw new wu(`The name "${I}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new xb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(I=>null),outputMasks:this.outputs.map(I=>null),inputShapes:this.inputs.map(I=>I.shape),outputShapes:this.outputs.map(I=>I.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Rt("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;for(const o of this.layers)for(const i of o.weights){if(n[i.originalName]!=null)throw new Rt(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,r++}const a=[];for(const o in e){let i=o;if(n[o]==null){const u=o.split("/");i=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[i]!=null)a.push([n[i],e[o]]);else if(t)throw new Rt(`Provided weight data has no target variable: ${o}`);delete n[i]}if(t){const o=[];for(const i in n)o.push(i);if(o.length>0)throw new Rt(`${o.length} of ${r} weights are not set: ${o}`)}iv(a)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${K_}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=z0(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Qt(()=>{e=Zr(e);const n=new dl;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],e[r]);return Yh(this.outputs,n,t)})}computeMask(e,t){return Qt(()=>{e=Zr(e);let n;return t==null?n=wd(null,e.length):n=Zr(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=Lm(e);if(t.length!==this.inputLayers.length)throw new Rt(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const u=this.inputLayers[i],c=t[i],d=u.name+"_0_0";n[d]=c}const r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(om);if(r.length>1)for(const i of r){const u=this.nodesByDepth[i];for(const c of u){const d=c.outboundLayer;if(this.inputLayers.map(x=>x.id).indexOf(d.id)!==-1)continue;const h=[];for(let x=0;x<c.inboundLayers.length;x++){const b=c.inboundLayers[x],m=c.nodeIndices[x],I=c.tensorIndices[x],N=`${b.name}_${m}_${I}`,E=n[N];h.push(E)}const l=d.computeOutputShape(Zo(h)),p=Lm(l),f=d.inboundNodes.indexOf(c);for(let x=0;x<p.length;x++){const b=`${d.name}_${f}_${x}`;n[b]=p[x]}}}const a=[],o=[];for(let i=0;i<this.outputLayers.length;i++){const u=this.outputLayers[i],c=this.outputLayersNodeIndices[i],d=this.outputLayersTensorIndices[i],h=`${u.name}_${c}_${d}`;o.push(h)}for(let i=0;i<o.length;i++){const u=o[i];cc(u in n),a.push(n[u])}return Zo(a)}runInternalGraph(e,t){t==null&&(t=wd(null,e.length));const n={};for(let u=0;u<this.inputs.length;++u){const c=this.inputs[u],d=e[u],h=t[u];n[c.id]=[d,h]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(om);for(const u of r){const c=this.nodesByDepth[u];for(const d of c){const h=d.outboundLayer,l=d.inputTensors,p=d.outputTensors,f=new Array;for(const x of l)x.id in n&&f.push(n[x.id]);if(f.length===l.length){let x={},b,m,I,N;if(d.callArgs!=null&&(x=d.callArgs),f.length===1){const[E,D]=f[0];x.mask==null&&(x.mask=D),I=Zr(h.call(E,x)),N=Zr(h.computeMask(E,D)),b=[E],m=[D]}else b=f.map(E=>E[0]),m=f.map(E=>E[1]),x.mask==null&&(x.mask=m),I=Zr(h.call(b,x)),N=Zr(h.computeMask(b,m));if(h.activityRegularizer)throw new Xs("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let E=0;E<p.length;++E){const D=p[E],U=I[E],L=N[E];n[D.id]=[U,L]}}}}const a=[],o=[],i=[];for(const u of this.outputs){cc(u.id in n,`Could not compute output ${u.name} : ${u.id}`);const[c,d]=n[u.id];i.push(c.shape),a.push(c),o.push(d)}return[a,o,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof Du?1:0;for(let a=0;a<r.inboundNodes.length;a++){const o=Du.nodeKey(r,a);this.containerNodes.has(o)&&(t[o]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new Rt(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new Rt("Provide either a layer name or layer index");for(const n of this.layers)if(n.name===e)return n;throw new Rt(`No such layer: ${e}`)}calculateLosses(){return Qt(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=Du.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const i=o.getClassName(),u=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const l=o.inboundNodes[h],p=Du.nodeKey(o,h);let f={};if(this.containerNodes.has(p)){if(l.callArgs)try{JSON.stringify(l.callArgs),f=l.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${l.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(l.inboundLayers.length>0){const x=[];for(let b=0;b<l.inboundLayers.length;b++){const m=l.inboundLayers[b],I=l.nodeIndices[b],N=l.tensorIndices[b],E=Du.nodeKey(m,I);let D=t[E];D==null&&(D=0),x.push([m.name,D,N,f])}c.push(x)}}}const d={};d.name=o.name,d.className=i,d.config=u,d.inboundNodes=c,n.push(d)}e.layers=n;const r=[];for(let o=0;o<this.inputLayers.length;o++){const i=this.inputLayers[o],u=this.inputLayersNodeIndices[o],c=Du.nodeKey(i,u);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const h=this.inputLayersTensorIndices[o];r.push([i.name,d,h])}e.inputLayers=r;const a=[];for(let o=0;o<this.outputLayers.length;o++){const i=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=Du.nodeKey(i,u);if(!this.containerNodes.has(c))continue;let d=t[c];d==null&&(d=0);const h=this.outputLayersTensorIndices[o];a.push([i.name,d,h])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){const a={},o={};function i(b,m){b.name in o?o[b.name].push(m):o[b.name]=[m]}function u(b,m){const I=[];let N;for(const E of m){const D=E[0],U=E[1],L=E[2];if(N=E[3]==null?{}:E[3],!(D in a)){i(b,m);return}const Y=a[D];if(Y.inboundNodes.length<=U){i(b,m);return}const V=Y.inboundNodes[U];I.push(V.outputTensors[L])}I.length>0&&b.apply(Zo(I),N)}function c(b){const m=b.name,I=Lc(b,t.customObjects!=null?t.customObjects:{});I.setFastWeightInitDuringBuild(r),a[m]=I,b.inboundNodes.forEach(E=>{if(!(E instanceof Array))throw new Rt(`Corrupted configuration, expected array for nodeData: ${E}`);i(I,E)})}const d=t.name,h=t.layers;for(const b of h)c(b);for(;!KP(o);)for(const b of h){const m=a[b.name];if(m.name in o){const I=o[m.name];delete o[m.name];for(const N of I)u(m,N)}}const l=[],p=[],f=t.inputLayers;for(const b of f){const m=b[0],I=b[1],N=b[2];cc(m in a);const D=a[m].inboundNodes[I].outputTensors;l.push(D[N])}const x=t.outputLayers;for(const b of x){const m=b[0],I=b[1],N=b[2];cc(m in a);const D=a[m].inboundNodes[I].outputTensors;p.push(D[N])}return new e({inputs:l,outputs:p,name:d})}get stateful(){if(this._stateful)throw new Rt("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Qt(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function uB(s,e,t){const n=e.length;if(s==null||Array.isArray(s)&&s.length===0)return e.map(r=>null);if(n===1)return Array.isArray(s)&&s.length===1?s:typeof s=="object"&&e[0]in s?[s[e[0]]]:[s];if(Array.isArray(s)){if(s.length!==n)throw new Error(`Provided ${t} is an array of ${s.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return s}else if(typeof s=="object"&&Object.keys(s).length>0&&typeof s[Object.keys(s)[0]]=="object"){const r=[];return e.forEach(a=>{a in s?r.push(s[a]):r.push(null)}),r}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(s)}`)}function X_(s,e){return uB(s,e,"classWeight")}async function Y_(s,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const r=Qt(()=>{if(s.shape.length===1)return id(s);if(s.shape.length===2){if(s.shape[1]>1)return ah(s,1);if(s.shape[1]===1)return zt(s,[s.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${s.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${s.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await r.data());ir(r);const o=[];return a.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);o.push(t[i])}),Hi(o,"float32")}else return null}function cB(s,e){return Ft(s,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lB=32;function Z_(s,e){let t,n;const r=e;t=r.xs,n=r.ys,ze(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=Lk("input",s.inputNames,t),o=Lk("output",s.outputNames,n),i=a[0].shape[0];ze(a.length===s.inputs.length,()=>`LayersModel has ${s.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(s.inputNames)})`),ze(o.length===s.outputs.length,()=>`LayersModel has ${s.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(s.outputNames)})`);for(let u=0;u<a.length;u++)ze(a[u].shape[0]===i,()=>`Batch size mismatch: input ${s.inputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${s.inputNames[0]}.`);for(let u=0;u<o.length;u++)ze(o[u].shape[0]===i,()=>`Batch size mismatch: output ${s.outputNames[u]} has ${o[u].shape[0]}; expected  ${i} based on input ${s.inputNames[0]}.`);return{xs:a,ys:o}}function Lk(s,e,t){if(t instanceof _a)return[t];if(Array.isArray(t))return ze(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${s} keys ${e}.`),t;{const n=[];for(const r of e){if(t[r]==null)throw new Rt(`The feature data generated by the dataset lacks the required ${s} key '${r}'.`);n.push(t[r])}return n}}function dB(s){if(s.length===3)throw new Xs("Validation with sample weights is not implemented yet.");return{xs:s[0],ys:s[1]}}async function hB(s,e,t){const n=t.batchesPerEpoch!=null;if(ze(s.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),ze(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),ze(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),ze(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),ze(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");s.isTraining=!0;try{const r=t.validationData!=null;let a,o;if(r)if(Bk(t.validationData))ze(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const b=dB(t.validationData);a=b.xs,o=b.ys}const i=s.makeTrainFunction(),u=s.getDedupedMetricsNames();let c;r?c=u.slice().concat(u.map(b=>"val_"+b)):c=u.slice();const d=z_(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:l,history:p}=W_(d,h,t.epochs,null,null,pB(e,t),null,r,c);l.setModel(s),s.history=p,await l.onTrainBegin(),s.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,x=await e.iterator();for(;f<t.epochs;){const b={};await l.onEpochBegin(f);let m=0,I=0;for(n||(x=await e.iterator());!n||m<t.batchesPerEpoch;){const N=await x.next();if(n&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${m} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){const{xs:E,ys:D}=Z_(s,N.value),U={};U.batch=I,U.size=E[0].shape[0],await l.onBatchBegin(I,U);const L=[];if(t.classWeight!=null){const P=X_(t.classWeight,s.outputNames);for(let oe=0;oe<P.length;++oe)L.push(await Y_(D[oe],null,P[oe]))}const Y=E.concat(D).concat(L),V=i(Y);ir(Y);for(let P=0;P<u.length;++P){const oe=u[P],ne=V[P];U[oe]=ne,mc(ne)}await l.onBatchEnd(I,U),B_(U),I++,m++}if(n?m>=t.batchesPerEpoch:N.done){if(r){let E;Bk(t.validationData)?E=Zr(await s.evaluateDataset(t.validationData,{batches:t.validationBatches})):E=Zr(s.evaluate(a,o,{batchSize:t.validationBatchSize==null?lB:t.validationBatchSize,verbose:0}));for(let D=0;D<s.metricsNames.length;++D)b[`val_${s.metricsNames[D]}`]=E[D]}break}if(s.stopTraining_)break}if(await l.onEpochEnd(f,b),f++,s.stopTraining_)break}return await l.onTrainEnd(),await s.history.syncData(),s.history}finally{s.isTraining=!1}}function pB(s,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(s.size)&&(t=s.size),t}function Bk(s){return typeof s.iterator=="function"}function fB(s){return typeof s.next=="function"}async function mB(s,e,t){t=t||{};const n=t.batches!=null,r=s.testFunction;let a=[];if(t.verbose>0)throw new Xs("Verbose mode is not implemented yet.");ze(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=fB(e)?e:await e.iterator();let i=0,u=0;for(;!n||u<t.batches;){const c=await o.next();if(a=Qt(()=>{if(c.value){const{xs:d,ys:h}=Z_(s,c.value),l=d.concat(h),p=Qt(()=>r(l));if(ir(l),u===0)for(let x=0;x<p.length;++x)a.push(Rr(0));const f=l[0].shape[0];for(let x=0;x<p.length;++x){const b=p[x],m=a[x];a[x]=Qt(()=>Bn(a[x],Ft(f,b))),u>0&&ir(m)}ir(p),i+=f,++u}return a}),c.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){const d=a[c];a[c]=_s(a[c],i),ir(d)}return Zo(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function X1(s){ze(s>0&&Number.isInteger(s),()=>`batchSize is required to be a positive integer, but got ${s}`)}function Gh(s,e,t){return s==null?[null]:Array.isArray(s)?s.map(n=>cd(n,e,t-e)):cd(s,e,t-e)}function W0(s,e){return Qt(()=>s==null?null:Array.isArray(s)?s.map(t=>W0(t,e)):__(s,e.dtype==="int32"?e:as(e,"int32")))}function Y1(s,e){const t=[];let n=0,r=null;for(;n<s;)r=n+e,r>=s&&(r=s),t.push([n,r]),n=r;return t}function Q_(s){const e=[];s instanceof _a&&(s=[s]);for(let t=0;t<s.length;++t){const n=s[t];if(n.rank===1)e.push(vf(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function Fu(s,e){if(s==null)return;const t=[];if(e instanceof _a)t.push(e.id);else if(Array.isArray(e))e.forEach(r=>t.push(r.id));else if(e!=null)for(const r in e){const a=e[r];t.push(a.id)}const n=[];if(s instanceof _a)t.indexOf(s.id)===-1&&n.push(s);else if(Array.isArray(s))s.forEach(r=>{t.indexOf(r.id)===-1&&n.push(r)});else if(s!=null)for(const r in s){const a=s[r];t.indexOf(a.id)===-1&&n.push(a)}n.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gB(s){return s instanceof _a}function V0(s){return Array.isArray(s)}function zk(s){return!gB(s)&&!V0(s)}function Wk(s,e,t,n=!0,r=""){if(e==null||e.length===0){if(s!=null){let o=!1;if(V0(s)&&s.length>0)o=!0;else if(zk(s)){for(const i in s)if(s.hasOwnProperty(i)){o=!0;break}}else o=!0;if(o)throw new Rt(`Error when checking model ${r} expected no data, but got ${s}`)}return[]}if(s==null)return e.map(o=>null);let a;if(zk(s)){s=s,a=[];for(const o of e){if(s[o]==null)throw new Rt(`No data provided for "${o}". Need data for each key in: ${e}`);a.push(s[o])}}else if(V0(s)){if(s=s,s.length!==e.length)throw new Rt(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${s}`);a=s}else{if(s=s,e.length>1)throw new Rt(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${s.shape}`);a=[s]}if(a=Q_(a),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const i=a[o];if(i.shape.length!==t[o].length)throw new Rt(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<t[o].length;++u){if(u===0&&!n)continue;const c=i.shape[u],d=t[o][u];if(d!=null&&d>=0&&c!==d)throw new Rt(`${r} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${r} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function bB(s,e,t){const n=ml(s.map(a=>a.shape[0]));n.sort();const r=ml(e.map(a=>a.shape[0]));if(r.sort(),n.length>1)throw new Rt(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(s.map(a=>a.shape))}`);if(r.length>1)throw new Rt(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(n.length>0&&r.length>0&&!Er(n,r))throw new Rt(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}function xB(s,e,t){const n=[yb,wb,ip];for(let r=0;r<s.length;++r){const a=s[r],o=e[r],i=t[r];if(o!=null){if(o===ip&&a.shape[a.shape.length-1]===1)throw new Rt(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(o)!==-1){const u=a.shape.slice(1),c=i.slice(1);for(let d=0;d<u.length;++d){const h=u[d],l=c[d];if(l!=null&&h!==l)throw new Rt(`A target Tensor with shape ${a.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function Vk(s,e,t,n=!0,r=""){let a;if(Array.isArray(s)){if(s.length!==e.length)throw new Rt(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${s.length} Tensors(s).`);a=s}else{if(e.length>1)throw new Rt(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(s.shape)}.`);a=[s]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const i=a[o];if(i.shape.length!==t[o].length)throw new Rt(`Error when checking ${r}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<t[o].length;++u){if(u===0&&!n)continue;const c=i.shape[u],d=t[o][u];if(d!=null&&d!==c)throw new Rt(`Error when checking ${r}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function yB(s,e){if(s==null||Array.isArray(s)&&s.length===0)return e.map(n=>[]);let t;if(typeof s=="string"||typeof s=="function")t=[s];else if(Array.isArray(s)||typeof s=="object")t=s;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${s}`);if(Array.isArray(t))return e.map(n=>t);{const n=[];for(const r of e){let a=t.hasOwnProperty(r)?t[r]:[];Array.isArray(a)||(a=[a]),n.push(a)}return n}}const wB="layers-model";class Qd extends Du{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Rt("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");sB(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=nB(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Nl))throw new Rt("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new Rt(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(K1(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Rt(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>K1(i))}else{const o=K1(e.loss);this.outputs.forEach(i=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const i=this.internalOutputShapes[o],u=this.outputNames[o];this.feedOutputNames.push(u),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ud("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;const i=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([i,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const r=yB(e.metrics,this.outputNames),a=(o,i,u)=>{this.outputNames.length>1&&(i=this.outputNames[o]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([u,o])};ud("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(n.indexOf(o)!==-1)continue;const i=r[o];(c=>{const d="";let h,l,p;for(const f of c){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const b=this.internalOutputShapes[o];b[b.length-1]===1||this.lossFunctions[o]===wb?["accuracy","acc"].indexOf(f)!==-1?l=U_:["crossentropy","ce"].indexOf(f)!==-1&&(l=HL):this.lossFunctions[o]===Um?["accuracy","acc"].indexOf(f)!==-1?l=qL:["crossentropy","ce"].indexOf(f)!==-1&&(l=H_):["accuracy","acc"].indexOf(f)!==-1?l=j_:["crossentropy","ce"].indexOf(f)!==-1&&(l=G_);let m;["accuracy","acc"].indexOf(f)!==-1?m="acc":["crossentropy","ce"].indexOf(f)!==-1&&(m="ce"),p=l,h=d+m}else p=tB(f),h=d+cm(f);let x;ud(h,()=>{x=p}),a(o,h,x)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=n.batchSize==null?32:n.batchSize;X1(r);const a=!0,o=this.standardizeUserDataXY(e,t,a,r);try{const i=o[0].concat(o[1]);this.makeTestFunction();const u=this.testFunction,c=this.testLoop(u,i,r,n.verbose,n.steps);return Zo(c)}finally{Fu(o[0],e),Fu(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),mB(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new Rt(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new Rt(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Rt("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),o=new dl;if(e instanceof _a&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Rt(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)o.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(c==null)throw new Rt(`No value is provided for the model's input ${u.name}`);o.add(u,c)}const i=Yh(a,o);return n?i:i[0]}retrieveSymbolicTensors(e){const t=wd(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],o=a.map(i=>i.name);for(let i=0;i<e.length;++i){const u=o.indexOf(e[i]);if(u!==-1&&(t[i]=a[u],n--),n===0)break}if(n===0)break}if(n>0){const r=[];throw t.forEach((a,o)=>{a==null&&r.push(e[o])}),new Rt(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return Qt(()=>{const r=this.checkNumSamples(e);if(n)throw new Xs("Verbose predictLoop() is not implemented yet.");const a=Y1(r,t),o=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)Qt(()=>{const c=a[i][0],d=a[i][1],h=Gh(e,c,d),l=[];if(Array.isArray(h))for(let f=0;f<h.length;++f)l.push({key:this.inputs[f],value:h[f]});else l.push({key:this.inputs[0],value:h});const p=new dl(l);return Yh(this.outputs,p)}).forEach((c,d)=>o[d].push(c));return Zo(o.map(i=>Qo(i,0)))})}predict(e,t={}){const n=Q_(e);Vk(n,this.inputNames,this.feedInputShapes,!1);try{const r=t.batchSize==null?32:t.batchSize;return X1(r),this.predictLoop(n,r)}finally{Fu(n,e)}}predictOnBatch(e){Vk(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new wu("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let o=0;o<this.feedOutputShapes.length;++o){const i=this.feedOutputShapes[o];this.feedLossFns[o]===Um?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=Wk(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Wk(t,this.feedOutputNames,a,!1,"target"),bB(e,t),xB(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new Rt(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,o){const[i,u]=this.standardizeUserDataXY(e,t,a,o);if(n!=null)throw new Error("sample weight is not supported yet.");let c=null;if(r!=null){const d=X_(r,this.outputNames);c=[];for(let h=0;h<d.length;++h)c.push(await Y_(u[h],null,d[h]))}return[i,u,c]}testLoop(e,t,n,r=0,a){return Qt(()=>{const o=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Xs("Verbose mode is not implemented yet.");if(a!=null)throw new Xs("steps mode in testLoop() is not implemented yet");{const u=Y1(o,n),c=Hi(Uu(0,o));for(let d=0;d<u.length;++d){const h=u[d][0],l=u[d][1],p=cd(c,h,l-h),f=W0(t,p),x=e(f);if(d===0)for(let b=0;b<x.length;++b)i.push(Rr(0));for(let b=0;b<x.length;++b){const m=x[b];i[b]=Bn(i[b],Ft(l-h,m))}}for(let d=0;d<i.length;++d)i[d]=_s(i[d],o)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;Sk(e,r)>1&&(a+=`_${Sk(e.slice(0,n),r)}`),t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],i=()=>{const h=[];for(let x=0;x<this.inputs.length;++x)h.push({key:this.inputs[x],value:n[x]});const l=new dl(h),p=Yh(this.outputs,l,{training:!0});let f;for(let x=0;x<this.lossFunctions.length;++x){let m=this.lossFunctions[x](r[x],p[x]);a[x]!=null&&(m=cB(m,a[x]));const I=Sa(m);t.push(I),x===0?f=m:f=Bn(f,m)}for(let x=0;x<this.metricsTensors.length;++x){let b;if(this.outputs.length>1&&x<this.outputs.length)b=t[x];else{const m=this.metricsTensors[x][0],I=this.metricsTensors[x][1];b=Sa(m(r[I],p[I]))}mc(b),o.push(b)}return f=Sa(f),this.calculateLosses().forEach(x=>{f=Bn(f,x)}),f},u=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(i,c,u)].concat(o)}}makeTestFunction(){this.testFunction=e=>Qt(()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:r[c]});const i=new dl(o),u=Yh(this.outputs,i);for(let c=0;c<this.lossFunctions.length;++c){const d=this.lossFunctions[c],h=Sa(d(a[c],u[c]));c===0?n=h:n=Bn(n,h),t.push(n)}for(let c=0;c<this.metricsTensors.length;++c){const d=this.metricsTensors[c][0],h=this.metricsTensors[c][1],l=Sa(d(a[h],u[h]));t.push(l)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,o,i,u,c,d,h,l;try{const p=n.batchSize==null?32:n.batchSize;X1(p);const f=!1,x=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,f,p);r=x[0],a=x[1],l=x[2];let b=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(b=!0,n.validationData.length===2)u=n.validationData[0],c=n.validationData[1];else throw n.validationData.length===3?new Xs("validationData including sample weights is not supported yet."):new Rt(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);const V=!0,P=await this.standardizeUserData(u,c,null,null,V,p);d=P[0],h=P[1],m=d.concat(h)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){b=!0;const V=Math.floor(r[0].shape[0]*(1-n.validationSplit)),P=r[0].shape[0];d=Gh(r,V,P),o=r,r=Gh(r,0,V),h=Gh(a,V,P),i=a,a=Gh(a,0,V),m=d.concat(h)}else n.validationSteps!=null&&(b=!0);const I=r.concat(a).concat(l);this.checkTrainableWeightsConsistency();const N=this.makeTrainFunction(),E=this.getDedupedMetricsNames();let D,U;b?(this.makeTestFunction(),D=this.testFunction,U=E.slice().concat(E.map(V=>"val_"+V))):(D=null,m=[],U=E.slice());const L=z_(n.callbacks,n.yieldEvery);return await this.fitLoop(N,I,E,p,n.epochs,n.verbose,L,D,m,n.shuffle,U,n.initialEpoch,null,null)}finally{this.isTraining=!1,Fu(r,e),Fu(a,t),Fu(o,e),Fu(i,t),Fu(d,u),Fu(h,c),l!=null&&ir(l)}}async fitLoop(e,t,n,r,a,o,i,u,c,d,h,l,p,f){r==null&&(r=32),a==null&&(a=1),d==null&&(d=!0),l==null&&(l=0);let x=!1;if(u!=null&&c!=null&&(x=!0),f!=null&&(x=!0,p==null))throw new Rt("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(t,r,p,"steps_per_epoch");let m;b!=null&&(m=Uu(0,b)),o==null&&(o=1);const{callbackList:I,history:N}=W_(i,o,a,l,b,p,r,x,h);I.setModel(this),this.history=N,await I.onTrainBegin(),this.stopTraining_=!1;for(let E=l;E<a;++E){await I.onEpochBegin(E);const D={};if(p!=null)throw new Xs("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new Xs("batch shuffling is not implemneted yet");d&&dE(m);const U=Hi(m),L=Y1(b,r);for(let Y=0;Y<L.length;++Y){const V={};if(await I.onBatchBegin(Y,V),Qt(()=>{const P=L[Y][0],oe=L[Y][1],ne=cd(U,P,oe-P);V.batch=Y,V.size=oe-P;const ge=W0(t,ne),ye=e(ge);for(let Ee=0;Ee<n.length;++Ee){const X=n[Ee],je=ye[Ee];V[X]=je,mc(je)}if(Y===L.length-1&&x){const Ee=this.testLoop(u,c,r);for(let X=0;X<n.length;++X){const je=n[X],Be=Ee[X];mc(Be),D["val_"+je]=Be}}}),await I.onBatchEnd(Y,V),B_(V),this.stopTraining_)break}U.dispose()}if(await I.onEpochEnd(E,D),this.stopTraining_)break}return await I.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return hB(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],i=this.makeTrainFunction()(r.concat(a)),u=[];for(const c of i){const d=await c.data();u.push(d[0])}return ir(i),Fu(n[0],e),Fu(n[1],t),Zo(u)}getNamedWeights(e){const t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let o=0;o<r.length;++o)n&&!r[o].trainable||t.push({name:r[o].originalName,tensor:a[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=S0().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-S0().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Dc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Dc(t))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t)if(typeof n[r]=="string")e[r]=Dc(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Dc(cm(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Dc(cm(e)));{const e={};for(const t in this.metrics)e[t]=Dc(cm(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=B0(e.optimizer_config),n=Lc(t);let r;if(typeof e.loss=="string")r=nd(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>nd(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=nd(e.loss[o])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(o=>nd(o));else if(e.metrics!=null){a={};for(const o in e.metrics)a[o]=nd(e.metrics[o])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){const c=aR(e);if(c.length===0)throw new Rt(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new Rt(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new Rt("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await ok(this.getNamedWeights(t)),r=!1,a=null,i={modelTopology:this.toJSON(a,r),format:wB,generatedBy:`TensorFlow.js tfjs-layers v${K_}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:d,specs:h}=await ok(await this.optimizer.getWeights(),c);n.specs.push(...h),n.data=PI([n.data,d])}return this.userDefinedMetadata!=null&&(Pk(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){Pk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Qd.className="Model";An(Qd);class J_ extends Qd{}J_.className="Functional";An(J_);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class up extends Qd{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:gb("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new Rt(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof up||e instanceof Qd;let n;if(t){if(n=e,n.outputs.length!==1)throw new Rt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new Rt("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Rt("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=IL({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new Rt(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Rt("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=F_(this.outputs[0])}this.inboundNodes=[],new xb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:wd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(kr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new wu("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new wu("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new wu("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new wu("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Rt("Legacy serialization format not supported yet.");a=t}else ze(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,o=t;const i=new e(o);if(!(i instanceof up))throw new Xs(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const u of a){const d=Lc(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),i.add(d)}return i}set stopTraining(e){if(this.model==null)throw new Rt("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Rt("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}up.className="Sequential";An(up);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ni extends Ih{getConfig(){return{}}}class eS extends ni{apply(e,t=1){return cL(e,t)}}eS.className="elu";An(eS);class tS extends ni{apply(e){return bC(e)}}tS.className="selu";An(tS);class nS extends ni{apply(e){return Nd(e)}}nS.className="relu";An(nS);class sS extends ni{apply(e){return Qt(()=>rp(6,Nd(e)))}}sS.className="relu6";An(sS);class rS extends ni{apply(e){return e}}rS.className="linear";An(rS);class aS extends ni{apply(e){return wh(e)}}aS.className="sigmoid";An(aS);class oS extends ni{apply(e){return dL(e)}}oS.className="hardSigmoid";An(oS);class iS extends ni{apply(e){return pf(e)}}iS.className="softplus";An(iS);class uS extends ni{apply(e){return lL(e)}}uS.className="softsign";An(uS);class cS extends ni{apply(e){return Xy(e)}}cS.className="tanh";An(cS);class dv extends ni{apply(e,t=-1){return pw(e,t)}}dv.className="softmax";An(dv);class lS extends ni{apply(e,t=-1){return sC(e,t)}}lS.className="logSoftmax";An(lS);class dS extends ni{apply(e,t=1){return Qt(()=>Ft(wh(Ft(e,t)),e))}}dS.className="swish";An(dS);class hS extends ni{apply(e){return Qt(()=>Ft(e,Xy(pf(e))))}}hS.className="mish";An(hS);function wl(s){return s.getClassName()}function Z1(s,e={}){return wf(s,gu.getMap().classNameMap,e,"activation")}function vl(s){if(s==null){const e={};return e.className="linear",e.config={},Z1(e)}if(typeof s=="string"){const e={};return e.className=s,e.config={},Z1(e)}else return s instanceof ni?s:Z1(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vB(s){if(s!=null&&typeof s!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${s}`)}class pS extends Ih{}class fS extends pS{constructor(e){super();vB(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Qt(()=>{let t=Ya([1]);return this.hasL1&&(t=Bn(t,Cs(Ft(this.l1,Fo(e))))),this.hasL2&&(t=Bn(t,Cs(Ft(this.l2,kf(e))))),zt(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}fS.className="L1L2";An(fS);const Uk={l1l2:"L1L2"};function zr(s){return Zw(s)}function jk(s,e={}){return wf(s,gu.getMap().classNameMap,e,"regularizer")}function oa(s){if(s==null)return null;if(typeof s=="string"){const t={className:s in Uk?Uk[s]:s,config:{}};return jk(t)}else return s instanceof pS?s:jk(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class mS extends sr{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Rs(e);let n=Nd(e);return this.maxValue!=null&&(n=Xi(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}mS.className="ReLU";An(mS);class gS extends sr{constructor(e){super(e==null?{}:e);this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Rs(e);return sw(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}gS.className="LeakyReLU";An(gS);class bS extends sr{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=aa(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=oa(e.alphaRegularizer),this.alphaConstraint=Ma(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Rt(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=kr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Fa({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Rs(e),cw(e,this.alpha.read())}getConfig(){const e={alphaInitializer:da(this.alphaInitializer),alphaRegularizer:zr(this.alphaRegularizer),alphaConstraint:Da(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}bS.className="PReLU";An(bS);class xS extends sr{constructor(e){super(e==null?{}:e);if(this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Xs(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Rs(e);return cb(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}xS.className="ELU";An(xS);class yS extends sr{constructor(e){super(e==null?{}:e);this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const n=Rs(e);return Ft(n,as(Yi(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}yS.className="ThresholdedReLU";An(yS);class wS extends sr{constructor(e){super(e==null?{}:e);this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new dv().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const n=Rs(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}wS.className="Softmax";An(wS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jd(s,e,t){if(typeof s=="number")return wd(s,e);if(s.length!==e)throw new Rt(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${s.length} elements.`);for(let n=0;n<e;++n){const r=s[n];if(!aL(r))throw new Rt(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(s)} including a non-integer number ${r}`)}return s}function Wu(s,e,t,n,r=1){if(s==null)return s;const a=e+(e-1)*(r-1);let o;return t==="same"?o=s:o=s-a+1,Math.floor((o+n-1)/n)}function lc(s,e,t,n){if(s==null)return null;if(n==="valid")s=s*e+yl([t-e,0]);else if(n==="same")s=s*e;else throw new Rt(`Unsupport padding mode: ${n}.`);return s}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hv(s,e){return Qt(()=>(va(e),e==="channelsFirst"?br(s,[0,2,3,1]):s))}function vS(s,e){return Qt(()=>(va(e),e==="channelsFirst"?br(s,[0,2,3,4,1]):s))}function kB(s,e,t,n=1,r="valid",a,o=1){return Qt(()=>{if(a==null&&(a=ju()),va(a),s.shape.length!==3)throw new Rt(`The input of a conv1dWithBias operation should be 3, but is ${s.shape.length} instead.`);if(e.shape.length!==3)throw new Rt(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Rt(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(a==="channelsFirst"&&(s=br(s,[0,2,1])),r==="causal")throw new Xs("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=KI(s,e,n,r==="same"?"same":"valid","NWC",o);return t!=null&&(i=qu(i,t)),i})}function Gk(s,e,t,n=[1,1],r="valid",a,o,i=null){return Qt(()=>{if(a==null&&(a=ju()),va(a),s.rank!==3&&s.rank!==4)throw new Rt(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${s.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Rt(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${s.rank}.`);let u=hv(s,a);if(r==="causal")throw new Xs("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=T3({x:u,filter:e,strides:n,pad:r==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:i}),a==="channelsFirst"&&(u=br(u,[0,3,1,2])),u})}function IB(s,e,t,n=[1,1,1],r="valid",a,o){return Qt(()=>{if(a==null&&(a=ju()),va(a),s.rank!==4&&s.rank!==5)throw new Rt(`conv3dWithBias expects input to be of rank 4 or 5, but received ${s.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Rt(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${s.rank}.`);let i=vS(s,a);if(r==="causal")throw new Xs("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=MA(i,e,n,r==="same"?"same":"valid","NDHWC",o),t!=null&&(i=qu(i,t)),a==="channelsFirst"&&(i=br(i,[0,4,1,2,3])),i})}class vb extends sr{constructor(e,t){super(t);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",vb.verifyArgs(t),this.rank=e,Za(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Xs(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Jd(t.kernelSize,e,"kernelSize"),this.strides=Jd(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Zi(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,va(this.dataFormat),this.activation=vl(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=aa(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ma(t.biasConstraint),this.biasRegularizer=oa(t.biasRegularizer),this.activityRegularizer=oa(t.activityRegularizer),this.dilationRate=Jd(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Rt(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Rt(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Rt(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(cc("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Qw(e.kernelSize,"number",1,3))throw new Rt(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:wl(this.activation),useBias:this.useBias,biasInitializer:da(this.biasInitializer),biasRegularizer:zr(this.biasRegularizer),activityRegularizer:zr(this.activityRegularizer),biasConstraint:Da(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Ch extends vb{constructor(e,t){super(e,t);this.kernel=null,Ch.verifyArgs(t),this.filters=t.filters,Za(this.filters,"filters"),this.kernelInitializer=aa(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ma(t.kernelConstraint),this.kernelRegularizer=oa(t.kernelRegularizer)}build(e){e=kr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Rt(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Qt(()=>{e=Rs(e);let n;const r=this.bias==null?null:this.bias.read(),a=y_(this.activation.getClassName());if(a!=null&&this.rank===2)n=Gk(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)n=kB(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=Gk(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=IB(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Xs("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=kr(e);const t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const o=Wu(n[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);t.push(o)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:da(this.kernelInitializer),kernelRegularizer:zr(this.kernelRegularizer),kernelConstraint:Da(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Rt(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Sf extends Ch{constructor(e){super(2,e);Sf.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Qw(e.kernelSize,"number",1,2))throw new Rt(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Sf.className="Conv2D";An(Sf);class $f extends Ch{constructor(e){super(3,e);$f.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Rt(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}$f.className="Conv3D";An($f);class kS extends Sf{constructor(e){super(e);if(this.inputSpec=[new Fa({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Rt(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kr(e),e.length!==4)throw new Rt("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Rt("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Fa({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Qt(()=>{let n=Rs(e);if(n.shape.length!==4)throw new Rt(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const r=n.shape,a=r[0];let o,i;this.dataFormat==="channelsFirst"?(o=2,i=3):(o=1,i=2);const u=r[o],c=r[i],d=this.kernelSize[0],h=this.kernelSize[1],l=this.strides[0],p=this.strides[1],f=lc(u,l,d,this.padding),x=lc(c,p,h,this.padding),b=[a,f,x,this.filters];this.dataFormat!=="channelsLast"&&(n=br(n,[0,2,3,1]));let m=XI(n,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(m=br(m,[0,3,1,2])),this.bias!=null&&(m=qu(m,this.bias.read(),this.dataFormat)),this.activation!=null&&(m=this.activation.apply(m)),m})}computeOutputShape(e){e=kr(e);const t=e.slice();let n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);const o=this.kernelSize[0],i=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[r]=lc(t[r],u,o,this.padding),t[a]=lc(t[a],c,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}kS.className="Conv2DTranspose";An(kS);class IS extends $f{constructor(e){super(e);if(this.inputSpec=[new Fa({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Rt(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kr(e),e.length!==5)throw new Rt("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Rt("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Fa({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Qt(()=>{let n=Rs(e);if(n.shape.length!==5)throw new Rt(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);const r=n.shape,a=r[0];let o,i,u;this.dataFormat==="channelsFirst"?(u=2,o=3,i=4):(u=1,o=2,i=3);const c=r[u],d=r[o],h=r[i],l=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],x=this.strides[0],b=this.strides[1],m=this.strides[2],I=lc(c,x,l,this.padding),N=lc(d,b,p,this.padding),E=lc(h,m,f,this.padding),D=[a,I,N,E,this.filters];this.dataFormat!=="channelsLast"&&(n=br(n,[0,2,3,4,1]));let U=BA(n,this.kernel.read(),D,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(U=br(U,[0,4,1,2,3])),this.bias!==null&&(U=qu(U,this.bias.read(),this.dataFormat)),this.activation!==null&&(U=this.activation.apply(U)),U})}computeOutputShape(e){e=kr(e);const t=e.slice();let n,r,a,o;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,o=4):(n=4,r=1,a=2,o=3);const i=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],l=this.strides[2];return t[n]=this.filters,t[r]=lc(t[r],d,i,this.padding),t[a]=lc(t[a],h,u,this.padding),t[o]=lc(t[o],l,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}IS.className="Conv3DTranspose";An(IS);class CS extends Ch{constructor(e,t){super(e,t);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Rt("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Rt("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Rt(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=aa(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=oa(t.depthwiseRegularizer),this.depthwiseConstraint=Ma(t.depthwiseConstraint),this.pointwiseInitializer=aa(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=oa(t.pointwiseRegularizer),this.pointwiseConstraint=Ma(t.pointwiseConstraint)}build(e){if(e=kr(e),e.length<this.rank+2)throw new Rt(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Rt(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Fa({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Qt(()=>{e=Rs(e);let n;if(this.rank===1)throw new Xs("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=br(e,[0,2,3,1])),n=xC(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=qu(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=br(n,[0,3,1,2])),n})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=da(this.depthwiseInitializer),e.pointwiseInitializer=da(this.pointwiseInitializer),e.depthwiseRegularizer=zr(this.depthwiseRegularizer),e.pointwiseRegularizer=zr(this.pointwiseRegularizer),e.depthwiseConstraint=Da(this.depthwiseConstraint),e.pointwiseConstraint=Da(this.pointwiseConstraint),e}}CS.className="SeparableConv";class _S extends CS{constructor(e){super(2,e)}}_S.className="SeparableConv2D";An(_S);class kb extends Ch{constructor(e){super(1,e);kb.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Qw(e.kernelSize,"number",1,1))throw new Rt(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}kb.className="Conv1D";An(kb);class SS extends sr{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Qt(()=>{if(e=Rs(e),this.dataFormat==="channelsLast"){const n=um(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return um(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const n=um(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return um(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}SS.className="Cropping2D";An(SS);class $S extends sr{constructor(e){super(e);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,va(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,nL(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{const t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Qt(()=>{let n=Rs(e);const r=n.shape;if(this.dataFormat==="channelsFirst"){n=br(n,[0,2,3,1]);const a=this.size[0]*r[2],o=this.size[1]*r[3],i=this.interpolation==="nearest"?Pc.resizeNearestNeighbor(n,[a,o]):Pc.resizeBilinear(n,[a,o]);return br(i,[0,3,1,2])}else{const a=this.size[0]*r[1],o=this.size[1]*r[2];return this.interpolation==="nearest"?Pc.resizeNearestNeighbor(n,[a,o]):Pc.resizeBilinear(n,[a,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}$S.className="UpSampling2D";An($S);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CB(s,e,t=[1,1],n="valid",r,a){return Qt(()=>{r==null&&(r=ju()),va(r);let o=hv(s,r);if(s.rank!==4)throw new Rt(`Input for depthwiseConv2d is required to be 4-D, but is instead ${s.rank}-D`);if(e.rank!==4)throw new Rt(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=Jy(o,e,t,n==="same"?"same":"valid","NHWC",a),r==="channelsFirst"&&(o=br(o,[0,3,1,2])),o})}class TS extends vb{constructor(e){super(2,e);this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=aa(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ma(e.depthwiseConstraint),this.depthwiseRegularizer=oa(e.depthwiseRegularizer)}build(e){if(e=kr(e),e.length<4)throw new Rt(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Rt(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Qt(()=>{e=Rs(e);let n=CB(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=qu(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=kr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Wu(t,this.kernelSize[0],this.padding,this.strides[0]),o=Wu(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,o]:[e[0],a,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=da(this.depthwiseInitializer),e.depthwiseRegularizer=zr(this.depthwiseRegularizer),e.depthwiseConstraint=Da(this.depthwiseRegularizer),e}}TS.className="DepthwiseConv2D";An(TS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function NS(s,e,t,n){if(Array.isArray(s)){if(e!=null||t!=null)throw new Rt("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=s.slice(s.length-n,s.length),s=s.slice(0,s.length-n)),s.length>1&&(e=s.slice(1,s.length)),s=s[0]}function r(a){return a==null||Array.isArray(a)?a:[a]}return e=r(e),t=r(t),{inputs:s,initialState:e,constants:t}}function ES(s,e,t,n=!1,r,a,o=!1,i=!1){return Qt(()=>{const u=e.shape.length;if(u<3)throw new Rt(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(Uu(2,u));if(e=br(e,c),a!=null)throw new Xs("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=as(as(r,"bool"),"float32"),r.rank===u-1&&(r=xi(r,-1)),r=br(r,c)),n&&(e=bd(e,0),r!=null&&(r=bd(r,0)));const d=[];let h,l=t;const p=e.shape[0],f=xd(e);let x;r!=null&&(x=xd(r));for(let m=0;m<p;++m){const I=f[m],N=Qt(()=>s(I,l));if(r==null)h=N[0],l=N[1];else{const E=Qt(()=>{const D=x[m],U=Ds(Iu(D),D),L=Bn(Ft(N[0],D),Ft(l[0],U)),Y=l.map((V,P)=>Bn(Ft(N[1][P],D),Ft(V,U)));return{output:L,newStates:Y}});h=E.output,l=E.newStates}i&&d.push(h)}let b;return i&&(b=xl(d,1)),[h,b,l]})}class El extends sr{constructor(e){super(e);let t;if(e.cell==null)throw new Rt("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new mv({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Rt("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Fa({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Uu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){M0(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(this.returnSequences?r=[e[0],e[1],n]:r=[e[0],n],this.returnState){const a=[];for(const o of t)a.push([e[0],o]);return[r].concat(a)}else return r}computeMask(e,t){return Qt(()=>{Array.isArray(t)&&(t=t[0]);const n=this.returnSequences?t:null;if(this.returnState){const r=this.states.map(a=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Xs("Constants support is not implemented in RNN yet.");M0(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Fa({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!Er(this.stateSpec.map(o=>o.shape[o.shape.length-1]),a))throw new Rt(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(o=>new Fa({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Qt(()=>{if(!this.stateful)throw new uc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(n==null)throw new Rt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ya([n,r])):this.states_=[Ya([n,this.cell.stateSize])];else if(e==null)ir(this.states_),this.keptStates!=null&&(ir(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Ya([n,r])):this.states_[0]=Ya([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Rt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):ir(this.states_);for(let r=0;r<this.states_.length;++r){const a=e[r],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,i=[n,o];if(!Er(a.shape,i))throw new Rt(`State ${r} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${a.shape}`);this.states_[r]=a}}this.states_=this.states_.map(r=>mc(r.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const a=NS(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let o=[],i=[];if(n!=null){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const c of n)this.stateSpec.push(new Fa({shape:c.shape}));i=i.concat(this.stateSpec)}if(r!=null&&(t.constants=r,o=o.concat(r),this.numConstants=r.length),o[0]instanceof dc){const c=[e].concat(o),d=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=d;const l=super.apply(c,t);return this.inputSpec=h,l}else return super.apply(e,t)}call(e,t){return Qt(()=>{const n=t==null?null:t.mask,r=t==null?null:t.training;let a=t==null?null:t.initialState;e=Rs(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==o)throw new Rt(`RNN Layer has ${o} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},c=ES((f,x)=>{const b=this.cell.call([f].concat(x),i);return[b[0],b.slice(1)]},e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),d=c[0],h=c[1],l=c[2];this.stateful&&this.resetStates(l,r);const p=this.returnSequences?h:d;return this.returnState?[p].concat(l):p})}getInitialState(e){return Qt(()=>{let t=Ya(e.shape);return t=Cs(t,[1,2]),t=vf(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?F0(t,[1,n]):t):this.cell.stateSize>1?[F0(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===El.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=t.cell,a=Lc(r,n);return new e(Object.assign(t,{cell:a}))}}El.className="RNN";An(El);class Ib extends sr{}class pv extends Ib{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Za(this.units,"units"),this.activation=vl(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=aa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=oa(e.kernelRegularizer),this.recurrentRegularizer=oa(e.recurrentRegularizer),this.biasRegularizer=oa(e.biasRegularizer),this.kernelConstraint=Ma(e.kernelConstraint),this.recurrentConstraint=Ma(e.recurrentConstraint),this.biasConstraint=Ma(e.biasConstraint),this.dropout=ch([1,yl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ch([1,yl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Qt(()=>{if(e=e,e.length!==2)throw new Rt(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kl({ones:()=>Iu(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kl({ones:()=>Iu(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a;const o=this.dropoutMask,i=this.recurrentDropoutMask;o!=null?a=xc(Ft(e,o),this.kernel.read()):a=xc(e,this.kernel.read()),this.bias!=null&&(a=qu(a,this.bias.read())),i!=null&&(n=Ft(n,i));let u=Bn(a,xc(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:wl(this.activation),useBias:this.useBias,kernelInitializer:da(this.kernelInitializer),recurrentInitializer:da(this.recurrentInitializer),biasInitializer:da(this.biasInitializer),kernelRegularizer:zr(this.kernelRegularizer),recurrentRegularizer:zr(this.recurrentRegularizer),biasRegularizer:zr(this.biasRegularizer),activityRegularizer:zr(this.activityRegularizer),kernelConstraint:Da(this.kernelConstraint),recurrentConstraint:Da(this.recurrentConstraint),biasConstraint:Da(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}pv.className="SimpleRNNCell";An(pv);class RS extends El{constructor(e){e.cell=new pv(e);super(e)}call(e,t){return Qt(()=>{this.cell.dropoutMask!=null&&(ir(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ir(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}}RS.className="SimpleRNN";An(RS);class fv extends Ib{constructor(e){super(e);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Rt("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Za(this.units,"units"),this.activation=vl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=vl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=aa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=oa(e.kernelRegularizer),this.recurrentRegularizer=oa(e.recurrentRegularizer),this.biasRegularizer=oa(e.biasRegularizer),this.kernelConstraint=Ma(e.kernelConstraint),this.recurrentConstraint=Ma(e.recurrentConstraint),this.biasConstraint=Ma(e.biasConstraint),this.dropout=ch([1,yl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ch([1,yl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Qt(()=>{if(e=e,e.length!==2)throw new Rt(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training==null?!1:t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kl({ones:()=>Iu(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kl({ones:()=>Iu(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let i,u,c;0<this.dropout&&this.dropout<1&&(e=Ft(e,a[0]));let d=xc(e,this.kernel.read());this.useBias&&(d=qu(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Ft(r,o[0]));const h=this.recurrentKernel.read(),[l,p]=Ki(h,[2*this.units,this.units],h.rank-1),f=xc(r,l),[x,b,m]=Ki(d,3,d.rank-1),[I,N]=Ki(f,2,f.rank-1);i=this.recurrentActivation.apply(Bn(x,I)),u=this.recurrentActivation.apply(Bn(b,N));const E=xc(Ft(u,r),p);c=this.activation.apply(Bn(m,E));const D=Bn(Ft(i,r),Ft(Bn(1,xa(i)),c));return[D,D]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:wl(this.activation),recurrentActivation:wl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:da(this.kernelInitializer),recurrentInitializer:da(this.recurrentInitializer),biasInitializer:da(this.biasInitializer),kernelRegularizer:zr(this.kernelRegularizer),recurrentRegularizer:zr(this.recurrentRegularizer),biasRegularizer:zr(this.biasRegularizer),activityRegularizer:zr(this.activityRegularizer),kernelConstraint:Da(this.kernelConstraint),recurrentConstraint:Da(this.recurrentConstraint),biasConstraint:Da(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}fv.className="GRUCell";An(fv);class AS extends El{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new fv(e);super(e)}call(e,t){return Qt(()=>{this.cell.dropoutMask!=null&&(ir(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ir(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}AS.className="GRU";An(AS);class Cb extends Ib{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Za(this.units,"units"),this.activation=vl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=vl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=aa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=aa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=aa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=oa(e.kernelRegularizer),this.recurrentRegularizer=oa(e.recurrentRegularizer),this.biasRegularizer=oa(e.biasRegularizer),this.kernelConstraint=Ma(e.kernelConstraint),this.recurrentConstraint=Ma(e.recurrentConstraint),this.biasConstraint=Ma(e.biasConstraint),this.dropout=ch([1,yl([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ch([1,yl([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=kr(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,o=this.units;r=new(t=class extends _u{apply(u,c){const d=a.apply([o]),h=new ev().apply([o]),l=a.apply([o*2]);return Tk(Tk(d,h),l)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Qt(()=>{const n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Rt(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kl({ones:()=>Iu(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kl({ones:()=>Iu(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=Ft(e,o[0]));let l=xc(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Ft(r,i[0])),l=Bn(l,xc(r,this.recurrentKernel.read())),this.useBias&&(l=qu(l,this.bias.read()));const[p,f,x,b]=Ki(l,4,l.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),d=Bn(Ft(c,a),Ft(u,this.activation.apply(x))),h=this.recurrentActivation.apply(b);const m=Ft(h,this.activation.apply(d));return[m,m,d]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:wl(this.activation),recurrentActivation:wl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:da(this.kernelInitializer),recurrentInitializer:da(this.recurrentInitializer),biasInitializer:da(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:zr(this.kernelRegularizer),recurrentRegularizer:zr(this.recurrentRegularizer),biasRegularizer:zr(this.biasRegularizer),activityRegularizer:zr(this.activityRegularizer),kernelConstraint:Da(this.kernelConstraint),recurrentConstraint:Da(this.recurrentConstraint),biasConstraint:Da(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Cb.className="LSTMCell";An(Cb);class OS extends El{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Cb(e);super(e)}call(e,t){return Qt(()=>{this.cell.dropoutMask!=null&&(ir(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ir(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}OS.className="LSTM";An(OS);class mv extends Ib{constructor(e){super(e);this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Qt(()=>{e=e;let n=e.slice(1);const r=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let o;for(let i=0;i<this.cells.length;++i){const u=this.cells[i];n=r[i],i===0?o=[e[0]].concat(n):o=[o[0]].concat(n),o=u.call(o,t),a.push(o.slice(1))}n=[];for(const i of a.slice().reverse())n.push(...i);return[o[0]].concat(n)})}build(e){M0(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{ud(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),r={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,t,n={}){const r=[];for(const a of t.cells)r.push(Lc(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return P0(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let o=0;o<n.weights.length;++o)t.push([n.weights[o],a[o]])}iv(t)}}mv.className="StackedRNNCells";An(mv);function kl(s){const{ones:e,rate:t,training:n=!1,count:r=1,dropoutFunc:a}=s,o=()=>a!=null?a(e(),t):S_(e(),t),i=()=>If(o,e,n);return!r||r<=1?mc(i().clone()):Array(r).fill(void 0).map(i).map(c=>mc(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var _B=globalThis&&globalThis.__rest||function(s,e){var t={};for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&e.indexOf(n)<0&&(t[n]=s[n]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,n=Object.getOwnPropertySymbols(s);r<n.length;r++)e.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(s,n[r])&&(t[n[r]]=s[n[r]]);return t};class FS extends El{constructor(e){if(e.unroll)throw new Xs("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xs("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Fa({ndim:5})]}call(e,t){return Qt(()=>{if(this.cell.dropoutMask!=null&&(ir(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ir(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Rt("ConvRNN2D cell does not support constants");const n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Qt(()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],o=Ya(a);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Qt(()=>{if(!this.stateful)throw new uc("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new Rt("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ya(a)):this.states_=[Ya(a)];else if(e==null)ir(this.states_),this.keptStates!=null&&(ir(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ya(a)):this.states_[0]=Ya(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Rt(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ir(this.states_);for(let i=0;i<this.states_.length;++i){const u=e[i],c=a;if(!Er(u.shape,c))throw new Rt(`State ${i} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[i]=u}}this.states_=this.states_.map(i=>mc(i.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:o,dilationRate:i}=this.cell,u=t==="channelsFirst",c=e[u?3:2],d=e[u?4:3],h=Wu(c,r[0],a,o[0],i[0]),l=Wu(d,r[1],a,o[1],i[1]);return[...e.slice(0,2),...u?[n,h,l]:[h,l,n]]}}FS.className="ConvRNN2D";class gv extends Cb{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:o,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t}));this.filters=t,Za(this.filters,"filters"),this.kernelSize=Jd(n,2,"kernelSize"),this.kernelSize.forEach(u=>Za(u,"kernelSize")),this.strides=Jd(r||1,2,"strides"),this.strides.forEach(u=>Za(u,"strides")),this.padding=a||"valid",Zi(this.padding),this.dataFormat=o||"channelsLast",va(this.dataFormat),this.dilationRate=Jd(i||1,2,"dilationRate"),this.dilationRate.forEach(u=>Za(u,"dilationRate"))}build(e){var t;e=kr(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new Rt(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=4,o=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new(t=class extends _u{apply(l,p){const f=c.apply([d]),x=$d([d]),b=c.apply([d*2]);return Jw([f,x,b])}},t.className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Qt(()=>{if(e.length!==3)throw new Rt(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],o=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=kl({ones:()=>Iu(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(ct,Me,wt)=>!Me||!Me[wt]?ct:Ft(Me[wt],ct);let d=c(r,u,0),h=c(r,u,1),l=c(r,u,2),p=c(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=kl({ones:()=>Iu(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let x=c(a,f,0),b=c(a,f,1),m=c(a,f,2),I=c(a,f,3);const N=3,[E,D,U,L]=Ki(this.kernel.read(),i,N),[Y,V,P,oe]=this.useBias?Ki(this.bias.read(),i):[null,null,null,null];d=this.inputConv(d,E,Y,this.padding),h=this.inputConv(h,D,V,this.padding),l=this.inputConv(l,U,P,this.padding),p=this.inputConv(p,L,oe,this.padding);const[ne,ge,ye,Ee]=Ki(this.recurrentKernel.read(),i,N);x=this.recurrentConv(x,ne),b=this.recurrentConv(b,ge),m=this.recurrentConv(m,ye),I=this.recurrentConv(I,Ee);const X=this.recurrentActivation.apply(Bn(d,x)),je=this.recurrentActivation.apply(Bn(h,b)),Be=Bn(Ft(je,o),Ft(X,this.activation.apply(Bn(l,m)))),tt=Ft(this.recurrentActivation.apply(Bn(p,I)),this.activation.apply(Be));return[tt,tt,Be]})}getConfig(){const e=super.getConfig(),t=_B(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),n)}inputConv(e,t,n,r){const a=gd(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?qu(a,n,this.dataFormat):a}recurrentConv(e,t){return gd(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}gv.className="ConvLSTM2DCell";An(gv);class DS extends FS{constructor(e){const t=new gv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}DS.className="ConvLSTM2D";An(DS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bv extends sr{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e);if(0<this.rate&&this.rate<1){const r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return If(()=>S_(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}bv.className="Dropout";An(bv);class MS extends bv{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}MS.className="SpatialDropout1D";An(MS);class PS extends sr{constructor(e){super(e);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Za(this.units,"units"),this.activation=vl(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=aa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=aa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ma(e.kernelConstraint),this.biasConstraint=Ma(e.biasConstraint),this.kernelRegularizer=oa(e.kernelRegularizer),this.biasRegularizer=oa(e.biasRegularizer),this.activityRegularizer=oa(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=kr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=kr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e),r=y_(this.activation.getClassName());let a;return r!=null?a=xc(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=xc(n,this.kernel.read()),this.bias!=null&&(a=qu(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:wl(this.activation),useBias:this.useBias,kernelInitializer:da(this.kernelInitializer),biasInitializer:da(this.biasInitializer),kernelRegularizer:zr(this.kernelRegularizer),biasRegularizer:zr(this.biasRegularizer),activityRegularizer:zr(this.activityRegularizer),kernelConstraint:Da(this.kernelConstraint),biasConstraint:Da(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}PS.className="Dense";An(PS);class LS extends sr{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=kr(e);for(const t of e.slice(1))if(t==null)throw new Rt(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],gl(e,1)]}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);let n=Rs(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){const r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=br(n,r)}return uL(n)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}LS.className="Flatten";An(LS);class BS extends sr{constructor(e){super(e);this.supportsMasking=!0,this.activation=vl(e.activation)}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e);return this.activation.apply(n)})}getConfig(){const e={activation:wl(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}BS.className="Activation";An(BS);class zS extends sr{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Qt(()=>(e=Rs(e),oL(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}zS.className="RepeatVector";An(zS);class WS extends sr{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,o=null;for(let u=0;u<r.length;++u){const c=r[u];if(this.isUnknown(c))if(o===null)o=u;else throw new Rt("Can only specifiy one unknown dimension.");else a*=c}const i=gl(e);if(o!==null){if(a===0||i%a!==0)throw new Rt(n);r[o]=i/a}else if(i!==a)throw new Rt(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return zt(n,a)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}WS.className="Reshape";An(WS);class VS extends sr{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Uu(1,e.dims.length+1);if(!Er(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Fa({ndim:this.dims.length+1})]}computeOutputShape(e){e=kr(e);const t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return br(Rs(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}VS.className="Permute";An(VS);class US extends sr{constructor(e){super(e==null?{}:e);this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Rs(e),r=-1;return $0(Dm(n,this.maskValue),r)}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e),r=-1,a=!0,o=$0(Dm(n,this.maskValue),r,a);return Ft(n,as(o,n.dtype))})}}US.className="Masking";An(US);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jS extends sr{constructor(e){super(e);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Zr(e.inputLength))}this.inputDim=e.inputDim,Za(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Za(this.outputDim,"outputDim"),this.embeddingsInitializer=aa(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=oa(e.embeddingsRegularizer),this.activityRegularizer=oa(e.activityRegularizer),this.embeddingsConstraint=Ma(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Qt(()=>this.maskZero?(e=Rs(e),Dm(e,wr(e))):null)}computeOutputShape(e){if(e=kr(e),this.inputLength==null)return[...e,this.outputDim];const t=Zr(this.inputLength);if(t.length!==e.length-1)throw new Rt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],o=e[r+1];if(a!=null&&o!=null&&a!==o)throw new Rt(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);let n=Rs(e);n.dtype!=="int32"&&(n=bc(n,"int32"));const r=__(this.embeddings.read(),zt(n,[n.size]));return zt(r,kr(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:da(this.embeddingsInitializer),embeddingsRegularizer:zr(this.embeddingsRegularizer),activityRegularizer:zr(this.activityRegularizer),embeddingsConstraint:Da(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}jS.className="Embedding";An(jS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ad extends sr{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new Xs}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],o=t[r];if(a==null||o==null||a<0||o<0)n.push(null);else if(a===1)n.push(o);else if(o===1)n.push(a);else{if(a!==o)throw new Rt("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[kr(e)]),e=e,e.length<2)throw new Rt(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=ml(t),t.length>1)throw new Rt(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const o=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}const r=e.map(a=>a.length);e.indexOf(null)===-1&&ml(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Qt(()=>{if(e=e,this.reshapeRequired){const n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){const a=yl(r);for(let o of e){const i=o.rank;for(let u=0;u<a-i;++u)o=vf(o,1);n.push(o)}return this.mergeFunction(n)}else{let a=!1;for(const u of e){const c=u.rank;if(c==null){const d=u.shape,h=d[0],l=d.slice(1).concat([h]);let p=zt(u,[h].concat(gl(d.slice(1))));p=br(p,[1,0]),p=zt(p,l),n.push(p),a=!0}else if(c>1){const d=Uu(1,c).concat([0]);n.push(br(u,d)),a=!0}else n.push(u)}let o=this.mergeFunction(n);const i=o.rank;if(a){if(i==null){const u=o.shape,c=u.length,d=u[c-1],h=[d].concat(u.slice(0,u.length-1));o=zt(br(zt(o,[-1,d]),[1,0]),h)}else if(i>1){const u=[i-1].concat(Uu(0,i-1));o=br(o,u)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(const r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=ml(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return Qt(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Rt("`mask` should be an Array");if(!Array.isArray(e))throw new Rt("`inputs` should be an Array");if(t.length!==e.length)throw new Rt(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:xi(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=Wc(n,t[r]);return n})}}class GS extends Ad{constructor(e){super(e)}mergeFunction(e){return Qt(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Bn(t,e[n]);return t})}}GS.className="Add";An(GS);class HS extends Ad{constructor(e){super(e)}mergeFunction(e){return Qt(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ft(t,e[n]);return t})}}HS.className="Multiply";An(HS);class qS extends Ad{constructor(e){super(e)}mergeFunction(e){return Qt(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Bn(t,e[n]);return Ft(1/e.length,t)})}}qS.className="Average";An(qS);class KS extends Ad{constructor(e){super(e)}mergeFunction(e){return Qt(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Tl(t,e[n]);return t})}}KS.className="Maximum";An(KS);class XS extends Ad{constructor(e){super(e)}mergeFunction(e){return Qt(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=rp(t,e[n]);return t})}}XS.className="Minimum";An(XS);class YS extends Ad{constructor(e){super(e);this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Rt("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const r of e)if(r!=null){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const a=e[r].slice();a.splice(this.axis,1);let o=!1;for(const i of n)if(Er(i,a)){o=!0;break}o||n.push(a)}if(n.length>1)throw new Rt("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Qt(()=>Jw(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Rt("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Rt("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Rt("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Rt(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Qt(()=>{let n=!0;if(t.forEach(o=>{if(o!=null){n=!1;return}}),n)return null;const r=[];for(let o=0;o<e.length;++o)t[o]==null?r.push(as(Iu(e[o]),"bool")):t[o].rank<e[o].rank?r.push(xi(t[o],-1)):r.push(t[o]);const a=Qo(r,this.axis);return qI(a,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}YS.className="Concatenate";An(YS);function Hh(s,e){for(;s<0;)s+=e;return s}function SB(s,e,t){if(s.shape.length>3||e.shape.length>3)throw new Xs("batchDot is not implemented for tensors of 4D or higher rank yet");if(ze(s.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${s.shape.length}`),ze(s.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),s.dtype==="complex64"||e.dtype==="complex64")throw new Xs("batchDot is not implemented for complex64-type Tensors yet.");const n=s.shape.length,r=e.shape.length;t==null&&(t=[n-1,r-2]);const a=t;return Qt(()=>{let o;if(n>r){o=n-r;const u=[];for(let c=0;c<o;++c)u.push(1);e=zt(e,e.shape.concat(u))}else if(r>n){o=r-n;const u=[];for(let c=0;c<o;++c)u.push(1);s=zt(s,s.shape.concat(u))}else o=0;let i;if(s.shape.length===2&&e.shape.length===2)a[0]===a[1]?i=Cs(Ft(s,e),a[0]):i=Cs(Ft(br(s,[1,0]),e),a[1]);else{const u=a[0]!==s.shape.length-1,c=a[1]===e.shape.length-1;i=Nr(s,e,u,c)}if(o>0){let u;n>r?u=n+r-3:u=n-1;const c=[];for(let d=u;d<u+o;++d)c.push(d);i=mf(i,c)}return i.shape.length===1&&(i=xi(i,1)),i})}class ZS extends Ad{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ze(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Xs("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Rt(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Rt(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,o)=>Hh(a,e[o].shape.length)):r=[Hh(this.axes,t.shape.length),Hh(this.axes,n.shape.length)],this.normalize&&(t=Vm(t,r[0]),n=Vm(n,r[1])),SB(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Hh(this.axes,e.length),Hh(this.axes,t.length)],n}computeOutputShape(e){ze(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Xs("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}ZS.className="Dot";An(ZS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QS extends sr{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e);return If(()=>Bn(bb(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}QS.className="GaussianNoise";An(QS);class JS extends sr{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Qt(()=>{this.invokeCallHook(e,t);const n=Rs(e);return this.rate>0&&this.rate<1?If(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return Ft(n,bb(n.shape,1,a))},()=>n,t.training||!1):n})}}JS.className="GaussianDropout";An(JS);class e$ extends sr{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Rs(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Qt(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return If(()=>{const a=Rs(e),o=1.6732632423543772,i=1.0507009873554805,u=-o*i;let c=Sd(ff(n),this.rate);c=bc(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,l=Bn(Ft(a,c),Ft(Bn(c,-1),u));return Bn(Ft(l,d),h)},()=>Rs(e),t.training||!1)}return e})}}e$.className="AlphaDropout";An(e$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cp(s,e,t,n,r,a=.001){let o;if(s.rank===2)o=hA(s,e,t,n,r,a);else if(s.rank===3)o=fA(s,e,t,n,r,a);else if(s.rank===4)o=gA(s,e,t,n,r,a);else throw new Xs(`batchNormalization is not implemented for array of rank ${s.rank} yet`);return o}function $B(s,e,t,n,r=.001){return Qt(()=>{const a=ow(s,n),o=a.mean,i=a.variance;return[cp(s,o,i,t,e,r),o,i]})}function TB(s,e,t,n,r=.001){return Qt(()=>{const a=ow(s,n),o=a.mean,i=a.variance,u=[];for(const f of Uu(0,s.rank))n.indexOf(f)!==-1?u.push(1):u.push(s.shape[f]);const c=zt(o,u),d=zt(i,u),h=e==null?null:zt(e,u),l=t==null?null:zt(t,u);return[cp(s,c,d,l,h,r),o,i]})}function NB(s,e,t,n,r=.001){return Er(n.slice().sort(),Uu(0,s.rank-1))?$B(s,e,t,n,r):TB(s,e,t,n,r)}class t$ extends sr{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=aa(e.betaInitializer||"zeros"),this.gammaInitializer=aa(e.gammaInitializer||"ones"),this.movingMeanInitializer=aa(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=aa(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ma(e.betaConstraint),this.gammaConstraint=Ma(e.gammaConstraint),this.betaRegularizer=oa(e.betaRegularizer),this.gammaRegularizer=oa(e.gammaRegularizer)}build(e){e=kr(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new Rt(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Fa({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Qt(()=>{const n=t.training==null?!1:t.training,r=Rs(e),a=r.shape,o=a.length,i=Uu(0,o),u=this.axis>=0?this.axis:this.axis+o;i.splice(u,1);const c=wd(1,o);c[u]=a[u];const d=i.slice();d.sort();const h=!Er(d,Uu(0,o).slice(0,o-1)),l=()=>{if(h){const I=zt(this.movingMean.read(),c),N=zt(this.movingVariance.read(),c),E=this.center?zt(this.beta.read(),c):null,D=this.scale?zt(this.gamma.read(),c):null;return cp(r,I,N,E,D,this.epsilon)}else return cp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return l();const[p,f,x]=NB(r,this.gamma.read(),this.beta.read(),i,this.epsilon),b=(I,N,E)=>{Qt(()=>{const D=1-E,U=I.read(),L=Ft(Ds(U,N),D);I.write(Ds(U,L))})};return(()=>{b(this.movingMean,f,this.momentum),b(this.movingVariance,x,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:da(this.betaInitializer),gammaInitializer:da(this.gammaInitializer),movingMeanInitializer:da(this.movingMeanInitializer),movingVarianceInitializer:da(this.movingVarianceInitializer),betaRegularizer:zr(this.betaRegularizer),gammaRegularizer:zr(this.gammaRegularizer),betaConstraint:Da(this.betaConstraint),gammaConstraint:Da(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}t$.className="BatchNormalization";An(t$);class n$ extends sr{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=aa(e.betaInitializer||"zeros"),this.gammaInitializer=aa(e.gammaInitializer||"ones"),this.betaRegularizer=oa(e.betaRegularizer),this.gammaRegularizer=oa(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=kr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==ml(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=Rs(e),r=n.shape,a=r.length;return Qt(()=>{let{mean:i,variance:u}=ow(n,this.axis,!0);const c=wd(1,a);for(const x of this.axis)c[x]=r[x];const d=x=>x!=null&&x.shape.length!==a?zt(x,c):x;let h=this.scale?d(this.gamma.read()):null,l=this.center?d(this.beta.read()):null;const p=[],f=[];for(let x=0;x<a;++x)this.axis.indexOf(x)!==-1?(p.push(r[x]),f.push(1)):(p.push(1),f.push(r[x]));return i=Lu(i,p),u=Lu(u,p),h!=null&&(h=Lu(h,f)),l!=null&&(l=Lu(l,f)),cp(n,i,u,l,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:da(this.betaInitializer),gammaInitializer:da(this.gammaInitializer),betaRegularizer:zr(this.betaRegularizer),gammaRegularizer:zr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}n$.className="LayerNormalization";An(n$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EB(s,e,t){return Qt(()=>{if(s.rank!==4)throw new Rt(`temporalPadding expects input tensor to be 4-D, but received a ${s.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Rt("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=ju()),t!=="channelsLast"&&t!=="channelsFirst")throw new Rt(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],iw(s,n)})}class s$ extends sr{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?ju():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Rt(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Rt(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Rt(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Fa({ndim:4})]}computeOutputShape(e){e=kr(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return Qt(()=>EB(Rs(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}s$.className="ZeroPadding2D";An(s$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _b(s,e,t,n,r,a){return Qt(()=>{va(r),v_(a),Zi(n),t==null&&(t=[1,1]),n==null&&(n="valid"),r==null&&(r=ju()),a==null&&(a="max"),s=hv(s,r);let o;const i=n==="same"?"same":"valid";return a==="max"?o=aw(s,e,t,i):o=Ky(s,e,t,i),r==="channelsFirst"&&(o=br(o,[0,3,1,2])),o})}function r$(s,e,t,n,r,a){return Qt(()=>{va(r),v_(a),Zi(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),r==null&&(r=ju()),a==null&&(a="max"),s=vS(s,r);let o;const i=n==="same"?"same":"valid";return a==="max"?o=tF(s,e,t,i):o=nA(s,e,t,i),r==="channelsFirst"&&(o=br(o,[0,4,1,2,3])),o})}class a$ extends sr{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Rt(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Za(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Rt(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Za(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Zi(this.padding),this.inputSpec=[new Fa({ndim:3})]}computeOutputShape(e){e=kr(e);const t=Wu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Qt(()=>{this.invokeCallHook(e,t),e=vf(Rs(e),2);const n=this.poolingFunction(Rs(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return mf(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class o$ extends a${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),_b(e,t,n,r,a,"max")}}o$.className="MaxPooling1D";An(o$);class i$ extends a${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),_b(e,t,n,r,a,"avg")}}i$.className="AveragePooling1D";An(i$);class u$ extends sr{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Rt(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Za(this.poolSize,"poolSize"),Za(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,va(this.dataFormat),Zi(this.padding),this.inputSpec=[new Fa({ndim:4})]}computeOutputShape(e){e=kr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Wu(t,this.poolSize[0],this.padding,this.strides[0]),n=Wu(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Qt(()=>(this.invokeCallHook(e,t),this.poolingFunction(Rs(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class c$ extends u${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),_b(e,t,n,r,a,"max")}}c$.className="MaxPooling2D";An(c$);class l$ extends u${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),_b(e,t,n,r,a,"avg")}}l$.className="AveragePooling2D";An(l$);class d$ extends sr{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Rt(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Za(this.poolSize,"poolSize"),Za(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,va(this.dataFormat),Zi(this.padding),this.inputSpec=[new Fa({ndim:5})]}computeOutputShape(e){e=kr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Wu(t,this.poolSize[0],this.padding,this.strides[0]),n=Wu(n,this.poolSize[1],this.padding,this.strides[1]),r=Wu(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Qt(()=>(this.invokeCallHook(e,t),this.poolingFunction(Rs(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class h$ extends d${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),r$(e,t,n,r,a,"max")}}h$.className="MaxPooling3D";An(h$);class p$ extends d${constructor(e){super(e)}poolingFunction(e,t,n,r,a){return va(a),Zi(r),r$(e,t,n,r,a,"avg")}}p$.className="AveragePooling3D";An(p$);class f$ extends sr{constructor(e){super(e);this.inputSpec=[new Fa({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Xs}}class m$ extends f${constructor(e){super(e||{})}call(e,t){return Qt(()=>{const n=Rs(e);return Sa(n,1)})}}m$.className="GlobalAveragePooling1D";An(m$);class g$ extends f${constructor(e){super(e||{})}call(e,t){return Qt(()=>{const n=Rs(e);return zu(n,1)})}}g$.className="GlobalMaxPooling1D";An(g$);class b$ extends sr{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,va(this.dataFormat),this.inputSpec=[new Fa({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Xs}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class x$ extends b${call(e,t){return Qt(()=>{const n=Rs(e);return this.dataFormat==="channelsLast"?Sa(n,[1,2]):Sa(n,[2,3])})}}x$.className="GlobalAveragePooling2D";An(x$);class y$ extends b${call(e,t){return Qt(()=>{const n=Rs(e);return this.dataFormat==="channelsLast"?zu(n,[1,2]):zu(n,[2,3])})}}y$.className="GlobalMaxPooling2D";An(y$);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class w$ extends sr{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=t.layer,a=Lc(r,n);delete t.layer;const o={layer:a};return Object.assign(o,t),new e(o)}}class v$ extends w${constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=kr(e),e.length<3)throw new Rt(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=kr(e);const t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Qt(()=>(e=Rs(e),ES((o,i)=>[Rs(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}v$.className="TimeDistributed";An(v$);function RB(s){Rd(tL,"BidirectionalMergeMode",s)}const AB="concat";class k$ extends w${constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Lc(n),t.goBackwards=t.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Lc(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?AB:e.mergeMode,RB(this.mergeMode),e.weights)throw new Xs("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):Zo(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});const a=NS(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);const o=[],i=[];if(n!=null){const c=n.length;if(c%2>0)throw new Rt("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const d=n.map(h=>new Fa({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),i.push(...d)}if(r!=null)throw new Xs("Support for constants in Bidirectional layers is not implemented yet.");const u=o[0]instanceof dc;for(const c of o)if(c instanceof dc!==u)throw new Rt("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(o),d=this.inputSpec.concat(i),h=this.inputSpec;this.inputSpec=d;const l=super.apply(c,t);return this.inputSpec=h,l}else return super.apply(e,t)}call(e,t){return Qt(()=>{const n=t.initialState;let r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const u=n.slice(0,n.length/2),c=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=bd(a,1));let i;return this.mergeMode==="concat"?i=Jw([r,a]):this.mergeMode==="sum"?i=Bn(r,a):this.mergeMode==="ave"?i=Ft(.5,Bn(r,a)):this.mergeMode==="mul"?i=Ft(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(o):[i].concat(o):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ud(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ud(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){const a=this.forwardLayer.states.map(o=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Lc(t.layer);if(delete t.layer,t.numConstants!=null)throw new Xs("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}k$.className="Bidirectional";An(k$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class I$ extends sr{constructor(e){super(e);this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Qt(()=>(e=Rs(e),e.dtype!=="float32"&&(e=bc(e,"float32")),Bn(Ft(e,this.scale),this.offset)))}}I$.className="Rescaling";An(I$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:OB,cropAndResize:FB}=Pc;class C$ extends sr{constructor(e){super(e);this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,o,i,u){return Qt(()=>{let c,d=!1;const h=t/o,l=n/i,p=(r+t)/o,f=(a+n)/i,x=[h,l,p,f],b=[];e.rank===3?(d=!0,c=xl([e])):c=e;for(let D=0;D<c.shape[0];D++)b.push(x);const m=Am(b,[b.length,4]),I=ap(0,b.length,1,"int32"),E=FB(c,m,I,[r,a],"nearest");return bc(d?Rs(xd(E)):E,u)})}upsize(e,t,n,r){return Qt(()=>{const a=OB(e,[t,n]);return bc(a,r)})}call(e,t){return Qt(()=>{const n=Rs(e),r=n.dtype,a=n.shape,o=a[a.length-3],i=a[a.length-2];let u=0;o!==this.height&&(u=Math.floor((o-this.height)/2));let c=0;return i!==this.width&&(c=Math.floor((i-this.width)/2),c===0&&(c=1)),u>=0&&c>=0?this.centerCrop(n,u,c,this.height,this.width,o,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=kr(e);const t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}C$.className="CenterCrop";An(C$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DB(s,e,t,n){let r=Rs(s);if(r.dtype!=="int32"&&(r=bc(r,"int32")),e==="int")return r;const a=r.shape;if(r.rank===0&&(r=xi(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=xi(r,-1)),r.rank>2)throw new Rt(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${a} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(e),i=r;let u;if(typeof n!="undefined"&&e==="count"?u=ck(i,n,t,o):u=ck(i,[],t,o),e!=="tfIdf")return u;if(n)return Ft(u,n);throw new Rt("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _$ extends sr{constructor(e){super(e);this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=kr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Qt(()=>{e=Rs(e),e.dtype!=="int32"&&(e=bc(e,"int32"));let n;if(typeof t.countWeights!="undefined"){if(this.outputMode!=="count")throw new Rt(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Rs(t.countWeights)}const r=zu(e),a=Om(e),o=Yi(this.numTokens,r).bufferSync().get(0),i=Sd(a,0).bufferSync().get(0);if(!(o&&i))throw new Rt(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return DB(e,this.outputMode,this.numTokens,n)})}}_$.className="CategoryEncoding";An(_$);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const MB=["bilinear","nearest"],Hk=new Set(MB);class S$ extends sr{constructor(e){super(e);if(this.height=e.height,this.width=e.width,e.interpolation)if(Hk.has(e.interpolation))this.interpolation=e.interpolation;else throw new Rt(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=kr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Qt(()=>{const n=[this.height,this.width];if(this.interpolation==="bilinear")return Pc.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Pc.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Hk]} are supported`)})}}S$.className="Resizing";An(S$);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $${constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}$$.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class T$ extends sr{constructor(e){super(e);this.randomGenerator=new $$(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}T$.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const PB=["bilinear","nearest"],qk=new Set(PB);class N$ extends T${constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Rt(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Rt(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Rt(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(qk.has(n))this.interpolation=n;else throw new Rt(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=kr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Qt(()=>{const n=Rs(e);this.imgHeight=n.shape[n.shape.length-3];const r=n.shape[n.shape.length-2];this.widthFactor=ff([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);const o=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Pc.resizeBilinear(e,o);case"nearest":return Pc.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...qk]} are supported`)}})}}N$.className="RandomWidth";An(N$);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LB=nn();LB.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Kk;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(Kk||(Kk={}));var Xk;(function(s){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(Xk||(Xk={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Yk;(function(s){s[s.FAIL=0]="FAIL",s[s.SHORTEST=1]="SHORTEST",s[s.LONGEST=2]="LONGEST"})(Yk||(Yk={}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(s,e){Array.isArray(s)||(s=[s]),s.forEach(t=>{t!=null&&ze(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BB=SC;class Sb extends J0{nextDataId(){return Sb.nextDataId++}constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new W2(this,oc())}write(e,t,n){this.firstUse&&(this.firstUse=!1,nn().get("IS_NODE")&&Gi(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&mp(n[0])){const a=n.map(o=>fl(o));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){const r=this.readSync(n.real.dataId),a=this.readSync(n.imag.dataId);return Vc(r,a)}return bE(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(r=>bl(r));return tr(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tr(e.shape,e.dtype,t)}makeOutput(e,t,n){return oc().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Yo();return e(),{kernelMs:Yo()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ls([e],"where");const t=this.readSync(e.dataId);return BB(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Sb.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(s){const e=new Float32Array(s.length);for(let t=0;t<s.length;++t)e[t]=Math.abs(s[t]);return e}const zB=s=>{const{x:e}=s.inputs,t=s.backend;ls(e,"abs");let n=new Float32Array(hn(e.shape));const r=t.data.get(e.dataId).values;return n=E$(r),t.makeOutput(n,e.shape,e.dtype)},WB={kernelName:sg,backendName:"cpu",kernelFunc:zB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(s){return(e,t,n,r,a)=>{const o=js(e,t),i=o.length,u=ws(o),c=hn(o),d=ko(a,c),h=e.length,l=t.length,p=ws(e),f=ws(t),x=oh(e,o),b=oh(t,o);if(x.length+b.length===0)for(let m=0;m<d.length;++m)d[m]=s(n[m%n.length],r[m%r.length]);else for(let m=0;m<d.length;++m){const I=xh(m,i,u),N=I.slice(-h);x.forEach(L=>N[L]=0);const E=fc(N,h,p),D=I.slice(-l);b.forEach(L=>D[L]=0);const U=fc(D,l,f);d[m]=s(n[E],r[U])}return[d,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(s){const{inputs:e,backend:t}=s,{real:n,imag:r}=e,a=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,i=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(i.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",a),imag:t.makeTensorInfo(r.shape,"float32",o)},i}const VB={kernelName:dy,backendName:"cpu",kernelFunc:yi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qm(s,e,t="float32"){if(t==="complex64"){const r=qm(s,e,"float32"),a=qm(s,e,"float32");return yi({inputs:{real:r,imag:a},backend:s})}const n=Io(hn(e),t);return s.makeTensorInfo(e,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vc(s){const{inputs:e,backend:t}=s,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const UB={kernelName:Mp,backendName:"cpu",kernelFunc:vc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vd(s){const{inputs:e,backend:t}=s,{input:n}=e,r=t.data.get(n.dataId).complexTensorInfos.real,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const jB={kernelName:Fy,backendName:"cpu",kernelFunc:vd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(s,e,t,n){if(n==="int32"){const r=Int32Array.from(s);return[e,"int32",r]}if(n==="bool"){const r=_d([0],t),[a,o]=ka((i,u)=>i!==u?1:0)(e,[],s,r,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${t} to ${n}`)}function Il(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{dtype:a}=n;if(a==="complex64"){if(r.dtype==="complex64")return vc({inputs:{x:r},backend:t});const d=qm(t,r.shape,r.dtype),h=Il({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=yi({inputs:{real:h,imag:d},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),l}if(r.dtype==="complex64"){const d=vd({inputs:{input:r},backend:t}),h=Il({inputs:{x:d},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(d),h}if(!j2(r.dtype,a)){const d=vc({inputs:{x:r},backend:t});return{dataId:d.dataId,shape:d.shape,dtype:a}}const o=t.data.get(r.dataId).values,[i,u,c]=R$(o,r.shape,r.dtype,a);return t.makeTensorInfo(i,u,c)}const GB={kernelName:Ip,backendName:"cpu",kernelFunc:Il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function La(s,e,t,n){return t==null?({inputs:r,backend:a})=>{const{a:o,b:i}=r,u=a;ls([o,i],s);const c=u.data.get(o.dataId).values,d=u.data.get(i.dataId).values,h=o.dtype==="string"?Uc(c):c,l=o.dtype==="string"?Uc(d):d,p=n||o.dtype,[f,x]=e(o.shape,i.shape,h,l,p);return u.makeTensorInfo(x,p,f)}:({inputs:r,backend:a})=>{const{a:o,b:i}=r,u=a;if(o.dtype==="complex64"||i.dtype==="complex64"){const c=Il({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(c.dataId),h=d.complexTensorInfos.real,l=d.complexTensorInfos.imag,p=u.data.get(h.dataId).values,f=u.data.get(l.dataId).values,x=Il({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),b=u.data.get(x.dataId),m=b.complexTensorInfos.real,I=b.complexTensorInfos.imag,N=u.data.get(m.dataId).values,E=u.data.get(I.dataId).values,[D,U,L]=t(o.shape,i.shape,p,f,N,E),Y=u.makeTensorInfo(L,"float32",D),V=u.makeTensorInfo(L,"float32",U),P=yi({inputs:{real:Y,imag:V},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(x),u.disposeIntermediateTensorInfo(Y),u.disposeIntermediateTensorInfo(V),P}else{const c=u.data.get(o.dataId).values,d=u.data.get(i.dataId).values,h=n||o.dtype,[l,p]=e(o.shape,i.shape,c,d,h);return u.makeTensorInfo(p,h,l)}}}function xv(s){return(e,t,n,r,a,o)=>{const i=js(e,t),u=hn(i),c=i.length,d=ws(i),h=ko("float32",u),l=ko("float32",u),p=oh(e,i),f=oh(t,i),x=Vc(n,r),b=Vc(a,o),m=e.length,I=ws(e),N=t.length,E=ws(t);if(p.length+f.length===0)for(let D=0;D<h.length;D++){const U=D%x.length,L=D%b.length,Y=s(x[U*2],x[U*2+1],b[L*2],b[L*2+1]);h[D]=Y.real,l[D]=Y.imag}else for(let D=0;D<h.length;D++){const U=xh(D,c,d),L=U.slice(-m);p.forEach(ne=>L[ne]=0);const Y=fc(L,m,I),V=U.slice(-N);f.forEach(ne=>V[ne]=0);const P=fc(V,N,E),oe=s(x[Y*2],x[Y*2+1],b[P*2],b[P*2+1]);h[D]=oe.real,l[D]=oe.imag}return[h,l,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A$=ka((s,e)=>s+e),HB=xv((s,e,t,n)=>({real:s+t,imag:e+n})),lh=La(yh,A$,HB),qB={kernelName:yh,backendName:"cpu",kernelFunc:lh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(s,e,t,n,r){const a=hn(n),o=Io(r,t);for(let i=0;i<s.length;i++){const u=s[i];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(a>0?o[u]+=e[i]:o[u]+=1)}return o}function O$(s,e,t,n=!1){const r=s.shape[0],a=s.shape[1],o=tr([r,t],e.dtype);for(let i=0;i<r;i++)for(let u=0;u<a;u++){const c=s.get(i,u);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(n?o.set(1,i,c):e.size>0?o.set(o.get(i,c)+e.get(i,u),i,c):o.set(o.get(i,c)+1,i,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$=ka((s,e)=>s&e),KB=La(X2,F$),XB={kernelName:X2,backendName:"cpu",kernelFunc:KB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kc(s){return(e,t,n)=>{const r=ba(t,e.length);for(let a=0;a<e.length;++a)r[a]=s(e[a],n);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fr(s,e,t){const n=kc(e);return Rl(s,n,t)}function Rl(s,e,t){return({inputs:n,attrs:r,backend:a})=>{const{x:o}=n;ls(o,s);const i=a,u=i.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Uc(u)}else c=u;const d=t||o.dtype,h=e(c,d,r);return i.makeTensorInfo(o.shape,d,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$=kc(s=>Math.ceil(s)),YB=Rl(Cp,D$),ZB={kernelName:Cp,backendName:"cpu",kernelFunc:YB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(s,e,t,n){const r=ba(t,hn(e));if(n&&t!=="string"){let a=0;s.forEach(o=>{const i=hn(o.shape);r.set(o.vals,a),a+=i})}else{let a=0;s.forEach(o=>{const i=t==="string"?Uc(o.vals):o.vals;let u=0;for(let c=0;c<o.shape[0];++c){const d=c*e[1]+a;for(let h=0;h<o.shape[1];++h)r[d+h]=i[u++]}a+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P$=ka((s,e)=>s===e?1:0),L$=La(xg,P$,null,"bool"),QB={kernelName:xg,backendName:"cpu",kernelFunc:L$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$=kc(s=>Math.exp(s)),z$=Rl(Rp,B$,"float32"),JB={kernelName:Rp,backendName:"cpu",kernelFunc:z$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$=kc(s=>Math.expm1(s)),e4=Rl(Ap,W$),t4={kernelName:Ap,backendName:"cpu",kernelFunc:e4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$=kc(s=>Math.floor(s)),n4=Rl(Op,V$),s4={kernelName:Op,backendName:"cpu",kernelFunc:n4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U$=ka((s,e)=>Math.floor(s/e)),r4=La(Fp,U$,null,"int32"),a4={kernelName:Fp,backendName:"cpu",kernelFunc:r4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(s,e,t,n,r,a,o,i,u){const c=tr([n,a],t);for(let d=0;d<n;d++){const h=[];let l=0;for(let p=0;p<r;p++){const f=s[d*r+p];l+=f*o[p],h.push(f)}if(l<0||l>=u/a)throw new Error(`Invalid indices: ${h} does not index into ${i}`);for(let p=0;p<a;p++)c.values[d*a+p]=e.get(...e.indexToLoc(l*a+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(s,e,t){const n=tr(t,s.dtype);for(let r=0;r<n.size;++r){const o=n.indexToLoc(r).slice(),i=o[0],u=o[2],c=e.locToIndex([i,u]);o[2]=e.values[c];const d=s.locToIndex(o);0<=d&&d<s.values.length&&(n.values[r]=s.values[d])}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$=ka((s,e)=>s>e?1:0),o4=La(kg,H$,null,"bool"),i4={kernelName:kg,backendName:"cpu",kernelFunc:o4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$=ka((s,e)=>s>=e?1:0),u4=La(Dp,q$,null,"bool"),c4={kernelName:Dp,backendName:"cpu",kernelFunc:u4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K$=ka((s,e)=>s<e?1:0),l4=La(Cg,K$,null,"bool"),d4={kernelName:Cg,backendName:"cpu",kernelFunc:l4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X$=ka((s,e)=>s<=e?1:0),h4=La(_g,X$,null,"bool"),p4={kernelName:_g,backendName:"cpu",kernelFunc:h4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(s,e,t){const n=(e-s)/(t-1),r=Io(t,"float32");r[0]=s;for(let a=1;a<r.length;a++)r[a]=r[a-1]+n;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$=kc(s=>Math.log(s)),f4=Rl(zp,Z$),m4={kernelName:zp,backendName:"cpu",kernelFunc:f4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(s,e,t,n){const r=ko(n,hn(t));for(let a=0;a<r.length;++a){const o=a*e;let i=s[o];for(let u=0;u<e;++u){const c=s[o+u];(Number.isNaN(c)||c>i)&&(i=c)}r[a]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$=ka((s,e)=>Math.max(s,e)),g4=La(Vp,J$),b4={kernelName:Vp,backendName:"cpu",kernelFunc:g4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=ka((s,e)=>Math.min(s,e)),x4=La(Up,eT),y4={kernelName:Up,backendName:"cpu",kernelFunc:x4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wv=ka((s,e)=>s*e),w4=xv((s,e,t,n)=>({real:s*t-e*n,imag:s*n+e*t})),$b=La(Gp,wv,w4),v4={kernelName:Gp,backendName:"cpu",kernelFunc:$b};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tT(s,e,t){const n=_l(-1,t);return wv([],e,n,s,t)}function k4(s){const{inputs:e,backend:t}=s,{x:n}=e;ls(n,"neg");const r=t.data.get(n.dataId).values,[a,o]=tT(r,n.shape,n.dtype);return t.makeTensorInfo(o,n.dtype,a)}const I4={kernelName:Mg,backendName:"cpu",kernelFunc:k4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT=ka((s,e)=>s!==e?1:0),C4=La(Pg,nT,null,"bool"),_4={kernelName:Pg,backendName:"cpu",kernelFunc:C4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(s,e,t,n,r){const a=e.length,o=hn(e),i=ws(e),u=ws(r),c=ko(t,hn(r));for(let d=0;d<o;++d){const h=xh(d,a,i),l=new Array(h.length);for(let f=0;f<l.length;f++)l[f]=h[n[f]];const p=fc(l,a,u);c[p]=s[d]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(s){const{inputs:e,attrs:t,backend:n}=s,{x:r}=e,{perm:a}=t;ls(r,"transpose");const o=r.shape.length,i=new Array(o);for(let h=0;h<i.length;h++)i[h]=r.shape[a[h]];const u=n.data.get(r.dataId).values,c=vv(u,r.shape,r.dtype,a,i);return{dataId:n.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const S4={kernelName:Yd,backendName:"cpu",kernelFunc:ei};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(s,e,t,n){const[r,a]=Ja(s,n),o=vi(e,"int32"),i=Io(hn(r),o),u=hn(a);for(let c=0;c<i.length;++c){const d=c*u;let h=1;for(let l=0;l<u;++l)h*=t[d+l];i[c]=h}return{outVals:i,outShape:r,outDtype:o}}function $4(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;ls(r,"prod");const i=r.shape.length,u=nr(a,r.shape),c=ha(u,i);let d=u,h=r;const l=[];c!=null&&(h=ei({inputs:{x:r},backend:t,attrs:{perm:c}}),l.push(h),d=wa(d.length,i));const p=t.data.get(h.dataId).values,{outVals:f,outShape:x,outDtype:b}=sT(h.shape,h.dtype,p,d);let m=x;return o&&(m=$a(x,u)),l.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.makeTensorInfo(m,b,f)}const T4={kernelName:Ug,backendName:"cpu",kernelFunc:$4};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4(s,e,t){s.forEach((n,r)=>{if(n<0||n>=t){const a=xh(r,e.length,ws(e)).join(",");throw new Error(`indices[${a}] = ${n} is not in [0, ${t})`)}})}function E4(s,e){for(let t=0;t<s.length;++t){const n=s[t],r=t===s.length-1?e:s[t+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<n.length;++a)if(n[a-1]>n[a])throw new Error("Ragged splits must be sorted in ascending order")}}function R4(s,e,t,n){const r=[];let a=0;const o=e.length-1+t.length,i=new Array(o).fill(null).map(()=>[0]);E4(t,n);let u=1;for(let c=0;c<e.length-1;++c){u*=e[c];const d=e[c+1];for(let h=1;h<u+1;++h)i[c].push(h*d)}for(let c=0;c<s.length;++c){let d=s[c],h=s[c]+1;for(let l=0;l<t.length;++l){const p=t[l],f=l+e.length-1;if(f>=0){const x=i[f],b=x[x.length-1]-p[d];for(let m=d;m<h;++m)i[f].push(p[m+1]+b)}d=p[d],h=p[h]}h!==d&&(r.push([d,h]),a+=h-d)}return{outSplits:i,valueSlices:r,numValues:a}}function A4(s){const e=[];for(let t=0;t<s.length;++t){const n=s[t].length,r=ba("int32",n);e.push(r),s[t].forEach((a,o)=>r[o]=a)}return e}function Zk(s,e){const t=s.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<s.length;n++)t[e-1]*=s[n];return t}function O4(s,e,t,n,r,a){const o=Zk(e,2)[1],i=Zk(a,2)[1];let u=0;for(const c of t)for(let d=c[0];d<c[1];++d){for(let h=0;h<n;++h)r[u*i+h]=s[d*o+h];++u}}function F4(s,e,t,n,r){const a=e.slice();a[0]=r;const o=ba(t,hn(a)),i=s.length,u=i===0?0:i/e[0];return O4(s,e,n,u,o,a),[o,a]}function rT(s,e,t,n,r,a,o,i){if(s.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(N4(a,o,u),n.length===0)throw new Error("params.rank must be nonzero");const c=n[0],{outSplits:d,valueSlices:h,numValues:l}=R4(a,o,s,c),p=A4(d),f=F4(t,n,r,h,l);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=2147483647;function aT(s,e,t,n,r,a,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=e.length===0,u=r.length===0,c=o.length===0,d=[];i||d.push(e[0]),u||d.push(r[0]),c||d.push(o[0]);for(let b=1;b<d.length;++b)if(d[b]!==d[b-1])throw new Error("starts, limits, and deltas must have the same shape");const h=d.length===0?1:d[0],l=ba("int32",h+1);l[0]=0;for(let b=0;b<h;++b){const m=i?s[0]:s[b],I=u?n[0]:n[b],N=c?a[0]:a[b];if(N===0)throw new Error("Requires delta != 0");let E;if(N>0&&I<m||N<0&&I>m)E=0;else if(E=Math.ceil(Math.abs((I-m)/N)),E>Qk)throw new Error(`Requires ((limit - start) / delta) <= ${Qk}`);l[b+1]=l[b]+E}const p=l[h],f=ba(t,p);let x=0;for(let b=0;b<h;++b){const m=l[b+1]-l[b];let I=i?s[0]:s[b];const N=c?a[0]:a[b];for(let E=0;E<m;++E)f[x++]=I,I+=N}return[l,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pu=Pu;class Km{constructor(e,t,n,r,a,o,i,u,c,d){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=HC(d),this.raggedRank=qC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===pu.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===pu.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case pu.VALUE_ROWIDS:return Km.getMaxWidthValueRowID(t);case pu.ROW_SPLITS:return Km.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${pu[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let n=0;for(let r=0;r<t-1;++r){const a=e[r+1]-e[r];a>n&&(n=a)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let n=0,r=e[0],a=0;for(let o=1;o<t;++o){const i=e[o];i!==r&&(r=i,a=Math.max(o-n,a),n=o)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return e2(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;KC(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=GC(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let o=0;for(let i=0;i<r;++i,o+=t)a.push(o);for(let i=r;i<e;++i)a.push(-1);return ze(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,o=[];for(let i=0;i<a-1;++i){const u=e[i+1]-e[i];let c=Math.min(r,u),d=t[i];d===-1&&(c=0);for(let h=0;h<c;++h)o.push(d),d+=n;for(let h=0;h<u-c;++h)o.push(-1)}if(a>0&&o.length!==e[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,o=[];if(a===0)return[];let i=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let c=t[u];o.push(c);for(let d=1;d<a;++d){const h=e[d];if(h===u)c>=0&&(++i,i<r?c+=n:c=-1);else{if(i=0,u=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case pu.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case pu.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${pu[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case pu.FIRST_DIM_SIZE:return e[0];case pu.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case pu.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${pu[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*n[u+1];const a=e2(n,!1),o=ba(this.valuesDType,hn(a));if(r[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,r[c],n[c]);this.setOutput(this.raggedRank,u,o,a)}return[a,o]}setOutput(e,t,n,r){if(n.length===0)return;const a=this.values,o=n;let i=r.slice();i=i.slice(e+1);const u=hn(i),c=t.length;let d=this.defaultValue;if(d.length!==u&&d.length!==1){const f=this.defaultValueShape;Qt(()=>{const x=zt(d,f);d=ep(x,i).dataSync()})}let h=0,l=0,p=0;for(let f=0;f<=c;++f){let x=f<c?t[f]:-1;if(x===p){++p;continue}if(l<p){const b=a.subarray(h*u),m=o.subarray(l*u),I=(p-l)*u;Jk(m,b,I)}if(f>=c){const b=n.length;x=Math.floor(b/u)}if(x>p)if(this.defaultValue.length===1)o.subarray(p*u,x*u).fill(this.defaultValue[0]),p=x;else for(;x>p;){const b=o.slice(p*u);Jk(b,d,u),++p}x<0?(h=f+1,l=p):(h=f,l=p,p=l+1)}}}function Jk(s,e,t){for(let n=0;n<t;n++)s[n]=e[n]}function e2(s,e){const t=[];for(let n of s){if(n<0){if(!e)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}t.push(n)}return t}function oT(s,e,t,n,r,a,o,i,u,c){return new Km(s,e,t,n,r,a,o,i,u,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iT(s,e,t,n){const r=s===e,a=s<e&&t<0,o=e<s&&t>1;if(r||a||o)return Io(0,n);const i=Math.abs(Math.ceil((e-s)/t)),u=Io(i,n);e<s&&t===1&&(t=-1),u[0]=s;for(let c=1;c<u.length;c++)u[c]=u[c-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uT=kc(s=>1/Math.sqrt(s)),D4=Rl(Zp,uT),M4={kernelName:Zp,backendName:"cpu",kernelFunc:D4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function od(s,e,t,n,r,a,o,i,u,c){const d=[n/r,r],h=s.values,l=e.values;if(n===0)return tr(t,e.dtype);const p=u instanceof co?u:tr(d,e.dtype);typeof u=="string"||typeof u=="number"?p.values.fill(u):typeof u=="boolean"&&p.values.fill(+u);for(let f=0;f<a;f++){const x=[];let b=0;for(let m=0;m<o;m++){const I=h[f*o+m];x.push(I),b+=I*i[m]}if(b<0||b>=n/r)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let m=0;m<r;m++)c?p.values[b*r+m]+=l[f*r+m]:p.values[b*r+m]=e.rank===0?l[0]:l[f*r+m]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P4=kc(s=>1/(1+Math.exp(-s))),cT=Fr(nf,s=>1/(1+Math.exp(-s))),L4={kernelName:nf,backendName:"cpu",kernelFunc:cT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lT(s,e,t,n,r){const a=Tw(n,e,t),o=hn(t),i=ws(n);if(a){const h=Nw(e,i);return r==="string"?s.slice(h,h+o):s.subarray(h,h+o)}const u=r==="string"?Uc(s):s,c=tr(n,r,u),d=tr(t,r);for(let h=0;h<d.size;++h){const l=d.indexToLoc(h),p=l.map((f,x)=>f+e[x]);d.set(c.get(...p),...l)}return r==="string"?f_(d.values):d.values}function kd(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{begin:a,size:o}=n;ls(r,"slice");const[i,u]=hb(r,a,o);Sw(r,i,u);const c=t.data.get(r.dataId).values,d=lT(c,i,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,d)}const B4={kernelName:Xg,backendName:"cpu",kernelFunc:kd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dT(s,e,t,n,r,a,o){const i=e[0],u=a[0],c=new Array(u),d=new Array(i),h=e[1];if(u===0){if(i!==0)throw new Error(t_(i));const b=ba(t,0),m=ba(r,0);return[b,[0,h],m,c,d]}let l=!0,p=0;const f=new Array(u).fill(0);for(let b=0;b<i;++b){const m=s[b*h];if(m<0)throw new Error(n_(b,m));if(m>=u)throw new Error(s_(b,m,u));++f[m],l=l&&m>=p,p=m}let x=!0;for(let b=0;b<u;++b){const m=f[b]===0;c[b]=m,x=x&&!m,f[b]=Math.max(f[b],1),b>0&&(f[b]+=f[b-1])}if(x&&l){const b=s,m=n;for(let I=0;I<i;++I)d[I]=I;return[b,[i,h],m,c,d]}else{const b=f[u-1],m=ba(t,b*h),I=ba(r,b),N=new Array(u).fill(0);for(let E=0;E<i;++E){const D=s[E*h],U=N[D],L=(D===0?0:f[D-1])+U;N[D]++;for(let Y=0;Y<h;++Y)m[L*h+Y]=s[E*h+Y];I[L]=n[E],d[E]=L}for(let E=0;E<u;++E)if(N[E]===0){const U=E===0?0:f[E-1];m[U*h+0]=E;for(let L=1;L<h;++L)m[U*h+L]=0;I[U]=o}return[m,[b,h],I,c,d]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hT(s,e,t,n,r){const a=hn(n),o=e[0],i=r.length,u=[];let c=1,d=-1;for(let b=0;b<i;++b){const m=r[b];if(m===-1){if(d!==-1)throw new Error(r_(d,b));d=b,u.push(1)}else{if(m<0)throw new Error(a_(b,m));c*=m,u.push(m)}}if(d!==-1){if(c<=0)throw new Error(o_());const b=Math.trunc(a/c);if(c*b!==a)throw new Error(i_(n,u));u[d]=b}if(hn(u)!==a)throw new Error(u_(n,u));const l=n.length,p=[];if(l>0){p[l-1]=1;for(let b=l-2;b>=0;--b)p[b]=p[b+1]*n[b+1]}const f=[];if(i>0){f[i-1]=1;for(let b=i-2;b>=0;--b)f[b]=f[b+1]*u[b+1]}const x=ba(t,o*i);for(let b=0;b<o;++b){let m=0;for(let I=0;I<l;++I)m+=s[b*l+I]*p[I];for(let I=0;I<i;++I)x[b*i+I]=Math.trunc(m/f[I]),m%=f[I]}return[x,[o,i],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(s,e,t,n,r,a=!1,o=0){const i=n.length,u=[e[0],s.length/e[0]],c=u[1],h=i>0?r[i-1]+1:0;if(h<0)throw new Error(A0());const l=e.slice();l[0]=h;const p=l.reduce((N,E)=>N*E,1),f=ba(t,p);if(i===0)return h>0&&f.fill(o),[f,l];if(h<=0)throw new Error(A0());let x=0,b=1,m=0,I=r[x];for(;;){let N=0;if(b<i){if(N=r[b],I===N){++b;continue}if(I>=N)throw new Error(c_())}if(I<0||I>=h)throw new Error(l_(I,h));I>m&&f.fill(o,m*c,I*c);for(let E=x;E<b;++E){const D=n[E];if(D<0||D>=u[0])throw new Error(d_(E,n[E],u[0]));for(let U=0;U<c;U++)f[I*c+U]+=s[D*c+U]}if(a)for(let E=0;E<c;E++)f[I*c+E]/=b-x;if(x=b,++b,m=I+1,I=N,b>i)break}return m<h&&f.fill(o,m*c,h*c),[f,l]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4=kc(s=>Math.sqrt(s)),W4=Fr(rf,s=>Math.sqrt(s)),V4={kernelName:rf,backendName:"cpu",kernelFunc:W4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pT=ka((s,e)=>{const t=s-e;return t*t}),U4=La(af,pT),j4={kernelName:af,backendName:"cpu",kernelFunc:U4};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fT=kc((s,e)=>{const{pattern:t,replaceGlobal:n,rewrite:r}=e;return s.replace(new RegExp(t,n?"g":""),r)}),G4=Rl(Ly,fT),H4={kernelName:Ly,backendName:"cpu",kernelFunc:G4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mT(s,e,t,n){const r=tr(s,e.dtype);for(let a=0;a<r.size;a++){const o=r.indexToLoc(a),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*t[u]+n[u];r.set(e.get(...i),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q4{constructor(e,t,n,r,a,o){this.separator=fl(e),this.nGramWidths=t,this.leftPad=fl(n),this.rightPad=fl(r),this.padWidth=a,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,o){for(let i=0;i<a;++i){const u=this.getPadWidth(o),c=Math.max(0,u-i),d=Math.max(0,u-(a-(i+1))),h=o-(c+d),l=t+(c>0?0:i-u);let p=0;p+=c*this.leftPad.length;for(let I=0;I<h;++I)p+=e[l+I].length;p+=d*this.rightPad.length,p+=(c+d+h-1)*this.separator.length,n[r+i]=new Uint8Array(p);const x=n[r+i];let b=0;const m=I=>I.forEach(N=>x[b++]=N);for(let I=0;I<c;++I)m(this.leftPad),m(this.separator);for(let I=0;I<h-1;++I)m(e[l+I]),m(this.separator);if(h>0){m(e[l+h-1]);for(let I=0;I<d;++I)m(this.separator),m(this.rightPad)}else{for(let I=0;I<d-1;++I)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<r;++c){let d=t[c]>=u;if(d=d&&t[c]<=n,!d)throw new Error(`Invalid split value ${t[c]}, must be in [${u}, ${n}]`);u=t[c]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}const a=r-1,o=ba("int32",r);if(n===0||r===0){const u=new Array(n);for(let c=0;c<=a;++c)o[c]=0;return[u,o]}o[0]=0;for(let u=1;u<=a;++u){const c=t[u]-t[u-1];let d=0;this.nGramWidths.forEach(h=>{d+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&d===0&&(d=1),o[u]=o[u-1]+d}const i=new Array(o[a]);for(let u=0;u<a;++u){const c=t[u];let d=o[u];if(this.nGramWidths.forEach(h=>{const l=t[u+1]-t[u],p=this.getNumNGrams(l,h);this.createNGrams(e,c,i,d,p,h),d+=p}),this.preserveShort&&d===o[u]){const h=t[u+1]-t[u];if(h===0)continue;const l=h+2*this.padWidth,p=1;this.createNGrams(e,c,i,d,p,l)}}return[i,o]}}function gT(s,e,t,n,r,a,o,i){return new q4(t,n,r,a,o,i).compute(s,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(s,e,t,n){if(!s.length)return;if(e.length===0){for(let a=0;a<s.length;++a)n.push(s.subarray(a,a+1));return}if(e.length===1){const a=e[0];let o=s.indexOf(a);for(;o!==-1;){const i=s.subarray(0,o);(!t||i.length!==0)&&n.push(i),s=s.subarray(o+1),o=s.indexOf(a)}(!t||s.length!==0)&&n.push(s);return}let r=0;for(let a=0;a<s.length+1;a++)if(a===s.length||e.indexOf(s[a])!==-1){const o=s.subarray(r,a);(!t||o.length!==0)&&n.push(o),r=a+1}}function bT(s,e,t){const n=s.length,r=[];let a=0,o=0;const i=new Array(n);for(let l=0;l<n;++l){const p=r.length;K4(s[l],e,t,r);const f=r.length-p;i[l]=f,a+=f,o=Math.max(o,f)}const u=ba("int32",a*2),c=new Array(a),d=[n,o];let h=0;for(let l=0;l<n;++l)for(let p=0;p<i[l];++p)u[h*2]=l,u[h*2+1]=p,c[h]=r[h],++h;return[u,c,d]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(s,e){const t=ba("int32",s.length);for(let n=0;n<s.length;++n)t[n]=DE(s[n]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yT=ka((s,e)=>s-e),X4=xv((s,e,t,n)=>({real:s-t,imag:e-n})),Iv=La(of,yT,X4),Y4={kernelName:of,backendName:"cpu",kernelFunc:Iv};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(s,e){const t=new Array(s.rank);for(let r=0;r<t.length;r++)t[r]=s.shape[r]*e[r];const n=tr(t,s.dtype);for(let r=0;r<n.values.length;++r){const a=n.indexToLoc(r),o=new Array(s.rank);for(let u=0;u<o.length;u++)o[u]=a[u]%s.shape[u];const i=s.locToIndex(o);n.values[r]=s.values[i]}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zh=(s,e)=>{const t=e.value-s.value;return t===0?s.index-e.index:t};function vT(s,e,t=0,n=s.length-1){for(;n>t;){if(n-t>600){const i=n-t+1,u=e-t+1,c=Math.log(i),d=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*d*(i-d)/i)*Math.sign(u-i/2),l=Math.max(t,Math.floor(e-u*d/i+h)),p=Math.min(n,Math.floor(e+(i-u)*d/i+h));vT(s,e,l,p)}const r=s[e];let a=t,o=n;for(Gd(s,t,e),Zh(s[n],r)>0&&Gd(s,t,n);a<o;){for(Gd(s,a,o),a++,o--;Zh(s[a],r)<0;)a=a+1;for(;Zh(s[o],r)>0;)o=o-1}Zh(s[t],r)===0?Gd(s,t,o):(o=o+1,Gd(s,o,n)),o<=e&&(t=o+1),e<=o&&(n=o-1)}}function kT(s,e,t,n,r){const a=e[e.length-1],[o,i]=[s.length/a,a],u=ko(t,o*n),c=ko("int32",o*n);for(let h=0;h<o;h++){const l=h*i,p=s.subarray(l,l+i);let f=new Array(p.length);p.forEach((I,N)=>f[N]={value:I,index:N}),n<f.length&&(vT(f,n),f=f.slice(0,n)),r&&f.sort(Zh);const x=h*n,b=u.subarray(x,x+n),m=c.subarray(x,x+n);for(let I=0;I<n;I++)b[I]=f[I].value,m[I]=f[I].index}const d=e.slice();return d[d.length-1]=n,[tr(d,t,u),tr(d,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IT(s,e,t,n){const r=nr(e,t)[0],a=[1,t[0],1];for(let f=0;f<r;f++)a[0]*=t[f];a[1]=t[r];for(let f=r+1;f<t.length;f++)a[2]*=t[f];const o=new Map,i=new Int32Array(t[r]),u=new co(a,n,s),c=[],d=a[0]===1&&a[2]===1;for(let f=0;f<t[r];f++){let x;if(d)x=s[f].toString();else{const m=[];for(let I=0;I<a[0];I++)for(let N=0;N<a[2];N++)m.push(u.get(I,f,N));x=m.join(",")}const b=o.get(x);if(b!=null)i[f]=b;else{const m=o.size;o.set(x,m),i[f]=m,c.push(f)}}const h=a.slice();h[1]=o.size;const l=new co(h,n);c.forEach((f,x)=>{for(let b=0;b<a[0];b++)for(let m=0;m<a[2];m++)l.set(u.get(b,f,m),b,x,m)});const p=t.slice();return p[r]=h[1],{outputValues:l.values,outputShape:p,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Z4=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:E$,addImpl:A$,bincountImpl:yv,bincountReduceImpl:O$,bitwiseAndImpl:F$,castImpl:R$,ceilImpl:D$,concatImpl:M$,equalImpl:P$,expImpl:B$,expm1Impl:W$,floorImpl:V$,floorDivImpl:U$,gatherNdImpl:j$,gatherV2Impl:G$,greaterImpl:H$,greaterEqualImpl:q$,lessImpl:K$,lessEqualImpl:X$,linSpaceImpl:Y$,logImpl:Z$,maxImpl:Q$,maximumImpl:J$,minimumImpl:eT,multiplyImpl:wv,negImpl:tT,notEqualImpl:nT,prodImpl:sT,raggedGatherImpl:rT,raggedRangeImpl:aT,raggedTensorToTensorImpl:oT,rangeImpl:iT,rsqrtImpl:uT,scatterImpl:od,sigmoidImpl:P4,sliceImpl:lT,sparseFillEmptyRowsImpl:dT,sparseReshapeImpl:hT,sparseSegmentReductionImpl:kv,sqrtImpl:z4,squaredDifferenceImpl:pT,staticRegexReplaceImpl:fT,stridedSliceImpl:mT,stringNGramsImpl:gT,stringSplitImpl:bT,stringToHashBucketFastImpl:xT,subImpl:yT,tileImpl:wT,topKImpl:kT,transposeImpl:vv,uniqueImpl:IT},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */GI("cpu",()=>new Sb,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CT=Fr(Np,s=>s>=0?s:Math.exp(s)-1),Q4={kernelName:Np,backendName:"cpu",kernelFunc:CT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{alpha:a}=n;ls([r],"leakyRelu");const o=hn(r.shape),i=t.data.get(r.dataId).values,u=ko("float32",o);for(let c=0;c<i.length;c++)u[c]=i[c]<0?a*i[c]:i[c];return t.makeTensorInfo(r.shape,"float32",u)}const J4={kernelName:Ig,backendName:"cpu",kernelFunc:_T};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ez=ka((s,e)=>s<0?e*s:s);function ST(s){const{inputs:e,backend:t}=s,{x:n,alpha:r}=e;ls([n,r],"prelu");const a=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,[i,u]=ez(n.shape,r.shape,a,o,"float32");return t.makeTensorInfo(u,"float32",i)}const tz={kernelName:Vg,backendName:"cpu",kernelFunc:ST};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $T=Fr(Kp,s=>Math.max(0,s)),nz={kernelName:Kp,backendName:"cpu",kernelFunc:$T};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TT=Fr(Xp,s=>Math.min(Math.max(0,s),6)),sz={kernelName:Xp,backendName:"cpu",kernelFunc:TT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xm(s,e,t,n,r){if(t==="linear")return vc({inputs:{x:e},backend:s});if(t==="relu")return $T({inputs:{x:e},backend:s});if(t==="elu")return CT({inputs:{x:e},backend:s});if(t==="relu6")return TT({inputs:{x:e},backend:s});if(t==="prelu")return ST({inputs:{x:e,alpha:n},backend:s});if(t==="leakyrelu")return _T({inputs:{x:e},backend:s,attrs:{alpha:r}});if(t==="sigmoid")return cT({inputs:{x:e},backend:s});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{shape:a}=n,o=hn(r.shape),i=U2(a,o),u=hn(i);ze(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const c=t.data.get(r.dataId);if(c.complexTensorInfos!=null){const d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;d.shape=i,h.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const rz={kernelName:jg,backendName:"cpu",kernelFunc:qr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(s){const{inputs:e,backend:t,attrs:n}=s,{a:r,b:a}=e,{transposeA:o,transposeB:i}=n;ls([r,a],"matMul");const u=r.shape.length,c=a.shape.length,d=o?r.shape[u-2]:r.shape[u-1],h=i?a.shape[c-1]:a.shape[c-2],l=o?r.shape[u-1]:r.shape[u-2],p=i?a.shape[c-2]:a.shape[c-1],f=r.shape.slice(0,-2),x=a.shape.slice(0,-2),b=hn(f),m=hn(x),N=js(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([l,p]);ze(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const E=o?[b,d,l]:[b,l,d],D=i?[m,p,h]:[m,h,p],U=qr({inputs:{x:r},backend:t,attrs:{shape:E}}),L=qr({inputs:{x:a},backend:t,attrs:{shape:D}}),Y=o?U.shape[1]:U.shape[2],V=o?U.shape[2]:U.shape[1],P=i?L.shape[1]:L.shape[2],oe=Math.max(b,m),ne=t.data.get(U.dataId).values,ge=t.data.get(L.dataId).values,ye=ws(U.shape),Ee=ws(L.shape),[X,je,Be]=o?[ye[0],1,ye[1]]:[ye[0],ye[1],1],[tt,ct,Me]=i?[1,Ee[1],Ee[0]]:[Ee[1],1,Ee[0]],wt=V*P,at=tr([oe,V,P],U.dtype),Gt=at.values,Ht=t.blockSize;for(let dn=0;dn<oe;dn++){const mn=dn%b,Rn=dn%m;for(let ee=0;ee<V;ee+=Ht){const se=Math.min(ee+Ht,V);for(let we=0;we<P;we+=Ht){const pt=Math.min(we+Ht,P);for(let bt=0;bt<Y;bt+=Ht){const At=Math.min(bt+Ht,Y);for(let $e=ee;$e<se;$e++)for(let ht=we;ht<pt;ht++){let Pt=0;for(let Ot=bt;Ot<At;Ot++){const xn=ne[mn*X+$e*je+Ot*Be],Dn=ge[Ot*tt+ht*ct+Rn*Me];Pt+=xn*Dn}Gt[dn*wt+($e*P+ht)]+=Pt}}}}}return t.disposeIntermediateTensorInfo(U),t.disposeIntermediateTensorInfo(L),t.makeTensorInfo(N,at.dtype,at.values)}const az={kernelName:ug,backendName:"cpu",kernelFunc:NT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oz(s){const{inputs:e,backend:t,attrs:n}=s,{a:r,b:a,bias:o,preluActivationWeights:i}=e,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:h}=n;let l,p,f;const x=[];l=NT({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:c},backend:t}),o&&(p=lh({inputs:{a:l,b:o},backend:t}),x.push(l),l=p),d&&(f=Xm(t,l,d,i,h),x.push(l),l=f);for(const m of x)t.disposeIntermediateTensorInfo(m);return l}const iz={kernelName:$m,backendName:"cpu",kernelFunc:oz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uz=Fr(gp,s=>Math.acos(s)),cz={kernelName:gp,backendName:"cpu",kernelFunc:uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lz=Fr(bp,s=>Math.acosh(s)),dz={kernelName:bp,backendName:"cpu",kernelFunc:lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hz(s){const{inputs:e,backend:t}=s,n=e;ls(e,"addN");const r=n.map(i=>t.data.get(i.dataId).values),a=tr(n[0].shape,n[0].dtype),o=a.values;for(let i=0;i<n.length;i++){const u=r[i];for(let c=0;c<o.length;c++)o[c]+=u[c]}return t.makeTensorInfo(a.shape,a.dtype,a.values)}const pz={kernelName:ay,backendName:"cpu",kernelFunc:hz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;ls(r,"all");const i=nr(a,r.shape);let u=i;const c=ha(u,r.shape.length);let d=r;c!=null&&(d=ei({inputs:{x:r},backend:t,attrs:{perm:c}}),u=wa(u.length,r.shape.length)),ho("all",u,d.shape.length);const[h,l]=Ja(d.shape,u),p=hn(l),f=Io(hn(h),d.dtype),x=t.data.get(d.dataId).values;for(let m=0;m<f.length;++m){const I=m*p;let N=x[I];for(let E=0;E<p;++E){const D=x[I+E];N=N&&D}f[m]=N}c!=null&&t.disposeIntermediateTensorInfo(d);const b=t.makeTensorInfo(h,d.dtype,f);if(o){const m=$a(h,i),I=qr({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),I}return b}const mz={kernelName:oy,backendName:"cpu",kernelFunc:fz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;ls(r,"any");const i=nr(a,r.shape);let u=i;const c=ha(u,r.shape.length);let d=r;c!=null&&(d=ei({inputs:{x:r},backend:t,attrs:{perm:c}}),u=wa(u.length,r.shape.length)),ho("any",u,d.shape.length);const[h,l]=Ja(d.shape,u),p=hn(l),f=Io(hn(h),d.dtype),x=t.data.get(d.dataId).values;for(let m=0;m<f.length;++m){const I=m*p;let N=x[I];for(let E=0;E<p;++E){const D=x[I+E];N=N||D}f[m]=N}c!=null&&t.disposeIntermediateTensorInfo(d);const b=t.makeTensorInfo(h,d.dtype,f);if(o){const m=$a(h,i),I=qr({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),I}return b}const bz={kernelName:iy,backendName:"cpu",kernelFunc:gz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a}=n;ls(r,"argMax");let o=nr(a,r.shape);const i=ha(o,r.shape.length);let u=r;const c=[];i!=null&&(u=ei({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),o=wa(o.length,u.shape.length)),o=[o[0]],ho("argMax",o,u.shape.length);const[d,h]=Ja(u.shape,o),l=hn(d),p=Io(l,"int32"),f=hn(h),x=t.data.get(u.dataId).values;for(let b=0;b<p.length;++b){const m=b*f;let I=x[m],N=0;for(let E=0;E<f;++E){const D=x[m+E];D>I&&(I=D,N=E)}p[b]=N}return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(d,"int32",p)}const yz={kernelName:rg,backendName:"cpu",kernelFunc:xz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a}=n;ls(r,"argMin");let o=nr(a,r.shape);const i=ha(o,r.shape.length);let u=r;const c=[];i!=null&&(u=ei({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),o=wa(o.length,u.shape.length)),o=[o[0]],ho("argMin",o,u.shape.length);const[d,h]=Ja(u.shape,o),l=hn(d),p=Io(l,"int32"),f=hn(h),x=t.data.get(u.dataId).values;for(let b=0;b<p.length;++b){const m=b*f;let I=x[m],N=0;for(let E=0;E<f;++E){const D=x[m+E];D<I&&(I=D,N=E)}p[b]=N}return c.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(d,"int32",p)}const vz={kernelName:ag,backendName:"cpu",kernelFunc:wz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kz=Fr(xp,s=>Math.asin(s)),Iz={kernelName:xp,backendName:"cpu",kernelFunc:kz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz=Fr(yp,s=>Math.asinh(s)),_z={kernelName:yp,backendName:"cpu",kernelFunc:Cz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sz=Fr(wp,s=>Math.atan(s)),$z={kernelName:wp,backendName:"cpu",kernelFunc:Sz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tz=ka((s,e)=>Math.atan2(s,e)),Nz=La(kp,Tz),Ez={kernelName:kp,backendName:"cpu",kernelFunc:Nz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rz=Fr(vp,s=>Math.atanh(s)),Az={kernelName:vp,backendName:"cpu",kernelFunc:Rz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(s,e,t,n,r,a){const o=r.strideHeight,i=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,l=r.padInfo.top,p=r.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=tr(r.outShape,t),b=x.values,m=r.outShape[1]*r.outShape[2]*r.outShape[3],I=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let E=0;E<r.batchSize;++E){const D=E*m,U=E*n[0];for(let L=0;L<r.inChannels;++L)for(let Y=0;Y<r.outHeight;++Y){const V=Y*o-l,P=Math.max(0,V),oe=Math.min(r.inHeight,d+V),ne=D+Y*I;for(let ge=0;ge<r.outWidth;++ge){const ye=ge*i-p,Ee=Math.max(0,ye),X=Math.min(r.inWidth,h+ye);let je=f,Be=0,tt=0;for(let Me=P;Me<oe;Me+=u){const wt=U+Me*n[1];for(let at=Ee;at<X;at+=c){const Gt=wt+at*n[2],Ht=s[Gt+L];a==="max"&&Ht>je?je=Ht:a==="avg"&&(Be+=Ht,tt++)}if(isNaN(je))break}const ct=ne+ge*N+L;b[ct]=a==="avg"?Be/tt:je}}}return x}function ET(s,e,t,n,r=!1,a=!1){const o=tr(n.outShape,"int32"),i=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.effectiveFilterHeight,l=n.effectiveFilterWidth,p=n.padInfo.top,f=n.padInfo.left,x=tr(e,t,s);for(let b=0;b<n.batchSize;++b)for(let m=0;m<n.inChannels;++m)for(let I=0;I<n.outHeight;++I){const N=I*i-p;let E=N;for(;E<0;)E+=c;const D=Math.min(n.inHeight,h+N);for(let U=0;U<n.outWidth;++U){const L=U*u-f;let Y=L;for(;Y<0;)Y+=d;const V=Math.min(n.inWidth,l+L);let P=Number.NEGATIVE_INFINITY,oe=-1;for(let ne=E;ne<D;ne+=c){const ge=ne-N;for(let ye=Y;ye<V;ye+=d){const Ee=ye-L,X=x.get(b,ne,ye,m);X>P&&(P=X,r?oe=a?((b*n.inHeight+ne)*n.inWidth+ye)*n.inChannels+m:(ne*n.inWidth+ye)*n.inChannels+m:oe=ge*l+Ee)}}o.set(oe,b,I,U,m)}}return o}function RT(s,e,t,n,r,a){const o=r.strideDepth,i=r.strideHeight,u=r.strideWidth,c=r.dilationDepth,d=r.dilationHeight,h=r.dilationWidth,l=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,x=r.padInfo.front,b=r.padInfo.top,m=r.padInfo.left,I=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=tr(r.outShape,t),E=N.values,D=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],U=r.outShape[2]*r.outShape[3]*r.outShape[4],L=r.outShape[3]*r.outShape[4],Y=r.outShape[4];for(let V=0;V<r.batchSize;++V){const P=V*D,oe=V*n[0];for(let ne=0;ne<r.inChannels;++ne)for(let ge=0;ge<r.outDepth;++ge){const ye=ge*o-x;let Ee=ye;for(;Ee<0;)Ee+=c;const X=Math.min(r.inDepth,l+ye),je=P+ge*U;for(let Be=0;Be<r.outHeight;++Be){const tt=Be*i-b;let ct=tt;for(;ct<0;)ct+=d;const Me=Math.min(r.inHeight,p+tt),wt=je+Be*L;for(let at=0;at<r.outWidth;++at){const Gt=at*u-m;let Ht=Gt;for(;Ht<0;)Ht+=h;const dn=Math.min(r.inWidth,f+Gt),mn=wt+at*Y;let Rn=I,ee=0,se=0;for(let pt=Ee;pt<X;pt+=c){const bt=oe+pt*n[1];for(let At=ct;At<Me;At+=d){const $e=bt+At*n[2];for(let ht=Ht;ht<dn;ht+=h){const Pt=$e+ht*n[3],Ot=s[Pt+ne];if(a==="max"&&Ot>Rn?Rn=Ot:a==="avg"&&(ee+=Ot,se++),isNaN(Rn))break}if(isNaN(Rn))break}if(isNaN(Rn))break}const we=mn+ne;E[we]=a==="avg"?ee/Math.max(se,1):Rn}}}}return N}function Oz(s,e){const t=tr(e.outShape,"int32"),n=e.strideDepth,r=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,l=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let x=0;x<e.batchSize;++x)for(let b=0;b<e.inChannels;++b)for(let m=0;m<e.outDepth;++m){const I=m*n-l;let N=I;for(;N<0;)N+=o;const E=Math.min(e.inDepth,c+I);for(let D=0;D<e.outHeight;++D){const U=D*r-p;let L=U;for(;L<0;)L+=i;const Y=Math.min(e.inHeight,d+U);for(let V=0;V<e.outWidth;++V){const P=V*a-f;let oe=P;for(;oe<0;)oe+=u;const ne=Math.min(e.inWidth,h+P);let ge=Number.NEGATIVE_INFINITY,ye=-1;for(let Ee=N;Ee<E;Ee+=o){const X=Ee-I;for(let je=L;je<Y;je+=i){const Be=je-U;for(let tt=oe;tt<ne;tt+=u){const ct=tt-P,Me=s.get(x,Ee,je,tt,b);Me>=ge&&(ge=Me,ye=X*d*h+Be*d+ct)}}}t.set(ye,x,m,D,V,b)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e;ls(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n,c=1;ze(Co(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Cu(r.shape,a,o,c,i,u);let h;if(d.filterWidth===1&&d.filterHeight===1&&Er(d.inShape,d.outShape))h=vc({inputs:{x:r},backend:t});else{const l=t.data.get(r.dataId).values,p=ws(r.shape),f=Cv(l,r.shape,r.dtype,p,d,"avg");h=t.makeTensorInfo(d.outShape,r.dtype,f.values)}return h}const Dz={kernelName:og,backendName:"cpu",kernelFunc:Fz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=n;ls(r,"avgPool3d");const d=Gc(r.shape,a,o,1,i,u,c),h=t.data.get(r.dataId).values,l=RT(h,r.shape,r.dtype,ws(r.shape),d,"avg");return t.makeTensorInfo(l.shape,"float32",l.values)}const Pz={kernelName:ig,backendName:"cpu",kernelFunc:Mz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=n;ls([r,a],"avgPool3DGrad");const d=Gc(a.shape,o,i,1,u,c),h=d.strideDepth,l=d.strideHeight,p=d.strideWidth,f=d.filterDepth,x=d.filterHeight,b=d.filterWidth,m=d.dilationDepth,I=d.dilationHeight,N=d.dilationWidth,E=d.effectiveFilterDepth,D=d.effectiveFilterHeight,U=d.effectiveFilterWidth,L=E-1-d.padInfo.front,Y=U-1-d.padInfo.left,V=D-1-d.padInfo.top,P=tr(a.shape,"float32"),oe=1/(f*x*b),ne=t.bufferSync(r);for(let ge=0;ge<d.batchSize;++ge)for(let ye=0;ye<d.inChannels;++ye)for(let Ee=0;Ee<d.inDepth;++Ee)for(let X=0;X<d.inHeight;++X)for(let je=0;je<d.inWidth;++je){const Be=Ee-L,tt=X-V,ct=je-Y;let Me=0;for(let wt=0;wt<E;wt+=m){const at=(Be+wt)/h;if(!(at<0||at>=d.outDepth||Math.floor(at)!==at))for(let Gt=0;Gt<D;Gt+=I){const Ht=(tt+Gt)/l;if(!(Ht<0||Ht>=d.outHeight||Math.floor(Ht)!==Ht))for(let dn=0;dn<U;dn+=N){const mn=(ct+dn)/p;if(mn<0||mn>=d.outWidth||Math.floor(mn)!==mn)continue;Me+=ne.get(ge,at,Ht,mn,ye)}}}P.set(Me*oe,ge,Ee,X,je,ye)}return t.makeTensorInfo(P.shape,P.dtype,P.values)}const Bz={kernelName:cy,backendName:"cpu",kernelFunc:Lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zz(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,o=a;ls([r,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:c}=n,d=Cu(o.shape,i,u,1,c),h=d.strideHeight,l=d.strideWidth,p=d.filterHeight,f=d.filterWidth,x=d.dilationHeight,b=d.dilationWidth,m=d.effectiveFilterHeight,I=d.effectiveFilterWidth,N=I-1-d.padInfo.left,E=m-1-d.padInfo.top,D=tr(o.shape,"float32"),U=1/(p*f),L=t.data.get(r.dataId).values,Y=tr(r.shape,"float32",L);for(let V=0;V<d.batchSize;++V)for(let P=0;P<d.inChannels;++P)for(let oe=0;oe<d.inHeight;++oe)for(let ne=0;ne<d.inWidth;++ne){const ge=oe-E,ye=ne-N;let Ee=0;for(let X=0;X<m;X+=x){const je=(ge+X)/h;if(!(je<0||je>=d.outHeight||Math.floor(je)!==je))for(let Be=0;Be<I;Be+=b){const tt=(ye+Be)/l;if(tt<0||tt>=d.outWidth||Math.floor(tt)!==tt)continue;Ee+=Y.get(V,je,tt,P)}}D.set(Ee*U,V,oe,ne,P)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}const Wz={kernelName:uy,backendName:"cpu",kernelFunc:zz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,scale:a,offset:o,mean:i,variance:u}=e;ze(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ze(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ze(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ls([r,i,u,a,o],"batchNorm");let{varianceEpsilon:c}=n;c==null&&(c=.001);const d=t.data.get(r.dataId).values,h=t.data.get(i.dataId).values,l=t.data.get(u.dataId).values,p=a?t.data.get(a.dataId).values:new Float32Array([1]),f=o?t.data.get(o.dataId).values:new Float32Array([0]),x=new Float32Array(d.length),b=f.length,m=p.length,I=l.length,N=h.length;let E=0,D=0,U=0,L=0;for(let Y=0;Y<d.length;++Y)x[Y]=f[E++]+(d[Y]-h[D++])*p[U++]/Math.sqrt(l[L++]+c),E>=b&&(E=0),D>=N&&(D=0),U>=m&&(U=0),L>=I&&(L=0);return t.makeTensorInfo(r.shape,r.dtype,x)}const Uz={kernelName:wg,backendName:"cpu",kernelFunc:Vz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockShape:a,crops:o}=n;ls([r],"batchToSpaceND");const i=a.reduce((m,I)=>m*I),u=bf(r.shape,a,i),c=xf(u.length,a.length),d=yf(r.shape,a,i),h=Fw(o,a.length),l=Dw(d,o,a.length),p=qr({inputs:{x:r},backend:t,attrs:{shape:u}}),f=ei({inputs:{x:p},backend:t,attrs:{perm:c}}),x=qr({inputs:{x:f},backend:t,attrs:{shape:d}}),b=kd({inputs:{x},backend:t,attrs:{begin:h,size:l}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),b}const Gz={kernelName:cg,backendName:"cpu",kernelFunc:jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hz(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,weights:a}=e,{size:o}=n,i=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,c=yv(i,u,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,c)}const qz={kernelName:ly,backendName:"cpu",kernelFunc:Hz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kz(s){const{inputs:e,backend:t}=s,{s0:n,s1:r}=e,a=t.data.get(n.dataId).values,o=t.data.get(r.dataId).values,i=js(Array.from(a),Array.from(o));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const Xz={kernelName:Y2,backendName:"cpu",kernelFunc:Kz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yz=Fr(_p,(s,e)=>{const t=e;return s>t.clipValueMax?t.clipValueMax:s<t.clipValueMin?t.clipValueMin:s}),Zz={kernelName:_p,backendName:"cpu",kernelFunc:Yz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qz=s=>{const{x:e}=s.inputs,t=s.backend,n=new Float32Array(hn(e.shape)),r=t.data.get(e.dataId),a=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=t.data.get(a.dataId).values,u=t.data.get(o.dataId).values;for(let c=0;c<i.length;c++){const d=i[c],h=u[c];n[c]=Math.hypot(d,h)}return t.makeOutput(n,e.shape,"float32")},Jz={kernelName:lg,backendName:"cpu",kernelFunc:Qz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dh(s){const{inputs:e,backend:t}=s,{input:n}=e,r=t.data.get(n.dataId).complexTensorInfos.imag,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const eW={kernelName:Sy,backendName:"cpu",kernelFunc:dh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(s){const{inputs:e,backend:t,attrs:n}=s,{axis:r}=n,a=nr(r,e[0].shape)[0],o=e.map(x=>x.shape);Rw(o,a);let i=gc(e.map(x=>x.shape),a);if(hn(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const u=e.filter(x=>hn(x.shape)>0);if(u.length===1)return vc({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){const x=u.map(E=>vd({inputs:{input:E},backend:t})),b=u.map(E=>dh({inputs:{input:E},backend:t})),m=hh({inputs:x,backend:t,attrs:{axis:a}}),I=hh({inputs:b,backend:t,attrs:{axis:a}}),N=yi({inputs:{real:m,imag:I},backend:t});return x.forEach(E=>t.disposeIntermediateTensorInfo(E)),b.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),N}const c=u.map(x=>{const b=hn(x.shape.slice(a));return qr({inputs:{x},backend:t,attrs:{shape:[-1,b]}})}),d=c.map(x=>({vals:t.data.get(x.dataId).values,shape:x.shape}));i=gc(c.map(x=>x.shape),1);const h=c[0].shape[0]===1,l=M$(d,i,e[0].dtype,h),p=gc(u.map(x=>x.shape),a),f=t.makeTensorInfo(p,e[0].dtype,l);return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),f}const tW={kernelName:dg,backendName:"cpu",kernelFunc:hh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dataFormat:u,dilations:c,dimRoundingMode:d}=n;ls([r,a],"conv2d");const h=Hc(u),l=lo(r.shape,a.shape,o,c,i,d,!1,h),p=l.filterHeight,f=l.filterWidth,x=l.dilationHeight,b=l.dilationWidth,m=l.padInfo.left,I=l.padInfo.top,N=l.dataFormat==="channelsLast",E=new co(l.outShape,r.dtype),D=ws(r.shape),U=ws(a.shape),L=D[0],Y=N?D[1]:D[2],V=N?D[2]:1,P=N?1:D[1],oe=E.strides[0],ne=N?E.strides[1]:E.strides[2],ge=N?E.strides[2]:1,ye=N?1:E.strides[1],Ee=t.data.get(r.dataId).values,X=t.data.get(a.dataId).values,je=E.values;for(let Be=0;Be<l.batchSize;++Be){const tt=Be*L,ct=Be*oe;for(let Me=0;Me<l.outHeight;++Me){const wt=ct+Me*ne,at=Me*l.strideHeight-I;for(let Gt=0;Gt<p;++Gt){const Ht=at+Gt*x;if(Ht<0||Ht>=l.inHeight)continue;const dn=Gt*U[0],mn=tt+Ht*Y;for(let Rn=0;Rn<l.outWidth;++Rn){const ee=wt+Rn*ge,se=Rn*l.strideWidth-m;for(let we=0;we<f;++we){const pt=se+we*b;if(pt<0||pt>=l.inWidth)continue;const bt=dn+we*U[1],At=mn+pt*V;let $e=bt;for(let ht=0;ht<l.inChannels;++ht){const Pt=Ee[At+ht*P];for(let Ot=0;Ot<l.outChannels;++Ot)je[ee+Ot*ye]+=Pt*X[$e+Ot];$e+=l.outChannels}}}}}}return t.makeTensorInfo(E.shape,E.dtype,je)}const nW={kernelName:hg,backendName:"cpu",kernelFunc:AT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:d}=n;ls([r,a],"conv2dBackpropFilter");const h=Hc(u),l=lo(r.shape,d,o,1,i,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:x,filterWidth:b}=l,m=l.dataFormat==="channelsLast",I=new co(l.filterShape,"float32"),N=l.padInfo.left,E=l.padInfo.top,D=t.data.get(r.dataId).values,U=t.data.get(a.dataId).values,L=new co(r.shape,r.dtype,D),Y=new co(a.shape,a.dtype,U);for(let V=0;V<x;++V){const P=Math.max(0,Math.ceil((E-V)/p)),oe=Math.min(l.outHeight,(l.inHeight+E-V)/p);for(let ne=0;ne<b;++ne){const ge=Math.max(0,Math.ceil((N-ne)/f)),ye=Math.min(l.outWidth,(l.inWidth+N-ne)/f);for(let Ee=0;Ee<l.inChannels;++Ee)for(let X=0;X<l.outChannels;++X){let je=0;for(let Be=0;Be<l.batchSize;++Be)for(let tt=P;tt<oe;++tt){const ct=V+tt*p-E;for(let Me=ge;Me<ye;++Me){const wt=ne+Me*f-N;m?je+=L.get(Be,ct,wt,Ee)*Y.get(Be,tt,Me,X):je+=L.get(Be,Ee,ct,wt)*Y.get(Be,X,tt,Me)}}I.set(je,V,ne,Ee,X)}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const rW={kernelName:hy,backendName:"cpu",kernelFunc:sW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aW(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{inputShape:o,strides:i,pad:u,dataFormat:c,dimRoundingMode:d}=n;ls([r,a],"conv2dBackpropInput");const h=ws(a.shape),l=ws(r.shape);let p=Hc(c);const f=lo(o,a.shape,i,1,u,d,!1,p),x=new co(f.inShape,"float32"),b=x.values,m=t.data.get(r.dataId).values,I=t.data.get(a.dataId).values,[N,E,D]=h,{batchSize:U,filterHeight:L,filterWidth:Y,inChannels:V,inHeight:P,inWidth:oe,outChannels:ne,outHeight:ge,outWidth:ye,strideHeight:Ee,strideWidth:X}=f;p=f.dataFormat;const je=L-1-f.padInfo.top,Be=Y-1-f.padInfo.left,tt=p==="channelsLast",ct=x.strides[0],Me=tt?x.strides[1]:x.strides[2],wt=tt?x.strides[2]:1,at=tt?1:x.strides[1],Gt=l[0],Ht=tt?l[1]:l[2],dn=tt?l[2]:1,mn=tt?1:l[1];for(let Rn=0;Rn<U;++Rn)for(let ee=0;ee<V;++ee)for(let se=0;se<P;++se){const we=se-je,pt=Math.max(0,Math.ceil(we/Ee)),bt=Math.min(ge,(L+we)/Ee);for(let At=0;At<oe;++At){const $e=At-Be,ht=Math.max(0,Math.ceil($e/X)),Pt=Math.min(ye,(Y+$e)/X);let Ot=0;for(let Dn=pt;Dn<bt;++Dn){const pe=Dn*Ee-we;for(let be=ht;be<Pt;++be){const Qe=be*X-$e,Un=Gt*Rn+Ht*Dn+dn*be,Ws=N*(L-1-pe)+E*(Y-1-Qe)+D*ee;for(let Gs=0;Gs<ne;++Gs){const As=m[Un+mn*Gs],xs=I[Ws+Gs];Ot+=As*xs}}}const xn=ct*Rn+Me*se+wt*At+at*ee;b[xn]=Ot}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const oW={kernelName:pg,backendName:"cpu",kernelFunc:aW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dilations:u}=n;ls([r,a],"conv3d");const c=Sl(r.shape,a.shape,o,u,i),{filterDepth:d,filterHeight:h,filterWidth:l,dilationDepth:p,dilationHeight:f,dilationWidth:x,padInfo:b}=c,m=b.front,I=b.left,N=b.top,E=new co(c.outShape,r.dtype),D=t.data.get(r.dataId).values,U=t.data.get(a.dataId).values,L=E.values,Y=ws(r.shape),V=ws(a.shape);for(let P=0;P<c.batchSize;++P){const oe=P*Y[0],ne=P*E.strides[0];for(let ge=0;ge<c.outDepth;++ge){const ye=ne+ge*E.strides[1],Ee=ge*c.strideDepth-m;for(let X=0;X<d;++X){const je=Ee+X*p;if(je<0||je>=c.inDepth)continue;const Be=X*V[0],tt=oe+je*Y[1];for(let ct=0;ct<c.outHeight;++ct){const Me=ye+ct*E.strides[2],wt=ct*c.strideHeight-N;for(let at=0;at<h;++at){const Gt=wt+at*f;if(Gt<0||Gt>=c.inHeight)continue;const Ht=Be+at*V[1],dn=tt+Gt*Y[2];for(let mn=0;mn<c.outWidth;++mn){const Rn=Me+mn*c.outChannels,ee=mn*c.strideWidth-I;for(let se=0;se<l;++se){const we=ee+se*x;if(we<0||we>=c.inWidth)continue;const pt=Ht+se*V[2],bt=dn+we*c.inChannels;let At=pt;for(let $e=0;$e<c.inChannels;++$e){const ht=D[bt+$e];for(let Pt=0;Pt<c.outChannels;++Pt)L[Rn+Pt]+=ht*U[At+Pt];At+=c.outChannels}}}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const uW={kernelName:fg,backendName:"cpu",kernelFunc:iW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,pad:i,filterShape:u}=n;ls([r,a],"conv3dBackpropFilterV2");const c=ws(r.shape),d=ws(a.shape),h=Sl(r.shape,u,o,1,i),l=h.strideDepth,p=h.strideHeight,f=h.strideWidth,x=h.filterDepth,b=h.filterHeight,m=h.filterWidth,I=new co(h.filterShape,"float32"),N=I.values,[E,D,U,L]=I.strides,Y=t.data.get(a.dataId).values,[V,P,oe,ne]=d,ge=t.data.get(r.dataId).values,[ye,Ee,X,je]=c,Be=h.padInfo.front,tt=h.padInfo.left,ct=h.padInfo.top;for(let Me=0;Me<x;++Me){const wt=Math.max(0,Math.ceil((Be-Me)/l)),at=Math.min(h.outDepth,(h.inDepth+Be-Me)/l),Gt=Me*E;for(let Ht=0;Ht<b;++Ht){const dn=Math.max(0,Math.ceil((ct-Ht)/p)),mn=Math.min(h.outHeight,(h.inHeight+ct-Ht)/p),Rn=Ht*D+Gt;for(let ee=0;ee<m;++ee){const se=Math.max(0,Math.ceil((tt-ee)/f)),we=Math.min(h.outWidth,(h.inWidth+tt-ee)/f),pt=ee*U+Rn;for(let bt=0;bt<h.inChannels;++bt){const At=bt*L+pt;for(let $e=0;$e<h.outChannels;++$e){let ht=0;for(let Pt=0;Pt<h.batchSize;++Pt){const Ot=Pt*ye,xn=Pt*V;for(let Dn=wt;Dn<at;++Dn){const be=(Me+Dn*l-Be)*Ee+Ot,Qe=Dn*P+xn;for(let Un=dn;Un<mn;++Un){const Gs=(Ht+Un*p-ct)*X+be,As=Un*oe+Qe;for(let xs=se;xs<we;++xs){const Ys=(ee+xs*f-tt)*je+Gs,pn=xs*ne+As;ht+=ge[Ys+bt]*Y[pn+$e]}}}}N[At+$e]=ht}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const lW={kernelName:py,backendName:"cpu",kernelFunc:cW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{pad:o,strides:i,inputShape:u}=n;ls([r],"conv3dBackpropInputV2");const c=ws(r.shape),d=ws(a.shape),h=Sl(u,a.shape,i,1,o),l=new co(h.inShape,"float32"),p=l.values,[f,x,b,m]=l.strides,I=t.data.get(r.dataId).values,[N,E,D,U]=c,L=t.data.get(a.dataId).values,[Y,V,P,oe]=d,{batchSize:ne,filterDepth:ge,filterHeight:ye,filterWidth:Ee,inChannels:X,inDepth:je,inHeight:Be,inWidth:tt,outChannels:ct,outDepth:Me,outHeight:wt,outWidth:at,strideDepth:Gt,strideHeight:Ht,strideWidth:dn}=h,mn=ge-1-h.padInfo.front,Rn=ye-1-h.padInfo.top,ee=Ee-1-h.padInfo.left;for(let se=0;se<ne;++se)for(let we=0;we<X;++we)for(let pt=0;pt<je;++pt){const bt=pt-mn,At=Math.max(0,Math.ceil(bt/Gt)),$e=Math.min(Me,(ge+bt)/Gt);for(let ht=0;ht<Be;++ht){const Pt=ht-Rn,Ot=Math.max(0,Math.ceil(Pt/Ht)),xn=Math.min(wt,(ye+Pt)/Ht);for(let Dn=0;Dn<tt;++Dn){const pe=Dn-ee,be=Math.max(0,Math.ceil(pe/dn)),Qe=Math.min(at,(Ee+pe)/dn);let Un=0;for(let Ws=At;Ws<$e;++Ws){const Gs=Ws*Gt-bt;for(let As=Ot;As<xn;++As){const xs=As*Ht-Pt;for(let ds=be;ds<Qe;++ds){const Ys=ds*dn-pe,pn=N*se+E*Ws+D*As+U*ds,Nn=Y*(ge-1-Gs)+V*(ye-1-xs)+P*(Ee-1-Ys)+oe*we;for(let ts=0;ts<ct;++ts){const $s=I[pn+ts],Ns=L[Nn+ts];Un+=$s*Ns}}}}p[f*se+x*pt+b*ht+m*Dn+we]=Un}}}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const hW={kernelName:fy,backendName:"cpu",kernelFunc:dW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pW=Fr(Sp,s=>Math.cos(s)),fW={kernelName:Sp,backendName:"cpu",kernelFunc:pW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=Fr($p,s=>Math.cosh(s)),gW={kernelName:$p,backendName:"cpu",kernelFunc:mW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bW(s){const{inputs:e,backend:t,attrs:n}=s,{image:r,boxes:a,boxInd:o}=e,{cropSize:i,method:u,extrapolationValue:c}=n,[d,h,l,p]=r.shape,f=a.shape[0],[x,b]=i,m=tr([f,x,b,p],"float32"),I=t.data.get(a.dataId).values,N=t.data.get(o.dataId).values,E=t.data.get(r.dataId).values,D=ws(r.shape),U=ws(m.shape);for(let L=0;L<f;L++){const Y=L*4,V=I[Y],P=I[Y+1],oe=I[Y+2],ne=I[Y+3],ge=N[L];if(ge>=d)continue;const ye=x>1?(oe-V)*(h-1)/(x-1):0,Ee=b>1?(ne-P)*(l-1)/(b-1):0;for(let X=0;X<x;X++){const je=x>1?V*(h-1)+X*ye:.5*(V+oe)*(h-1);if(je<0||je>h-1){for(let Be=0;Be<b;Be++)for(let tt=0;tt<p;tt++){const ct=tt+Be*U[2]+X*U[1]+L*U[0];m.values[ct]=c}continue}if(u==="bilinear"){const Be=Math.floor(je),tt=Math.ceil(je),ct=je-Be;for(let Me=0;Me<b;Me++){const wt=b>1?P*(l-1)+Me*Ee:.5*(P+ne)*(l-1);if(wt<0||wt>l-1){for(let dn=0;dn<p;dn++){const mn=dn+Me*U[2]+X*U[1]+L*U[0];m.values[mn]=c}continue}const at=Math.floor(wt),Gt=Math.ceil(wt),Ht=wt-at;for(let dn=0;dn<p;dn++){let mn=dn+at*D[2]+Be*D[1]+ge*D[0];const Rn=E[mn];mn=dn+Gt*D[2]+Be*D[1]+ge*D[0];const ee=E[mn];mn=dn+at*D[2]+tt*D[1]+ge*D[0];const se=E[mn];mn=dn+Gt*D[2]+tt*D[1]+ge*D[0];const we=E[mn],pt=Rn+(ee-Rn)*Ht,bt=se+(we-se)*Ht;mn=dn+Me*U[2]+X*U[1]+L*U[0],m.values[mn]=pt+(bt-pt)*ct}}}else for(let Be=0;Be<b;++Be){const tt=b>1?P*(l-1)+Be*Ee:.5*(P+ne)*(l-1);if(tt<0||tt>l-1){for(let wt=0;wt<p;wt++){const at=wt+Be*U[2]+X*U[1]+L*U[0];m.values[at]=c}continue}const ct=Math.round(tt),Me=Math.round(je);for(let wt=0;wt<p;wt++){const at=wt+ct*D[2]+Me*D[1]+ge*D[0],Gt=wt+Be*U[2]+X*U[1]+L*U[0];m.values[Gt]=E[at]}}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const xW={kernelName:gy,backendName:"cpu",kernelFunc:bW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,exclusive:o,reverse:i}=n;ls(r,"cumprod");const u=ha([a],r.shape.length);let c=r;u!=null&&(c=ei({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=wa(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const h=vi(c.dtype,"int32"),l=ny(hn(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],x=i?(m,I)=>m+f-I-1:(m,I)=>m+I;for(let m=0;m<p.length;m+=f)for(let I=0;I<f;I++){const N=x(m,I);if(I===0)l[N]=o?1:p[N];else{const E=x(m,I-1);l[N]=o?p[E]*l[E]:p[N]*l[E]}}const b=t.makeTensorInfo(c.shape,h,l);if(u!=null){const m=$l(u),I=ei({inputs:{x:b},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(c),I}return b}const wW={kernelName:my,backendName:"cpu",kernelFunc:yW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,exclusive:o,reverse:i}=n;ls(r,"cumsum");const u=ha([a],r.shape.length);let c=r;u!=null&&(c=ei({inputs:{x:r},backend:t,attrs:{perm:u}}));const d=wa(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const h=vi(c.dtype,"int32"),l=Io(hn(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],x=i?(m,I)=>m+f-I-1:(m,I)=>m+I;for(let m=0;m<p.length;m+=f)for(let I=0;I<f;I++){const N=x(m,I);if(I===0)l[N]=o?0:p[N];else{const E=x(m,I-1);l[N]=o?p[E]+l[E]:p[N]+l[E]}}const b=t.makeTensorInfo(c.shape,h,l);if(u!=null){const m=$l(u),I=ei({inputs:{x:b},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(c),I}return b}const kW={kernelName:mg,backendName:"cpu",kernelFunc:vW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,weights:a}=e,{size:o,binaryOutput:i}=n;if(r.shape.length===1){const u=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,d=yv(u,c,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),c=t.bufferSync(a),d=O$(u,c,o,i);return t.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const CW={kernelName:by,backendName:"cpu",kernelFunc:IW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _W(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockSize:a,dataFormat:o}=n;ze(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const i=r.shape[0],u=r.shape[1],c=r.shape[2],d=r.shape[3],h=u*a,l=c*a,p=d/(a*a),f=t.data.get(r.dataId).values,x=new Float32Array(i*h*l*p);let b=0;for(let m=0;m<i;++m)for(let I=0;I<h;++I){const N=Math.floor(I/a),E=I%a;for(let D=0;D<l;++D){const U=Math.floor(D/a),L=D%a,Y=(E*a+L)*p;for(let V=0;V<p;++V){const oe=V+Y+d*(U+c*(N+u*m));x[b++]=f[oe]}}}return t.makeTensorInfo([i,h,l,p],r.dtype,x)}const SW={kernelName:xy,backendName:"cpu",kernelFunc:_W};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OT(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dilations:u,dimRoundingMode:c}=n;ls([r,a],"depthwiseConv2DNative");const d=ws(r.shape),h=ws(a.shape);let l=u;l==null&&(l=[1,1]),ze(Co(o,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const p=lo(r.shape,a.shape,o,l,i,c,!0),{filterHeight:f,filterWidth:x,dilationHeight:b,dilationWidth:m,padInfo:I}=p,N=I.left,E=I.top,D=p.outChannels/p.inChannels,U=new co(p.outShape,r.dtype),L=t.data.get(r.dataId).values,Y=t.data.get(a.dataId).values,V=U.values;for(let P=0;P<p.batchSize;++P){const oe=P*d[0],ne=P*U.strides[0];for(let ge=0;ge<p.outHeight;++ge){const ye=ne+ge*U.strides[1],Ee=ge*p.strideHeight-E;for(let X=0;X<f;++X){const je=Ee+X*b;if(je<0||je>=p.inHeight)continue;const Be=X*h[0],tt=oe+je*d[1];for(let ct=0;ct<p.outWidth;++ct){const Me=ye+ct*U.strides[2],wt=ct*p.strideWidth-N;for(let at=0;at<x;++at){const Gt=wt+at*m;if(Gt<0||Gt>=p.inWidth)continue;const Ht=Be+at*h[1],dn=tt+Gt*p.inChannels;let mn=Me,Rn=Ht;for(let ee=0;ee<p.inChannels;++ee){const se=L[dn+ee];for(let we=0;we<D;++we)V[mn+we]+=se*Y[Rn+we];mn+=D,Rn+=D}}}}}}return t.makeTensorInfo(U.shape,U.dtype,U.values)}const $W={kernelName:gg,backendName:"cpu",kernelFunc:OT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:c,filterShape:d}=n;ls([r,a],"depthwiseConv2dNativeBackpropFilter");const h=lo(r.shape,d,o,i,u,c,!0),{strideHeight:l,strideWidth:p,filterHeight:f,filterWidth:x}=h,b=new co(h.filterShape,"float32"),m=h.padInfo.left,I=h.padInfo.top,N=h.outChannels/h.inChannels,E=t.data.get(r.dataId).values,D=new co(r.shape,r.dtype,E),U=t.data.get(a.dataId).values,L=new co(a.shape,a.dtype,U);for(let Y=0;Y<f;++Y){const V=Math.max(0,Math.ceil((I-Y)/l)),P=Math.min(h.outHeight,(h.inHeight+I-Y)/l);for(let oe=0;oe<x;++oe){const ne=Math.max(0,Math.ceil((m-oe)/p)),ge=Math.min(h.outWidth,(h.inWidth+m-oe)/p);for(let ye=0;ye<h.outChannels;++ye){const Ee=Math.trunc(ye/N),X=ye%N;let je=0;for(let Be=0;Be<h.batchSize;++Be)for(let tt=V;tt<P;++tt){const ct=Y+tt*l-I;for(let Me=ne;Me<ge;++Me){const wt=oe+Me*p-m;je+=D.get(Be,ct,wt,Ee)*L.get(Be,tt,Me,ye)}}b.set(je,Y,oe,Ee,X)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const NW={kernelName:yy,backendName:"cpu",kernelFunc:TW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:c,inputShape:d}=n;ls([r,a],"depthwiseConv2DNativeBackpropInput");const h=ws(r.shape),l=ws(a.shape),p=lo(d,a.shape,o,i,u,c,!0),f=new co(p.inShape,"float32"),x=f.values,[b,m,I]=f.strides,N=t.data.get(r.dataId).values,[E,D,U]=h,L=t.data.get(a.dataId).values,[Y,V,P]=l,{batchSize:oe,filterHeight:ne,filterWidth:ge,inChannels:ye,inHeight:Ee,inWidth:X,outChannels:je,outHeight:Be,outWidth:tt,strideHeight:ct,strideWidth:Me}=p,wt=ne-1-p.padInfo.top,at=ge-1-p.padInfo.left,Gt=je/ye;for(let Ht=0;Ht<oe;++Ht)for(let dn=0;dn<ye;++dn)for(let mn=0;mn<Ee;++mn){const Rn=mn-wt,ee=Math.max(0,Math.ceil(Rn/ct)),se=Math.min(Be,(ne+Rn)/ct);for(let we=0;we<X;++we){const pt=we-at,bt=Math.max(0,Math.ceil(pt/Me)),At=Math.min(tt,(ge+pt)/Me);let $e=0;for(let ht=ee;ht<se;++ht){const Pt=ht*ct-Rn;for(let Ot=bt;Ot<At;++Ot){const xn=Ot*Me-pt,Dn=E*Ht+D*ht+U*Ot,pe=Y*(ne-1-Pt)+V*(ge-1-xn)+P*dn;for(let be=0;be<Gt;++be){const Qe=dn*Gt+be,Un=N[Dn+Qe],Ws=L[pe+be];$e+=Un*Ws}}}x[b*Ht+m*mn+I*we+dn]=$e}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const RW={kernelName:wy,backendName:"cpu",kernelFunc:EW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AW(s){const{inputs:e,backend:t}=s,{x:n}=e,r=hn(n.shape),a=t.data.get(n.dataId).values,o=tr([r,r],n.dtype),i=o.values;for(let c=0;c<a.length;c++)i[c*r+c]=a[c];const u=[...n.shape,...n.shape];return t.makeTensorInfo(u,o.dtype,o.values)}const OW={kernelName:Z2,backendName:"cpu",kernelFunc:AW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FW={kernelName:bg,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:r}=s,{strides:a,pad:o,dilations:i}=t,u=e,c=u.data.get(n.dataId).values,d=n.shape.length,h=u.data.get(r.dataId).values,l=r.shape.length,{batchSize:p,inHeight:f,inWidth:x,inChannels:b,outHeight:m,outWidth:I,padInfo:N,strideHeight:E,strideWidth:D,filterHeight:U,filterWidth:L,dilationHeight:Y,dilationWidth:V,outShape:P}=hf(n.shape,r.shape,a,o,"NHWC",i),oe=hn(P),ne=P.length,ge=ba(n.dtype,oe);for(let Ee=0;Ee<p;++Ee)for(let X=0;X<m;++X){const je=X*E-N.top;for(let Be=0;Be<I;++Be){const tt=Be*D-N.left;for(let ct=0;ct<b;++ct){let Me=Number.MIN_SAFE_INTEGER;for(let at=0;at<U;++at){const Gt=je+at*Y;if(Gt>=0&&Gt<f)for(let Ht=0;Ht<L;++Ht){const dn=tt+Ht*V;if(dn>=0&&dn<x){const mn=fc([Ee,Gt,dn,ct],d,ws(n.shape)),Rn=fc([at,Ht,ct],l,ws(r.shape)),ee=c[mn]+h[Rn];ee>Me&&(Me=ee)}}}const wt=fc([Ee,X,Be,ct],ne,ws(P));ge[wt]=Me}}}return{dataId:u.write(_d(ge,n.dtype),P,n.dtype),shape:P,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW={kernelName:f0,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:r,dy:a}=s,{strides:o,pad:i,dilations:u}=t,c=e,d=Bu(n.shape,c.data.get(n.dataId).values),h=Bu(r.shape,c.data.get(r.dataId).values),{batchSize:l,inHeight:p,inWidth:f,inChannels:x,outHeight:b,outWidth:m,padInfo:I,strideHeight:N,strideWidth:E,filterHeight:D,filterWidth:U,dilationHeight:L,dilationWidth:Y,outShape:V}=hf(n.shape,r.shape,o,i,"NHWC",u);ze(a.rank===V.length,()=>`Error in ${f0}, dy must have the same rank as output ${V.length}, but got ${a.rank}`);const P=Bu(V,c.data.get(a.dataId).values),oe=H2(r.shape,r.dtype);for(let ge=0;ge<l;++ge)for(let ye=0;ye<b;++ye){const Ee=ye*N-I.top;for(let X=0;X<m;++X){const je=X*E-I.left;for(let Be=0;Be<x;++Be){let tt=Number.MIN_SAFE_INTEGER,ct=0,Me=0;for(let wt=0;wt<D;++wt){const at=Ee+wt*L;if(at>=0&&at<p)for(let Gt=0;Gt<U;++Gt){const Ht=je+Gt*Y;if(Ht>=0&&Ht<f){const dn=d[ge][at][Ht][Be]+h[wt][Gt][Be];dn>tt&&(tt=dn,ct=wt,Me=Gt)}}}oe[ct][Me][Be]+=P[ge][ye][X][Be]}}}return{dataId:c.write(_d(oe,n.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MW={kernelName:p0,backendName:"cpu",kernelFunc:({inputs:s,backend:e,attrs:t})=>{const{x:n,filter:r,dy:a}=s,{strides:o,pad:i,dilations:u}=t,c=e,d=Bu(n.shape,c.data.get(n.dataId).values),h=Bu(r.shape,c.data.get(r.dataId).values),{batchSize:l,inHeight:p,inWidth:f,inChannels:x,outHeight:b,outWidth:m,padInfo:I,strideHeight:N,strideWidth:E,filterHeight:D,filterWidth:U,dilationHeight:L,dilationWidth:Y,outShape:V}=hf(n.shape,r.shape,o,i,"NHWC",u);ze(a.rank===V.length,()=>`Error in ${p0}, dy must have the same rank as output ${V.length}, but got ${a.rank}`);const P=Bu(V,c.data.get(a.dataId).values),oe=H2(n.shape,n.dtype);for(let ge=0;ge<l;++ge)for(let ye=0;ye<b;++ye){const Ee=ye*N-I.top;for(let X=0;X<m;++X){const je=X*E-I.left;for(let Be=0;Be<x;++Be){let tt=Number.MIN_SAFE_INTEGER,ct=Ee<0?0:Ee,Me=je<0?0:je;for(let wt=0;wt<D;++wt){const at=Ee+wt*L;if(at>=0&&at<p)for(let Gt=0;Gt<U;++Gt){const Ht=je+Gt*Y;if(Ht>=0&&Ht<f){const dn=d[ge][at][Ht][Be]+h[wt][Gt][Be];dn>tt&&(tt=dn,ct=at,Me=Ht)}}}oe[ge][ct][Me][Be]+=P[ge][ye][X][Be]}}}return{dataId:c.write(_d(oe,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tf(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;ls(r,"sum");let i;r.dtype==="bool"?i=Il({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):i=vc({inputs:{x:r},backend:t});const u=i.shape.length,c=nr(a,i.shape),d=ha(c,u);let h=c,l=i;d!=null&&(l=ei({inputs:{x:i},backend:t,attrs:{perm:d}}),h=wa(h.length,u)),ho("sum",h,l.shape.length);const[p,f]=Ja(l.shape,h),x=vi(l.dtype,"int32");let b=qm(t,p,x);const m=hn(f),I=t.data.get(b.dataId).values,N=t.data.get(l.dataId).values;for(let E=0;E<I.length;++E){const D=E*m;let U=0;for(let L=0;L<m;++L)U+=N[D+L];I[E]=U}if(o){const E=$a(b.shape,c),D=b;b=qr({inputs:{x:b},backend:t,attrs:{shape:E}}),t.disposeIntermediateTensorInfo(D)}return t.disposeIntermediateTensorInfo(i),d!=null&&t.disposeIntermediateTensorInfo(l),b}const PW={kernelName:Yg,backendName:"cpu",kernelFunc:Tf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LW(s){const{inputs:e,backend:t,attrs:n}=s,{equation:r}=n,a=e,{allDims:o,summedDims:i,idDims:u}=Uw(r,a.length);Gw(o.length,u,a);const{path:c,steps:d}=Hw(i,u),h=d.length;let l=null,p=o.length;const f=[];for(let x=0;x<h;++x){for(const b of d[x]){const{permutationIndices:m,expandDims:I}=jw(p,u[b]);let N;qw(m)?N=a[b]:(N=ei({inputs:{x:a[b]},backend:t,attrs:{perm:m}}),f.push(N));const E=N.shape.slice();for(let D=0;D<I.length;++D)E.splice(I[D],0,1);Er(N.shape,E)||(N=qr({inputs:{x:N},backend:t,attrs:{shape:E}}),f.push(N)),l===null?l=N:(l=$b({inputs:{a:N,b:l},backend:t}),f.push(l))}x<h-1&&(c[x]>=0&&(l=Tf({inputs:{x:l},backend:t,attrs:{axis:c[x]-(o.length-p),keepDims:!1}}),f.push(l)),p--)}for(const x of f)x!==l&&t.disposeIntermediateTensorInfo(x);return l}const BW={kernelName:Q2,backendName:"cpu",kernelFunc:LW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zW(s){const{inputs:e,backend:t}=s,{dy:n,y:r}=e;ls([n,r],"eluGrad");const a=new Float32Array(hn(r.shape)),o=t.data.get(r.dataId).values,i=t.data.get(n.dataId).values;for(let u=0;u<o.length;++u){const c=o[u];c>=0?a[u]=i[u]:a[u]=i[u]*(c+1)}return t.makeTensorInfo(r.shape,"float32",a)}const WW={kernelName:vy,backendName:"cpu",kernelFunc:zW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=Mw,UW=Pw,jW=Lw,GW=Bw,HW=zw,qW=Ww,KW=Fr(Ep,s=>{const e=Math.sign(s),t=Math.abs(s),n=1/(1+VW*t);return e*(1-((((qW*n+HW)*n+GW)*n+jW)*n+UW)*n*Math.exp(-t*t))}),XW={kernelName:Ep,backendName:"cpu",kernelFunc:KW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(s){const{inputs:e,backend:t,attrs:n}=s,{input:r}=e,{dim:a}=n,o=r.shape.length,i=r.shape.slice();let u=a;return a<0&&(ze(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),qr({inputs:{x:r},backend:t,attrs:{shape:i}})}const YW={kernelName:yg,backendName:"cpu",kernelFunc:Ym};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZW=ka((s,e)=>s/e),_v=La(Tp,ZW),U0={kernelName:Tp,backendName:"cpu",kernelFunc:_v};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(s,e,t){const n=s.shape,r=n[0],a=n[1],o=t.data.get(s.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,c=[r,a],d=hn(c),h=ko("float32",d),l=ko("float32",d);for(let b=0;b<r;b++){const m=kd({inputs:{x:i},backend:t,attrs:{begin:[b,0],size:[1,a]}}),I=kd({inputs:{x:u},backend:t,attrs:{begin:[b,0],size:[1,a]}}),N=yi({inputs:{real:m,imag:I},backend:t}),{real:E,imag:D}=QW(N,e,t),U=Vc(E,D);for(let L=0;L<a;L++){const Y=Vw(U,L);h[b*a+L]=Y.real,l[b*a+L]=Y.imag}t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(N)}const p=t.makeTensorInfo(c,"float32",h),f=t.makeTensorInfo(c,"float32",l),x=yi({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),x}function QW(s,e,t){const n=hn(s.shape),r=t.data.get(s.dataId),a=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(JW(n)){const i=j0(a,o,n,e,t),u=[s.shape[0],s.shape[1]];if(e){const c=t.makeTensorInfo(u,"float32",i.real),d=t.makeTensorInfo(u,"float32",i.imag),h=t.makeTensorInfo([],"float32",_l(n,"float32")),l=vc({inputs:{x:h},backend:t}),p=U0.kernelFunc({inputs:{a:c,b:h},backend:t}),f=U0.kernelFunc({inputs:{a:d,b:l},backend:t}),x=t.data.get(p.dataId).values,b=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:x,imag:b}}return i}else{const i=Vc(a,o),u=eV(i,n,e);return XC(u)}}function JW(s){return(s&s-1)===0}function j0(s,e,t,n,r){if(t===1)return{real:s,imag:e};const a=Vc(s,e),o=t/2,i=YC(a),u=i.real,c=i.imag,d=[u.length],h=r.makeTensorInfo(d,"float32",u),l=r.makeTensorInfo(d,"float32",c),p=yi({inputs:{real:h,imag:l},backend:r}),f=ZC(a),x=f.real,b=f.imag,m=[x.length],I=r.makeTensorInfo(m,"float32",x),N=r.makeTensorInfo(m,"float32",b),E=yi({inputs:{real:I,imag:N},backend:r}),D=j0(u,c,o,n,r),U=D.real,L=D.imag,Y=[U.length],V=r.makeTensorInfo(Y,"float32",U),P=r.makeTensorInfo(Y,"float32",L),oe=yi({inputs:{real:V,imag:P},backend:r}),ne=j0(x,b,o,n,r),ge=ne.real,ye=ne.imag,Ee=[ge.length],X=r.makeTensorInfo(Ee,"float32",ge),je=r.makeTensorInfo(Ee,"float32",ye),Be=yi({inputs:{real:X,imag:je},backend:r}),tt=JC(t,n),ct=[tt.real.length],Me=r.makeTensorInfo(ct,"float32",tt.real),wt=r.makeTensorInfo(ct,"float32",tt.imag),at=yi({inputs:{real:Me,imag:wt},backend:r}),Gt=$b({inputs:{a:at,b:Be},backend:r}),Ht=lh({inputs:{a:oe,b:Gt},backend:r}),dn=Iv({inputs:{a:oe,b:Gt},backend:r}),mn=vd({inputs:{input:Ht},backend:r}),Rn=vd({inputs:{input:dn},backend:r}),ee=dh({inputs:{input:Ht},backend:r}),se=dh({inputs:{input:dn},backend:r}),we=hh({inputs:[mn,Rn],backend:r,attrs:{axis:0}}),pt=hh({inputs:[ee,se],backend:r,attrs:{axis:0}}),bt=r.data.get(we.dataId).values,At=r.data.get(pt.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(Be),r.disposeIntermediateTensorInfo(Me),r.disposeIntermediateTensorInfo(wt),r.disposeIntermediateTensorInfo(at),r.disposeIntermediateTensorInfo(Gt),r.disposeIntermediateTensorInfo(Ht),r.disposeIntermediateTensorInfo(dn),r.disposeIntermediateTensorInfo(mn),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(Rn),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(we),r.disposeIntermediateTensorInfo(pt),{real:bt,imag:At}}function eV(s,e,t){const n=new Float32Array(e*2);for(let r=0;r<e;r++){let a=0,o=0;for(let i=0;i<e;i++){const u=e_(r*i,e,t),c=Vw(s,i);a+=c.real*u.real-c.imag*u.imag,o+=c.real*u.imag+c.imag*u.real}t&&(a/=e,o/=e),QC(n,a,o,r)}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(s){const{inputs:e,backend:t}=s,{input:n}=e,r=hn(n.shape),a=n.shape[n.shape.length-1],o=r/a,i=qr({inputs:{x:n},backend:t,attrs:{shape:[o,a]}}),u=FT(i,!1,t),c=qr({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),c}const nV={kernelName:ky,backendName:"cpu",kernelFunc:tV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sv(s){const{backend:e,attrs:t}=s,{shape:n,value:r,dtype:a}=t,o=a||bh(r),i=ba(o,hn(n));return rV(i,r,o),e.makeTensorInfo(n,o,i)}const sV={kernelName:Iy,backendName:"cpu",kernelFunc:Sv};function rV(s,e,t){s.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV={kernelName:Cy,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,r=t,a=ko(n.dtype,hn(n.shape)),[o,i,u,c]=n.shape,d=r.data.get(n.dataId).values;for(let l=0;l<o;l++){const p=l*u*i*c;for(let f=0;f<i;f++){const x=f*(u*c);for(let b=0;b<u;b++){const m=b*c;for(let I=0;I<c;I++){const N=Math.round(u-b-1),E=p+x+m+I;let D=d[E];if(N>=0&&N<u){const U=N*c,L=p+x+U+I;D=d[L]}a[E]=D}}}}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:l,activation:p,leakyreluAlpha:f}=n;let x=AT({inputs:{x:r,filter:a},backend:t,attrs:{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:l}});if(o){const b=x;if(d==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const m=qr({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});x=lh({inputs:{a:x,b:m},backend:t}),t.disposeIntermediateTensorInfo(m)}else x=lh({inputs:{a:x,b:o},backend:t});t.disposeIntermediateTensorInfo(b)}if(p){const b=x;if(d==="NCHW"&&p==="prelu"&&i.shape.length===1&&i.shape[0]!==1){const m=qr({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});x=Xm(t,x,p,m,f),t.disposeIntermediateTensorInfo(m)}else x=Xm(t,x,p,i,f);t.disposeIntermediateTensorInfo(b)}return x}const iV={kernelName:Tm,backendName:"cpu",kernelFunc:oV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:l,activation:p,leakyreluAlpha:f}=n;let x=OT({inputs:{x:r,filter:a},backend:t,attrs:{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:l}});if(o){const b=x;x=lh({inputs:{a:x,b:o},backend:t}),t.disposeIntermediateTensorInfo(b)}if(p){const b=x;x=Xm(t,x,p,i,f),t.disposeIntermediateTensorInfo(b)}return x}const cV={kernelName:bI,backendName:"cpu",kernelFunc:uV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(s){const{inputs:e,backend:t}=s,{params:n,indices:r}=e,a=hn(n.shape),o=r.shape,i=o[o.length-1],[u,c,d,h]=_w(n,r);if(c===0)return t.makeTensorInfo(u,n.dtype,[]);const l=t.data.get(r.dataId).values,p=t.bufferSync(n),f=j$(l,p,n.dtype,c,i,d,h,n.shape,a);return t.makeTensorInfo(u,n.dtype,f.values)}const dV={kernelName:J2,backendName:"cpu",kernelFunc:lV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,indices:a}=e,{axis:o,batchDims:i}=n;ls([r,a],"gatherV2");const u=nr(o,r.shape)[0],c=t.data.get(a.dataId).values,d=r.shape[u];for(let E=0;E<c.length;++E){const D=c[E];ze(D<=d-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${d-1}]`)}let h=i;i==null&&(h=0);const l=hn(a.shape),p=Xw(r,a,u,h),f=qr({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),x=qr({inputs:{x:a},backend:t,attrs:{shape:[p.batchSize,l/p.batchSize]}}),b=[p.batchSize,p.outerSize,l/p.batchSize,p.sliceSize],m=t.bufferSync(x),I=t.bufferSync(f),N=G$(I,m,b);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.makeTensorInfo(p.outputShape,N.dtype,N.values)}const pV={kernelName:vg,backendName:"cpu",kernelFunc:hV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(s){const{inputs:e,backend:t}=s,{input:n}=e,r=hn(n.shape),a=n.shape[n.shape.length-1],o=r/a,i=qr({inputs:{x:n},backend:t,attrs:{shape:[o,a]}}),u=FT(i,!0,t),c=qr({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),c}const mV={kernelName:_y,backendName:"cpu",kernelFunc:fV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gV=Fr(Pp,s=>Number.isFinite(s)?1:0,"bool"),bV={kernelName:Pp,backendName:"cpu",kernelFunc:gV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xV=Fr(Lp,s=>Math.abs(s)===1/0?1:0,"bool"),yV={kernelName:Lp,backendName:"cpu",kernelFunc:xV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wV=Fr(Bp,s=>Number.isNaN(s)?1:0,"bool"),vV={kernelName:Bp,backendName:"cpu",kernelFunc:wV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(s){const{backend:e,attrs:t}=s,{start:n,stop:r,num:a}=t,o=Y$(n,r,a);return e.makeTensorInfo([o.length],"float32",o)}const IV={kernelName:eI,backendName:"cpu",kernelFunc:kV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CV=Fr(Wp,s=>Math.log1p(s)),_V={kernelName:Wp,backendName:"cpu",kernelFunc:CV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SV=ka((s,e)=>s&&e),$V=La(Sg,SV,null,"bool"),TV={kernelName:Sg,backendName:"cpu",kernelFunc:$V};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV=Fr($g,s=>s?0:1,"bool"),EV={kernelName:$g,backendName:"cpu",kernelFunc:NV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RV=ka((s,e)=>s||e),AV=La(Tg,RV,null,"bool"),OV={kernelName:Tg,backendName:"cpu",kernelFunc:AV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{depthRadius:a,bias:o,alpha:i,beta:u}=n;ls(r,"LRN");const c=r.shape[3],d=c-1,h=t.data.get(r.dataId).values,l=hn(r.shape),p=new Float32Array(l);function f(x){const b=x%c;let m=x-b+Math.max(0,b-a);const I=x-b+Math.min(b+a,d);let N=0;for(;m<=I;m++){const E=h[m];N+=E*E}return N}for(let x=0;x<l;x++){const b=f(x),m=h[x]*Math.pow(o+i*b,-u);p[x]=m}return t.makeTensorInfo(r.shape,r.dtype,p)}const DV={kernelName:Ng,backendName:"cpu",kernelFunc:FV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,y:a,dy:o}=e,{depthRadius:i,bias:u,alpha:c,beta:d}=n;ls(o,"LRNGrad");const h=hn(o.shape),l=o.shape[3],p=t.data.get(o.dataId).values,f=t.data.get(r.dataId).values,x=t.data.get(a.dataId).values,b=new Float32Array(h),m=h;for(let I=0;I<m;I++){const N=I%l,E=I-N+Math.max(0,N-i),D=I-N+Math.min(l,N+i+1);let U=0;for(let L=E;L<D;L++)U+=Math.pow(f[L],2);U=c*U+u;for(let L=E;L<D;L++){let Y=-2*c*d*f[L]*x[I]/U;I===L&&(Y+=Math.pow(U,-d)),Y*=p[I],b[L]+=Y}}return t.makeTensorInfo(o.shape,r.dtype,b)}const PV={kernelName:$y,backendName:"cpu",kernelFunc:MV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{reductionIndices:a,keepDims:o}=n,i=t;let u=r.shape;const c=u.length,d=nr(a,u);let h=d;const l=ha(h,c);let p=i.data.get(r.dataId).values;if(l!=null){const E=new Array(c);for(let D=0;D<E.length;D++)E[D]=u[l[D]];p=vv(p,u,r.dtype,l,E),h=wa(h.length,c),u=E}ls(r,"max"),ho("max",h,c);const[f,x]=Ja(u,h),b=hn(x),m=Q$(p,b,f,r.dtype),I=i.write(m,f,r.dtype);let N=f;return o&&(N=$a(f,d)),{dataId:I,shape:N,dtype:r.dtype}}const LV={kernelName:Eg,backendName:"cpu",kernelFunc:DT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e;ls(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n,c=1;ze(Co(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Cu(r.shape,a,o,c,i,u);let h;if(d.filterWidth===1&&d.filterHeight===1&&Er(d.inShape,d.outShape))h=vc({inputs:{x:r},backend:t});else{const l=t.data.get(r.dataId).values,p=ws(r.shape),f=Cv(l,r.shape,r.dtype,p,d,"max");h=t.makeTensorInfo(d.outShape,r.dtype,f.values)}return h}const zV={kernelName:Rg,backendName:"cpu",kernelFunc:BV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=n;ls(r,"maxPool3d");const d=Gc(r.shape,a,o,1,i,u,c),h=t.data.get(r.dataId).values,l=RT(h,r.shape,r.dtype,ws(r.shape),d,"max");return t.makeTensorInfo(l.shape,"float32",l.values)}const VV={kernelName:Ag,backendName:"cpu",kernelFunc:WV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,{filterSize:o,strides:i,pad:u,dimRoundingMode:c}=n;ls([r,a],"maxPool3DGrad");const d=Gc(a.shape,o,i,1,u,c),h=t.bufferSync(a),l=Oz(h,d),p=d.strideDepth,f=d.strideHeight,x=d.strideWidth,b=d.dilationDepth,m=d.dilationHeight,I=d.dilationWidth,N=d.effectiveFilterDepth,E=d.effectiveFilterHeight,D=d.effectiveFilterWidth,U=N-1-d.padInfo.front,L=D-1-d.padInfo.left,Y=E-1-d.padInfo.top,V=tr(a.shape,"float32"),P=t.bufferSync(r);for(let oe=0;oe<d.batchSize;++oe)for(let ne=0;ne<d.inChannels;++ne)for(let ge=0;ge<d.inDepth;++ge)for(let ye=0;ye<d.inHeight;++ye)for(let Ee=0;Ee<d.inWidth;++Ee){const X=ge-U,je=ye-Y,Be=Ee-L;let tt=0;for(let ct=0;ct<N;ct+=b){const Me=(X+ct)/p;if(!(Me<0||Me>=d.outDepth||Math.floor(Me)!==Me))for(let wt=0;wt<E;wt+=m){const at=(je+wt)/f;if(!(at<0||at>=d.outHeight||Math.floor(at)!==at))for(let Gt=0;Gt<D;Gt+=I){const Ht=(Be+Gt)/x;if(Ht<0||Ht>=d.outWidth||Math.floor(Ht)!==Ht)continue;const dn=N*E*D-1-l.get(oe,Me,at,Ht,ne),mn=ct*E*D+wt*D+Gt,Rn=dn===mn?1:0;if(Rn===0)continue;tt+=P.get(oe,Me,at,Ht,ne)*Rn}}}V.set(tt,oe,ge,ye,Ee,ne)}return t.makeTensorInfo(V.shape,V.dtype,V.values)}const jV={kernelName:Ny,backendName:"cpu",kernelFunc:UV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GV(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a,output:o}=e,i=a;ls([a,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:h}=n,l=Cu(i.shape,u,c,1,d,h),p=t.data.get(i.dataId).values,f=tr(l.outShape,i.dtype,ET(p,i.shape,i.dtype,l).values),x=l.strideHeight,b=l.strideWidth,m=l.dilationHeight,I=l.dilationWidth,N=l.effectiveFilterHeight,E=l.effectiveFilterWidth,D=E-1-l.padInfo.left,U=N-1-l.padInfo.top,L=tr(i.shape,"float32"),Y=t.data.get(r.dataId).values,V=tr(r.shape,"float32",Y);for(let P=0;P<l.batchSize;++P)for(let oe=0;oe<l.inChannels;++oe)for(let ne=0;ne<l.inHeight;++ne)for(let ge=0;ge<l.inWidth;++ge){const ye=ne-U,Ee=ge-D;let X=0;for(let je=0;je<N;je+=m){const Be=(ye+je)/x;if(!(Be<0||Be>=l.outHeight||Math.floor(Be)!==Be))for(let tt=0;tt<E;tt+=I){const ct=(Ee+tt)/b;if(ct<0||ct>=l.outWidth||Math.floor(ct)!==ct)continue;const Me=N*E-1-f.get(P,Be,ct,oe),wt=je*E+tt,at=Me===wt?1:0;if(at===0)continue;X+=V.get(P,Be,ct,oe)*at}}L.set(X,P,ne,ge,oe)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}const HV={kernelName:Ty,backendName:"cpu",kernelFunc:GV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(s,e,t,n,r){const a=ws(e),o=Cv(s,e,t,a,r,"max"),i=ET(s,e,t,r,!0,n);return[o.values,i.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KV={kernelName:tI,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=e,u=t;ls(n,"MaxPoolWithArgmax");const c=u.data.get(n.dataId).values,d=Cu(n.shape,r,a,[1,1],o),[h,l]=qV(c,n.shape,n.dtype,i,d),p=u.write(h,d.outShape,n.dtype),f=u.write(l,d.outShape,n.dtype);return[{dataId:p,shape:d.outShape,dtype:n.dtype},{dataId:f,shape:d.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n,i=nr(a,r.shape),c=Ja(r.shape,i)[1],d=hn(c),h=[],l=t.makeTensorInfo([],"float32",new Float32Array([d]));h.push(l);const p=Il({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});h.push(p);const f=_v({inputs:{a:p,b:l},backend:t});h.push(f);const x=Tf({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:o}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),x}const YV={kernelName:Og,backendName:"cpu",kernelFunc:XV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;ls(r,"min");const i=nr(a,r.shape);let u=i;const c=ha(u,r.shape.length);let d=r;c!=null&&(d=ei({inputs:{x:r},backend:t,attrs:{perm:c}}),u=wa(u.length,r.shape.length)),ho("min",u,d.shape.length);const[h,l]=Ja(d.shape,u),p=hn(l),f=Io(hn(h),d.dtype),x=t.data.get(d.dataId).values;for(let m=0;m<f.length;++m){const I=m*p;let N=x[I];for(let E=0;E<p;++E){const D=x[I+E];(Number.isNaN(D)||D<N)&&(N=D)}f[m]=N}c!=null&&t.disposeIntermediateTensorInfo(d);const b=t.makeTensorInfo(h,d.dtype,f);if(o){const m=$a(h,i),I=qr({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(b),I}return b}const QV={kernelName:Fg,backendName:"cpu",kernelFunc:ZV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JV(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{paddings:a,mode:o}=n;ls(r,"mirrorPad");const i=a.map((N,E)=>N[0]+r.shape[E]+N[1]),u=a.map(N=>N[0]),c=a.map((N,E)=>N[0]+r.shape[E]),d=o==="reflect"?0:1,h=t.data.get(r.dataId).values,l=r.shape.length,p=ws(r.shape),f=hn(i),x=i.length,b=ws(i),m=ko(r.dtype,f);for(let N=0;N<f;N++){let E=xh(N,x,b);for(let U=0;U<x;U++)E[U]<u[U]?E[U]=u[U]*2-E[U]-d:E[U]>=c[U]&&(E[U]=(c[U]-1)*2-E[U]+d);E=E.map((U,L)=>U-u[L]);const D=fc(E,l,p);m[N]=h[D]}return{dataId:t.write(m,i,r.dtype),shape:i,dtype:r.dtype}}const eU={kernelName:Dg,backendName:"cpu",kernelFunc:JV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tU=ka((s,e)=>{const t=s%e;return s<0&&e<0||s>=0&&e>=0?t:(t+e)%e}),nU=La(jp,tU),sU={kernelName:jp,backendName:"cpu",kernelFunc:nU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(s){const{inputs:e,backend:t,attrs:n}=s,{logits:r}=e,{dim:a}=n,o=r.shape.length;let i=a;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const u=nr([i],r.shape),c=DT({inputs:{x:r},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),d=$a(c.shape,u),h=qr({inputs:{x:c},backend:t,attrs:{shape:d}}),l=Iv({inputs:{a:r,b:h},backend:t}),p=z$({inputs:{x:l},backend:t}),f=Tf({inputs:{x:p},backend:t,attrs:{axis:u,keepDims:!1}}),x=qr({inputs:{x:f},backend:t,attrs:{shape:d}}),b=_v({inputs:{a:p,b:x},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),b}const rU={kernelName:Jg,backendName:"cpu",kernelFunc:MT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aU(s){const{inputs:e,backend:t,attrs:n}=s,{logits:r}=e,{numSamples:a,seed:o,normalized:i}=n;ls(r,"multinomial");const u=i?r:MT({inputs:{logits:r},backend:t,attrs:{dim:-1}}),c=u.shape[0],d=u.shape[1],h=t.data.get(u.dataId).values,l=[c,a],p=Io(hn(l),"int32");for(let f=0;f<c;++f){const x=f*d,b=new Float32Array(d-1);b[0]=h[x];for(let N=1;N<b.length;++N)b[N]=b[N-1]+h[x+N];const m=lw.alea(o.toString()),I=f*a;for(let N=0;N<a;++N){const E=m();p[I+N]=b.length;for(let D=0;D<b.length;D++)if(E<b[D]){p[I+N]=D;break}}}return i||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(l,"int32",p)}const oU={kernelName:nI,backendName:"cpu",kernelFunc:aU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iU=yw;function uU(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=n;ls(r,"NonMaxSuppression");const c=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,{selectedIndices:h}=iU(c,d,o,i,u);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const cU={kernelName:Ey,backendName:"cpu",kernelFunc:uU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lU=ww;function dU(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=n;ls(r,"NonMaxSuppressionPadded");const d=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,{selectedIndices:l,validOutputs:p}=lU(d,h,o,i,u,c);return[t.makeTensorInfo([l.length],"int32",new Int32Array(l)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const hU={kernelName:Ry,backendName:"cpu",kernelFunc:dU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pU=vw;function fU(s){const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=n;ls(r,"NonMaxSuppressionWithScore");const d=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,l=o,p=i,f=u,x=c,{selectedIndices:b,selectedScores:m}=pU(d,h,l,p,f,x);return[t.makeTensorInfo([b.length],"int32",new Int32Array(b)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}const mU={kernelName:Ay,backendName:"cpu",kernelFunc:fU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(s){const{inputs:e,backend:t,attrs:n}=s,{indices:r}=e,{dtype:a,depth:o,onValue:i,offValue:u}=n;ls(r,"oneHot");const c=hn(r.shape),d=new Float32Array(c*o);d.fill(u);const h=t.data.get(r.dataId).values;for(let l=0;l<c;++l)h[l]>=0&&h[l]<o&&(d[l*o+h[l]]=i);return t.makeTensorInfo([...r.shape,o],a,d)}const bU={kernelName:Bg,backendName:"cpu",kernelFunc:gU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zm(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){const r=vd({inputs:{input:n},backend:t}),a=Zm({inputs:{x:r},backend:t}),o=dh({inputs:{input:n},backend:t}),i=Zm({inputs:{x:o},backend:t}),u=yi({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Sv({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}const xU={kernelName:nb,backendName:"cpu",kernelFunc:Zm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){const r=vd({inputs:{input:n},backend:t}),a=PT({inputs:{x:r},backend:t}),o=dh({inputs:{input:n},backend:t}),i=Zm({inputs:{x:o},backend:t}),u=yi({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Sv({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}const yU={kernelName:Lg,backendName:"cpu",kernelFunc:PT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LT(s){const{inputs:e,backend:t,attrs:n}=s,{axis:r}=n;if(e.length===1)return Ym({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,o=e[0].dtype;e.forEach(d=>{ty(a,d.shape,"All tensors passed to stack must have matching shapes"),ze(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(d=>{const h=Ym({inputs:{input:d},backend:t,attrs:{dim:r}});return i.push(h),h}),c=hh({inputs:u,backend:t,attrs:{axis:r}});return i.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const wU={kernelName:zg,backendName:"cpu",kernelFunc:LT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{paddings:a,constantValue:o}=n;ls(r,"pad");const i=a.map((I,N)=>I[0]+r.shape[N]+I[1]),u=a.map(I=>I[0]),c=t.data.get(r.dataId).values,d=hn(r.shape),h=r.shape.length,l=ws(r.shape),p=hn(i),f=i.length,x=ws(i),b=ko(r.dtype,p);o!==0&&b.fill(o);for(let I=0;I<d;I++){const E=xh(I,h,l).map((U,L)=>U+u[L]),D=fc(E,f,x);b[D]=c[I]}return{dataId:t.write(b,i,r.dtype),shape:i,dtype:r.dtype}}const BT={kernelName:Wg,backendName:"cpu",kernelFunc:vU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU=ka((s,e)=>Math.pow(s,e)),IU=La(Hp,kU),CU={kernelName:Hp,backendName:"cpu",kernelFunc:IU};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(s){const{inputs:e,backend:t,attrs:n}=s,{paramsNestedSplits:r,paramsDenseValues:a,indices:o}=e,i=r.map(b=>t.data.get(b.dataId).values),u=r.map(b=>b.shape),c=t.data.get(a.dataId).values,d=t.data.get(o.dataId).values,[h,l,p]=rT(i,u,c,a.shape,a.dtype,d,o.shape),f=h.map(b=>t.makeTensorInfo([b.length],"int32",b)),x=t.makeTensorInfo(p,a.dtype,l);return f.concat([x])}const SU={kernelName:sI,backendName:"cpu",kernelFunc:_U};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(s){const{inputs:e,backend:t}=s,{starts:n,limits:r,deltas:a}=e,o=t.data.get(n.dataId).values,i=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,[c,d]=aT(o,n.shape,n.dtype,i,r.shape,u,a.shape),h=t.makeTensorInfo([c.length],"int32",c),l=t.makeTensorInfo([d.length],n.dtype,d);return[h,l]}const TU={kernelName:rI,backendName:"cpu",kernelFunc:$U};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(s){const{inputs:e,backend:t,attrs:n}=s,{shape:r,values:a,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,c=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,h=t.data.get(o.dataId).values,l=i.map(b=>t.data.get(b.dataId).values),p=i.map(b=>b.shape),[f,x]=oT(c,r.shape,d,a.shape,a.dtype,h,o.shape,l,p,u);return t.makeTensorInfo(f,a.dtype,x)}const EU={kernelName:aI,backendName:"cpu",kernelFunc:NU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(s){const{backend:e,attrs:t}=s,{start:n,stop:r,dtype:a,step:o}=t,i=iT(n,r,o,a);return e.makeTensorInfo([i.length],a,i)}const AU={kernelName:Oy,backendName:"cpu",kernelFunc:RU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OU=Fr(qp,s=>1/s),FU={kernelName:qp,backendName:"cpu",kernelFunc:OU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(s){const{inputs:e,backend:t,attrs:n}=s,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=n;ls(r,"resizeBilinear");const u=ws(r.shape),[c,d]=i,[h,l,p,f]=r.shape,x=t.data.get(r.dataId).values,b=new Float32Array(hn([h,c,d,f])),m=[a&&c>1?l-1:l,a&&d>1?p-1:p],I=[a&&c>1?c-1:c,a&&d>1?d-1:d];let N=0;const E=m[0]/I[0],D=m[1]/I[1];for(let U=0;U<h;U++)for(let L=0;L<c;L++){let Y;o?Y=E*(L+.5)-.5:Y=E*L;const V=Math.max(0,Math.floor(Y)),P=Y-V,oe=Math.min(l-1,Math.ceil(Y)),ne=U*u[0]+V*u[1],ge=U*u[0]+oe*u[1];for(let ye=0;ye<d;ye++){let Ee;o?Ee=D*(ye+.5)-.5:Ee=D*ye;const X=Math.max(0,Math.floor(Ee)),je=Ee-X,Be=Math.min(p-1,Math.ceil(Ee)),tt=ne+X*u[2],ct=ge+X*u[2],Me=ne+Be*u[2],wt=ge+Be*u[2];for(let at=0;at<f;at++){const Gt=x[tt+at],Ht=x[ct+at],dn=x[Me+at],mn=x[wt+at],Rn=Gt+(dn-Gt)*je,ee=Ht+(mn-Ht)*je,se=Rn+(ee-Rn)*P;b[N++]=se}}}return t.makeTensorInfo([h,c,d,f],"float32",b)}const MU={kernelName:Hg,backendName:"cpu",kernelFunc:DU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(s){const{inputs:e,backend:t,attrs:n}=s,{images:r,dy:a}=e,{alignCorners:o}=n;ls([a,r],"resizeBilinearGrad");const i=ws(r.shape),[u,c,d,h]=r.shape,[,l,p]=a.shape,f=new Float32Array(u*c*d*h),x=[o&&l>1?c-1:c,o&&p>1?d-1:d],b=[o&&l>1?l-1:l,o&&p>1?p-1:p],m=x[0]/b[0],I=x[1]/b[1],N=t.data.get(a.dataId).values;let E=0;for(let D=0;D<u;D++){const U=D*i[0];for(let L=0;L<l;L++){const Y=L*m,V=Math.floor(Y),P=Math.min(Math.ceil(Y),c-1),oe=U+V*i[1],ne=U+P*i[1],ge=Y-V,ye=1-ge;for(let Ee=0;Ee<p;Ee++){const X=Ee*I,je=Math.floor(X),Be=Math.min(Math.ceil(X),d-1),tt=X-je,ct=1-tt,Me=oe+je*i[2],wt=oe+Be*i[2],at=ne+je*i[2],Gt=ne+Be*i[2],Ht=ye*ct,dn=ye*tt,mn=ge*ct,Rn=ge*tt;for(let ee=0;ee<h;ee++){const se=N[E++];f[Me+ee]+=se*Ht,f[wt+ee]+=se*dn,f[at+ee]+=se*mn,f[Gt+ee]+=se*Rn}}}}return t.makeTensorInfo([u,d,c,h],"float32",f)}const LU={kernelName:My,backendName:"cpu",kernelFunc:PU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(s){const{inputs:e,backend:t,attrs:n}=s,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=n;ls(r,"resizeNearestNeighbor");const u=ws(r.shape),[c,d]=i,[h,l,p,f]=r.shape,x=t.data.get(r.dataId).values,b=new Float32Array(h*c*d*f),m=[a&&c>1?l-1:l,a&&d>1?p-1:p],I=[a&&c>1?c-1:c,a&&d>1?d-1:d],N=m[0]/I[0],E=m[1]/I[1];let D=0;for(let U=0;U<h;U++){const L=U*u[0];for(let Y=0;Y<c;Y++){const V=o?N*(Y+.5):N*Y;let P=Math.min(l-1,a?Math.round(V):Math.floor(V));o&&(P=Math.max(0,P));const oe=L+P*u[1];for(let ne=0;ne<d;ne++){const ge=o?E*(ne+.5):E*ne;let ye=Math.min(p-1,a?Math.round(ge):Math.floor(ge));o&&(ye=Math.max(0,ye));const Ee=oe+ye*u[2];for(let X=0;X<f;X++){const je=x[Ee+X];b[D++]=je}}}}return t.makeTensorInfo([h,c,d,f],r.dtype,b)}const zU={kernelName:Gg,backendName:"cpu",kernelFunc:BU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(s){const{inputs:e,backend:t,attrs:n}=s,{images:r,dy:a}=e,{alignCorners:o}=n;ls([a,r],"resizeNearestNeighborGrad");const i=ws(r.shape),u=ws(a.shape),[c,d,h,l]=r.shape,[,p,f]=a.shape,x=new Float32Array(c*d*h*l),b=t.data.get(a.dataId).values,m=[o&&p>1?d-1:d,o&&f>1?h-1:h],I=[o&&p>1?p-1:p,o&&f>1?f-1:f],N=m[0]/I[0],E=m[1]/I[1],D=1/N,U=1/E,L=Math.ceil(D)*2+2,Y=Math.ceil(U)*2+2;for(let V=0;V<c;V++){const P=V*i[0];for(let oe=0;oe<d;oe++){const ne=P+oe*i[1],ge=Math.floor(oe*D),ye=Math.floor(ge-L/2);for(let Ee=0;Ee<h;Ee++){const X=ne+Ee*i[2],je=Math.floor(Ee*U),Be=Math.floor(je-Y/2);for(let tt=0;tt<l;tt++){let ct=0;for(let Me=0;Me<L;Me++){const wt=Me+ye;if(wt<0||wt>=p)continue;const at=P+wt*u[1],Gt=wt*N,Ht=Math.min(d-1,o?Math.round(Gt):Math.floor(Gt));if(oe===Ht)for(let dn=0;dn<Y;dn++){const mn=dn+Be;if(mn<0||mn>=f)continue;const Rn=at+mn*u[2],ee=mn*E,se=Math.min(h-1,o?Math.round(ee):Math.floor(ee));Ee===se&&(ct+=b[Rn+tt])}}x[X+tt]=ct}}}}return t.makeTensorInfo(r.shape,r.dtype,x)}const VU={kernelName:Dy,backendName:"cpu",kernelFunc:WU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{dims:a}=n;ls(r,"reverse");const o=r.shape.length,i=nr(a,r.shape);if(o===0)return vc({inputs:{x:r},backend:t});const u=new co(r.shape,r.dtype),c=t.bufferSync(r);for(let d=0;d<u.size;d++){const h=u.indexToLoc(d),l=h.slice();i.forEach(p=>l[p]=r.shape[p]-1-l[p]),u.set(c.get(...l),...h)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}const jU={kernelName:qg,backendName:"cpu",kernelFunc:UU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GU={kernelName:Uy,backendName:"cpu",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,{radians:r,fillValue:a,center:o}=e,i=t,u=ko(n.dtype,hn(n.shape)),[c,d,h,l]=n.shape,[p,f]=Ow(o,d,h),x=255,b=Math.sin(r),m=Math.cos(r),I=i.data.get(n.dataId).values;for(let E=0;E<c;E++){const D=E*h*d*l;for(let U=0;U<d;U++){const L=U*(h*l);for(let Y=0;Y<h;Y++){const V=Y*l;for(let P=0;P<l;P++){const oe=[c,U,Y,P],ne=oe[2],ge=oe[1];let ye=(ne-p)*m-(ge-f)*b,Ee=(ne-p)*b+(ge-f)*m;ye=Math.round(ye+p),Ee=Math.round(Ee+f);let X=a;if(typeof a!="number"&&(P===3?X=x:X=a[P]),ye>=0&&ye<h&&Ee>=0&&Ee<d){const Be=Ee*(h*l),tt=ye*l,ct=D+Be+tt+P;X=I[ct]}const je=D+L+V+P;u[je]=X}}}}return{dataId:i.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU=Fr(Yp,s=>{const e=Math.floor(s);return s-e<.5?Math.floor(s):s-e>.5?Math.ceil(s):e%2===0?e:e+1}),qU={kernelName:Yp,backendName:"cpu",kernelFunc:HU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(s){const{inputs:e,backend:t,attrs:n}=s,{indices:r,updates:a}=e,{shape:o}=n,{sliceRank:i,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Ed(a,r,o),l=!0,p=t.bufferSync(r),f=t.bufferSync(a),x=od(p,f,o,h,c,u,i,d,0,l);return t.makeTensorInfo(o,x.dtype,x.values)}const XU={kernelName:oI,backendName:"cpu",kernelFunc:KU};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(s,e){let t=0,n=s.length,r=0;for(;t<n;)r=Math.floor((t+n)/2),s[r]<e?t=r+1:n=r;return n}function ZU(s,e){let t=0,n=s.length,r=0;for(;t<n;)r=Math.floor((t+n)/2),s[r]<=e?t=r+1:n=r;return n}function QU(s,e,t,n,r,a){const o=ba("int32",t*r);for(let i=0;i<t;++i){const u=s.slice(i*n,(i+1)*n),c=i*r;for(let d=0;d<r;++d)o[c+d]=a==="left"?YU(u,e[d+c]):ZU(u,e[d+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(s){const{inputs:e,backend:t,attrs:n}=s,{sortedSequence:r,values:a}=e,{side:o}=n,i=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,c=QU(i,u,r.shape[0],r.shape[1],a.shape[1],o);return t.makeTensorInfo(a.shape,"int32",c)}const ej={kernelName:uI,backendName:"cpu",kernelFunc:JU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(s){const{inputs:e,backend:t}=s,{condition:n,t:r,e:a}=e;ls([n,r,a],"select");const o=n.shape.length,i=t.data.get(n.dataId).values,u=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,d=vi(r.dtype,a.dtype),h=Io(hn(r.shape),d);let l=0;const p=o===0||o>1||r.shape.length===1?1:hn(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let x=0;x<p;x++)i[f]===1?h[l++]=u[f]:h[l++]=c[f];return t.makeTensorInfo(r.shape,d,h)}const nj={kernelName:Kg,backendName:"cpu",kernelFunc:tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sj=fb,rj=mb,aj=Fr(Qp,s=>s>=0?rj*s:sj*(Math.exp(s)-1)),oj={kernelName:Qp,backendName:"cpu",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij=Fr(tf,s=>s<0?-1:s>0?1:0),uj={kernelName:tf,backendName:"cpu",kernelFunc:ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cj=Fr(Jp,s=>Math.sin(s)),lj={kernelName:Jp,backendName:"cpu",kernelFunc:cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dj=Fr(ef,s=>Math.sinh(s)),hj={kernelName:ef,backendName:"cpu",kernelFunc:dj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pj=11920928955078125e-23,t2=Math.log(pj)+2,fj=Fr(sf,s=>{const e=s>-t2,t=s<t2,n=Math.exp(s);let r;return t?r=n:e?r=s:r=Math.log(1+n),r}),mj={kernelName:sf,backendName:"cpu",kernelFunc:fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gj(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockShape:a,paddings:o}=n;ls([r],"spaceToBatchND");const i=hn(a),u=[[0,0]];u.push(...o);for(let U=1+a.length;U<r.shape.length;++U)u.push([0,0]);const c=BT.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),d=bf(c.shape,a,i,!1),h=xf(d.length,a.length,!1),l=yf(c.shape,a,i,!1),x=qr({inputs:{x:c},backend:t,attrs:{shape:d}}),I=ei({inputs:{x},backend:t,attrs:{perm:h}}),D=qr({inputs:{x:I},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(I),D}const bj={kernelName:Zg,backendName:"cpu",kernelFunc:gj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xj(s){const{inputs:e,backend:t}=s,{indices:n,values:r,denseShape:a,defaultValue:o}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=t.data.get(n.dataId).values,u=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,d=t.data.get(o.dataId).values[0],[h,l,p,f,x]=dT(i,n.shape,n.dtype,u,r.dtype,c,d);return[t.makeTensorInfo(l,n.dtype,h),t.makeTensorInfo([l[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(b=>Number(b)))),t.makeTensorInfo([x.length],n.dtype,new Int32Array(x))]}const yj={kernelName:cI,backendName:"cpu",kernelFunc:xj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wj(s){const{inputs:e,backend:t}=s,{inputIndices:n,inputShape:r,newShape:a}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(t.data.get(r.dataId).values),i=t.data.get(n.dataId).values,u=Array.from(t.data.get(a.dataId).values),[c,d,h]=hT(i,n.shape,n.dtype,o,u);return[t.makeTensorInfo(d,n.dtype,c),t.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const vj={kernelName:lI,backendName:"cpu",kernelFunc:wj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kj(s){const{inputs:e,backend:t}=s,{data:n,indices:r,segmentIds:a}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(n.dataId).values,i=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,[c,d]=kv(o,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(d,n.dtype,c)}const Ij={kernelName:dI,backendName:"cpu",kernelFunc:kj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cj(s){const{inputs:e,backend:t}=s,{data:n,indices:r,segmentIds:a}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(n.dataId).values,i=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,[c,d]=kv(o,n.shape,n.dtype,i,u);return t.makeTensorInfo(d,n.dtype,c)}const _j={kernelName:hI,backendName:"cpu",kernelFunc:Cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(s){const{inputs:e,backend:t,attrs:n}=s,{sparseIndices:r,sparseValues:a,defaultValue:o}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:l}=Ed(a,r,i),p=!1,f=t.bufferSync(r);let x;switch(a.dtype){case"bool":{const b=t.bufferSync(a),m=Boolean(t.data.get(o.dataId).values[0]);x=od(f,b,i,l,d,c,u,h,m,p);break}case"float32":{const b=t.bufferSync(a),m=t.data.get(o.dataId).values[0];x=od(f,b,i,l,d,c,u,h,m,p);break}case"int32":{const b=t.bufferSync(a),m=t.data.get(o.dataId).values[0];x=od(f,b,i,l,d,c,u,h,m,p);break}case"string":{const b=t.bufferSync(a),m=bl(t.data.get(o.dataId).values[0]);x=od(f,b,i,l,d,c,u,h,m,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return t.makeTensorInfo(i,x.dtype,x.values)}const $j={kernelName:pI,backendName:"cpu",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{numOrSizeSplits:a,axis:o}=n,i=nr(o,r.shape)[0],u=Kw(r,a,i),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return u.map(h=>{const l=[...d];l[i]=h;const p=kd({inputs:{x:r},backend:t,attrs:{begin:c,size:l}});return c[i]+=h,p})}const Nj={kernelName:Qg,backendName:"cpu",kernelFunc:Tj};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ej={kernelName:Py,backendName:"cpu",kernelFunc:({inputs:s,backend:e})=>{const{x:t}=s,n=e;ls(t,"square");const r=n.data.get(t.dataId).values,a=new Float32Array(r.length);for(let i=0;i<r.length;++i){const u=r[i];a[i]=u*u}return{dataId:n.write(a,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rj=Fr(df,(s,e)=>{const t=e;return isNaN(s)?NaN:s>0?1:t.alpha}),Aj={kernelName:df,backendName:"cpu",kernelFunc:Rj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oj(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:l}=n;ls(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:x,sliceDim0:b,isSimpleSlice:m,begin:I,end:N,strides:E}=Ew(r.shape,a,o,i,u,c,d,h,l);let D;if(x)D=qr({inputs:{x:r},backend:t,attrs:{shape:f}});else if(b||m){ze(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const U=$w(I,N,E),L=kd({inputs:{x:r},backend:t,attrs:{begin:I,size:U}});D=qr({inputs:{x:L},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(L)}else{const U=t.bufferSync(r),L=mT(p,U,E,I);D=t.makeTensorInfo(f,L.dtype,L.values)}return D}const Fj={kernelName:By,backendName:"cpu",kernelFunc:Oj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dj(s){const{inputs:e,backend:t,attrs:n}=s,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:c}=n,{data:d,dataSplits:h}=e,l=t.data.get(d.dataId).values,p=t.data.get(h.dataId).values,[f,x]=gT(l,p,r,a,o,i,u,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",x)]}const Mj={kernelName:fI,backendName:"cpu",kernelFunc:Dj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(s){const{inputs:e,backend:t,attrs:n}=s,{skipEmpty:r}=n,{input:a,delimiter:o}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=t.data.get(a.dataId).values,u=t.data.get(o.dataId).values[0],[c,d,h]=bT(i,u,r),l=d.length;return[t.makeTensorInfo([l,2],"int32",c),t.makeTensorInfo([l],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Lj={kernelName:mI,backendName:"cpu",kernelFunc:Pj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(s){const{inputs:e,backend:t,attrs:n}=s,{numBuckets:r}=n,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(a.dataId).values,i=xT(o,r);return t.makeTensorInfo(a.shape,"int32",i)}const zj={kernelName:gI,backendName:"cpu",kernelFunc:Bj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wj=Fr(uf,s=>Math.tan(s)),Vj={kernelName:uf,backendName:"cpu",kernelFunc:Wj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uj=Fr(cf,s=>Math.tanh(s)),jj={kernelName:cf,backendName:"cpu",kernelFunc:Uj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gj(s){const{inputs:e,backend:t}=s,{tensor:n,indices:r,updates:a}=e,{sliceRank:o,numUpdates:i,sliceSize:u,strides:c,outputSize:d}=Ed(a,r,n.shape),h=!1,l=t.bufferSync(r),p=t.bufferSync(a),f=t.bufferSync(n),x=od(l,p,n.shape,d,u,i,o,c,f,h);return t.makeTensorInfo(n.shape,x.dtype,x.values)}const Hj={kernelName:iI,backendName:"cpu",kernelFunc:Gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{reps:a}=n;ls(r,"tile");const o=wT(t.bufferSync(r),a);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const Kj={kernelName:lf,backendName:"cpu",kernelFunc:qj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xj(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{k:a,sorted:o}=n;ls(r,"topk");const i=t.data.get(r.dataId).values,[u,c]=kT(i,r.shape,r.dtype,a,o);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Yj={kernelName:zy,backendName:"cpu",kernelFunc:Xj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zj(s){const{inputs:e,attrs:t,backend:n}=s,{image:r,transforms:a}=e,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=t,[d,h,l,p]=r.shape,[f,x]=c!=null?c:[h,l],b=[d,f,x,p],m=ws(r.shape),I=m[0],N=m[1],E=m[2],D=ws(b),U=D[0],L=D[1],Y=D[2],V=ko(r.dtype,hn(b));V.fill(u);const P=n.data.get(r.dataId).values,oe=n.data.get(a.dataId).values;for(let ge=0;ge<d;++ge){const ye=a.shape[0]===1?oe:oe.subarray(ge*8,ge*8+8);for(let Ee=0;Ee<f;++Ee)for(let X=0;X<x;++X)for(let je=0;je<p;++je){let Be;const tt=ye[6]*X+ye[7]*Ee+1;if(tt===0)continue;const ct=(ye[0]*X+ye[1]*Ee+ye[2])/tt,Me=(ye[3]*X+ye[4]*Ee+ye[5])/tt,wt=n2(ct,l,i),at=n2(Me,h,i);switch(o){case"nearest":Be=sG(P,h,l,I,N,E,ge,at,wt,je,u);break;case"bilinear":Be=rG(P,h,l,I,N,E,ge,at,wt,je,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const Gt=ge*U+Ee*L+X*Y+je;V[Gt]=Be}return n.makeTensorInfo(b,r.dtype,V)}return{dataId:n.write(V,b,r.dtype),shape:r.shape,dtype:r.dtype}}const Qj={kernelName:Wy,backendName:"cpu",kernelFunc:Zj};function n2(s,e,t){switch(t){case"reflect":return Jj(s,e);case"wrap":return eG(s,e);case"nearest":return nG(s,e);case"constant":default:return tG(s)}}function Jj(s,e){let t=s;if(t<0)if(e<=1)t=0;else{const n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{const n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return ld(0,t,e-1)}function eG(s,e){let t=s;if(t<0)if(e<=1)t=0;else{const n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{const n=e-1;t-=e*Math.trunc(t/n)}return ld(0,t,e-1)}function tG(s,e){return s}function nG(s,e){return ld(0,s,e-1)}function Qh(s,e,t,n,r,a,o,i,u,c,d){const h=o*n+i*r+u*a+c;return 0<=i&&i<e&&0<=u&&u<t?s[h]:d}function sG(s,e,t,n,r,a,o,i,u,c,d){const h=Math.round(i),l=Math.round(u);return Qh(s,e,t,n,r,a,o,h,l,c,d)}function rG(s,e,t,n,r,a,o,i,u,c,d){const h=Math.floor(i),l=Math.floor(u),p=h+1,f=l+1,x=(f-u)*Qh(s,e,t,n,r,a,o,h,l,c,d)+(u-l)*Qh(s,e,t,n,r,a,o,h,f,c,d),b=(f-u)*Qh(s,e,t,n,r,a,o,p,l,c,d)+(u-l)*Qh(s,e,t,n,r,a,o,p,f,c,d);return(p-i)*x+(i-h)*b}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(s){const{inputs:e,attrs:t,backend:n}=s,{axis:r}=t,{x:a}=e;ls(a,"unique");const o=n.data.get(a.dataId).values,{outputValues:i,outputShape:u,indices:c}=IT(o,r,a.shape,a.dtype);return[n.makeTensorInfo(u,a.dtype,i),n.makeTensorInfo([c.length],"int32",c)]}const oG={kernelName:Vy,backendName:"cpu",kernelFunc:aG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iG(s){const{inputs:e,backend:t,attrs:n}=s,{value:r}=e;let{axis:a}=n;a<0&&(a+=r.shape.length);const o=r.shape.length,i=r.shape[a],u=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==a&&(u[c++]=r.shape[p]);const d=new Array(o).fill(0),h=r.shape.slice();h[a]=1;const l=new Array(i);for(let p=0;p<l.length;p++){d[a]=p;const f=kd({inputs:{x:r},backend:t,attrs:{begin:d,size:h}});l[p]=qr({inputs:{x:f},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(f)}return l}const uG={kernelName:eb,backendName:"cpu",kernelFunc:iG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cG(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,segmentIds:a}=e,{numSegments:o}=n;ls(r,"unsortedSegmentSum");const i=r.shape.length,u=a.shape.length,c=[],d=[],h=i-u;let l=a;for(let f=0;f<h;++f){const x=Ym({inputs:{input:l},backend:t,attrs:{dim:f+1}});l=x,d.push(x)}for(let f=0;f<o;++f){const x=_l(f,"int32"),b=t.makeTensorInfo([],"int32",x),m=L$({inputs:{a:b,b:l},backend:t}),I=Il({inputs:{x:m},backend:t,attrs:{dtype:"float32"}}),N=$b({inputs:{a:I,b:r},backend:t}),E=Tf({inputs:{x:N},backend:t,attrs:{axis:0,keepDims:!1}});c.push(E),d.push(b),d.push(m),d.push(I),d.push(N),d.push(E)}const p=LT({inputs:c,backend:t,attrs:{axis:0}});return d.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const lG={kernelName:tb,backendName:"cpu",kernelFunc:cG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG=[iz,WB,cz,dz,qB,pz,mz,bz,yz,vz,Iz,_z,$z,Ez,Az,Dz,Pz,Bz,Wz,az,Uz,Gz,qz,XB,Xz,GB,ZB,Zz,VB,Jz,tW,nW,rW,oW,uW,lW,hW,fW,gW,xW,wW,kW,CW,SW,$W,NW,RW,OW,FW,DW,MW,BW,Q4,WW,QB,XW,JB,YW,t4,nV,sV,aV,s4,a4,iV,cV,dV,pV,i4,c4,UB,mV,eW,bV,yV,vV,J4,d4,p4,IV,m4,_V,TV,EV,OV,DV,PV,LV,b4,zV,VV,jV,HV,KV,YV,QV,y4,eU,sU,oU,v4,I4,cU,hU,mU,_4,bU,yU,wU,BT,CU,tz,T4,SU,TU,EU,AU,jB,U0,FU,nz,sz,rz,MU,LU,zU,VU,jU,GU,qU,M4,XU,ej,nj,oj,L4,uj,lj,hj,B4,rU,mj,bj,yj,vj,Ij,_j,$j,Nj,V4,Ej,j4,H4,Aj,Fj,Mj,Lj,zj,Y4,PW,Vj,jj,Hj,Kj,Yj,Qj,S4,oG,uG,lG,xU];for(const s of dG)xI(s);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sd={},lm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function hG(s,e){sd[s]=e}function Gu(s,e){if(!(s in sd)||e!=null){const n=fG(s,e);if(n!==null)sd[s]=n;else return console.log("Could not get context for WebGL version",s),null}const t=sd[s];return t==null||t.isContextLost()?(delete sd[s],Gu(s)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),sd[s])}function pG(s){if(!nn().getBool("IS_SAFARI")&&typeof OffscreenCanvas!="undefined"&&s===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function fG(s,e){if(s!==1&&s!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?pG(s):e;return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete sd[s]},!1),nn().getBool("SOFTWARE_WEBGL_ENABLED")&&(lm.failIfMajorPerformanceCaveat=!1),s===1?t.getContext("webgl",lm)||t.getContext("experimental-webgl",lm):t.getContext("webgl2",lm)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var lp;(function(s){s[s.DENSE=0]="DENSE",s[s.SHARED_BATCH=1]="SHARED_BATCH"})(lp||(lp={}));var qi;(function(s){s[s.RENDER=0]="RENDER",s[s.UPLOAD=1]="UPLOAD",s[s.PIXELS=2]="PIXELS",s[s.DOWNLOAD=3]="DOWNLOAD"})(qi||(qi={}));var uo;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(uo||(uo={}));function Nf(s,e){return[e,s]}function mG(s,e){return s*e}function dm(s){const e=hn(s),t=Math.ceil(e/4);return c0(t)}function _h(s,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(s/2))]}function gG(s,e){const[t,n]=_h(s,e);return t*n*4}function $v(s,e){const t=s;let n,r,a,o,i,u,c,d,h,l;return nn().getNumber("WEBGL_VERSION")===2?(n=t.R32F,r=t.R16F,a=t.RGBA16F,o=t.RGBA32F,i=t.RED,c=4,d=1,h=t.HALF_FLOAT,l=t.FLOAT,u=t.RGBA8):(n=s.RGBA,r=s.RGBA,a=s.RGBA,o=t.RGBA,i=s.RGBA,c=4,d=4,h=e!=null?e.HALF_FLOAT_OES:null,l=s.FLOAT,u=s.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:l}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rs(s,e){const t=e();return nn().getBool("DEBUG")&&bG(s),t}function bG(s){const e=s.getError();if(e!==s.NO_ERROR)throw new Error("WebGL Error: "+vG(s,e))}const xG=596e-10,yG=65504;function wG(s){return!!(nn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||s===0||xG<Math.abs(s)&&Math.abs(s)<yG)}function vG(s,e){switch(e){case s.NO_ERROR:return"NO_ERROR";case s.INVALID_ENUM:return"INVALID_ENUM";case s.INVALID_VALUE:return"INVALID_VALUE";case s.INVALID_OPERATION:return"INVALID_OPERATION";case s.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case s.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case s.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function hm(s,e){return qc(s,()=>s.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function kG(s,e){const t=qc(s,()=>s.createShader(s.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(rs(s,()=>s.shaderSource(t,e)),rs(s,()=>s.compileShader(t)),s.getShaderParameter(t,s.COMPILE_STATUS)===!1)throw console.log(s.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function IG(s,e){const t=qc(s,()=>s.createShader(s.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(rs(s,()=>s.shaderSource(t,e)),rs(s,()=>s.compileShader(t)),nn().get("ENGINE_COMPILE_ONLY"))return t;if(s.getShaderParameter(t,s.COMPILE_STATUS)===!1)throw zT(e,s.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const CG=/ERROR: [0-9]+:([0-9]+):/g;function zT(s,e){const t=CG.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(s);return}const n=+t[1],r=s.split(`
`),a=r.length.toString().length+2,o=r.map((h,l)=>Xd((l+1).toString(),a)+h);let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const u=o.slice(0,n-1),c=o.slice(n-1,n),d=o.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Xd(c[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join(`
`))}function _G(s){return qc(s,()=>s.createProgram(),"Unable to create WebGLProgram.")}function SG(s,e){if(rs(s,()=>s.linkProgram(e)),!nn().get("ENGINE_COMPILE_ONLY")&&s.getProgramParameter(e,s.LINK_STATUS)===!1)throw console.log(s.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Q1(s,e){if(rs(s,()=>s.validateProgram(e)),s.getProgramParameter(e,s.VALIDATE_STATUS)===!1)throw console.log(s.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function $G(s,e){const t=qc(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return rs(s,()=>s.bindBuffer(s.ARRAY_BUFFER,t)),rs(s,()=>s.bufferData(s.ARRAY_BUFFER,e,s.STATIC_DRAW)),t}function TG(s,e){const t=qc(s,()=>s.createBuffer(),"Unable to create WebGLBuffer");return rs(s,()=>s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t)),rs(s,()=>s.bufferData(s.ELEMENT_ARRAY_BUFFER,e,s.STATIC_DRAW)),t}function NG(s){return qc(s,()=>s.createTexture(),"Unable to create WebGLTexture.")}function EG(s,e){const t=nn().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(s<=0||e<=0){const n=`[${s}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(s>t||e>t){const n=`[${s}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+r+".")}}function RG(s){return qc(s,()=>s.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function s2(s,e,t,n,r,a,o){const i=s.getAttribLocation(e,t);return i===-1?!1:(rs(s,()=>s.bindBuffer(s.ARRAY_BUFFER,n)),rs(s,()=>s.vertexAttribPointer(i,r,s.FLOAT,!1,a,o)),rs(s,()=>s.enableVertexAttribArray(i)),!0)}function AG(s,e,t){PG(s,t),rs(s,()=>s.activeTexture(s.TEXTURE0+t)),rs(s,()=>s.bindTexture(s.TEXTURE_2D,e))}function OG(s,e,t){return qc(s,()=>s.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function FG(s,e,t){return s.getUniformLocation(e,t)}function DG(s,e,t,n){rs(s,()=>AG(s,e,n)),rs(s,()=>s.uniform1i(t,n))}function J1(s,e,t){rs(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,t)),rs(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0))}function r2(s,e){rs(s,()=>s.bindFramebuffer(s.FRAMEBUFFER,e)),rs(s,()=>s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,null,0))}function pm(s){const e=s.checkFramebufferStatus(s.FRAMEBUFFER);if(e!==s.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+MG(s,e))}function MG(s,e){switch(e){case s.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case s.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case s.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function qc(s,e,t){const n=rs(s,()=>e());if(n==null)throw new Error(t);return n}function PG(s,e){const t=s.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+s.TEXTURE0;if(n<s.TEXTURE0||n>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function ph(s,e=2){return hn(s.slice(0,s.length-e))}function fh(s){if(s.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[s.length>1?s[s.length-2]:1,s[s.length-1]]}function fm(s){let e=[1,1,1];return s.length===0||s.length===1&&s[0]===1||(e=[ph(s),...fh(s)]),e}function LG(s,e=!1){let t=nn().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=nn().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&nn().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=t/2),e&&(t=t*2,n=n*2,s=s.map((i,u)=>u>=s.length-2?ey(s[u]):s[u]),s.length===1&&(s=[2,s[0]])),s.length!==2&&(s=Cl(s).newShape);let r=hn(s),a=null;s.length<=1&&r<=t?a=[1,r]:s.length===2&&s[0]<=t&&s[1]<=t?a=s:s.length===3&&s[0]*s[1]<=t&&s[2]<=t?a=[s[0]*s[1],s[2]]:s.length===3&&s[0]<=t&&s[1]*s[2]<=t?a=[s[0],s[1]*s[2]]:s.length===4&&s[0]*s[1]*s[2]<=t&&s[3]<=t?a=[s[0]*s[1]*s[2],s[3]]:s.length===4&&s[0]<=t&&s[1]*s[2]*s[3]<=t&&(a=[s[0],s[1]*s[2]*s[3]]);const o=a!=null&&Math.max(...a)>n&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||o)if(e){const i=ph(s);let u=2,c=2;s.length&&([u,c]=fh(s)),r=i*(u/2)*(c/2),a=c0(r).map(d=>d*2)}else a=c0(r);return a}function mm(s){return s%2===0}function Qm(s,e){if(s=s.slice(-2),e=e.slice(-2),Er(s,e)||!s.length||!e.length||s[0]===0||s[1]===0||e[0]===0||e[1]===0)return!0;if(s.length!==e.length){const t=s[s.length-1],n=e[e.length-1];if(t===n||mm(t)&&mm(n)&&(s[0]===1||e[0]===1))return!0}return s[1]===e[1]&&mm(s[0])&&mm(e[0])}let e0,t0;function BG(s){if(e0==null){const e=Gu(s);e0=e.getParameter(e.MAX_TEXTURE_SIZE)}return e0}function zG(s){if(t0==null){const e=Gu(s);t0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,t0)}function WG(s){if(s===0)return 0;let e;const t=Gu(s);return vu(t,"EXT_disjoint_timer_query_webgl2")&&s===2?e=2:vu(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function vu(s,e){return s.getExtension(e)!=null}function a2(s){try{if(Gu(s)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function VG(s){if(s===0)return!1;const e=Gu(s);if(s===1){if(!vu(e,"OES_texture_float"))return!1}else if(!vu(e,"EXT_color_buffer_float"))return!1;return G0(e)}function UG(s){if(s===0)return!1;const e=Gu(s);if(s===1){if(!vu(e,"OES_texture_float")||!vu(e,"WEBGL_color_buffer_float"))return!1}else{if(vu(e,"EXT_color_buffer_float"))return G0(e);const n="EXT_color_buffer_half_float";if(vu(e,n)){const r=e.getExtension(n);return jG(e,r)}return!1}return G0(e)}function G0(s){const e=$v(s),t=s.createTexture();s.bindTexture(s.TEXTURE_2D,t);const n=1,r=1;s.texImage2D(s.TEXTURE_2D,0,e.internalFormatFloat,n,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,a),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t,0);const o=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(t),s.deleteFramebuffer(a),o}function jG(s,e){const t=$v(s,e),n=s.createTexture();s.bindTexture(s.TEXTURE_2D,n);const r=1,a=1;s.texImage2D(s.TEXTURE_2D,0,t.internalFormatHalfFloat,r,a,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,o),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,n,0);const i=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(n),s.deleteFramebuffer(o),i}function GG(s){return s!==2?!1:Gu(s).fenceSync!=null}function Ef(s,e){Array.isArray(s)||(s=[s]),s.forEach(t=>{t!=null&&ze(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ms=nn();ms.registerFlag("HAS_WEBGL",()=>ms.getNumber("WEBGL_VERSION")>0);ms.registerFlag("WEBGL_VERSION",()=>a2(2)?2:a2(1)?1:0);ms.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ms.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ms.get("WEBGL_VERSION")===2);ms.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ms.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ms.registerFlag("WEBGL_PACK",()=>ms.getBool("HAS_WEBGL"));ms.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_CLIP",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_PACK_REDUCE",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_LAZILY_UNPACK",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_CONV_IM2COL",()=>ms.getBool("WEBGL_PACK"));ms.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>BG(ms.getNumber("WEBGL_VERSION")));ms.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>zG(ms.getNumber("WEBGL_VERSION")));ms.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const s=ms.getNumber("WEBGL_VERSION");return s===0?0:WG(s)});ms.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ms.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!OI());ms.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>VG(ms.getNumber("WEBGL_VERSION")));ms.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ms.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ms.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ms.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>UG(ms.getNumber("WEBGL_VERSION")));ms.registerFlag("WEBGL_FENCE_API_ENABLED",()=>GG(ms.getNumber("WEBGL_VERSION")));ms.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ms.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ms.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${s}.`)});ms.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>OI()?1:-1,s=>{if(s<0&&s!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${s}.`)});ms.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ms.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ms.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ms.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ms.registerFlag("WEBGL_EXP_CONV",()=>!1);ms.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ms.getBool("IS_TEST"));ms.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ms.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ms.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ms.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(){let s,e,t,n,r,a,o,i,u,c;return nn().getNumber("WEBGL_VERSION")===2?(s="#version 300 es",e="in",t="out",n="in",r="texture",a="outputColor",o="out vec4 outputColor;",i=nn().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(s="",e="attribute",t="varying",n="varying",r="texture2D",a="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:s,attribute:e,varyingVs:t,varyingFs:n,texture2D:r,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Od(s,e,t="index"){const n=ws(e);return n.map((r,a)=>{const o=`int ${s[a]} = ${t} / ${r}`,i=a===n.length-1?`int ${s[a+1]} = ${t} - ${s[a]} * ${r}`:`index -= ${s[a]} * ${r}`;return`${o}; ${i};`}).join("")}function Tb(s,e,t="index"){const n=ws(e);return n.map((r,a)=>{const o=`int ${s[a]} = ${t} / outShapeStrides[${a}]`,i=a===n.length-1?`int ${s[a+1]} = ${t} - ${s[a]} * outShapeStrides[${a}]`:`index -= ${s[a]} * outShapeStrides[${a}]`;return`${o}; ${i};`}).join("")}function HG(s,e){const t=s.length,n=s.map(a=>`${e}[${a}]`),r=new Array(t-1);r[t-2]=n[t-1];for(let a=t-3;a>=0;--a)r[a]=`(${r[a+1]} * ${n[a+1]})`;return r}function qG(s,e,t="index"){const n=s.map((a,o)=>o),r=HG(n,e);return r.map((a,o)=>{const i=`int ${s[o]} = ${t} / ${r[o]}`,u=o===r.length-1?`int ${s[o+1]} = ${t} - ${s[o]} * ${r[o]}`:`index -= ${s[o]} * ${r[o]}`;return`${i}; ${u};`}).join("")}function Tv(s){const e=ws(s).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Nv(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const WT=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:VT}=VD;function KG(s,e,t){const n=[];if(s.forEach(p=>{const f=hn(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?n.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${p.name};`),n.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:x}=Ev(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(x.length){case 1:n.push(`uniform int ${p.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${p.name}Shape;`);break}n.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{n.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=n.join(`
`),a=s.map(p=>XG(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,i=zo(),u=QG(i);let c,d,h=t6(i);return e.isPacked?(c=YG(e.logicalShape,o,t.enableShapeUniforms),d=e6(i)):(c=ZG(e.logicalShape,o,t.enableShapeUniforms),d=JG(i)),t.packedInputs&&(h+=a6),[h,u,d,r,c,a,t.userCode].join(`
`)}function Sh(s,e=!1){const t=s.shapeInfo.logicalShape;switch(t.length){case 0:return b6(s,e);case 1:return y6(s,e);case 2:return v6(s,e);case 3:return I6(s,e);case 4:return _6(s,e);case 5:return S6(s);case 6:return $6(s);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function UT(s,e){switch(s.shapeInfo.logicalShape.length){case 0:return g6(s);case 1:return x6(s,e);case 2:return w6(s,e);case 3:return k6(s,e);default:return C6(s,e)}}function XG(s,e,t=!1,n){let r="";t?r+=UT(s,n):r+=Sh(s,n);const a=s.shapeInfo.logicalShape,o=e.logicalShape;return a.length<=o.length&&(t?r+=T6(s,e):r+=N6(s,e)),r}function YG(s,e,t){switch(s.length){case 0:return jT();case 1:return o6(s,e,t);case 2:return f6(s,e,t);case 3:return u6(s,e,t);default:return l6(s,e,t)}}function ZG(s,e,t){switch(s.length){case 0:return jT();case 1:return i6(s,e,t);case 2:return m6(s,e,t);case 3:return c6(s,e,t);case 4:return d6(s,e,t);case 5:return h6(s,e);case 6:return p6(s,e);default:throw new Error(`${s.length}-D output sampling is not yet supported`)}}function QG(s){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${s.texture2D}(textureSampler, uv).r;
    }
  `}function JG(s){return`
    void setOutput(float val) {
      ${s.output} = vec4(val, 0, 0, 0);
    }
  `}function e6(s){return`
    void setOutput(vec4 val) {
      ${s.output} = val;
    }
  `}function t6(s){return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFs} vec2 resultUV;
    ${s.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${s.defineSpecialNaN}
    ${s.defineSpecialInf}
    ${s.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${n6}
    ${s6}
    ${r6}
  `}const n6=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,s6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,r6=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,a6=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function jT(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function o6(s,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function i6(s,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function u6(s,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(s[2]/2),a=r*Math.ceil(s[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function c6(s,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Tb(["r","c","d"],s)}
    return ivec3(r, c, d);
  }
`;const n=Od(["r","c","d"],s);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function l6(s,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(s[s.length-1]/2),a=r*Math.ceil(s[s.length-2]/2);let o=a,i="",u="b, r, c";for(let c=2;c<s.length-1;c++)o*=s[s.length-c-1],i=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+i,u=`b${c}, `+u;return`
    ivec${s.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${i}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${s.length}(${u});
    }
  `}function d6(s,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Tb(["r","c","d","d2"],s)}
      return ivec4(r, c, d, d2);
    }
  `;const n=Od(["r","c","d","d2"],s);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function h6(s,e){const t=Od(["r","c","d","d2","d3"],s);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function p6(s,e){const t=Od(["r","c","d","d2","d3","d4"],s);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function f6(s,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Er(s,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;const r=Math.ceil(s[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function m6(s,e,t){return Er(s,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:s[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:s[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${s[1]};
      int c = index - r * ${s[1]};
      return ivec2(r, c);
    }
  `}function Fd(s){return`offset${s}`}function g6(s){const e=s.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=zo();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function b6(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(s.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,a]=s.shapeInfo.texShape;if(r===1&&a===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Fd(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[i,u]=s.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function x6(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=s.shapeInfo.texShape,a=zo();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `}function y6(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(s.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${$h(s)}
      }
    `;const r=s.shapeInfo.texShape,a=r[0],o=r[1];if(o===1&&a===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Fd(t);return o===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    `:a===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function w6(s,e){const t=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=s.shapeInfo.texShape,o=a[0],i=a[1],u=zo();if(a!=null&&Er(t,a))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],d=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function v6(s,e){const t=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=s.shapeInfo.texShape;if(a!=null&&Er(t,a)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;const l=a[0],p=a[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `}const{newShape:o,keptDims:i}=Cl(t),u=o;if(u.length<t.length){const l=Th(s,u),p=["row","col"];return`
      ${Sh(l,e)}
      float ${r}(int row, int col) {
        return ${r}(${Nh(p,i)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${$h(s)}
      }
    `;const c=a[0],d=a[1],h=Fd(n);return d===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${d}, index);
    return sampleTexture(${n}, uv);
  }
`}function k6(s,e){const t=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=s.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(t[0]===1){const l=t.slice(1),p=[1,2],f=Th(s,l),x=["b","row","col"];return`
        ${UT(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${Nh(x,p)});
        }
      `}const i=zo();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `;const u=o[0],c=o[1],d=Math.ceil(t[2]/2),h=d*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${h}, ${d}, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `}function I6(s,e){const t=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[1]*t[2],o=t[2],{newShape:i,keptDims:u}=Cl(t),c=i;if(c.length<t.length){const x=Th(s,c),b=["row","col","depth"];return`
        ${Sh(x,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${Nh(b,u)});
        }
      `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${$h(s)}
      }
    `;const d=s.shapeInfo.texShape,h=d[0],l=d[1],p=s.shapeInfo.flatOffset;if(l===a&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${l}.0, ${h}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(l===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}.0, ${h}.0);
      return sampleTexture(${n}, uv);
    }
  `;const f=Fd(n);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${l}, index);
        return sampleTexture(${n}, uv);
      }
  `}function C6(s,e){const t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=zo();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const a=s.shapeInfo.logicalShape,o=a.length,i=s.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=u[0],d=u[1],h=Math.ceil(a[o-1]/2);let l=h*Math.ceil(a[o-2]/2),p="int b, int row, int col",f=`b * ${l} + (row / 2) * ${h} + (col / 2)`;for(let x=2;x<o-1;x++)p=`int b${x}, `+p,l*=a[o-x-1],f=`b${x} * ${l} + `+f;return`
    vec4 ${n}(${p}) {
      int index = ${f};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function _6(s,e){const t=s.shapeInfo.logicalShape,n=s.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[3],o=t[2]*a,i=t[1]*o,{newShape:u,keptDims:c}=Cl(t);if(u.length<t.length){const I=Th(s,u),N=["row","col","depth","depth2"];return`
      ${Sh(I,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${Nh(N,c)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${a}, 1)));
        ${$h(s)}
      }
    `;const d=s.shapeInfo.flatOffset,h=s.shapeInfo.texShape,l=h[0],p=h[1],f=`int stride2 = ${n}Shape[3];`,x=`int stride1 = ${n}Shape[2] * stride2;`,b=`int stride0 = ${n}Shape[1] * stride1;`;if(p===i&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${l}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===a&&d==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${l}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Fd(n);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${x}
      ${b}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${m});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${l}, ${p}, index + ${m});
      return sampleTexture(${n}, uv);
    }
  `}function S6(s){const e=s.shapeInfo.logicalShape,t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],a=e[3]*r,o=e[2]*a,i=e[1]*o,{newShape:u,keptDims:c}=Cl(e);if(u.length<e.length){const x=Th(s,u),b=["row","col","depth","depth2","depth3"];return`
      ${Sh(x)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Nh(b,c)});
      }
    `}if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${a}, ${r})) +
          depth3;
        ${$h(s)}
      }
    `;const d=s.shapeInfo.flatOffset,h=s.shapeInfo.texShape,l=h[0],p=h[1];if(p===i&&d==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${l}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&d==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${l}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Fd(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${a} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${l}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function $6(s){const e=s.shapeInfo.logicalShape,t=s.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:a}=Cl(e);if(r.length<e.length){const b=Th(s,r),m=["row","col","depth","depth2","depth3","depth4"];return`
      ${Sh(b)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Nh(m,a)});
      }
    `}const o=e[5],i=e[4]*o,u=e[3]*i,c=e[2]*u,d=e[1]*c;if(s.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d}, ${c}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${$h(s)}
      }
    `;const h=s.shapeInfo.flatOffset,l=s.shapeInfo.texShape,p=l[0],f=l[1];if(f===d&&h==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${u}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&h==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const x=Fd(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} + depth * ${u} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function $h(s){const e=s.name,t=hn(s.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function T6(s,e){const t=s.name,n=t.charAt(0).toUpperCase()+t.slice(1),r="get"+n+"AtOutCoords",a=s.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=VT(s.shapeInfo.logicalShape,e.logicalShape),u=Mr(o),c=o-a;let d;const h=["x","y","z","w","u","v"];a===0?d="":o<2&&i.length>=1?d="coords = 0;":d=i.map(I=>`coords.${h[I+c]} = 0;`).join(`
`);let l="";o<2&&a>0?l="coords":l=s.shapeInfo.logicalShape.map((I,N)=>`coords.${h[N+c]}`).join(", ");let p="return outputValue;";const x=hn(s.shapeInfo.logicalShape)===1,m=hn(e.logicalShape)===1;if(a===1&&!x&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!m)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(i.length){const I=a-2,N=a-1;i.indexOf(I)>-1&&i.indexOf(N)>-1?p="return vec4(outputValue.x);":i.indexOf(I)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(N)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${d}
      vec4 outputValue = get${n}(${l});
      ${p}
    }
  `}function N6(s,e){const t=s.name,n=t.charAt(0).toUpperCase()+t.slice(1),r="get"+n+"AtOutCoords",a=e.texShape,o=s.shapeInfo.texShape,i=s.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!s.shapeInfo.isUniform&&i===u&&s.shapeInfo.flatOffset==null&&Er(o,a))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Mr(u),d=VT(s.shapeInfo.logicalShape,e.logicalShape),h=u-i;let l;const p=["x","y","z","w","u","v"];i===0?l="":u<2&&d.length>=1?l="coords = 0;":l=d.map(x=>`coords.${p[x+h]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=s.shapeInfo.logicalShape.map((x,b)=>`coords.${p[b+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${l}
      return get${n}(${f});
    }
  `}function Mr(s){if(s<=1)return"int";if(s===2)return"ivec2";if(s===3)return"ivec3";if(s===4)return"ivec4";if(s===5)return"ivec5";if(s===6)return"ivec6";throw Error(`GPU for rank ${s} is not yet supported`)}function Ev(s,e,t){const{newShape:n,keptDims:r}=Cl(e),a=e.length,o=s&&a===3&&e[0]===1,i=o?e.slice(1):n,u=!s&&a>1&&!Er(e,t)&&n.length<a||o;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:r}}function Th(s,e){const t=JSON.parse(JSON.stringify(s));return t.shapeInfo.logicalShape=e,t}function Nh(s,e){return e.map(t=>s[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6(s,e,t,n){const r=t.map((d,h)=>{const l={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:d.isUniform?!1:d.texData.isPacked,flatOffset:null};return d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0&&(l.flatOffset=d.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:l}}),a=r.map(d=>d.shapeInfo),o={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},i=KG(r,o,e),u=IG(s.gl,i),c=s.createProgram(u);return nn().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(s.buildVao(c),Object.assign({program:e,fragmentShader:u,source:i,webGLProgram:c,inShapeInfos:a,outShapeInfo:o},GT(s,e,c)))}function GT(s,e,t){const n=[],r=[];let a,o,i,u=null,c=null;c=s.getUniformLocation(t,"NAN",!1),nn().getNumber("WEBGL_VERSION")===1&&(u=s.getUniformLocation(t,"INFINITY",!1));const d=!1;for(const h of e.variableNames){const l={name:h,uniform:s.getUniformLocation(t,h,d),offset:s.getUniformLocation(t,`offset${h}`,d)};e.enableShapeUniforms&&(l.shape=s.getUniformLocation(t,`${h}Shape`,d),l.texShape=s.getUniformLocation(t,`${h}TexShape`,d)),n.push(l)}if(e.enableShapeUniforms&&(a=s.getUniformLocation(t,"outShape",d),i=s.getUniformLocation(t,"outShapeStrides",d),o=s.getUniformLocation(t,"outTexShape",d)),e.customUniforms)for(const h of e.customUniforms)r.push(s.getUniformLocation(t,h.name,d));return{variablesLocations:n,customUniformLocations:r,infLoc:u,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}}function o2(s,e){if(s.length!==e.length)throw Error(`Binary was compiled with ${s.length} inputs, but was executed with ${e.length} inputs`);s.forEach((t,n)=>{const r=t.logicalShape,a=e[n],o=a.shape;if(!Er(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&a.isUniform)return;const i=t.texShape,u=a.isUniform?null:a.texData.texShape;if(!Er(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function R6(s,e,t,n,r){e.program.enableShapeUniforms||(o2(e.inShapeInfos,t),o2([e.outShapeInfo],[n]));const a=n.texData.texture,o=n.texData.texShape;n.texData.isPacked?s.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):s.setOutputMatrixTexture(a.texture,o[0],o[1]),s.setProgram(e.webGLProgram),s.bindVertexArray(e.webGLProgram.vao),nn().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&s.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&s.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<t.length;++u){const c=t[u],{uniform:d,offset:h,shape:l,texShape:p}=e.variablesLocations[u];if(l){const{uniformShape:f}=Ev(e.program.packedInputs,c.shape,c.texData.texShape);switch(f.length){case 1:s.gl.uniform1iv(l,new Int32Array(f));break;case 2:s.gl.uniform2iv(l,new Int32Array(f));break;case 3:s.gl.uniform3iv(l,new Int32Array(f));break;case 4:s.gl.uniform4iv(l,new Int32Array(f));break}}if(p&&s.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(hn(c.shape)<2)s.gl.uniform1f(d,c.uniformValues[0]);else{let f=c.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),s.gl.uniform1fv(d,f)}continue}c.texData.slice!=null&&h!=null&&s.gl.uniform1i(h,c.texData.slice.flatOffset),s.setInputMatrixTexture(c.texData.texture.texture,d,u)}}const i=e.outShapeLocation;if(i)switch(n.shape.length){case 1:s.gl.uniform1iv(i,new Int32Array(n.shape));break;case 2:s.gl.uniform2iv(i,new Int32Array(n.shape));break;case 3:s.gl.uniform3iv(i,new Int32Array(n.shape));break;case 4:s.gl.uniform4iv(i,new Int32Array(n.shape));break}if(e.outShapeStridesLocation){const u=ws(n.shape);switch(n.shape.length){case 2:s.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:s.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:s.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&s.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const c=e.program.customUniforms[u],d=e.customUniformLocations[u],h=r[u];if(c.type==="float")s.gl.uniform1fv(d,h);else if(c.type==="vec2")s.gl.uniform2fv(d,h);else if(c.type==="vec3")s.gl.uniform3fv(d,h);else if(c.type==="vec4")s.gl.uniform4fv(d,h);else if(c.type==="int")s.gl.uniform1iv(d,h);else if(c.type==="ivec2")s.gl.uniform2iv(d,h);else if(c.type==="ivec3")s.gl.uniform3iv(d,h);else if(c.type==="ivec4")s.gl.uniform4iv(d,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}s.executeProgram()}function A6(s,e,t){let n="";e.concat(t).forEach(o=>{const i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(s.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:h}=Ev(s.packedInputs,o.shape,u);let l="",p="",f="";if(d.length===1&&s.packedInputs){const D=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];l=`${D[0]>1}_${D[1]>1}`}else if(d.length===2&&!s.packedInputs)p=`${d[0]>1}_${d[1]>1}`;else if(d.length>2&&!s.packedInputs){const D=ws(d);f=`${D[0]===u[1]}_${D[D.length-1]===u[1]}`}const x=o.shape.length,b=d.length===2&&Er(o.shape,u),m=hn(o.shape)===1,I=oh(o.shape,t.shape),N=!s.packedInputs&&x===t.shape.length&&Er(u,t.texData.texShape),E=s.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${x}_${N}_${c?h:""}_${d.length}_${m}_${I}_${b}_${l}_${p}_${f}_${E}_${i}`}else{const u=o.isUniform?"uniform":o.texData.texShape;n+=`${o.shape}_${u}_${i}`}});const r=s.userCode;let a=s.constructor.name;return a+="_"+n+"_"+r+`${nn().getNumber("WEBGL_VERSION")}`,a}function _o(s){return nn().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&s<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O6{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=lp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=zo();this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tb(["r","c","d"],e):Od(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=lp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=zo();this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Tb(["r","c","d"],e):Od(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D6{constructor(e){this.variableNames=["A"],this.outTexUsage=qi.DOWNLOAD;const t=zo();this.outputShape=e,this.userCode=`
      ${WT}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M6{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qi.DOWNLOAD;const t=zo();this.outputShape=e,this.userCode=`
      ${WT}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P6={R:0,G:1,B:2,A:3};class i2{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=zo();this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let o="";for(let i=0;i<n.length;i++){const u=n[i];o+=`
          if(offset == ${i}) {
            result = values[${P6[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Nv():Tv(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${o}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L6{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=zo();this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const u=o*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Nv():Tv(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6(s){const e=zo(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return kG(s,t)}function z6(s){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return $G(s,e)}function W6(s){const e=new Uint16Array([0,1,2,2,1,3]);return TG(s,e)}function Rf(s,e,t,n,r,a){EG(e,t);const o=NG(s),i=s.TEXTURE_2D;return rs(s,()=>s.bindTexture(i,o)),rs(s,()=>s.texParameteri(i,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE)),rs(s,()=>s.texParameteri(i,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE)),rs(s,()=>s.texParameteri(i,s.TEXTURE_MIN_FILTER,s.NEAREST)),rs(s,()=>s.texParameteri(i,s.TEXTURE_MAG_FILTER,s.NEAREST)),nn().getNumber("WEBGL_VERSION")===1?rs(s,()=>s.texImage2D(i,0,n,e,t,0,r,a,null)):rs(s,()=>s.texStorage2D(i,1,n,e,t)),rs(s,()=>s.bindTexture(s.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function HT(s){return s.internalFormatFloat}function V6(s,e,t,n){const[r,a]=Nf(e,t);return Rf(s,r,a,HT(n),n.textureFormatFloat,s.FLOAT)}function qT(s){return s.internalFormatHalfFloat}function U6(s,e,t,n){const[r,a]=Nf(e,t);return Rf(s,r,a,qT(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function KT(s){return s.downloadTextureFormat}function j6(s,e,t,n){const[r,a]=Nf(e,t);return Rf(s,r,a,KT(n),s.RGBA,s.UNSIGNED_BYTE)}function XT(s){return s.internalFormatPackedFloat}function G6(s,e,t,n){const[r,a]=_h(e,t);return Rf(s,r,a,XT(n),s.RGBA,s.FLOAT)}function YT(s){return s.internalFormatPackedHalfFloat}function H6(s,e,t,n){const[r,a]=_h(e,t);return Rf(s,r,a,YT(n),s.RGBA,n.textureTypeHalfFloat)}function q6(s,e,t){return rs(s,()=>s.bindBuffer(s.ARRAY_BUFFER,t)),s2(s,e,"clipSpacePos",t,3,20,0)&&s2(s,e,"uv",t,2,20,12)}function K6(s,e,t,n,r,a){rs(s,()=>s.bindTexture(s.TEXTURE_2D,e));let o,i,u;r instanceof Uint8Array?(o=new Uint8Array(t*n*4),i=s.UNSIGNED_BYTE,u=s.RGBA):(o=new Float32Array(t*n*4),i=s.FLOAT,u=a.internalFormatPackedFloat),o.set(r),nn().getNumber("WEBGL_VERSION")===2?rs(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,t,n,s.RGBA,i,o)):rs(s,()=>s.texImage2D(s.TEXTURE_2D,0,u,t,n,0,s.RGBA,i,o)),rs(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function X6(s,e,t){rs(s,()=>s.bindTexture(s.TEXTURE_2D,e)),t.data instanceof Uint8Array?nn().getNumber("WEBGL_VERSION")===2?rs(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,t.width,t.height,s.RGBA,s.UNSIGNED_BYTE,t.data)):rs(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,t.width,t.height,0,s.RGBA,s.UNSIGNED_BYTE,t.data)):nn().getNumber("WEBGL_VERSION")===2?rs(s,()=>s.texSubImage2D(s.TEXTURE_2D,0,0,0,s.RGBA,s.UNSIGNED_BYTE,t)):rs(s,()=>s.texImage2D(s.TEXTURE_2D,0,s.RGBA,s.RGBA,s.UNSIGNED_BYTE,t)),rs(s,()=>s.bindTexture(s.TEXTURE_2D,null))}function Y6(s,e,t,n){const r=s.createBuffer();rs(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,r));const i=4*4*e*t;return rs(s,()=>s.bufferData(s.PIXEL_PACK_BUFFER,i,s.STREAM_READ)),rs(s,()=>s.readPixels(0,0,t,e,s.RGBA,s.FLOAT,0)),rs(s,()=>s.bindBuffer(s.PIXEL_PACK_BUFFER,null)),r}function Z6(s,e,t){const n=s,r=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,r),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),r}function Q6(s,e,t,n){const[r,a]=Nf(e,t),o=4,i=new Uint8Array(mG(e*t,o));return rs(s,()=>s.readPixels(0,0,r,a,n.downloadTextureFormat,s.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function J6(s,e,t,n,r,a,o,i){const u=s,c=new Float32Array(gG(a,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}function eH(s,e,t){const n=new Float32Array(e*t*4);return rs(s,()=>s.readPixels(0,0,t,e,s.RGBA,s.FLOAT,n)),n}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=nn().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,hG(t,e)):this.gl=Gu(t),e=this.gl,nn().getNumber("WEBGL_VERSION")===2){const a=e;this.createVertexArray=()=>rs(a,()=>a.createVertexArray()),this.bindVertexArray=o=>rs(a,()=>a.bindVertexArray(o)),this.deleteVertexArray=o=>rs(a,()=>a.deleteVertexArray(o)),this.getVertexArray=()=>rs(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){const a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>rs(e,()=>a.createVertexArrayOES()),this.bindVertexArray=o=>rs(e,()=>a.bindVertexArrayOES(o)),this.deleteVertexArray=o=>rs(e,()=>a.deleteVertexArrayOES(o)),this.getVertexArray=()=>rs(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),nn().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=hm(this.gl,a),vu(this.gl,o))this.textureHalfFloatExtension=hm(this.gl,o);else if(nn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),vu(this.gl,r))this.colorBufferHalfFloatExtension=hm(this.gl,r);else if(nn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",vu(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(vu(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=z6(this.gl),this.indexBuffer=W6(this.gl),this.framebuffer=RG(this.gl),this.textureConfig=$v(this.gl,this.textureHalfFloatExtension)}get debug(){return nn().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;rs(e,()=>e.finish()),rs(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),rs(e,()=>e.deleteFramebuffer(this.framebuffer)),rs(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),rs(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),rs(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),V6(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),U6(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),j6(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),X6(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),K6(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),H6(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),G6(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(r2(this.gl,this.framebuffer),this.outputTexture=null),rs(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Q6(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,o){return J6(this.gl,e,t,n,r,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Z6(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=Y6(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(nn().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const o=r.clientWaitSync(a,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=a}else nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>eH(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=B6(t));const n=_G(t);rs(t,()=>t.attachShader(n,this.vertexShader)),rs(t,()=>t.attachShader(n,e)),SG(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Q1(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;rs(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),q6(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(rs(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Q1(this.gl,this.program),rs(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?OG(this.gl,e,t):FG(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),rs(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),DG(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=_h(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Q1(this.gl,this.program),pm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}rs(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rs(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=hm(this.gl,nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await jv(()=>this.disposed||this.isQueryAvailable(e,nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{const n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=tH(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in nn().platform&&(n=nn().platform.setTimeoutCustom.bind(nn().platform)),jv(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),J1(this.gl,e,this.framebuffer),this.debug&&pm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(J1(this.gl,this.outputTexture,this.framebuffer),this.debug&&pm(this.gl)):r2(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;J1(r,e,this.framebuffer),this.debug&&pm(r),this.outputTexture=e,rs(r,()=>r.viewport(0,0,t,n)),rs(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),rs(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function tH(s){let e=0;for(;e<s.length&&s[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:nH,bincountImpl:ZT,bincountReduceImpl:sH,castImpl:rH,ceilImpl:aH,concatImpl:oH,equalImpl:iH,expImpl:uH,expm1Impl:cH,floorImpl:lH,gatherNdImpl:dH,gatherV2Impl:hH,greaterImpl:pH,greaterEqualImpl:fH,lessImpl:mH,lessEqualImpl:gH,linSpaceImpl:bH,logImpl:xH,maxImpl:yH,maximumImpl:wH,minimumImpl:vH,multiplyImpl:kH,negImpl:IH,notEqualImpl:CH,prodImpl:_H,raggedGatherImpl:SH,raggedRangeImpl:$H,raggedTensorToTensorImpl:TH,rangeImpl:NH,rsqrtImpl:EH,scatterImpl:RH,sigmoidImpl:AH,simpleAbsImpl:QT,sliceImpl:OH,sparseFillEmptyRowsImpl:FH,sparseReshapeImpl:DH,sparseSegmentReductionImpl:JT,sqrtImpl:MH,staticRegexReplaceImpl:PH,stridedSliceImpl:LH,stringNGramsImpl:BH,stringSplitImpl:zH,stringToHashBucketFastImpl:WH,subImpl:VH,tileImpl:UH,topKImpl:jH,transposeImpl:Rv,uniqueImpl:GH}=Z4;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(s,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${s}.${t}`)}function Mo(s,e){return e===1?[s]:eN(s,e)}function HH(s,e){if(s===1)return"rc";let t="";for(let n=0;n<s;n++)t+=e[n],n<s-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qH{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=_o(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Mo("rc",this.rank),n=Mr(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)a=`${e[e.length-1-o]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${KH(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Nv():Tv(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}}function KH(s,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?qG(["r","c","d"],"inputShape"):Od(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XH{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=c2(t,n),a=l2(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=u2(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[a].pop();return this.usedTextures[a].push(u),u}let i;return r===uo.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===uo.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===uo.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===uo.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===uo.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;const a=c2(n,r),o=l2(t,a,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=u2(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=nn().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const c=this.usedTextures[o],d=c&&c.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function YH(s,e){const t=s;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===s.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function u2(s,e,t,n,r){const a=ZH(e,n);let o;if(r){const[u,c]=_h(s[0],s[1]);o=u*c}else{const[u,c]=Nf(s[0],s[1]);o=u*c}const i=YH(t,a);return o*i}function ZH(s,e){switch(s){case uo.PACKED_2X2_FLOAT32:return XT(e);case uo.PACKED_2X2_FLOAT16:return YT(e);case uo.UNPACKED_FLOAT32:return HT(e);case uo.UNPACKED_FLOAT16:return qT(e);case uo.PACKED_4X1_UNSIGNED_BYTE:return KT(e);default:throw new Error(`Unknown physical texture type ${s}`)}}function QH(s){return nn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?s?uo.PACKED_2X2_FLOAT32:uo.UNPACKED_FLOAT32:s?uo.PACKED_2X2_FLOAT16:uo.UNPACKED_FLOAT16}function c2(s,e){if(s===qi.UPLOAD)return uo.PACKED_2X2_FLOAT32;if(s===qi.RENDER||s==null)return QH(e);if(s===qi.DOWNLOAD||s===qi.PIXELS)return uo.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${s}`)}function l2(s,e,t){return`${s[0]}_${s[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hc{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Su="if (isnan(x)) return x;",JH="return x;",d2="return abs(x);",e5="return (x >= 0.0) ? x : (exp(x) - 1.0);",t5=Su+`
  return (x < 0.0) ? 0.0 : x;
`,n5=Su+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,cl="return x;",s5="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r5="return x;",a5=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,o5=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,i5=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,u5="return 1.0 / (1.0 + exp(-1.0 * x));";class hl{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c5{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length);const t=e.length,n=Mo("rc",t),r=Mr(t),a=HH(t,n),o=n.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l5=SC,d5=1e-7,h5=1e-4,gm={};function p5(s){return s in gm||(gm[s]={}),gm[s]}const f5=nn().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),m5=600;function g5(){return nn().global.screen==null?1024:nn().global.screen.height*nn().global.screen.width*window.devicePixelRatio*m5/1024/1024}class Nb extends J0{nextDataId(){return Nb.nextDataId++}constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!nn().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof n0)t=e;else{const n=Gu(nn().getNumber("WEBGL_VERSION"),e);t=new n0(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const n=Gu(nn().getNumber("WEBGL_VERSION"));t=new n0(n),this.binaryCache=p5(nn().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new XH(this.gpgpu),this.numMBBeforeWarning=g5(),this.texData=new W2(this,oc())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,o){const i=this.makeTensorInfo(t,n),u=this.texData.get(i.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,a]},u.texShape=[r,a];const c=fm(t),d=new i2(c,!1,o),h=this.runWebGLProgram(d,[i],n,[[r,a]]);return h.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(i),h.dataId}write(e,t,n){if((nn().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||nn().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:qi.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(nn().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:qi.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:o,shape:i,isPacked:u}=t;if(o!=null){let l;u?l=new hl(i,cl):l=new hc(i,cl);const p=this.runWebGLProgram(l,[{dataId:e,shape:i,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(n!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return n;const c=this.activeTimers!=null;let d;c&&(d=Yo());let h;if(r==="complex64"){const l=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);h=Vc(l,p)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Yo()-d),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(x=>f.push(x))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:o,complexTensorInfos:i,isPacked:u}=t;if(a!=null){let f;u?f=new hl(r,cl):f=new hc(r,cl);const x=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),b=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),b}if(n!=null)return this.convertAndCacheOnCPU(e);if(nn().getBool("DEBUG")&&!nn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&nn().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,d;if(o!=="complex64"&&nn().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(e);const f=this.texData.get(d.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...dm(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),x=f[0],b=f[1];h=Vc(x,b)}else if(c==null)h=this.getValuesFromTexture(e);else{const f=hn(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(d!=null&&this.disposeIntermediateTensorInfo(d),c!=null){const f=this.gpgpu.gl;rs(f,()=>f.deleteBuffer(c))}const l=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(l)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&oc().removeDataId(e,this),this.pendingDeletes--),l}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:a,slice:o,dtype:i,isPacked:u,texture:c}=n;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;u?p=new hl(a,cl):p=new hc(a,cl);const f=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:i}],i),x=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),x}if(c==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,t.customTexShape),h=oc().makeTensorFromTensorInfo(d),l=this.texData.get(d.dataId);return Object.assign({tensorRef:h},l.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(r=>bl(r));return tr(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return tr(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const n=e[t];if(!wG(n))throw nn().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=hn(t);if(nn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const l=this.decode(e),p=this.texData.get(l.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...dm(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(l),f}const o=nn().getBool("WEBGL_PACK")&&r===!0,i=o?fm(t):t,u=o?new M6(i):new D6(i),c=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=dd(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=dd(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(a);i.kernelMs=hE(u),i.getExtraProfileInfo=()=>u.map((c,d)=>({name:o[d],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Yo(),endMs:null}}endTimer(e){return nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Yo(),e)}async getQueryTime(e){if(nn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:o,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,o)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=f5){return nn().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&hn(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Gi("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return l5(e.shape,t)}packedUnaryOp(e,t,n){const r=new hl(e.shape,t),a=this.compileAndRun(r,[e],n);return oc().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=QT(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(nn().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,d2,e.dtype);const t=new hc(e.shape,d2),n=this.compileAndRun(t,[e]);return oc().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&mp(n[0])){const a=n.map(o=>fl(o));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return oc().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new c5(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new qH(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[ph(e.shape),...fh(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[ph(t),...fh(t)],o=new tN(a,n),i=!0,u=[n],c=this.runWebGLProgram(o,[r],e.dtype,u,i);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:o}=n;if(t!=null){const l=hn(a),p=t[0]*t[1]*4;ze(l<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=fm(a);let u;r?u=new F6(i):u=new O6(i);const c=!0,d=[t!=null?t:dm(i)],h=this.runWebGLProgram(u,[{shape:i,dtype:o,dataId:e}],o,d,c,t);return{dtype:o,shape:a,dataId:h.dataId}}runWebGLProgram(e,t,n,r,a=!1,o){const i=this.makeTensorInfo(e.outputShape,n),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===lp.DENSE){const m=o!=null?o:dm(e.outputShape);u.texShape=m.map(I=>I*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),hn(i.shape)===0)return u.values=ko(i.dtype,0),i;const c=[],d=t.map(m=>{if(m.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let I=this.texData.get(m.dataId);if(I.texture==null){if(!e.packedInputs&&hn(m.shape)<=nn().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:m.shape,texData:null,isUniform:!0,uniformValues:I.values};e.packedInputs&&(I.isPacked=!0,I.shape=m.shape)}if(this.uploadToGPU(m.dataId),!!I.isPacked!=!!e.packedInputs)m=I.isPacked?this.unpackTensor(m):this.packTensor(m),c.push(m),I=this.texData.get(m.dataId);else if(I.isPacked&&!Qm(I.shape,m.shape)){const N=m,E=m.shape;m.shape=I.shape,m=this.packedReshape(m,E),c.push(m),I=this.texData.get(m.dataId),N.shape=E}return{shape:m.shape,texData:I,isUniform:!1}});this.uploadToGPU(i.dataId);const h={shape:i.shape,texData:u,isUniform:!1},l=A6(e,d,h),p=this.getAndSaveBinary(l,()=>E6(this.gpgpu,e,d,h)),f=this.activeTimers!=null;let x;f&&(x=this.startTimer()),nn().get("ENGINE_COMPILE_ONLY")||R6(this.gpgpu,p,d,h,r),c.forEach(m=>this.disposeIntermediateTensorInfo(m)),f&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const b=nn().get("WEBGL_FLUSH_THRESHOLD");if(b>0){const m=Yo();m-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=m)}if(!nn().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&a===!1){const m=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),m}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(nn().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Qt(()=>{if(!nn().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=nn().getBool("DEBUG");nn().set("DEBUG",!1);const t=this.abs(Rr(1e-8)).dataSync()[0];if(nn().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?d5:h5}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:o,usage:i,isPacked:u}=t;if(o!=null)return;const c=this.activeTimers!=null;let d;c&&(d=Yo());let h=t.texShape;if(h==null&&(h=LG(n,u),t.texShape=h),a!=null){const l=fm(n);let p,f=h[1],x=h[0];const b=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(u||!b)&&([f,x]=_h(h[0],h[1])),u?p=new L6(l,b):p=new i2(l,b);const m=b?[x,f]:h,I=this.makeTensorInfo(m,r),N=this.texData.get(I.dataId);b?N.usage=qi.PIXELS:N.usage=qi.UPLOAD,N.texShape=m,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(I.dataId),f,x,a);const E=[[x,f]],D=!0,U=this.runWebGLProgram(p,[I],r,E,D),L=this.texData.get(U.dataId);t.texShape=L.texShape,t.isPacked=L.isPacked,t.usage=L.usage,nn().get("ENGINE_COMPILE_ONLY")?this.disposeData(U.dataId):(t.texture=L.texture,t.values=null,this.texData.delete(U.dataId)),this.disposeIntermediateTensorInfo(I),c&&(this.uploadWaitMs+=Yo()-d)}else{const l=this.acquireTexture(h,i,r,u);t.texture=l}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return t!=null&&(n.values=b5(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Sm(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(r=>{try{this.checkCompletion_(t),r(!0)}catch(a){throw a}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await jC(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(zT(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:u}=GT(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=o,e.outShapeStridesLocation=i,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:o,channels:i}=e,u=oc().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(r,t,n,a,o,i);return oc().makeTensorFromDataId(c,t,n,u)}}Nb.nextDataId=0;function b5(s,e){if(e==="float32"||e==="complex64")return s;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(s.length):new Uint8Array(s.length);for(let n=0;n<t.length;++n)t[n]=Math.round(s[n]);return t}else throw new Error(`Unknown dtype ${e}`)}/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */FI()&&GI("webgl",()=>new Nb,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Av=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class mh{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=js(t,n),this.enableShapeUniforms=_o(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dd=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Af{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=js(t,n);const a=this.outputShape.length;this.enableShapeUniforms=_o(a);let o="";if(r)if(a===0||hn(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Mr(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Mo("coords",a);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ii(s){const{inputs:e,backend:t}=s,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const x5={kernelName:Mp,backendName:"webgl",kernelFunc:Ii};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(s){const{inputs:e,backend:t}=s,{real:n,imag:r}=e,a=t.makeTensorInfo(n.shape,"complex64"),o=t.texData.get(a.dataId),i=Ii({inputs:{x:n},backend:t}),u=Ii({inputs:{x:r},backend:t});return o.complexTensorInfos={real:i,imag:u},a}const y5={kernelName:dy,backendName:"webgl",kernelFunc:Al};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN="return (a < 0.) ? b * a : a;",sN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function w5(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{alpha:a}=n,o=t.makeTensorInfo([],"float32",_l(a,"float32")),i=nn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Af(sN,r.shape,o.shape):new mh(nN,r.shape,o.shape),u=t.runWebGLProgram(i,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),u}const v5={kernelName:Ig,backendName:"webgl",kernelFunc:w5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN="return (a < 0.) ? b * a : a;",aN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function k5(s){const{inputs:e,backend:t}=s,{x:n,alpha:r}=e,a=nn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Af(aN,n.shape,r.shape):new mh(rN,n.shape,r.shape);return t.runWebGLProgram(a,[n,r],"float32")}const I5={kernelName:Vg,backendName:"webgl",kernelFunc:k5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eh="if (isnan(x)) return x;";function vr({opSnippet:s,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:a})=>{const{x:o}=r,i=a,u=n||o.dtype;if(i.shouldExecuteOnCPU([o])&&t!=null){const h=i.texData.get(o.dataId),l=t(h.values,u);return i.makeTensorInfo(o.shape,u,l)}const c=nn().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let d;return c?d=new hl(o.shape,e):d=new hc(o.shape,s),i.runWebGLProgram(d,[o],u)}}function po({opSnippet:s,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:r,dtype:a}){return({inputs:o,backend:i})=>{const{a:u,b:c}=o,d=i;if(n&&u.dtype==="complex64"){const f=d.texData.get(u.dataId),x=d.texData.get(c.dataId),[b,m]=[[f.complexTensorInfos.real,x.complexTensorInfos.real],[f.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(N=>{const[E,D]=N,U={dataId:E.dataId,dtype:E.dtype,shape:u.shape},L={dataId:D.dataId,dtype:D.dtype,shape:c.shape},Y=new mh(s,u.shape,c.shape);return d.runWebGLProgram(Y,[U,L],vi(E.dtype,D.dtype))}),I=Al({inputs:{real:b,imag:m},backend:d});return d.disposeIntermediateTensorInfo(b),d.disposeIntermediateTensorInfo(m),I}const h=a||vi(u.dtype,c.dtype);if((u.dtype==="string"||c.dtype==="string"||d.shouldExecuteOnCPU([u,c]))&&r!=null){const f=d.texData.get(u.dataId).values,x=d.texData.get(c.dataId).values,b=u.dtype==="string"?Uc(f):f,m=u.dtype==="string"?Uc(x):x,[I,N]=r(u.shape,c.shape,b,m,h),E=d.makeTensorInfo(N,h),D=d.texData.get(E.dataId);return D.values=I,E}const l=nn().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return l?p=new Af(e,u.shape,c.shape,t):p=new mh(s,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function dp(s,e=!1){if(s==="linear")return e?r5:JH;if(s==="relu")return e?o5:t5;if(s==="elu")return e?a5:e5;if(s==="relu6")return e?i5:n5;if(s==="prelu")return e?aN:rN;if(s==="leakyrelu")return e?sN:nN;if(s==="sigmoid")return e?u5:s5;throw new Error(`Activation ${s} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oN{constructor(e,t,n,r=!1,a=!1,o=!1,i=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=_o(this.outputShape.length);const d=r?e[1]:e[2],h=Math.ceil(d/2),l=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let b="",m="";i&&(u?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:c?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:b=`vec4 activation(vec4 x) {
          ${i}
        }`,m="result = activation(result);");const I=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let N="rc.x",E="rc.x";e[0]<t[0]?N=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(E=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${b}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${N};
        int batchB = ${E};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${l});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${x[0]});
          result += (${f[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${I}

        ${m}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class p2{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=js(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f2="return a * b;";function Ov(s){const{inputs:e,backend:t}=s,{a:n,b:r}=e,a=vi(n.dtype,r.dtype);if(n.dtype==="complex64"){const i=t.texData.get(n.dataId),u=t.texData.get(r.dataId),c=new p2(h2.REAL,n.shape,r.shape),d=new p2(h2.IMAG,n.shape,r.shape),h=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],l=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(d,h,"float32"),f=Al({inputs:{real:l,imag:p},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([n,r])){const i=t.texData.get(n.dataId),u=t.texData.get(r.dataId),[c,d]=kH(n.shape,r.shape,i.values,u.values,a),h=t.makeTensorInfo(d,a),l=t.texData.get(h.dataId);return l.values=c,h}let o;return nn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Af(f2,n.shape,r.shape):o=new mh(f2,n.shape,r.shape),t.runWebGLProgram(o,[n,r],a)}const C5={kernelName:Gp,backendName:"webgl",kernelFunc:Ov};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(s,e,t){const n=[ph(s.shape),...fh(s.shape)],r={dtype:s.dtype,shape:n,dataId:s.dataId},a=[ph(e),...fh(e)],o=new tN(a,n),i=!0,u=[n],c=t.runWebGLProgram(o,[r],s.dtype,u,i);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{shape:a}=n,o=t,i=hn(r.shape),u=U2(a,i),c=hn(u);ze(i===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const d=o.texData.get(r.dataId);return d.isPacked&&!Qm(r.shape,u)&&!(d.texture!==null&&Qm(d.shape,u))?_5(r,u,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const S5={kernelName:jg,backendName:"webgl",kernelFunc:Yn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m2{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];const i=Math.floor(n/4)*4,u=n%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${th(h)?h.toPrecision(2):h}, ones);`}let d="";a%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $5{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const d=Math.floor(n/4)*4,h=n%4;let l=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(i="1.0",l=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(i="0.0",l=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";a%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${d};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${l}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${l}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${l}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5(s){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:s[1],n=pb(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function Md(s,e,t,n){const r=T5(s.shape);let a=s;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:u,outSize:c}=r[o];let d,h;t==="mean"?d=o===0?new m2({windowSize:u,inSize:i,batchSize:s.shape[0],outSize:c},i):new m2({windowSize:u,inSize:i,batchSize:s.shape[0],outSize:c}):d=new $5({windowSize:u,inSize:i,batchSize:s.shape[0],outSize:c},t),h=a,a=n.runWebGLProgram(d,[a],e),h.dataId!==s.dataId&&n.disposeIntermediateTensorInfo(h)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N5{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const r=Mr(this.rank),a=E5(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function E5(s){const e=s.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let r=0;r<s.length;r++)n[s[r]]=t[r];return n.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R5{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let d=0;d<n.length;d++)n[d]=e[t[d]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Mr(this.rank),a=eN("rc",this.rank),o=new Array(this.rank);for(let d=0;d<t.length;d++)o[t[d]]=a[d];const i=`vec2(${o.slice(-2).join()})`,u=`++${a[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${u}) {
        result[1] = ${c};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${c};
        if(${u}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eb(s,e,t){const n=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new R5(s.shape,e):new N5(s.shape,e);return t.runWebGLProgram(n,[s],s.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(s,e,t,n){const r=e,a=s.shape.length,o=nr(r,s.shape);let i=o;const u=ha(i,a),c=u!=null;let d=s;c&&(d=Eb(s,u,n),i=wa(i.length,a)),ho("sum",i,a);const[h,l]=Ja(d.shape,i);let p=h;t&&(p=$a(h,o));const f=hn(l),b=hn(s.shape)/f,m=Yn({inputs:{x:d},attrs:{shape:[b,f]},backend:n}),I=Gy(s.dtype),N=Md(m,I,"sum",n),E=Yn({inputs:{x:N},attrs:{shape:p},backend:n});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(N),c&&n.disposeIntermediateTensorInfo(d),E}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rb(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n;return A5(r,a,o,t)}const O5={kernelName:Yg,backendName:"webgl",kernelFunc:Rb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{perm:a}=n,o=t,i=r.shape.length,u=new Array(i);for(let d=0;d<u.length;d++)u[d]=r.shape[a[d]];let c;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,l=Rv(h,r.shape,r.dtype,a,u);c=o.makeTensorInfo(u,r.dtype);const p=o.texData.get(c.dataId);p.values=l}else c=Eb(r,a,o);return c}const F5={kernelName:Yd,backendName:"webgl",kernelFunc:Bo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iN=1e3;function Jm({a:s,b:e,transposeA:t,transposeB:n,backend:r,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const c=s.shape.length,d=e.shape.length,h=t?s.shape[c-2]:s.shape[c-1],l=n?e.shape[d-1]:e.shape[d-2],p=t?s.shape[c-1]:s.shape[c-2],f=n?e.shape[d-2]:e.shape[d-1],x=s.shape.slice(0,-2),b=e.shape.slice(0,-2),m=hn(x),I=hn(b),E=js(s.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);ze(h===l,()=>`Error in matMul: inner shapes (${h}) and (${l}) of Tensors with shapes ${s.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);const D=t?[m,h,p]:[m,p,h],U=n?[I,f,l]:[I,l,f],L=Yn({inputs:{x:s},backend:r,attrs:{shape:D}}),Y=Yn({inputs:{x:e},backend:r,attrs:{shape:U}}),V=[L,Y],P=Math.max(m,I),oe=t?L.shape[1]:L.shape[2],ne=a!=null,ge=o!=null,ye=u==="leakyrelu",Ee=u!=null?dp(u,!0):null,X=ne||ge||ye||Ee!=null;let je;if((p===1||f===1)&&oe>iN&&X===!1){let tt=L,ct=Y;t&&(tt=Bo({inputs:{x:L},backend:r,attrs:{perm:[0,2,1]}}),V.push(tt)),n&&(ct=Bo({inputs:{x:Y},backend:r,attrs:{perm:[0,2,1]}}),V.push(ct));const Me=f!==1,wt=f===1;let at=tt;Me&&(at=Yn({inputs:{x:tt},backend:r,attrs:{shape:[P,oe,1]}}),V.push(at));const Gt=f===1?2:1;let Ht=ct;wt&&(Ht=Yn({inputs:{x:ct},backend:r,attrs:{shape:[P,1,oe]}}),V.push(Ht));const dn=Ov({inputs:{a:at,b:Ht},backend:r});je=Rb({inputs:{x:dn},backend:r,attrs:{axis:Gt,keepDims:!0}}),V.push(dn)}else{const tt=vi(s.dtype,e.dtype),ct=new oN(D,U,[P,p,f],t,n,ne,Ee,ge,ye),Me=[L,Y];if(a!=null&&Me.push(a),ge&&Me.push(o),ye){const wt=r.makeTensorInfo([],"float32",_l(i,"float32"));Me.push(wt),V.push(wt)}je=r.runWebGLProgram(ct,Me,tt)}const Be=Yn({inputs:{x:je},backend:r,attrs:{shape:E}});V.push(je);for(const tt of V)r.disposeIntermediateTensorInfo(tt);return Be}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5(s){const{inputs:e,backend:t,attrs:n}=s,{a:r,b:a,bias:o,preluActivationWeights:i}=e,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:h}=n;return Jm({a:r,b:a,transposeA:u,transposeB:c,backend:t,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:d})}const M5={kernelName:$m,backendName:"webgl",kernelFunc:D5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2="return abs(x);";function P5(s){const{inputs:e,backend:t}=s,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){const a=t.texData.get(n.dataId),o=QT(a.values);return t.makeTensorInfo(n.shape,n.dtype,o)}let r;return nn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new hl(n.shape,g2):r=new hc(n.shape,g2),t.runWebGLProgram(r,[n],n.dtype)}const L5={kernelName:sg,backendName:"webgl",kernelFunc:P5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B5=Su+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,z5=vr({opSnippet:B5}),W5={kernelName:gp,backendName:"webgl",kernelFunc:z5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V5=Su+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,U5=vr({opSnippet:V5}),j5={kernelName:bp,backendName:"webgl",kernelFunc:U5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2="return a + b;",G5=po({opSnippet:b2,packedOpSnippet:b2,supportsComplex:!0,cpuKernelImpl:nH}),H5={kernelName:yh,backendName:"webgl",kernelFunc:G5};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q5{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K5{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vm(s){const{inputs:e,backend:t}=s,n=e;if(n.length===1)return Ii({inputs:{x:n[0]},backend:t});if(n.length>nn().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(n.length/2),c=vm({inputs:n.slice(0,u),backend:t}),d=vm({inputs:n.slice(u),backend:t});return vm({inputs:[c,d],backend:t})}const r=n.map(u=>u.dtype).reduce((u,c)=>vi(u,c)),a=n.map(u=>u.shape),i=nn().getBool("WEBGL_PACK")?new K5(n[0].shape,a):new q5(n[0].shape,a);return t.runWebGLProgram(i,n,r)}const X5={kernelName:ay,backendName:"webgl",kernelFunc:vm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n,i=r.shape.length,u=nr(a,r.shape);let c=u;const d=ha(c,i);let h=r;d!=null&&(h=Bo({inputs:{x:r},backend:t,attrs:{perm:d}}),c=wa(c.length,i)),ho("all",c,i);const[l,p]=Ja(h.shape,c),f=hn(p),x=Yn({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),b=Md(x,x.dtype,"all",t);let m;if(o){const I=$a(l,u);m=Yn({inputs:{x:b},backend:t,attrs:{shape:I}})}else m=Yn({inputs:{x:b},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),d!=null&&t.disposeIntermediateTensorInfo(h),m}const Z5={kernelName:oy,backendName:"webgl",kernelFunc:Y5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n,i=r.shape.length,u=nr(a,r.shape);let c=u;const d=ha(c,i);let h=r;d!=null&&(h=Bo({inputs:{x:r},backend:t,attrs:{perm:d}}),c=wa(c.length,i)),ho("any",c,i);const[l,p]=Ja(h.shape,c),f=hn(p),x=Yn({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),b=Md(x,x.dtype,"any",t);let m;if(o){const I=$a(l,u);m=Yn({inputs:{x:b},backend:t,attrs:{shape:I}})}else m=Yn({inputs:{x:b},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),d!=null&&t.disposeIntermediateTensorInfo(h),m}const J5={kernelName:iy,backendName:"webgl",kernelFunc:Q5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eq{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const i=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tq{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ze(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],o=Math.ceil(a/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,c=Mr(u),d=Mo("coords",u);let h,l;if(o===1){l=u+1;const Y=Mr(l);h=`
        ${Y} sourceLocR = ${Y}(${d.join()}, 0);
        ++${d[u-1]};
        ${Y} sourceLocG = ${Y}(${d.join()}, 0);
        ++${d[u-2]};
        ${Y} sourceLocA = ${Y}(${d.join()}, 0);
        --${d[u-1]};
        ${Y} sourceLocB = ${Y}(${d.join()}, 0);
        --${d[u-2]};`}else l=u,h=`
        ${c} sourceLocR = coords;
        ++${d[u-1]};
        ${c} sourceLocG = coords;
        ++${d[u-2]};
        ${c} sourceLocA = coords;
        --${d[u-1]};
        ${c} sourceLocB = coords;
        --${d[u-2]};`;const p=["x","y","z","w","u","v"].slice(0,l),f="."+p[l-1],x=p.map(Y=>"int "+Y),b=Mo("sourceLocR",l-1).concat("inIdx.r"),m=Mo("sourceLocG",l-1).concat("inIdx.g"),I=Mo("sourceLocB",l-1).concat("inIdx.b"),N=Mo("sourceLocA",l-1).concat("inIdx.a"),E=n==="max"?"greaterThan":"lessThan",D=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${I.join()}),
                             getBestIndicesAChannel(${N.join()})));`,U=`vec4(
            getAChannel(${b.join()}),
            hasNextCol ? getAChannel(${m.join()}) : 0.,
            hasNextRow ? getAChannel(${I.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,L=r?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${L}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${d[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${d[u-2]} < ${i[u-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${U};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${D}
          vec4 candidate = ${U};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${E}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(s,e,t,n=null){let r=e.shape[0],a=e.shape[1];n!=null&&(r=n.shape[0],a=n.shape[1]);const o=pb(a),i={windowSize:o,inSize:a,batchSize:r,outSize:Math.ceil(a/o)},u=new eq(i,t,n==null),c=[e];n!=null&&c.push(n);const d=s.runWebGLProgram(u,c,"int32");if(d.shape[1]===1)return d;const h=uN(s,e,t,d);return s.disposeIntermediateTensorInfo(d),h}function cN(s,e,t,n=null){const r=n!=null?n.shape:e.shape,a=r[r.length-1],o=pb(a),i=new tq(r,o,t,n==null),u=n==null?[e]:[e,n],c=s.runWebGLProgram(i,u,"int32");if(c.shape.length===e.shape.length){const d=cN(s,e,t,c);return s.disposeIntermediateTensorInfo(c),d}return c}function lN(s,e,t,n){const r=[t];if(ho("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,e.shape.length),!nn().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],o=s.texData.get(e.dataId),i=o!==null&&o.isPacked;let u=e;i&&(u=s.unpackTensor(e),a.push(u));const[c,d]=Ja(u.shape,r),h=hn(d),l=Yn({inputs:{x:u},backend:s,attrs:{shape:[-1,h]}});a.push(l);const p=uN(s,l,n);a.push(p);const f=Yn({inputs:{x:p},backend:s,attrs:{shape:c}});return a.forEach(x=>s.disposeIntermediateTensorInfo(x)),f}return cN(s,e,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nq(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a}=n;let o=nr(a,r.shape);const i=ha(o,r.shape.length);let u=r;const c=[];i!=null&&(u=Bo({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),o=wa(o.length,u.shape.length)),ho("argMax",[o[0]],u.shape.length);const d=lN(t,u,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const sq={kernelName:rg,backendName:"webgl",kernelFunc:nq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rq(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a}=n;let o=nr(a,r.shape);const i=ha(o,r.shape.length);let u=r;const c=[];i!=null&&(u=Bo({inputs:{x:r},backend:t,attrs:{perm:i}}),c.push(u),o=wa(o.length,u.shape.length)),ho("argMin",[o[0]],u.shape.length);const d=lN(t,u,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}const aq={kernelName:ag,backendName:"webgl",kernelFunc:rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oq=Su+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,iq=vr({opSnippet:oq}),uq={kernelName:xp,backendName:"webgl",kernelFunc:iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cq=Su+"return log(x + sqrt(x * x + 1.0));",lq=vr({opSnippet:cq}),dq={kernelName:yp,backendName:"webgl",kernelFunc:lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hq=Su+`
  return atan(x);
`,pq=vr({opSnippet:hq}),fq={kernelName:wp,backendName:"webgl",kernelFunc:pq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq=Av+`
  return atan(a, b);
`,gq=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dd+`
  return result;
`,bq=po({opSnippet:mq,packedOpSnippet:gq}),xq={kernelName:kp,backendName:"webgl",kernelFunc:bq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yq=Su+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,wq=vr({opSnippet:yq}),vq={kernelName:vp,backendName:"webgl",kernelFunc:wq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hp{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg",b=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let I="0.0";if(x||(I="-1.0 / 1e-20"),n){const Y=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${l};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${Y} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?b:m:`wR * ${l} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const D=Math.floor(o/4)*4,U=o%4,L=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${D}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${L}
          }

          int xC = xCCorner + ${D};
          if (${U===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${U===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${U===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${L}
          }
        }
        setOutput(${E});
      }
    `}}class Fv{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,u=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,l=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,x=e.effectiveFilterWidth,b=e.padInfo.front,m=e.padInfo.top,I=e.padInfo.left;this.outputShape=e.outShape;const N=t==="avg";let E="0.0";if(N||(E="-1.0 / 1e-20"),n){const P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${c});
        const ivec3 pads = ivec3(${b}, ${m}, ${I});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${l}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const D="max";let U=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(U="avgValue / max(count, 1.0)");const L=Math.floor(o/4)*4,Y=o%4,V=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${D}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${c});
      const ivec3 pads = ivec3(${b}, ${m}, ${I});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${L}; wC += 4) {
              int xC = xCCorner + wC * ${l};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                getValue(batch, xD, xR, xC + 2 * ${l}, ch),
                getValue(batch, xD, xR, xC + 3 * ${l}, ch)
              );

              ${V}
            }

            int xC = xCCorner + ${L};
            if (${Y===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${V}
            } else if (${Y===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                initializationValue,
                initializationValue
              );

              ${V}
            } else if (${Y===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${l}, ch),
                getValue(batch, xD, xR, xC + 2 * ${l}, ch),
                initializationValue
              );

              ${V}
            }
          }
        }
        setOutput(${U});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e;Ef(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n,c=1;ze(Co(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Cu(r.shape,a,o,c,i,u);if(d.filterWidth===1&&d.filterHeight===1&&Er(d.inShape,d.outShape))return Ii({inputs:{x:r},backend:t});const h=new hp(d,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const Iq={kernelName:og,backendName:"webgl",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cq(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:c}=n,d=[1,1,1],h=Gc(r.shape,a,o,d,i,u,c),l=new Fv(h,"avg",!1);return t.runWebGLProgram(l,[r],"float32")}const _q={kernelName:ig,backendName:"webgl",kernelFunc:Cq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sq{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=u-1-e.padInfo.top,h=c-1-e.padInfo.left,l=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${h});
      const float avgMultiplier = float(${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class $q{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,x=l-1-e.padInfo.top,b=p-1-e.padInfo.left,m=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${x}, ${b});
      const float avgMultiplier = float(${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tq(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,o=a,{filterSize:i,strides:u,pad:c,dimRoundingMode:d}=n,h=[1,1,1],l=Gc(o.shape,i,u,h,c,d),p=new $q(l);return t.runWebGLProgram(p,[r],o.dtype)}const Nq={kernelName:cy,backendName:"webgl",kernelFunc:Tq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eq(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,o=a;Ef([r,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:c}=n,d=Cu(o.shape,i,u,1,c),h=new Sq(d);return t.runWebGLProgram(h,[r],o.dtype)}const Rq={kernelName:uy,backendName:"webgl",kernelFunc:Eq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aq(s){const{inputs:e,backend:t,attrs:n}=s,{a:r,b:a}=e,{transposeA:o,transposeB:i}=n;return Jm({a:r,b:a,transposeA:o,transposeB:i,backend:t})}const Oq={kernelName:ug,backendName:"webgl",kernelFunc:Aq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fq{constructor(e,t,n,r,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],js(e,t),js(e,n);let i="0.0";r!=null&&(js(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";a!=null&&(js(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dq{constructor(e,t,n,r,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],js(e,t),js(e,n);let i="vec4(0.0)";r!=null&&(js(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";a!=null&&(js(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mq=({inputs:s,backend:e,attrs:t})=>{const{x:n,mean:r,variance:a,offset:o,scale:i}=s;ze(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ze(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ze(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const c=[n,r,a];let d=null;o!=null&&(d=o.shape,c.push(o));let h=null;i!=null&&(h=i.shape,c.push(i));const l=nn().getBool("WEBGL_PACK_NORMALIZATION")?new Dq(n.shape,r.shape,a.shape,d,h,u):new Fq(n.shape,r.shape,a.shape,d,h,u);return e.runWebGLProgram(l,c,c[0].dtype)},Pq={kernelName:wg,backendName:"webgl",kernelFunc:Mq};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lq{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Mr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Bq(this.rank);let r;const a=e.map((o,i)=>`sourceLoc.${H0[i]} = start[${i}] + coords.${H0[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}}const H0=["x","y","z","w","u","v"];function Bq(s){if(s===1)return"sourceLoc";if(s<=6)return H0.slice(0,s).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zq{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Mr(this.rank),n=Mo("coords",this.rank),r=Mo("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${o};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,h)=>`start[${h}]`).join()});`:e.map((d,h)=>`${r[h]} = ${n[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wq(s,e,t,n){const r=n.texData.get(s.dataId),a=n.makeTensorInfo(t,s.dtype),o=n.texData.get(a.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=s.dtype;let i=Nw(e,ws(s.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||s.dataId};const u=n.dataRefCount.get(o.slice.origDataId)||1;return n.dataRefCount.set(o.slice.origDataId,u+1),a}function Rh(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{begin:a,size:o}=n,[i,u]=hb(r,a,o);if(Sw(r,i,u),hn(u)===0)return t.makeTensorInfo(u,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),l=OH(h.values,i,u,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,l)}const{isPacked:c}=t.texData.get(r.dataId),d=Tw(r.shape,i,u);if(c||!d){const h=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zq(u):new Lq(u),l=[i];return t.runWebGLProgram(h,[r],r.dtype,l)}return t.uploadToGPU(r.dataId),Wq(r,i,u,t)}const Vq={kernelName:Xg,backendName:"webgl",kernelFunc:Rh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uq=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockShape:a,crops:o}=n;ze(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((I,N)=>I*N),u=bf(r.shape,a,i),c=xf(u.length,a.length),d=yf(r.shape,a,i),h=Fw(o,a.length),l=Dw(d,o,a.length),p=[],f=Yn({inputs:{x:r},backend:t,attrs:{shape:u}}),x=Bo({inputs:{x:f},backend:t,attrs:{perm:c}}),b=Yn({inputs:{x},backend:t,attrs:{shape:d}}),m=Rh({inputs:{x:b},backend:t,attrs:{begin:h,size:l}});return p.push(f),p.push(x),p.push(b),p.forEach(I=>t.disposeIntermediateTensorInfo(I)),m},jq={kernelName:cg,backendName:"webgl",kernelFunc:Uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gq(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,weights:a}=e,{size:o}=n,i=t.readSync(r.dataId),u=t.readSync(a.dataId),c=ZT(i,u,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,c)}const Hq={kernelName:ly,backendName:"webgl",kernelFunc:Gq};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qq(s){const{inputs:e,backend:t}=s,{s0:n,s1:r}=e,a=t.readSync(n.dataId),o=t.readSync(r.dataId),i=js(Array.from(a),Array.from(o));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const Kq={kernelName:Y2,backendName:"webgl",kernelFunc:qq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xq="return float(a != b);",dN=po({opSnippet:Xq,cpuKernelImpl:CH,dtype:"bool"}),Yq={kernelName:Pg,backendName:"webgl",kernelFunc:dN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Of(s){const{inputs:e,backend:t}=s,{input:n}=e,r=t.texData.get(n.dataId);return Ii({inputs:{x:r.complexTensorInfos.real},backend:t})}const Zq={kernelName:Fy,backendName:"webgl",kernelFunc:Of};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qq="return float(int(x));";function Jq(s,e){const t=new hc(s.shape,Qq),n=e.runWebGLProgram(t,[s],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{dtype:a}=n;if(a==="complex64"){if(r.dtype==="complex64")return Ii({inputs:{x:r},backend:t});const o=Ya(r.shape),i=q0({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),u=Al({inputs:{real:i,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(i),u}if(r.dtype==="complex64"){const o=Of({inputs:{input:r},backend:t}),i=q0({inputs:{x:o},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(o),i}if(!j2(r.dtype,a)){const o=Ii({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId).values,[i,u,c]=rH(o,r.shape,r.dtype,a);return t.makeTensorInfo(i,u,c)}if(a==="int32")return Jq(r,t);if(a==="bool"){const o=t.makeTensorInfo([],"bool",ko("bool",1)),u=dN({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const e8={kernelName:Ip,backendName:"webgl",kernelFunc:q0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2="return ceil(x);",t8=vr({opSnippet:x2,packedOpSnippet:x2,cpuKernelImpl:aH}),n8={kernelName:Cp,backendName:"webgl",kernelFunc:t8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s8{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r8{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{clipValueMin:a,clipValueMax:o}=n;let i;nn().getBool("WEBGL_PACK_CLIP")?i=new r8(r.shape):i=new s8(r.shape);const u=[[a],[o]];return t.runWebGLProgram(i,[r],r.dtype,u)}const o8={kernelName:_p,backendName:"webgl",kernelFunc:a8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i8{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2(s,e){return{dataId:e.dataId,dtype:e.dtype,shape:s.shape}}function u8(s){const{inputs:e,backend:t}=s,{x:n}=e,r=t.texData.get(n.dataId),a=new i8(n.shape),o=[y2(n,r.complexTensorInfos.real),y2(n,r.complexTensorInfos.imag)];return t.runWebGLProgram(a,o,o[0].dtype)}const c8={kernelName:lg,backendName:"webgl",kernelFunc:u8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l8{constructor(e){this.outputShape=[],this.outputShape=gc(e,1),this.variableNames=e.map((o,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const i=t[o-1];n.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${i}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d8{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=gc(e,t);const n=this.outputShape,r=n.length,a=Mr(r),o=Mo("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((x,b)=>`T${b}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let x=1;x<u.length;x++)u[x]=u[x-1]+e[x][t];const c=i[t],d=i.slice(-2),h=i.join();let l=`if (${c} < ${u[0]}) {
        return getChannel(
            getT0(${h}), vec2(${d.join()}));
        }`;for(let x=1;x<u.length;x++){const b=u[x-1];l+=`
        if (${c} < ${u[x]}  && ${c} >= ${u[x-1]}) {
          return getChannel(
            getT${x}(${bm(i,c,b)}),
            vec2(${bm(d,c,b)}));
        }`}const p=u.length,f=u[u.length-1];l+=`
        return getChannel(
          getT${p}(${bm(i,c,f)}),
          vec2(${bm(d,c,f)}));`,this.userCode=`
      float getValue(${i.map(x=>"int "+x)}) {
        ${l}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${n[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${n[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${n[r-2]} &&
            ${o[r-1]} < ${n[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function bm(s,e,t){const n=s.indexOf(e);return s.map((a,o)=>o===n?`${a} - ${t}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(s){const{inputs:e,backend:t}=s,{input:n}=e,r=t.texData.get(n.dataId);return Ii({inputs:{x:r.complexTensorInfos.imag},backend:t})}const h8={kernelName:Sy,backendName:"webgl",kernelFunc:Ab};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jh(s,e,t){const n=s[0].dtype;if(n==="complex64"){const p=s.map(I=>Of({inputs:{input:I},backend:t})),f=s.map(I=>Ab({inputs:{input:I},backend:t})),x=Jh(p,e,t),b=Jh(f,e,t),m=Al({inputs:{real:x,imag:b},backend:t});return p.forEach(I=>t.disposeIntermediateTensorInfo(I)),f.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),m}let r=t.shouldExecuteOnCPU(s);if(n==="string"&&(r=!0),r){const p=s.map(E=>{const D=hn(E.shape.slice(e));return Yn({inputs:{x:E},backend:t,attrs:{shape:[-1,D]}})}),f=p.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),x=gc(p.map(E=>E.shape),1),b=p[0].shape[0]===1,m=oH(f,x,n,b),I=gc(s.map(E=>E.shape),e),N=t.makeTensorInfo(I,n,m);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),N}const a=s.filter(p=>hn(p.shape)>0),o=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=o?new hc(s[0].shape,cl):new hl(s[0].shape,cl);return t.runWebGLProgram(p,s,n)}const i=nn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>i){const p=[];for(let x=0;x<a.length;x+=i){const b=a.slice(x,x+i);p.push(Jh(b,e,t))}const f=Jh(p,e,t);for(const x of p)t.disposeIntermediateTensorInfo(x);return f}if(o){const p=new d8(a.map(f=>f.shape),e);return t.runWebGLProgram(p,a,n)}const{tensors2D:u,outShape:c}=p8(a,e,t),d=new l8(u.map(p=>p.shape)),h=t.runWebGLProgram(d,u,n);u.forEach(p=>t.disposeIntermediateTensorInfo(p));const l=Yn({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),l}function p8(s,e,t){const n=gc(s.map(a=>a.shape),e);return{tensors2D:s.map(a=>Yn({inputs:{x:a},attrs:{shape:[-1,hn(a.shape.slice(e))]},backend:t})),outShape:n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(s){const{inputs:e,backend:t,attrs:n}=s,{axis:r}=n,a=nr(r,e[0].shape)[0],o=e.map(c=>c.shape);Rw(o,a);const i=gc(e.map(c=>c.shape),a);if(hn(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const u=e.filter(c=>hn(c.shape)>0);return u.length===1?Ii({inputs:{x:u[0]},backend:t}):Jh(u,a,t)}const f8={kernelName:dg,backendName:"webgl",kernelFunc:hN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pN{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,b=e.dataFormat==="channelsLast",m=b?1:2,I=b?2:3,N=b?3:1;let E="",D="";n&&(r?E=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?E=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:E=`
          float activation(float x) {
            ${n}
          }
        `,D="result = activation(result);");const U=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${E}

      const ivec2 strides = ivec2(${u}, ${c});
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${N}];

        ivec2 xRCCorner =
            ivec2(coords[${m}], coords[${I}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${b}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${b}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${b}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${b}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${U}
        ${D}
        setOutput(result);
      }
    `}}class m8{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.filterDepth,l=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${o}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${l}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fN{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_o(this.outputShape.length);const o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,h=d;let l=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)l+=`
           vec4 xTexelC${b*2};
           int xTexelC${b*2}Ready;
           vec4 xTexelC${b*2+1};
           int xTexelC${b*2+1}Ready;
           vec4 xC${b};`;l+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let b=0;b<d;b++)l+=`
           xTexelC${b*2} = vec4(0.0);
           xTexelC${b*2}Ready = 0;
           xTexelC${b*2+1} = vec4(0.0);
           xTexelC${b*2+1}Ready = 0;
           xC${b} = vec4(0.0);`;l+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let b=0;b<(h+1)/2;b++){const m=b*2;if(l+=`
           xC = xCCorner + ${m*u};
           `,i===1){if(m<d&&(o%2===1?(l+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }
               `,u===1&&m>0?l+=`
                 xC${m} = vec4(xTexelC${m-2}.zw, xTexelC${m}.xy);
                 `:l+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${m} = vec4(previous.zw, xTexelC${m}.xy);
                   } else {
                     xC${m} = vec4(0.0, 0.0, xTexelC${m}.xy);
                   }
                   `):l+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xC${m} = xTexelC${m};
                 `,m+1<d)){const I=o%2===0?ey(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(l+=`
                   xCOffset = xC + imod(pads[1], 2) + ${I};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                     xTexelC${m+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${m+1}.zw = vec2(0.0);
                     }
                     xTexelC${m+1}Ready = 1;
                   }
                   `,u>1?l+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${m+1} = vec4(previous.zw, xTexelC${m+1}.xy);
                     } else {
                      xC${m+1} = vec4(0.0, 0.0, xTexelC${m+1}.xy);
                     }
                     `:l+=`
                     xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.xy);
                     `):I===1?l+=`
                     xC${m+1} = xTexelC${m};
                     `:l+=`
                     xCOffset = xC + ${I};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                       xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${m+1}.zw = vec2(0.0);
                       }
                       xTexelC${m+1}Ready = 1;
                     }

                     xC${m+1} = xTexelC${m+1};
                     `}}else m<d&&(o%2===1?(l+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.0);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
               `,m+1<d&&(l+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${m+1} = vec4(xTexelC${m+1}.xy, final.xy);
                 `)):(l+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${m}Ready == 0) {
                   xTexelC${m} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${m}.zw = vec2(0.0);
                   }
                   xTexelC${m}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${m+1}Ready == 0) {
                   xTexelC${m+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${m+1}.zw = vec2(0.);
                   }
                   xTexelC${m+1}Ready = 1;
                 }

                 xC${m} = vec4(
                   xTexelC${m}.xy, xTexelC${m+1}.xy);
               `,m+1<d&&(l+=`
                   xC${m+1} = vec4(xTexelC${m}.zw, xTexelC${m+1}.zw);
                 `)));m<d&&(l+=`
             wTexel = getW(r, ${m}, d1, d2);
             dotProd += xC${m}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${m}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,m+1<d&&(l+=`
               wTexel = getW(r, ${m+1}, d1, d2);
               dotProd += xC${m+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${m+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}l+=`
     }
   `,l+=`
     }
   `,l+=`
     }
   `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:p=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${l}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g8{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_o(this.outputShape.length);const{dataFormat:n}=t,r=zo(),a=n==="channelsLast",o=a?1:2,i=a?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${d};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eg(s,e){const t=s.length;return t>=3?e?[...s.slice(0,-3),s[t-3]*s[t-2],s[t-1]]:[...s.slice(0,-3),s[t-3],s[t-2]*s[t-1]]:!e&&t===1&&s[0]>1?[s[0],1]:null}function mN({x:s,filter:e,convInfo:t,backend:n,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const u=s.shape,c=n.texData.get(s.dataId),d=t.inChannels,h=u[0]*u[1]*u[2],l=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,x=!1;let b;const m=[];if(a!=null){const E=eg(a.shape,p);E!=null&&(a=Yn({inputs:{x:a},backend:n,attrs:{shape:E}}),m.push(a))}if(r!=null){const E=eg(r.shape,p);E!=null&&(r=Yn({inputs:{x:r},backend:n,attrs:{shape:E}}),m.push(r))}if(!((h===1||l===1)&&d>iN)&&c.isPacked&&p&&c.texture!=null&&u[2]%2!==0&&Er(c.shape.slice(-3),u.slice(-3))){const E=u[0]*u[1]*(u[2]+1),D={dataId:s.dataId,shape:[1,E,t.inChannels],dtype:s.dtype},U=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,ze(Qm(c.shape,D.shape),()=>`packed reshape ${c.shape} to ${D.shape} isn't free`);const L=Yn({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});m.push(L);const Y=Jm({a:D,b:L,backend:n,transposeA:f,transposeB:x,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),V=n.texData.get(Y.dataId);ze(V.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=U,V.shape=t.outShape,b=Ii({inputs:{x:Y},backend:n}),b.shape=t.outShape,m.push(Y)}else{const E=t.outHeight*t.outWidth,D=Yn({inputs:{x:s},backend:n,attrs:{shape:p?[t.batchSize,E,t.inChannels]:[t.batchSize,t.inChannels,E]}}),U=Yn({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),L=Jm({a:p?D:U,b:p?U:D,transposeA:!p,transposeB:x,backend:n,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o});b=Yn({inputs:{x:L},backend:n,attrs:{shape:t.outShape}}),m.push(D),m.push(U),m.push(L)}for(const E of m)n.disposeIntermediateTensorInfo(E);return b}function gN({x:s,filter:e,convInfo:t,backend:n,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:l,dataFormat:p}=t,f=p==="channelsLast",x=u*c*d,b=l*h,m=[t.batchSize,x,b],I=!0,N=!1,E=[];if(a!=null){const Be=eg(a.shape,f);Be!=null&&(a=Yn({inputs:{x:a},backend:n,attrs:{shape:Be}}),E.push(a))}if(r!=null){const Be=eg(r.shape,f);Be!=null&&(r=Yn({inputs:{x:r},backend:n,attrs:{shape:Be}}),E.push(r))}const D=Yn({inputs:{x:e},backend:n,attrs:{shape:[1,x,hn(e.shape)/x]}});E.push(D);const U=new g8(m,t),L=[s.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],Y=n.runWebGLProgram(U,[s],"float32",L),V=Yn({inputs:{x:Y},backend:n,attrs:{shape:m}});E.push(Y),E.push(V);const P=r!=null,oe=a!=null,ne=i==="leakyrelu",ge=i?dp(i,!0):null,ye=new oN(f?V.shape:D.shape,f?D.shape:V.shape,f?[t.batchSize,b,t.outChannels]:[t.batchSize,t.outChannels,b],I,N,P,ge,oe,ne),Ee=f?[V,D]:[D,V];if(r&&Ee.push(r),oe&&Ee.push(a),ne){const Be=n.makeTensorInfo([],"float32",_l(o,"float32"));Ee.push(Be),E.push(Be)}const X=n.runWebGLProgram(ye,Ee,"float32"),je=Yn({inputs:{x:X},backend:n,attrs:{shape:t.outShape}});E.push(X);for(const Be of E)n.disposeIntermediateTensorInfo(Be);return je}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dataFormat:u,dilations:c,dimRoundingMode:d}=n,h=Hc(u),l=lo(r.shape,a.shape,o,c,i,d,!1,h);let p;if(l.filterHeight===1&&l.filterWidth===1&&l.dilationHeight===1&&l.dilationWidth===1&&l.strideHeight===1&&l.strideWidth===1&&(l.padInfo.type==="SAME"||l.padInfo.type==="VALID"))p=mN({x:r,filter:a,convInfo:l,backend:t});else if(l.strideWidth<=2&&h==="channelsLast"&&nn().getBool("WEBGL_EXP_CONV")){const x=new fN(l),b=[[l.padInfo.top,l.padInfo.left],[l.strideHeight,l.strideWidth],[l.dilationHeight,l.dilationWidth],[l.inHeight,l.inWidth]];p=t.runWebGLProgram(x,[r,a],"float32",b)}else if(nn().getBool("WEBGL_CONV_IM2COL"))p=gN({x:r,filter:a,convInfo:l,backend:t});else{const x=new pN(l);p=t.runWebGLProgram(x,[r,a],"float32")}const f=Yn({inputs:{x:p},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(p),f}const x8={kernelName:hg,backendName:"webgl",kernelFunc:b8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y8{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class w8{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=n-1-e.padInfo.left,c=o?1:2,d=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class v8{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class k8{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,c=n-1-e.padInfo.top,d=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,pad:i,dataFormat:u,dimRoundingMode:c,filterShape:d}=n,h=Hc(u),l=lo(r.shape,d,o,1,i,c,!1,h),p=new y8(l);return t.runWebGLProgram(p,[r,a],"float32")}const C8={kernelName:hy,backendName:"webgl",kernelFunc:I8};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _8{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=_o(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{inputShape:o,strides:i,pad:u,dataFormat:c,dimRoundingMode:d}=n,h=Hc(c),l=lo(o,a.shape,i,1,u,d,!1,h);if(nn().getBool("WEBGL_PACK")&&h==="channelsLast"){const p=[[l.strideHeight,l.strideWidth]],f=new _8(l);return t.runWebGLProgram(f,[r,a],"float32",p)}else{const p=new w8(l);return t.runWebGLProgram(p,[r,a],"float32")}}const $8={kernelName:pg,backendName:"webgl",kernelFunc:S8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dilations:u}=n,c=Sl(r.shape,a.shape,o,u,i),d=new m8(c);return t.runWebGLProgram(d,[r,a],"float32")}const N8={kernelName:fg,backendName:"webgl",kernelFunc:T8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,pad:i,filterShape:u}=n,c=Sl(r.shape,u,o,1,i),d=new v8(c);return t.runWebGLProgram(d,[r,a],"float32")}const R8={kernelName:py,backendName:"webgl",kernelFunc:E8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{pad:o,strides:i,inputShape:u}=n,c=Sl(u,a.shape,i,1,o),d=new k8(c);return t.runWebGLProgram(d,[r,a],"float32")}const O8={kernelName:fy,backendName:"webgl",kernelFunc:A8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F8=Eh+`
  return cos(x);
`,D8=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Dd}
  return result;
`,M8=vr({opSnippet:F8,packedOpSnippet:D8}),P8={kernelName:Sp,backendName:"webgl",kernelFunc:M8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L8=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,B8=vr({opSnippet:L8}),z8={kernelName:$p,backendName:"webgl",kernelFunc:B8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W8{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,u,c]=e,[d]=t,[h,l]=n;this.outputShape=[d,h,l,c];const p=r==="bilinear"?1:0,[f,x]=[`${i-1}.0`,`${u-1}.0`],[b,m,I]=h>1?[`${(i-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[N,E,D]=l>1?[`${(u-1)/(l-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${b});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${E};

        float in_y = ${I};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${D};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V8=s=>{const{inputs:e,backend:t,attrs:n}=s,{image:r,boxes:a,boxInd:o}=e,{cropSize:i,method:u,extrapolationValue:c}=n,d=new W8(r.shape,a.shape,i,u,c);return t.runWebGLProgram(d,[r,a,o],"float32")},U8={kernelName:gy,backendName:"webgl",kernelFunc:V8};var pp;(function(s){s.Prod="*",s.Sum="+"})(pp||(pp={}));class w2{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=this.op===pp.Prod?"1.0":"0.0",i=n?o:`getX(${v2(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",d="";n?(c=r?`end != ${u-1}`:"end != 0",d=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${u}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Mr(a)} coords = getOutputCoords();
        int end = ${k2(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${d};
          ${k2(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${v2(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function v2(s,e,t){if(s===1)return`${e}`;if(s===2)return`${e}.x, ${e}.y`;if(s===3)return`${e}.x, ${e}.y, ${e}.z`;if(s===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${s} is not yet supported`)}function k2(s,e,t){if(s===1)return`${e}`;if(s===2)return`${e}.y`;if(s===3)return`${e}.z`;if(s===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${s} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(s,e,t,n,r,a){const o=e.shape.length,i=ha([n],o);let u=e;i!=null&&(u=Bo({inputs:{x:e},backend:t,attrs:{perm:i}}));const c=wa(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);const d=u.shape[c];let h=Ii({inputs:{x:u},backend:t});for(let l=0;l<=Math.ceil(Math.log2(d))-1;l++){const p=new w2(s,u.shape,!1,a),f=[[l]],x=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(x)}if(r){const l=new w2(s,u.shape,r,a),p=h;h=t.runWebGLProgram(l,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(i!=null){const l=$l(i),p=Bo({inputs:{x:h},backend:t,attrs:{perm:l}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(u),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,exclusive:o,reverse:i}=n;return bN(pp.Prod,r,t,a,o,i)}const G8={kernelName:my,backendName:"webgl",kernelFunc:j8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,exclusive:o,reverse:i}=n;return bN(pp.Sum,r,t,a,o,i)}const q8={kernelName:mg,backendName:"webgl",kernelFunc:H8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,weights:a}=e,{size:o,binaryOutput:i}=n;if(r.shape.length===1){const u=t.readSync(r.dataId),c=t.readSync(a.dataId),d=ZT(u,c,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,d)}else if(r.shape.length===2){const u=t.bufferSync(r),c=t.bufferSync(a),d=sH(u,c,o,i);return t.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const X8={kernelName:by,backendName:"webgl",kernelFunc:K8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y8{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockSize:a,dataFormat:o}=n,i=r.shape[0],u=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],d=o==="NHWC"?r.shape[3]:r.shape[1],h=u*a,l=c*a,p=d/(a*a),f=o==="NHWC"?[i,h,l,p]:[i,p,h,l],x=new Y8(f,a,o);return t.runWebGLProgram(x,[r],r.dtype)}const Q8={kernelName:xy,backendName:"webgl",kernelFunc:Z8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xN{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_o(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels;let c="",d="";n&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:c=`
          float activation(float x) {
            ${n}
          }
        `,d="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yN{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_o(this.outputShape.length);const o=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,l=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<h;m++)p+=`
          vec4 xTexelC${m*2};
          int xTexelC${m*2}Ready;
          vec4 xTexelC${m*2+1};
          int xTexelC${m*2+1}Ready;
          vec4 xC${m};`;p+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let m=0;m<h;m++)p+=`
          xTexelC${m*2} = vec4(0.0);
          xTexelC${m*2}Ready = 0;
          xTexelC${m*2+1} = vec4(0.0);
          xTexelC${m*2+1}Ready = 0;
          xC${m} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let m=0;m<(l+1)/2;m++){const I=m*2;if(p+=`
          xC = xCCorner + ${I*c};
          `,u===1){if(I<h&&(i%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I}Ready == 0) {
                  xTexelC${I} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${I}.zw = vec2(0.0);
                  }
                  xTexelC${I}Ready = 1;
                }
              `,c===1&&I>0?p+=`
                xC${I} = vec4(xTexelC${I-2}.zw, xTexelC${I}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${I} = vec4(previous.zw, xTexelC${I}.xy);
                  } else {
                    xC${I} = vec4(0.0, 0.0, xTexelC${I}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${I}Ready == 0) {
                  xTexelC${I} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${I}.zw = vec2(0.0);
                  }
                  xTexelC${I}Ready = 1;
                }

                xC${I} = xTexelC${I};
                `,I+1<h)){const N=i%2===0?ey(c):c;c%2===0&&i%2===1||c%2!==0&&i%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {
                    xTexelC${I+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${I+1}.zw = vec2(0.0);
                    }
                    xTexelC${I+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${I+1} = vec4(previous.zw, xTexelC${I+1}.xy);
                    } else {
                     xC${I+1} = vec4(0.0, 0.0, xTexelC${I+1}.xy);
                    }
                    `:p+=`
                    xC${I+1} = vec4(xTexelC${I}.zw, xTexelC${I+1}.xy);
                    `):N===1?p+=`
                    xC${I+1} = xTexelC${I};
                    `:p+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {
                      xTexelC${I+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${I+1}.zw = vec2(0.0);
                      }
                      xTexelC${I+1}Ready = 1;
                    }

                    xC${I+1} = xTexelC${I+1};
                    `}}else I<h&&(i%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I}Ready == 0) {
                  xTexelC${I} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${I}.zw = vec2(0.0);
                  }
                  xTexelC${I}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${I+1}Ready == 0) {
                  xTexelC${I+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${I+1}.zw = vec2(0.0);
                  }
                  xTexelC${I+1}Ready = 1;
                }

                xC${I} = vec4(xTexelC${I}.zw, xTexelC${I+1}.zw);
              `,I+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${I+1} = vec4(xTexelC${I+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${I}Ready == 0) {
                  xTexelC${I} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${I}.zw = vec2(0.0);
                  }
                  xTexelC${I}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${I+1}Ready == 0) {
                  xTexelC${I+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${I+1}.zw = vec2(0.);
                  }
                  xTexelC${I+1}Ready = 1;
                }

                xC${I} = vec4(
                  xTexelC${I}.xy, xTexelC${I+1}.xy);
              `,I+1<h&&(p+=`
                  xC${I+1} = vec4(xTexelC${I}.zw, xTexelC${I+1}.zw);
                `)));I<h&&(p+=`
            wTexel = getW(r, ${I}, d1, q);
            dotProd += xC${I} * vec4(wTexel.xz, wTexel.xz);
          `,I+1<h&&(p+=`
              wTexel = getW(r, ${I+1}, d1, q);
              dotProd += xC${I+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",x="";n&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,x="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${b}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dilations:u,dimRoundingMode:c}=n;let d=u;d==null&&(d=[1,1]),ze(Co(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const h=lo(r.shape,a.shape,o,d,i,c,!0);let l;nn().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?l=new yN(h):l=new xN(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(l,[r,a],"float32",p)}const eK={kernelName:gg,backendName:"webgl",kernelFunc:J8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tK{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nK{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sK(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,dy:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:c,filterShape:d}=n,h=lo(r.shape,d,o,i,u,c,!0),l=new tK(h);return t.runWebGLProgram(l,[r,a],"float32")}const rK={kernelName:yy,backendName:"webgl",kernelFunc:sK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aK(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,filter:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:c,inputShape:d}=n,h=lo(d,a.shape,o,i,u,c,!0),l=new nK(h);return t.runWebGLProgram(l,[r,a],"float32")}const oK={kernelName:wy,backendName:"webgl",kernelFunc:aK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iK{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uK(s){const{inputs:e,backend:t}=s,{x:n}=e,r=[...n.shape,...n.shape],a=hn(n.shape),o=Yn({inputs:{x:n},backend:t,attrs:{shape:[a]}}),i=new iK(a),u=t.runWebGLProgram(i,[o],o.dtype),c=Yn({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),c}const cK={kernelName:Z2,backendName:"webgl",kernelFunc:uK};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lK{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:u,dilationHeight:c,dilationWidth:d}=e,{top:h,left:l}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${o});
      const ivec2 pads = ivec2(${h}, ${l});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dK(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a}=e,{strides:o,pad:i,dilations:u}=n,c=hf(r.shape,a.shape,o,i,"NHWC",u);let d;const h=new lK(c);d=t.runWebGLProgram(h,[r,a],"float32");const l=Yn({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),l}const hK={kernelName:bg,backendName:"webgl",kernelFunc:dK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(s){const{inputs:e,backend:t,attrs:n}=s,{equation:r}=n,a=e,{allDims:o,summedDims:i,idDims:u}=Uw(r,a.length);Gw(o.length,u,a);const{path:c,steps:d}=Hw(i,u),h=d.length;let l=null,p=o.length;const f=[];for(let x=0;x<h;++x){for(const b of d[x]){const{permutationIndices:m,expandDims:I}=jw(p,u[b]);let N;qw(m)?N=a[b]:(N=Bo({inputs:{x:a[b]},backend:t,attrs:{perm:m}}),f.push(N));const E=N.shape.slice();for(let D=0;D<I.length;++D)E.splice(I[D],0,1);Er(N.shape,E)||(N=Yn({inputs:{x:N},backend:t,attrs:{shape:E}}),f.push(N)),l===null?l=N:(l=Ov({inputs:{a:N,b:l},backend:t}),f.push(l))}x<h-1&&(c[x]>=0&&(l=Rb({inputs:{x:l},backend:t,attrs:{axis:c[x]-(o.length-p),keepDims:!1}}),f.push(l)),p--)}for(const x of f)x!==l&&t.disposeIntermediateTensorInfo(x);return l}const fK={kernelName:Q2,backendName:"webgl",kernelFunc:pK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mK="return (x >= 0.0) ? x : (exp(x) - 1.0);",gK=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,bK=vr({opSnippet:mK,packedOpSnippet:gK}),xK={kernelName:Np,backendName:"webgl",kernelFunc:bK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yK="return (b >= 0.0) ? a : a * (b + 1.0);",wK=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vK=s=>{const{inputs:e,backend:t}=s,{dy:n,y:r}=e,a=nn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Af(wK,n.shape,r.shape):new mh(yK,n.shape,r.shape);return t.runWebGLProgram(a,[n,r],n.dtype)},kK={kernelName:vy,backendName:"webgl",kernelFunc:vK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK=`
  return vec4(equal(a, b));
`,CK="return float(a == b);",_K=po({opSnippet:CK,packedOpSnippet:IK,dtype:"bool",cpuKernelImpl:iH}),SK={kernelName:xg,backendName:"webgl",kernelFunc:_K};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $K=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Mw};
  float a1 = ${Pw};
  float a2 = ${Lw};
  float a3 = ${Bw};
  float a4 = ${zw};
  float a5 = ${Ww};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,TK=vr({opSnippet:$K}),NK={kernelName:Ep,backendName:"webgl",kernelFunc:TK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK=Eh+`
  return exp(x);
`,RK=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wN=vr({opSnippet:EK,packedOpSnippet:RK,cpuKernelImpl:uH,dtype:"float32"}),AK={kernelName:Rp,backendName:"webgl",kernelFunc:wN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0(s){const{inputs:e,attrs:t,backend:n}=s,{dim:r}=t,{input:a}=e,o=a.shape.length,i=a.shape.slice();let u=r;return r<0&&(ze(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+r+1),i.splice(u,0,1),Yn({inputs:{x:a},backend:n,attrs:{shape:i}})}const OK={kernelName:yg,backendName:"webgl",kernelFunc:K0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2="return exp(x) - 1.0;",FK=vr({opSnippet:I2,packedOpSnippet:I2,cpuKernelImpl:cH}),DK={kernelName:Ap,backendName:"webgl",kernelFunc:FK};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C2{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(s,e,t){const n=t.texData.get(s.dataId),r=hn(s.shape),a=s.shape[s.shape.length-1],o=r/a,i=Yn({inputs:{x:s},backend:t,attrs:{shape:[o,a]}}),u=i.shape,c=new C2("real",u,e),d=new C2("imag",u,e),h=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],l=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(d,h,"float32"),f=Al({inputs:{real:l,imag:p},backend:t});t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p);const x=Yn({inputs:{x:f},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MK(s){const{inputs:e,backend:t}=s,{input:n}=e;return vN(n,!1,t)}const PK={kernelName:ky,backendName:"webgl",kernelFunc:MK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LK{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ff(s){const{backend:e,attrs:t}=s,{shape:n,value:r}=t;let{dtype:a}=t;if(a=a||bh(r),a==="string"){const o=ba(a,hn(n));return o.fill(r),e.makeTensorInfo(n,a,o)}else{const o=new LK(n,r),i=[[r]];return e.runWebGLProgram(o,[],a,i)}}const BK={kernelName:Iy,backendName:"webgl",kernelFunc:Ff};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zK{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WK={kernelName:Cy,backendName:"webgl",kernelFunc:({inputs:s,backend:e})=>{const{image:t}=s,n=e,r=new zK(t.shape);return n.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2="return floor(x);",VK=vr({opSnippet:_2,packedOpSnippet:_2,cpuKernelImpl:lH}),UK={kernelName:Op,backendName:"webgl",kernelFunc:VK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jK=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,GK=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,HK=po({opSnippet:jK,packedOpSnippet:GK,dtype:"int32"}),qK={kernelName:Fp,backendName:"webgl",kernelFunc:HK};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KK{constructor(e){this.variableNames=["A"];const t=zo(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XK{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=zo(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YK={kernelName:SE,backendName:"webgl",kernelFunc:ZK};let jd,s0=nn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function ZK(s){const{inputs:e,backend:t,attrs:n}=s;let{pixels:r}=e;const{numChannels:a}=n,o=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,[u,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,u],h=[c,u,a];if(i||o){const x=nn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(jd==null||x!==s0)&&(s0=x,jd=document.createElement("canvas").getContext("2d",{willReadFrequently:s0})),jd.canvas.width=u,jd.canvas.height=c,jd.drawImage(r,0,0,u,c),r=jd.canvas}const l=t.makeTensorInfo(d,"int32");t.texData.get(l.dataId).usage=qi.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(l.dataId),r);const p=nn().getBool("WEBGL_PACK")?new XK(h):new KK(h),f=t.runWebGLProgram(p,[l],"int32");return t.disposeData(l.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QK(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:l,activation:p,leakyreluAlpha:f}=n,x=Hc(d),b=lo(r.shape,a.shape,u,h,c,l,!1,x);let m;const I=[],N=o!=null,E=i!=null,D=p==="leakyrelu",U=()=>{const Y=[r,a],V=(P,oe)=>{if(oe==="NCHW"&&P.shape.length===1&&P.shape[0]!==1){const ne=Yn({inputs:{x:P},backend:t,attrs:{shape:[P.shape[0],1,1]}});return I.push(ne),ne}return P};if(N&&Y.push(V(o,d)),E&&Y.push(V(i,d)),D){const P=t.makeTensorInfo([],"float32",_l(f,"float32"));Y.push(P),I.push(P)}return Y};if(b.filterHeight===1&&b.filterWidth===1&&b.dilationHeight===1&&b.dilationWidth===1&&b.strideHeight===1&&b.strideWidth===1&&(b.padInfo.type==="SAME"||b.padInfo.type==="VALID"))m=mN({x:r,filter:a,convInfo:b,backend:t,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else if(b.strideWidth<=2&&x==="channelsLast"&&nn().getBool("WEBGL_EXP_CONV")){const Y=p?dp(p,!0):null,V=new fN(b,N,Y,E,D),P=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],oe=U();m=t.runWebGLProgram(V,oe,"float32",P)}else if(nn().getBool("WEBGL_CONV_IM2COL"))m=gN({x:r,filter:a,convInfo:b,backend:t,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const Y=p?dp(p,!1):null,V=new pN(b,N,Y,E,D),P=U();m=t.runWebGLProgram(V,P,"float32")}const L=Yn({inputs:{x:m},backend:t,attrs:{shape:b.outShape}});return I.push(m),I.forEach(Y=>t.disposeIntermediateTensorInfo(Y)),L}const JK={kernelName:Tm,backendName:"webgl",kernelFunc:QK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:c,dilations:d,dimRoundingMode:h,activation:l,leakyreluAlpha:p}=n,f=[];let x=d;x==null&&(x=[1,1]),ze(Co(u,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${x}'`);const b=lo(r.shape,a.shape,u,x,c,h,!0),m=nn().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,I=l?dp(l,m):null,N=[r,a],E=o!=null,D=i!=null,U=l==="leakyrelu";if(E&&N.push(o),D&&N.push(i),U){const P=t.makeTensorInfo([],"float32",_l(p,"float32"));N.push(P),f.push(P)}let L;m?L=new yN(b,E,I,D,U):L=new xN(b,E,I,D,U);const Y=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],V=t.runWebGLProgram(L,N,"float32",Y);return f.forEach(P=>t.disposeIntermediateTensorInfo(P)),V}const tX={kernelName:bI,backendName:"webgl",kernelFunc:eX};class nX{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=Mr(n.length);let o=`
    int index;`;for(let i=0;i<this.sliceDim;i++)o+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sX(s){const{inputs:e,backend:t}=s,{params:n,indices:r}=e,a=r.shape,o=a[a.length-1],i=hn(n.shape),[u,c,d,h]=_w(n,r),l=Yn({inputs:{x:r},backend:t,attrs:{shape:[c,o]}}),p=Yn({inputs:{x:n},backend:t,attrs:{shape:[hn(n.shape)/d,d]}});if(t.shouldExecuteOnCPU([n,r])||n.dtype==="string"){const m=t.readSync(r.dataId),I=t.bufferSync(n),N=dH(m,I,n.dtype,c,o,d,h,n.shape,i);return t.makeTensorInfo(u,n.dtype,N.values)}const f=new nX(o,h,[c,d],n.shape),x=t.runWebGLProgram(f,[p,l],p.dtype),b=Yn({inputs:{x},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(x),b}const rX={kernelName:J2,backendName:"webgl",kernelFunc:sX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aX{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=Mr(this.rank),r=oX(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function oX(s,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<s.length;r++)r===2?n.push("index"):n.push(`${t[r]}`);return n.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,indices:a}=e,{axis:o,batchDims:i}=n,u=nr(o,r.shape)[0];if(nn().get("DEBUG")){const I=t.readSync(a.dataId),N=r.shape[u];for(let E=0;E<I.length;++E){const D=I[E];ze(D<=N-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${N-1}]`)}}const c=Xw(r,a,u,i),d=hn(a.shape),h=[],l=Yn({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Yn({inputs:{x:a},backend:t,attrs:{shape:[c.batchSize,d/c.batchSize]}});h.push(l),h.push(p);const f=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const I=t.bufferSync(p),N=t.bufferSync(l),E=hH(N,I,f);return h.forEach(D=>t.disposeIntermediateTensorInfo(D)),t.makeTensorInfo(c.outputShape,E.dtype,E.values)}const x=new aX(l.shape,f),b=t.runWebGLProgram(x,[l,p],l.dtype);h.push(b);const m=Yn({inputs:{x:b},backend:t,attrs:{shape:c.outputShape}});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),m}const iX={kernelName:vg,backendName:"webgl",kernelFunc:kN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uX="return float(a > b);",cX=`
  return vec4(greaterThan(a, b));
`,lX=po({opSnippet:uX,packedOpSnippet:cX,cpuKernelImpl:pH,dtype:"bool"}),dX={kernelName:kg,backendName:"webgl",kernelFunc:lX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hX="return float(a >= b);",pX=`
  return vec4(greaterThanEqual(a, b));
`,fX=po({opSnippet:hX,packedOpSnippet:pX,dtype:"bool",cpuKernelImpl:fH}),mX={kernelName:Dp,backendName:"webgl",kernelFunc:fX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(s){const{inputs:e,backend:t}=s,{input:n}=e;return vN(n,!0,t)}const bX={kernelName:_y,backendName:"webgl",kernelFunc:gX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xX="return float(!isnan(x) && !isinf(x));",yX=vr({opSnippet:xX,dtype:"bool"}),wX={kernelName:Pp,backendName:"webgl",kernelFunc:yX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX="return float(isinf(x));",kX=vr({opSnippet:vX,dtype:"bool"}),IX={kernelName:Lp,backendName:"webgl",kernelFunc:kX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CX="return float(isnan(x));",_X=vr({opSnippet:CX,dtype:"bool"}),SX={kernelName:Bp,backendName:"webgl",kernelFunc:_X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X="return float(a < b);",TX=`
  return vec4(lessThan(a, b));
`,NX=po({opSnippet:$X,packedOpSnippet:TX,cpuKernelImpl:mH,dtype:"bool"}),EX={kernelName:Cg,backendName:"webgl",kernelFunc:NX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX="return float(a <= b);",AX=`
  return vec4(lessThanEqual(a, b));
`,OX=po({opSnippet:RX,packedOpSnippet:AX,cpuKernelImpl:gH,dtype:"bool"}),FX={kernelName:_g,backendName:"webgl",kernelFunc:OX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DX(s){const{backend:e,attrs:t}=s,{start:n,stop:r,num:a}=t,o=bH(n,r,a);return e.makeTensorInfo([o.length],"float32",o)}const MX={kernelName:eI,backendName:"webgl",kernelFunc:DX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PX=Eh+`
  return x < 0.0 ? 0./0. : log(x);
`,LX=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,BX=vr({opSnippet:PX,packedOpSnippet:LX,cpuKernelImpl:xH}),zX={kernelName:zp,backendName:"webgl",kernelFunc:BX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WX=Eh+`
  return log(1.0 + x);
`,VX=vr({opSnippet:WX}),UX={kernelName:Wp,backendName:"webgl",kernelFunc:VX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jX="return float(a >= 1.0 && b >= 1.0);",GX=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,HX=po({opSnippet:jX,packedOpSnippet:GX,dtype:"bool"}),qX={kernelName:Sg,backendName:"webgl",kernelFunc:HX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KX="return float(!(x >= 1.0));",XX=vr({opSnippet:KX}),YX={kernelName:$g,backendName:"webgl",kernelFunc:XX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZX="return float(a >= 1.0 || b >= 1.0);",QX=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,JX=po({opSnippet:ZX,packedOpSnippet:QX,dtype:"bool"}),e7={kernelName:Tg,backendName:"webgl",kernelFunc:JX};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t7{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${n}) + float(${r}) * sum`;a===.5?u=`inversesqrt(${c})`:a===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n7{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;this.outputShape=e;let u;const c=`float(${n}) + float(${r}) * sum`;a===.5?u=`inversesqrt(${c})`:a===1?u=`1.0/(${c})`:u=`exp(log(${c}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s7=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{depthRadius:a,bias:o,alpha:i,beta:u}=n,c=nn().getBool("WEBGL_PACK_NORMALIZATION")?new n7(r.shape,a,o,i,u):new t7(r.shape,a,o,i,u);return t.runWebGLProgram(c,[r],r.dtype)},r7={kernelName:Ng,backendName:"webgl",kernelFunc:s7};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a7{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o7=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:r,y:a,dy:o}=e,{depthRadius:i,bias:u,alpha:c,beta:d}=n,h=new a7(r.shape,i,u,c,d);return t.runWebGLProgram(h,[r,a,o],r.dtype)},i7={kernelName:$y,backendName:"webgl",kernelFunc:o7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7(s,e,t,n){const r=hn(e),o=hn(s.shape)/r,i=Yn({inputs:{x:s},attrs:{shape:[o,r]},backend:n}),u=Md(i,s.dtype,"max",n),c=Yn({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{reductionIndices:a,keepDims:o}=n,i=r.shape.length,u=nr(a,r.shape);let c=u;const d=ha(c,i),h=d!=null,l=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(l){const N=t.texData.get(p.dataId).values,E=new Array(i);for(let L=0;L<E.length;L++)E[L]=r.shape[d[L]];const D=Rv(N,r.shape,r.dtype,d,E);p=t.makeTensorInfo(E,r.dtype);const U=t.texData.get(p.dataId);U.values=D}else p=Eb(r,d,t);c=wa(c.length,i)}ho("max",c,i);const[f,x]=Ja(p.shape,c);let b=f;o&&(b=$a(f,u));let m;if(l){const N=t.texData.get(p.dataId).values,E=yH(N,hn(x),b,r.dtype);m=t.makeTensorInfo(b,r.dtype);const D=t.texData.get(m.dataId);D.values=E}else m=u7(p,x,b,t);return h&&t.disposeIntermediateTensorInfo(p),m}const c7={kernelName:Eg,backendName:"webgl",kernelFunc:IN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l7=Av+`
  return max(a, b);
`,d7=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dd+`
  return result;
`,h7=po({opSnippet:l7,packedOpSnippet:d7,cpuKernelImpl:wH}),p7={kernelName:Vp,backendName:"webgl",kernelFunc:h7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e;Ef(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=n,c=1;ze(Co(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Cu(r.shape,a,o,c,i,u);if(d.filterWidth===1&&d.filterHeight===1&&Er(d.inShape,d.outShape))return Ii({inputs:{x:r},backend:t});const h=new hp(d,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const m7={kernelName:Rg,backendName:"webgl",kernelFunc:f7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{filterSize:a,strides:o,pad:i,dataFormat:u,dimRoundingMode:c}=n,d=[1,1,1],h=Gc(r.shape,a,o,d,i,c,u),l=new Fv(h,"max",!1);return t.runWebGLProgram(l,[r],r.dtype)}const b7={kernelName:Ag,backendName:"webgl",kernelFunc:g7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x7{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=a-1-e.padInfo.top,u=o-1-e.padInfo.left,c=a*o-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class y7{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=u-1-e.padInfo.front,l=c-1-e.padInfo.top,p=d-1-e.padInfo.left,f=u*c*d-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w7(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a}=e,o=a,{filterSize:i,strides:u,pad:c,dimRoundingMode:d}=n,h=[1,1,1],l=Gc(o.shape,i,u,h,c,d),p=new Fv(l,"max",!0),f=t.runWebGLProgram(p,[o],o.dtype),x=new y7(l),b=t.runWebGLProgram(x,[r,f],o.dtype);return t.disposeIntermediateTensorInfo(f),b}const v7={kernelName:Ny,backendName:"webgl",kernelFunc:w7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k7(s){const{inputs:e,backend:t,attrs:n}=s,{dy:r,input:a,output:o}=e,i=a;Ef([a,o],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:h}=n,l=Cu(i.shape,u,c,1,d,h),p=!0,f=new hp(l,"max",p),x=t.runWebGLProgram(f,[i],i.dtype),b=new x7(l),m=t.runWebGLProgram(b,[r,x],i.dtype);return t.disposeIntermediateTensorInfo(x),m}const I7={kernelName:Ty,backendName:"webgl",kernelFunc:k7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7(s,e,t,n){let r=new hp(t,"max",!1);const a=n.runWebGLProgram(r,[s],"float32");r=new hp(t,"max",!0,!0,e);const o=n.runWebGLProgram(r,[s],"float32");return[a,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _7={kernelName:tI,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=e,u=t;ze(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);const c=[1,1];ze(Co(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=Cu(n.shape,r,a,c,o),[h,l]=C7(n,i,d,u);return[h,l]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(s,e,t,n){const r=hn(e),o=hn(s.shape)/r,i=Yn({inputs:{x:s},attrs:{shape:[o,r]},backend:n}),u=Md(i,"float32","mean",n),c=Yn({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $7={kernelName:Og,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{x:n}=s,{keepDims:r,axis:a}=e,o=t,i=n.shape.length,u=nr(a,n.shape);let c=u;const d=ha(c,i),h=d!=null,l=o.shouldExecuteOnCPU([n]),p=[];let f=n;if(h){if(l){const E=o.texData.get(f.dataId).values,D=new Array(i);for(let Y=0;Y<D.length;Y++)D[Y]=n.shape[d[Y]];const U=Rv(E,n.shape,n.dtype,d,D);f=o.makeTensorInfo(D,n.dtype);const L=o.texData.get(f.dataId);L.values=U}else f=Eb(n,d,o);p.push(f),c=wa(c.length,i)}ho("sum",c,i);const[x,b]=Ja(f.shape,c);let m=x;r&&(m=$a(x,u));const I=S7(f,b,m,o);for(const N of p)o.disposeIntermediateTensorInfo(N);return I}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n,i=r.shape.length,u=nr(a,r.shape);let c=u;const d=ha(c,i);let h=r;d!=null&&(h=Bo({inputs:{x:r},backend:t,attrs:{perm:d}}),c=wa(c.length,r.shape.length)),ho("min",c,i);const[l,p]=Ja(h.shape,c),f=hn(p),x=Yn({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),b=Md(x,x.dtype,"min",t);let m;if(o){const I=$a(l,u);m=Yn({inputs:{x:b},backend:t,attrs:{shape:I}})}else m=Yn({inputs:{x:b},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b),d!=null&&t.disposeIntermediateTensorInfo(h),m}const N7={kernelName:Fg,backendName:"webgl",kernelFunc:T7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E7=Av+`
  return min(a, b);
`,R7=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dd+`
  return result;
`,A7=po({opSnippet:E7,packedOpSnippet:R7,cpuKernelImpl:vH}),O7={kernelName:Up,backendName:"webgl",kernelFunc:A7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F7{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);const r=e.length,a=Mr(r),o=t.map(d=>d[0]).join(","),i=t.map((d,h)=>d[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D7{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,x)=>f[0]+e[x]+f[1]);const r=e.length,a=Mr(r),o=t.map(f=>f[0]).join(","),i=t.map((f,x)=>f[0]+e[x]).join(","),u=Mo("rc",r),c=Mo("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,l=n==="reflect"?0:1;let p="";if(r===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${l};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${l};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${u[r-1]} += 1;
        if(${d}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${l}) +
                gte * ((end - 1) * 2 - source + ${l});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${u[r-1]} += 1;
        if(${d}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${u[r-1]} += 1;
          if(${d}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M7=({inputs:s,backend:e,attrs:t})=>{const{x:n}=s,{paddings:r,mode:a}=t,o=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new D7(n.shape,r,a):new F7(n.shape,r,a);return e.runWebGLProgram(o,[n],n.dtype)},P7={kernelName:Dg,backendName:"webgl",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L7=`if (b == 0.0) return NAN;
  return mod(a, b);`,B7=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Dd+`
  return result;
`,z7=po({opSnippet:L7,packedOpSnippet:B7}),W7={kernelName:jp,backendName:"webgl",kernelFunc:z7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V7{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U7=`
if (a == b) {
  return 1.0;
};
return a / b;`,j7=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,CN=po({opSnippet:U7,packedOpSnippet:j7,checkOutOfBounds:!0}),G7={kernelName:Tp,backendName:"webgl",kernelFunc:CN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2="return a - b;",_N=po({opSnippet:S2,packedOpSnippet:S2,supportsComplex:!0,cpuKernelImpl:VH}),H7={kernelName:of,backendName:"webgl",kernelFunc:_N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(s){const{inputs:e,backend:t,attrs:n}=s,{logits:r}=e,{dim:a}=n,o=nr([a],r.shape),i=IN({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),u=$a(i.shape,o),c=Yn({inputs:{x:i},backend:t,attrs:{shape:u}}),d=_N({inputs:{a:r,b:c},backend:t}),h=wN({inputs:{x:d},backend:t}),l=Rb({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=Yn({inputs:{x:l},backend:t,attrs:{shape:u}}),f=CN({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),f}const q7={kernelName:Jg,backendName:"webgl",kernelFunc:SN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(s){const{inputs:e,backend:t,attrs:n}=s,{logits:r}=e,{numSamples:a,seed:o,normalized:i}=n,u=i?r:SN({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=u.shape[0],d=u.shape[1],h=new V7(c,d,a),l=[[o]],p=t.runWebGLProgram(h,[u],"int32",l);return i||t.disposeIntermediateTensorInfo(u),p}const X7={kernelName:nI,backendName:"webgl",kernelFunc:K7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y7=Su+`
  return -x;
`,Z7=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Q7(s){const{inputs:e,backend:t}=s,{x:n}=e;if(t.shouldExecuteOnCPU([n])){const a=t.texData.get(n.dataId),[o,i]=IH(a.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,o)}let r;return nn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new hl(n.shape,Z7):r=new hc(n.shape,Y7),t.runWebGLProgram(r,[n],n.dtype)}const J7={kernelName:Mg,backendName:"webgl",kernelFunc:Q7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e9=yw;function t9(s){Gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=n,c=t.readSync(r.dataId),d=t.readSync(a.dataId),{selectedIndices:h}=e9(c,d,o,i,u);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const n9={kernelName:Ey,backendName:"webgl",kernelFunc:t9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s9=ww;function r9(s){Gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:c}=n,d=t.readSync(r.dataId),h=t.readSync(a.dataId),{selectedIndices:l,validOutputs:p}=s9(d,h,o,i,u,c);return[t.makeTensorInfo([l.length],"int32",new Int32Array(l)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const a9={kernelName:Ry,backendName:"webgl",kernelFunc:r9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o9=vw;function i9(s){Gi("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:n}=s,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:c}=n,d=t.readSync(r.dataId),h=t.readSync(a.dataId),l=o,p=i,f=u,x=c,{selectedIndices:b,selectedScores:m}=o9(d,h,l,p,f,x);return[t.makeTensorInfo([b.length],"int32",new Int32Array(b)),t.makeTensorInfo([m.length],"float32",new Float32Array(m))]}const u9={kernelName:Ay,backendName:"webgl",kernelFunc:i9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c9{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l9=s=>{const{inputs:e,backend:t,attrs:n}=s,{indices:r}=e,{dtype:a,depth:o,onValue:i,offValue:u}=n,c=hn(r.shape),d=new c9(c,o,i,u),h=Yn({inputs:{x:r},backend:t,attrs:{shape:[c]}}),l=t.runWebGLProgram(d,[h],a);t.disposeIntermediateTensorInfo(h);const p=[...r.shape,o],f=Yn({inputs:{x:l},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(l),f},d9={kernelName:Bg,backendName:"webgl",kernelFunc:l9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tg(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="complex64"){const r=Of({inputs:{input:n},backend:t}),a=tg({inputs:{x:r},backend:t}),o=Ab({inputs:{input:n},backend:t}),i=tg({inputs:{x:o},backend:t}),u=Al({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Ff({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}const h9={kernelName:nb,backendName:"webgl",kernelFunc:tg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(s){const{inputs:e,backend:t}=s,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){const r=Of({inputs:{input:n},backend:t}),a=$N({inputs:{x:r},backend:t}),o=Ab({inputs:{input:n},backend:t}),i=tg({inputs:{x:o},backend:t}),u=Al({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Ff({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}const p9={kernelName:Lg,backendName:"webgl",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f9(s){const{inputs:e,backend:t,attrs:n}=s,{axis:r}=n;if(e.length===1)return K0({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,o=e[0].dtype;e.forEach(d=>{ty(a,d.shape,"All tensors passed to stack must have matching shapes"),ze(o===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(d=>{const h=K0({inputs:{input:d},backend:t,attrs:{dim:r}});return i.push(h),h}),c=hN({inputs:u,backend:t,attrs:{axis:r}});return i.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}const m9={kernelName:zg,backendName:"webgl",kernelFunc:f9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g9{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,d)=>c[0]+e[d]+c[1]);const r=e.length,a=Mr(r),o=t.map(c=>c[0]).join(","),i=t.map((c,d)=>c[0]+e[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b9{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((x,b)=>x[0]+e[b]+x[1]);const r=e.length,a=Mr(r),o=t.map(x=>x[0]).join(","),i=t.map((x,b)=>x[0]+e[b]).join(","),u=Mo("rc",r),c=Mo("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,l=[`${a} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${d}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${d}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let x=0,b=r===1?2:4;x<b;x++)f+=`
        ${l[x]}
        if (${p}) {
          result[${x}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TN=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{paddings:a,constantValue:o}=n;if(hn(r.shape)===0){const c=a.map((d,h)=>d[0]+r.shape[h]+d[1]);return Ff({backend:t,attrs:{shape:c,value:o,dtype:r.dtype}})}const i=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b9(r.shape,a,o):new g9(r.shape,a,o),u=[[o]];return t.runWebGLProgram(i,[r],r.dtype,u)},x9={kernelName:Wg,backendName:"webgl",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y9=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,w9=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Dd+`
  return result;
`,v9=po({opSnippet:y9,packedOpSnippet:w9}),k9={kernelName:Hp,backendName:"webgl",kernelFunc:v9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{axis:a,keepDims:o}=n,i=r.shape.length,u=[],c=nr(a,r.shape);let d=c;const h=ha(d,i);let l=r;h!=null&&(l=Bo({inputs:{x:r},backend:t,attrs:{perm:h}}),d=wa(d.length,i),u.push(l)),ho("prod",d,i);let p;if(t.shouldExecuteOnCPU([l])){const f=t.texData.get(l.dataId).values,{outVals:x,outShape:b,outDtype:m}=_H(l.shape,l.dtype,f,d);p=t.makeTensorInfo(b,m,x)}else{const[f,x]=Ja(l.shape,d),b=hn(x),m=Yn({inputs:{x:l},backend:t,attrs:{shape:[-1,b]}}),I=Gy(r.dtype),N=Md(m,I,"prod",t);p=Yn({inputs:{x:N},backend:t,attrs:{shape:f}}),u.push(m),u.push(N)}if(o){u.push(p);const f=$a(p.shape,c);p=Yn({inputs:{x:p},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const C9={kernelName:Ug,backendName:"webgl",kernelFunc:I9};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _9(s){const{inputs:e,backend:t,attrs:n}=s,{paramsNestedSplits:r,paramsDenseValues:a,indices:o}=e,{outputRaggedRank:i}=n,u=r.map(m=>t.readSync(m.dataId)),c=r.map(m=>m.shape),d=t.readSync(a.dataId),h=t.readSync(o.dataId),[l,p,f]=SH(u,c,d,a.shape,a.dtype,h,o.shape,i),x=l.map(m=>t.makeTensorInfo([m.length],"int32",m)),b=t.makeTensorInfo(f,a.dtype,p);return x.concat([b])}const S9={kernelName:sI,backendName:"webgl",kernelFunc:_9};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(s){const{inputs:e,backend:t}=s,{starts:n,limits:r,deltas:a}=e,o=t.readSync(n.dataId),i=t.readSync(r.dataId),u=t.readSync(a.dataId),[c,d]=$H(o,n.shape,n.dtype,i,r.shape,u,a.shape),h=t.makeTensorInfo([c.length],"int32",c),l=t.makeTensorInfo([d.length],n.dtype,d);return[h,l]}const T9={kernelName:rI,backendName:"webgl",kernelFunc:$9};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9(s){const{inputs:e,backend:t,attrs:n}=s,{shape:r,values:a,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,c=t.readSync(r.dataId),d=t.readSync(a.dataId),h=t.readSync(o.dataId),l=i.map(b=>t.readSync(b.dataId)),p=i.map(b=>b.shape),[f,x]=TH(c,r.shape,d,a.shape,a.dtype,h,o.shape,l,p,u);return t.makeTensorInfo(f,a.dtype,x)}const E9={kernelName:aI,backendName:"webgl",kernelFunc:N9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NN=s=>{const{backend:e,attrs:t}=s,{start:n,stop:r,step:a,dtype:o}=t,i=NH(n,r,a,o);return e.makeTensorInfo([i.length],o,i)},R9={kernelName:Oy,backendName:"webgl",kernelFunc:NN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A9="return 1.0 / x;",O9=vr({opSnippet:A9}),F9={kernelName:qp,backendName:"webgl",kernelFunc:O9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D9=Su+`
  return (x < 0.0) ? 0.0 : x;
`,M9=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,P9=vr({opSnippet:D9,packedOpSnippet:M9}),L9={kernelName:Kp,backendName:"webgl",kernelFunc:P9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B9=Su+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,z9=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,W9=vr({opSnippet:B9,packedOpSnippet:z9}),V9={kernelName:Xp,backendName:"webgl",kernelFunc:W9};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U9{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,u,c]=e;this.outputShape=[o,t,n,c];const d=[r&&t>1?i-1:i,r&&n>1?u-1:u],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];let l;a?l="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":l="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/h[0]},
          ${d[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${l};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j9{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,c]=e;this.outputShape=[o,t,n,c];const d=[r&&t>1?i-1:i,r&&n>1?u-1:u],h=[r&&t>1?t-1:t,r&&n>1?n-1:n];let l;a?l="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":l="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/h[0]},
          ${d[1]/h[1]},
          ${d[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${l};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G9(s){const{inputs:e,backend:t,attrs:n}=s,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=n,[u,c]=i,d=nn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new j9(r.shape,u,c,a,o):new U9(r.shape,u,c,a,o);return t.runWebGLProgram(d,[r],"float32")}const H9={kernelName:Hg,backendName:"webgl",kernelFunc:G9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q9{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,u=[n&&o>1?r-1:r,n&&i>1?a-1:a],c=[n&&o>1?o-1:o,n&&i>1?i-1:i],d=u[0]/c[0],h=u[1]/c[1],l=1/d,p=1/h,f=Math.ceil(l)*2+2,x=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${h});

        const float invHeightScale = float(${l});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K9(s){const{inputs:e,backend:t,attrs:n}=s,{images:r,dy:a}=e,{alignCorners:o}=n,i=new q9(a.shape,r.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const X9={kernelName:My,backendName:"webgl",kernelFunc:K9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y9{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,u,c]=e;this.outputShape=[o,t,n,c];const d=[r&&t>1?i-1:i,r&&n>1?u-1:u],h=[r&&t>1?t-1:t,r&&n>1?n-1:n],l=r?"0.5":"0.0";let p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/h[0]},
          ${d[1]/h[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${l})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z9{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,c]=e;this.outputShape=[o,t,n,c];const d=[r&&t>1?i-1:i,r&&n>1?u-1:u],h=[r&&t>1?t-1:t,r&&n>1?n-1:n],l=r?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/h[0]},
          ${d[1]/h[1]},
          ${d[1]/h[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${l})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q9(s){const{inputs:e,backend:t,attrs:n}=s,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=n,[u,c]=i,d=nn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Z9(r.shape,u,c,a,o):new Y9(r.shape,u,c,a,o);return t.runWebGLProgram(d,[r],r.dtype)}const J9={kernelName:Gg,backendName:"webgl",kernelFunc:Q9};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eY{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,u=[n&&o>1?r-1:r,n&&i>1?a-1:a],c=[n&&o>1?o-1:o,n&&i>1?i-1:i],d=u[0]/c[0],h=u[1]/c[1],l=1/d,p=1/h,f=Math.ceil(l)*2+2,x=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${h});

        const float invHeightScale = float(${l});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tY(s){const{inputs:e,backend:t,attrs:n}=s,{images:r,dy:a}=e,{alignCorners:o}=n,i=new eY(a.shape,r.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const nY={kernelName:Dy,backendName:"webgl",kernelFunc:tY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sY{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,u)=>r(u)).join(","),o=Mr(n);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rY{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Mo("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Mr(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${a}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${d(r.slice())};
            if(${a}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return l(f)}function c(f){return f[n-1]="("+f[n-1]+" + 1)",l(f)}function d(f){return f[n-2]="("+f[n-2]+" + 1)",l(f)}function h(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",l(f)}function l(f){const x=e.map((I,N)=>p(N,f)),b=x.join(","),m=x.slice(-2).join(",");return`getChannel(getX(${b}), vec2(${m}))`}function p(f,x){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${x[f]} - 1`:`${x[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{dims:a}=n,o=r.shape.length,i=nr(a,r.shape);if(o===0)return Ii({inputs:{x:r},backend:t});const u=nn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rY(r.shape,i):new sY(r.shape,i);return t.runWebGLProgram(u,[r],r.dtype)}const oY={kernelName:qg,backendName:"webgl",kernelFunc:aY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iY{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uY={kernelName:Uy,backendName:"webgl",kernelFunc:({inputs:s,attrs:e,backend:t})=>{const{image:n}=s,{radians:r,fillValue:a,center:o}=e,i=t,u=new iY(n.shape,a),[c,d]=Ow(o,n.shape[1],n.shape[2]),h=[[c,d,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(u,[n],n.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cY=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,lY=vr({opSnippet:cY}),dY={kernelName:Yp,backendName:"webgl",kernelFunc:lY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hY="return inversesqrt(x);",pY=vr({opSnippet:hY,cpuKernelImpl:EH}),fY={kernelName:Zp,backendName:"webgl",kernelFunc:pY};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dv{constructor(e,t,n,r,a,o,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Mr(a.length),d=Mr(o.length);let h="";n===1?h="i":n===2&&(h="i, j");const l=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let x="";u&&(x="coords[0], coords[1]");const b=`getDefaultValue(${x})`,m=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${l});
              flattenedIndex += index * ${m};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${b}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mY{constructor(e,t,n,r,a,o,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Mr(a.length),d=Mr(o.length);let h="";n===1?h="i":n===2&&(h="i, j");const l=`getIndices(${h})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let x="";u&&(x="coords[0], coords[1]");const b=`getDefaultValue(${x})`,m=t>1?"strides[j]":"strides",I=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${l});
              flattenedIndex += index.xz * ${m};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${I};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${b}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gY(s){const{inputs:e,backend:t,attrs:n}=s,{indices:r,updates:a}=e,{shape:o}=n,{sliceRank:i,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Ed(a,r,o),l=[h/c,c];if(h===0)return t.makeTensorInfo(o,r.dtype);const p=Yn({inputs:{x:r},backend:t,attrs:{shape:[u,i]}}),f=Yn({inputs:{x:a},backend:t,attrs:{shape:[u,c]}}),x=t.makeTensorInfo([],"float32",new Float32Array([0]));let b;nn().getBool("WEBGL_PACK")?b=new mY(u,i,p.shape.length,f.shape.length,d,l):b=new Dv(u,i,p.shape.length,f.shape.length,d,l);const m=t.runWebGLProgram(b,[f,p,x],f.dtype),I=Yn({inputs:{x:m},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),I}const bY={kernelName:oI,backendName:"webgl",kernelFunc:gY};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xY{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=nn().getNumber("WEBGL_VERSION")===2?a:o,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(s){const{inputs:e,backend:t,attrs:n}=s,{sortedSequence:r,values:a}=e,{side:o}=n,i=new xY(r.shape[0],r.shape[1],a.shape[1],o),u=[[r.shape[1]]];return t.runWebGLProgram(i,[r,a],"int32",u)}const wY={kernelName:uI,backendName:"webgl",kernelFunc:yY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vY{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let d=0;d<t.length;d++)c.push(`${i[d]}`),d<e&&u.push(`${i[d]}`);r=u.join(),a=c.join()}const o=Mr(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(s){const{inputs:e,backend:t}=s,{condition:n,t:r,e:a}=e,o=new vY(n.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[n,r,a],vi(r.dtype,a.dtype))}const IY={kernelName:Kg,backendName:"webgl",kernelFunc:kY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CY=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${fb};
  float scale = ${mb};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,_Y=vr({opSnippet:CY}),SY={kernelName:Qp,backendName:"webgl",kernelFunc:_Y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Y=Eh+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,TY=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,NY=vr({opSnippet:$Y,packedOpSnippet:TY,cpuKernelImpl:AH}),EY={kernelName:nf,backendName:"webgl",kernelFunc:NY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RY=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,AY=vr({opSnippet:RY}),OY={kernelName:tf,backendName:"webgl",kernelFunc:AY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FY=Eh+`
  return sin(x);
`,DY=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Dd}
  return result;
`,MY=vr({opSnippet:FY,packedOpSnippet:DY}),PY={kernelName:Jp,backendName:"webgl",kernelFunc:MY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LY=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,BY=vr({opSnippet:LY}),zY={kernelName:ef,backendName:"webgl",kernelFunc:BY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WY=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,VY=vr({opSnippet:WY}),UY={kernelName:sf,backendName:"webgl",kernelFunc:VY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jY=s=>{const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{blockShape:a,paddings:o}=n;ze(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((m,I)=>m*I),u=[[0,0]];u.push(...o);for(let m=1+a.length;m<r.shape.length;++m)u.push([0,0]);const c=[],d=TN({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),h=bf(d.shape,a,i,!1),l=xf(h.length,a.length,!1),p=yf(d.shape,a,i,!1),f=Yn({inputs:{x:d},backend:t,attrs:{shape:h}}),x=Bo({inputs:{x:f},backend:t,attrs:{perm:l}}),b=Yn({inputs:{x},backend:t,attrs:{shape:p}});return c.push(d),c.push(f),c.push(x),c.forEach(m=>t.disposeIntermediateTensorInfo(m)),b},GY={kernelName:Zg,backendName:"webgl",kernelFunc:jY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HY(s){const{inputs:e,backend:t}=s,{indices:n,values:r,denseShape:a,defaultValue:o}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=t.readSync(n.dataId),u=t.readSync(r.dataId),c=t.readSync(a.dataId),d=t.readSync(o.dataId)[0],[h,l,p,f,x]=FH(i,n.shape,n.dtype,u,r.dtype,c,d);return[t.makeTensorInfo(l,n.dtype,h),t.makeTensorInfo([l[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(b=>Number(b)))),t.makeTensorInfo([x.length],n.dtype,new Int32Array(x))]}const qY={kernelName:cI,backendName:"webgl",kernelFunc:HY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KY(s){const{inputs:e,backend:t}=s,{inputIndices:n,inputShape:r,newShape:a}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(t.readSync(r.dataId)),i=t.readSync(n.dataId),u=Array.from(t.readSync(a.dataId)),[c,d,h]=DH(i,n.shape,n.dtype,o,u);return[t.makeTensorInfo(d,n.dtype,c),t.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}const XY={kernelName:lI,backendName:"webgl",kernelFunc:KY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(s){const{inputs:e,backend:t}=s,{data:n,indices:r,segmentIds:a}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const o=t.readSync(n.dataId),i=t.readSync(r.dataId),u=t.readSync(a.dataId),[c,d]=JT(o,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(d,n.dtype,c)}const ZY={kernelName:dI,backendName:"webgl",kernelFunc:YY};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QY(s){const{inputs:e,backend:t}=s,{data:n,indices:r,segmentIds:a}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const o=t.readSync(n.dataId),i=t.readSync(r.dataId),u=t.readSync(a.dataId),[c,d]=JT(o,n.shape,n.dtype,i,u);return t.makeTensorInfo(d,n.dtype,c)}const JY={kernelName:hI,backendName:"webgl",kernelFunc:QY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eZ(s){const{inputs:e,backend:t,attrs:n}=s,{sparseIndices:r,sparseValues:a,defaultValue:o}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:l}=Ed(a,r,i),p=!1;if(a.dtype==="string"){const m=t.bufferSync(r),I=t.bufferSync(a),N=bl(t.readSync(o.dataId)[0]),E=RH(m,I,i,l,d,c,u,h,N,p);return t.makeTensorInfo(i,E.dtype,E.values)}const f=new Dv(c,u,r.shape.length,a.shape.length,h,[l,1],p),x=t.runWebGLProgram(f,[a,r,o],a.dtype),b=Yn({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(x),b}const tZ={kernelName:pI,backendName:"webgl",kernelFunc:eZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{numOrSizeSplits:a,axis:o}=n,i=nr(o,r.shape)[0],u=Kw(r,a,i),c=r.shape.length,d=new Array(c).fill(0),h=r.shape.slice();return u.map(l=>{const p=[...h];p[i]=l;const f=Rh({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});return d[i]+=l,f})}const sZ={kernelName:Qg,backendName:"webgl",kernelFunc:nZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $2="return sqrt(x);",rZ=vr({opSnippet:$2,packedOpSnippet:$2,cpuKernelImpl:MH}),aZ={kernelName:rf,backendName:"webgl",kernelFunc:rZ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oZ="return x * x;",iZ=vr({opSnippet:oZ}),uZ={kernelName:Py,backendName:"webgl",kernelFunc:iZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2="return (a - b) * (a - b);",cZ=po({opSnippet:T2,packedOpSnippet:T2}),lZ={kernelName:af,backendName:"webgl",kernelFunc:cZ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const a=t.readSync(r.dataId),o=Uc(a),i=PH(o,"string",n);return t.makeTensorInfo(r.shape,"string",i)}const hZ={kernelName:Ly,backendName:"webgl",kernelFunc:dZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pZ({inputs:s,attrs:e,backend:t}){const{x:n}=s,r=Su+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new hc(n.shape,r);return t.runWebGLProgram(a,[n],n.dtype)}const fZ={kernelName:df,backendName:"webgl",kernelFunc:pZ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mZ{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=Mr(n.length),o=Mr(n.length);let i="";if(r===1)i="coords * strides + begin";else{let u=0;i=n.map((c,d)=>(u++,n.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{begin:a,end:o,strides:i,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:l}=n,{finalShapeSparse:p,finalShape:f,isIdentity:x,sliceDim0:b,isSimpleSlice:m,begin:I,end:N,strides:E}=Ew(r.shape,a,o,i,u,c,d,h,l);let D;if(x)D=Yn({inputs:{x:r},backend:t,attrs:{shape:f}});else if(b||m){ze(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const L=$w(I,N,E),Y=Rh({inputs:{x:r},backend:t,attrs:{begin:I,size:L}});D=Yn({inputs:{x:Y},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(Y)}else if(t.shouldExecuteOnCPU([r])){const Y=t.readSync(r.dataId),V=tr(r.shape,r.dtype,Y),P=LH(p,V,E,I);D=t.makeTensorInfo(f,r.dtype,P.values)}else{const Y=new mZ(I,E,p);D=t.runWebGLProgram(Y,[r],r.dtype)}const U=Yn({inputs:{x:D},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(D),U}const bZ={kernelName:By,backendName:"webgl",kernelFunc:gZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(s){const{inputs:e,backend:t,attrs:n}=s,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:c}=n,{data:d,dataSplits:h}=e,l=t.readSync(d.dataId),p=t.readSync(h.dataId),[f,x]=BH(l,p,r,a,o,i,u,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",x)]}const yZ={kernelName:fI,backendName:"webgl",kernelFunc:xZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wZ(s){const{inputs:e,backend:t,attrs:n}=s,{skipEmpty:r}=n,{input:a,delimiter:o}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=t.readSync(a.dataId),u=t.readSync(o.dataId)[0],[c,d,h]=zH(i,u,r),l=d.length;return[t.makeTensorInfo([l,2],"int32",c),t.makeTensorInfo([l],"string",d),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const vZ={kernelName:mI,backendName:"webgl",kernelFunc:wZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(s){const{inputs:e,backend:t,attrs:n}=s,{numBuckets:r}=n,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(a.dataId),i=WH(o,r);return t.makeTensorInfo(a.shape,"int32",i)}const IZ={kernelName:gI,backendName:"webgl",kernelFunc:kZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CZ="return tan(x);",_Z=vr({opSnippet:CZ}),SZ={kernelName:uf,backendName:"webgl",kernelFunc:_Z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Z=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,TZ=vr({opSnippet:$Z}),NZ={kernelName:cf,backendName:"webgl",kernelFunc:TZ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(s){const{inputs:e,backend:t,attrs:n}=s,{tensor:r,indices:a,updates:o}=e,{sliceRank:i,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Ed(o,a,r.shape),l=[h/c,c];if(h===0)return t.makeTensorInfo(r.shape,a.dtype);const p=Yn({inputs:{x:a},backend:t,attrs:{shape:[u,i]}}),f=Yn({inputs:{x:o},backend:t,attrs:{shape:[u,c]}}),x=Yn({inputs:{x:r},backend:t,attrs:{shape:l}}),b=new Dv(u,i,p.shape.length,f.shape.length,d,l,!1,!0),m=t.runWebGLProgram(b,[f,p,x],x.dtype),I=Yn({inputs:{x:m},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(m),I}const RZ={kernelName:iI,backendName:"webgl",kernelFunc:EZ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AZ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const r=Mr(this.rank),a=OZ(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function OZ(s){const e=s.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${s[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let r=0;r<s.length;r++)n.push(`imod(${t[r]}, ${s[r]})`);return n.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{reps:a}=n;if(r.dtype==="string"||r.shape.length>5){const u=t.readSync(r.dataId),c=r.dtype==="string"?u.map(l=>bl(l)):u,d=tr(r.shape,r.dtype,c),h=UH(d,a);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new AZ(r.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const FZ={kernelName:lf,backendName:"webgl",kernelFunc:EN};class DZ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class MZ{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ql(s,e){e!==null&&s.disposeIntermediateTensorInfo(e)}function N2(s){let e=1;for(;e<s;)e*=2;return e}function PZ(s){const{inputs:e,backend:t,attrs:n}=s,{x:r}=e,{k:a,sorted:o}=n,i=nn().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=nn().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,d=c[c.length-1];if(t.shouldExecuteOnCPU([r])||d<i||a>u){const P=t.readSync(r.dataId),[oe,ne]=jH(P,c,r.dtype,a,o);return[t.makeTensorInfo(oe.shape,oe.dtype,oe.values),t.makeTensorInfo(ne.shape,ne.dtype,ne.values)]}if(a===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(d===1)return[r,Ff({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),l=h!==null&&h.isPacked,p=l?t.unpackTensor(r):r,x=hn(c)/d,b=Yn({inputs:{x:p},attrs:{shape:[x,d]},backend:t});l&&Ql(t,p);const m=N2(a),I=N2(d);let N=null;const E=()=>N===null?[b,b]:[b,N],D=(P,oe,ne)=>{const ge=E(),ye=new DZ(ne),X=[[d],[N===null?1:0],[Number.NEGATIVE_INFINITY],[P],[oe]],je=N;N=t.runWebGLProgram(ye,ge,"int32",X),Ql(t,je)};for(let P=1;P<m;P*=2){const oe=P*2;for(let ne=P;ne>=1;ne/=2)D(oe,ne,[x,I])}for(let P=I;P>m;P/=2){const oe=E(),ne=new MZ([x,P/2]),ye=[[d],[N===null?1:0],[m]],Ee=N;N=t.runWebGLProgram(ne,oe,"int32",ye),Ql(t,Ee);const X=m/2,je=X*2;for(let Be=X;Be>=1;Be/=2)D(je,Be,N.shape)}let U=N;N=Rh({inputs:{x:N},backend:t,attrs:{begin:0,size:[x,a]}}),Ql(t,U);let L=kN({inputs:{x:b,indices:N},backend:t,attrs:{axis:1,batchDims:1}});Ql(t,b);const Y=c.slice(0,-1);Y.push(a),U=N,N=Yn({inputs:{x:N},attrs:{shape:Y},backend:t}),Ql(t,U);const V=L;return L=Yn({inputs:{x:L},attrs:{shape:Y},backend:t}),Ql(t,V),[L,N]}const LZ={kernelName:zy,backendName:"webgl",kernelFunc:PZ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BZ{constructor(e,t,n,r,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i=n==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(s){const{inputs:e,backend:t,attrs:n}=s,{image:r,transforms:a}=e,{interpolation:o,fillMode:i,fillValue:u,outputShape:c}=n,[d,h,l,p]=r.shape,[f,x]=c!=null?c:[h,l],b=[d,f,x,p],m=new BZ(h,l,o,i,u,b);return t.runWebGLProgram(m,[r,a],"float32")}const WZ={kernelName:Wy,backendName:"webgl",kernelFunc:zZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(s){const{inputs:e,attrs:t,backend:n}=s,{axis:r}=t,{x:a}=e;Ef(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=n.readSync(a.dataId),{outputValues:i,outputShape:u,indices:c}=GH(o,r,a.shape,a.dtype);return[n.makeTensorInfo(u,a.dtype,i),n.makeTensorInfo([c.length],"int32",c)]}const UZ={kernelName:Vy,backendName:"webgl",kernelFunc:VZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(s){const{inputs:e,backend:t,attrs:n}=s,{value:r}=e;let{axis:a}=n;a<0&&(a+=r.shape.length);const o=r,i=o.shape.length,u=r.shape[a],c=new Array(i-1);let d=0;for(let x=0;x<i;x++)x!==a&&(c[d++]=o.shape[x]);const h=[],l=new Array(i).fill(0),p=o.shape.slice();p[a]=1;const f=new Array(u);for(let x=0;x<f.length;x++){l[a]=x;const b=Rh({inputs:{x:o},backend:t,attrs:{begin:l,size:p}}),m=Yn({inputs:{x:b},backend:t,attrs:{shape:c}});f[x]=m,h.push(b)}return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),f}const GZ={kernelName:eb,backendName:"webgl",kernelFunc:jZ};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HZ{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,o=e.numSegments,i=o*Math.ceil(a/n);this.outputShape=[r,i];const u="0.0",c="sumValue",d=Math.floor(n/4)*4,h=n%4,l=`
        sumValue += dot(values, segFilter);
    `;let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${l}
        }

        int inIdx = inOffset + ${d};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${l}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${l}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${l}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZ(s){const{inputs:e,backend:t,attrs:n}=s,{x:r,segmentIds:a}=e,{numSegments:o}=n,i=r.shape.length,u=[];let c=0;const d=ha([c],i);let h=r;d!=null&&(h=Bo({inputs:{x:r},backend:t,attrs:{perm:d}}),u.push(h),c=wa(1,i)[0]);const l=p_(h.shape,c,o),p=hn([h.shape[c]]),f=Yn({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});u.push(f);const x=Gy(r.dtype),b=(E,D,U,L,Y)=>{const V=E.shape[0],P=E.shape[1],oe=h_(P,Y),ne={windowSize:oe,inSize:P,batchSize:V,numSegments:Y},ge=new HZ(ne,D),ye=t.compileAndRun(ge,[E,U],L);if(u.push(ye),ye.shape[1]===Y)return ye;const Ee=NN({backend:t,attrs:{start:0,stop:Y,step:1,dtype:"float32"}}),X=EN({inputs:{x:Ee},backend:t,attrs:{reps:[P/oe]}});return u.push(Ee),u.push(X),b(ye,D,X,L,Y)},m=b(f,"unsortedSegmentSum",a,x,o),I=Yn({inputs:{x:m},backend:t,attrs:{shape:l}});let N=I;if(d!=null){u.push(I);const E=$l(d);N=Bo({inputs:{x:N},backend:t,attrs:{perm:E}})}return u.forEach(E=>t.disposeIntermediateTensorInfo(E)),N}const KZ={kernelName:tb,backendName:"webgl",kernelFunc:qZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ=[M5,L5,W5,j5,H5,X5,Z5,J5,sq,aq,uq,dq,fq,xq,vq,Iq,_q,Nq,Rq,Oq,Pq,jq,Hq,Kq,e8,n8,o8,y5,c8,f8,x8,C8,$8,N8,R8,O8,P8,z8,U8,G8,q8,X8,Q8,eK,rK,oK,cK,hK,fK,xK,kK,SK,NK,AK,OK,DK,PK,BK,WK,UK,qK,YK,JK,tX,rX,iX,dX,mX,x5,bX,h8,wX,IX,SX,v5,EX,FX,MX,zX,UX,qX,YX,e7,r7,i7,c7,p7,m7,b7,v7,I7,_7,$7,N7,O7,P7,W7,X7,C5,J7,n9,a9,u9,Yq,d9,p9,m9,x9,k9,I5,C9,S9,T9,E9,R9,Zq,G7,F9,L9,V9,S5,H9,X9,J9,nY,oY,uY,dY,fY,bY,wY,IY,SY,EY,OY,PY,zY,Vq,q7,UY,GY,qY,XY,ZY,JY,tZ,sZ,aZ,uZ,lZ,hZ,fZ,bZ,yZ,vZ,IZ,H7,O5,SZ,NZ,RZ,FZ,LZ,WZ,F5,UZ,GZ,KZ,h9];for(const s of XZ)xI(s);/** @license See the LICENSE file. *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YZ{constructor(e,t,n,r,a=0,o=[]){this.xmin=e,this.ymin=t,this.xmax=n,this.ymax=r,this.confidence=a,this.classes=o,this.label=-1,this.score=-1}getLabel(){if(this.label===-1){let e=0,t=0;for(let n=0;n<this.classes.length;++n)this.classes[n]>e&&(e=this.classes[n],t=n);this.label=t}return this.label}getScore(){return this.score===-1&&(this.score=this.classes[this.getLabel()]),this.score}}function ZZ(s,e,t){const{numClasses:n=20,numBoxes:r=5,gridHeight:a=13,gridWidth:o=13,objThreshold:i=.5,nmsThreshold:u=.3}=s,c=4+1+n;for(let m=0;m<a*o*r;++m)e[c*m+4]=r0(e[c*m+4]);const d=[],h=[];for(let m=0;m<a*o*r;++m){let I=e.slice((n+5)*m+5,(n+5)*(m+1));I=tQ(I);let N=!1;for(let E=0;E<n;++E){const D=e[c*m+4]*I[E];I[E]=0,D>i&&(I[E]=D,N=!0)}d.push(I),N&&h.push(m)}const l=[];h.forEach(m=>{const I=d[m],N=m%r,E=(m-N)/r%o,D=((m-N)/r-E)/o%a;let U=e[c*m+0],L=e[c*m+1],Y=e[c*m+2],V=e[c*m+3];U=(E+r0(U))/o,L=(D+r0(L))/a,Y=t[2*N+0]*Math.exp(Y)/o,V=t[2*N+1]*Math.exp(V)/a;const P=e[c*m+4],oe=new YZ(U-Y/2,L-V/2,U+Y/2,L+V/2,P,I);l.push(oe)});const p=[];let f=[];for(let m=0;m<n;++m){for(let I=0;I<l.length;++I)p[I]=[l[I],I];f=p.sort((I,N)=>N[0].classes[m]-I[0].classes[m]);for(let I=0;I<f.length;++I)if(f[I][0].classes[m]!==0)for(let N=I+1;N<f.length;++N)eQ(f[I][0],f[N][0])>=u&&(l[f[N][1]].classes[m]=0)}const x=[];l.forEach(m=>{m.getScore()>i&&x.push(m)});const b=[];for(let m=0;m<x.length;++m){if(Math.max(...x[m].classes)===0)continue;const I=x[m].getLabel(),N=x[m].score,E=(x[m].xmax+x[m].xmin)/2,D=(x[m].ymax+x[m].ymin)/2,U=x[m].xmax-x[m].xmin,L=x[m].ymax-x[m].ymin;b.push([I,E,D,U,L,N])}return b}function QZ(s,e){const t=[];for(let n=0;n<s.length;++n){const r=s[n][0],a=s[n][1],o=s[n][2],i=s[n][3],u=s[n][4],c=s[n][5],[d,h,l,p]=nQ(a,o,i,u,e);t.push([r,d,h,l,p,c])}return t}function JZ(s,e,t,n){const r=e.getContext("2d"),a=s.naturalWidth||s.width,o=s.naturalHeight||s.height;e.width=a/o*e.height,r.drawImage(s,0,0,e.width,e.height);const i=["#ff0000","#ffc107","#00b067","#704e99","#ff3860","#009bea"];t.forEach(u=>{const c=n[u[0]],d=u[1]*e.width,h=u[2]*e.width,l=u[3]*e.height,p=u[4]*e.height,f=u[5];r.strokeStyle=i[u[0]%i.length],r.fillStyle=i[u[0]%i.length],r.lineWidth=3,r.strokeRect(d,l,h-d,p-l),r.font="20px Arial";const x=`${c}: ${f.toFixed(2)}`,b=r.measureText(x).width;d>=2&&l>=parseInt(r.font,10)?(r.fillRect(d-2,l-parseInt(r.font,10),b+4,parseInt(r.font,10)),r.fillStyle="white",r.textAlign="start",r.fillText(x,d,l-3)):(r.fillRect(d+2,l,b+4,parseInt(r.font,10)),r.fillStyle="white",r.textAlign="start",r.fillText(x,d+2,l+15))})}function eQ(s,e){const t=E2([s.xmin,s.xmax],[e.xmin,e.xmax]),n=E2([s.ymin,s.ymax],[e.ymin,e.ymax]),r=t*n,a=s.xmax-s.xmin,o=s.ymax-s.ymin,i=e.xmax-e.xmin,u=e.ymax-e.ymin,c=a*o+i*u-r;return r/c}function E2(s,e){const[t,n]=s,[r,a]=e;return r<t?a<t?0:Math.min(n,a)-t:n<r?0:Math.min(n,a)-r}function r0(s){return 1/(1+Math.exp(-s))}function tQ(s){const e=Math.max(...s);let t=0;for(let n=0;n<s.length;++n)t=Math.exp(s[n]-e)+t;for(let n=0;n<s.length;++n)s[n]=Math.exp(s[n]-e)/t;return s}function nQ(s,e,t,n,r){let a=s-t/2*r[0],o=s+t/2*r[1],i=e-n/2*r[2],u=e+n/2*r[3];return a<0&&(a=0),i<0&&(i=0),o>1&&(o=1),u>1&&(u=1),[a,o,i,u]}const ol=[2,2],ac="same-upper";class sQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n,r=void 0,a=!0){const o=`${this.weightsUrl}/const_fold_opt__${t}.npy`,i=await Ln(this.builder,o),u=`${this.weightsUrl}/${n}_Conv2D_bias.npy`,c=await Ln(this.builder,u);return r!==void 0?r.bias=c:r={bias:c},a&&(r.activation=this.builder.relu()),this.builder.conv2d(e,i,r)}async buildBlock35(e,t,n){const r=await this.buildConv(e,n[0],`Block35_${t}_Branch_0_Conv2d_1x1`),a=await this.buildConv(e,n[1],`Block35_${t}_Branch_1_Conv2d_0a_1x1`),o=await this.buildConv(a,n[2],`Block35_${t}_Branch_1_Conv2d_0b_3x3`,{autoPad:ac}),i=await this.buildConv(e,n[3],`Block35_${t}_Branch_2_Conv2d_0a_1x1`),u=await this.buildConv(i,n[4],`Block35_${t}_Branch_2_Conv2d_0b_3x3`,{autoPad:ac}),c=await this.buildConv(u,n[5],`Block35_${t}_Branch_2_Conv2d_0c_3x3`,{autoPad:ac}),d=this.builder.concat([r,o,c],1),h=await this.buildConv(d,n[6],`Block35_${t}_Conv2d_1x1`,{},!1);return this.builder.relu(this.builder.add(e,h))}async buildBlock17(e,t,n){const r=await this.buildConv(e,n[0],`Block17_${t}_Branch_0_Conv2d_1x1`),a=await this.buildConv(e,n[1],`Block17_${t}_Branch_1_Conv2d_0a_1x1`),o=await this.buildConv(a,n[2],`Block17_${t}_Branch_1_Conv2d_0b_1x7`,{autoPad:ac}),i=await this.buildConv(o,n[3],`Block17_${t}_Branch_1_Conv2d_0c_7x1`,{autoPad:ac}),u=this.builder.concat([r,i],1),c=await this.buildConv(u,n[4],`Block17_${t}_Conv2d_1x1`,{},!1);return this.builder.relu(this.builder.add(e,c))}async buildBlock8_(e,t,n,r=!0){const a=await this.buildConv(e,n[0],`Block8_${t}_Branch_0_Conv2d_1x1`),o=await this.buildConv(e,n[1],`Block8_${t}_Branch_1_Conv2d_0a_1x1`),i=await this.buildConv(o,n[2],`Block8_${t}_Branch_1_Conv2d_0b_1x3`,{autoPad:ac}),u=await this.buildConv(i,n[3],`Block8_${t}_Branch_1_Conv2d_0c_3x1`,{autoPad:ac}),c=this.builder.concat([a,u],1),d=await this.buildConv(c,n[4],`Block8_${t}_Conv2d_1x1`,{},!1);let h=this.builder.add(e,d);return r&&(h=this.builder.relu(h)),h}async buildGemm_(e){const t=await Ln(this.builder,`${this.weightsUrl}/const_fold_opt__888.npy`),n=await Ln(this.builder,`${this.weightsUrl}/Bottleneck_MatMul_bias.npy`);return this.builder.gemm(e,t,{c:n})}async load(e){const t={windowDimensions:[3,3],strides:ol},n=await this.buildConv(e,"1070","Conv2d_1a_3x3",{strides:ol}),r=await this.buildConv(n,"1146","Conv2d_2a_3x3"),a=await this.buildConv(r,"1068","Conv2d_2b_3x3",{autoPad:ac}),o=this.builder.maxPool2d(a,t),i=await this.buildConv(o,"1058","Conv2d_3b_1x1"),u=await this.buildConv(i,"1045","Conv2d_4a_3x3"),c=await this.buildConv(u,"976","Conv2d_4b_3x3",{strides:ol}),d=await this.buildBlock35(c,1,["930","1073","912","1134","1127","921","959"]),h=await this.buildBlock35(d,2,["1005","1036","902","925","1016","1133","1059"]),l=await this.buildBlock35(h,3,["1046","1115","1020","1091","958","948","891"]),p=await this.buildBlock35(l,4,["1053","1151","919","961","1111","1124","900"]),f=await this.buildBlock35(p,5,["1083","1100","1015","1082","1099","1125","1081"]),x=await this.buildConv(f,"1079","Mixed_6a_Branch_0_Conv2d_1a_3x3",{strides:ol}),b=this.builder.maxPool2d(f,t),m=await this.buildConv(f,"1072","Mixed_6a_Branch_1_Conv2d_0a_1x1"),I=await this.buildConv(m,"1022","Mixed_6a_Branch_1_Conv2d_0b_3x3",{autoPad:ac}),N=await this.buildConv(I,"1012","Mixed_6a_Branch_1_Conv2d_1a_3x3",{strides:ol}),E=this.builder.concat([x,N,b],1),D=await this.buildBlock17(E,1,["1119","1112","989","1095","952"]),U=await this.buildBlock17(D,2,["947","918","906","1069","1148"]),L=await this.buildBlock17(U,3,["1087","932","1028","1150","1137"]),Y=await this.buildBlock17(L,4,["1089","1039","1001","1135","1129"]),V=await this.buildBlock17(Y,5,["1123","898","1090","1105","920"]),P=await this.buildBlock17(V,6,["935","998","1143","1061","1049"]),oe=await this.buildBlock17(P,7,["1118","1023","1013","1092","1093"]),ne=await this.buildBlock17(oe,8,["1141","1024","1140","929","1120"]),ge=await this.buildBlock17(ne,9,["1067","908","1142","1003","1074"]),ye=await this.buildBlock17(ge,10,["1078","913","1138","982","967"]),Ee=this.builder.maxPool2d(ye,t),X=await this.buildConv(ye,"1103","Mixed_7a_Branch_0_Conv2d_0a_1x1"),je=await this.buildConv(X,"1066","Mixed_7a_Branch_0_Conv2d_1a_3x3",{strides:ol}),Be=await this.buildConv(ye,"1056","Mixed_7a_Branch_1_Conv2d_0a_1x1"),tt=await this.buildConv(Be,"1043","Mixed_7a_Branch_1_Conv2d_1a_3x3",{strides:ol}),ct=await this.buildConv(ye,"1145","Mixed_7a_Branch_2_Conv2d_0a_1x1"),Me=await this.buildConv(ct,"1077","Mixed_7a_Branch_2_Conv2d_0b_3x3",{autoPad:ac}),wt=await this.buildConv(Me,"897","Mixed_7a_Branch_2_Conv2d_1a_3x3",{strides:ol}),at=this.builder.concat([je,tt,wt,Ee],1),Gt=await this.buildBlock8_(at,1,["1065","1126","1110","1116","1107"]),Ht=await this.buildBlock8_(Gt,2,["999","1144","1102","1097","981"]),dn=await this.buildBlock8_(Ht,3,["962","934","1064","1052","1042"]),mn=await this.buildBlock8_(dn,4,["915","957","1000","1034","1071"]),Rn=await this.buildBlock8_(mn,5,["1139","1114","1106","997","970"]),ee=await this.buildBlock8_(Rn,6,["977","1104","978","1080","1086"],!1),se=this.builder.averagePool2d(ee),we=this.builder.squeeze(se,{axes:[2,3]});return await this.buildGemm_(we)}}const il=[2,2],la="same-upper";class rQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=void 0,r=!0){const a=`${this.weightsUrl}/${t}_kernel.npy`,o=await Ln(this.builder,a),i=`${this.weightsUrl}/${t}_Conv2D_bias.npy`,u=await Ln(this.builder,i);return n!==void 0?(n.inputLayout="nhwc",n.filterLayout="ohwi",n.bias=u):n={inputLayout:"nhwc",filterLayout:"ohwi",bias:u},r&&(n.activation=this.builder.relu()),this.builder.conv2d(e,o,n)}async buildBlock35(e,t){const n=await this.buildConv(e,`Block35_${t}_Branch_0_Conv2d_1x1`,{autoPad:la}),r=await this.buildConv(e,`Block35_${t}_Branch_1_Conv2d_0a_1x1`,{autoPad:la}),a=await this.buildConv(r,`Block35_${t}_Branch_1_Conv2d_0b_3x3`,{autoPad:la}),o=await this.buildConv(e,`Block35_${t}_Branch_2_Conv2d_0a_1x1`,{autoPad:la}),i=await this.buildConv(o,`Block35_${t}_Branch_2_Conv2d_0b_3x3`,{autoPad:la}),u=await this.buildConv(i,`Block35_${t}_Branch_2_Conv2d_0c_3x3`,{autoPad:la}),c=this.builder.concat([n,a,u],3),d=await this.buildConv(c,`Block35_${t}_Conv2d_1x1`,{autoPad:la},!1);return this.builder.relu(this.builder.add(e,d))}async buildBlock17(e,t){const n=await this.buildConv(e,`Block17_${t}_Branch_0_Conv2d_1x1`,{autoPad:la}),r=await this.buildConv(e,`Block17_${t}_Branch_1_Conv2d_0a_1x1`,{autoPad:la}),a=await this.buildConv(r,`Block17_${t}_Branch_1_Conv2d_0b_1x7`,{autoPad:la}),o=await this.buildConv(a,`Block17_${t}_Branch_1_Conv2d_0c_7x1`,{autoPad:la}),i=this.builder.concat([n,o],3),u=await this.buildConv(i,`Block17_${t}_Conv2d_1x1`,{autoPad:la},!1);return this.builder.relu(this.builder.add(e,u))}async buildBlock8(e,t,n=!0){const r=await this.buildConv(e,`Block8_${t}_Branch_0_Conv2d_1x1`,{autoPad:la}),a=await this.buildConv(e,`Block8_${t}_Branch_1_Conv2d_0a_1x1`,{autoPad:la}),o=await this.buildConv(a,`Block8_${t}_Branch_1_Conv2d_0b_1x3`,{autoPad:la}),i=await this.buildConv(o,`Block8_${t}_Branch_1_Conv2d_0c_3x1`,{autoPad:la}),u=this.builder.concat([r,i],3),c=await this.buildConv(u,`Block8_${t}_Conv2d_1x1`,{autoPad:la},!1);let d=this.builder.add(e,c);return n&&(d=this.builder.relu(d)),d}async buildFullyConnected(e){const t=await Ln(this.builder,`${this.weightsUrl}/Bottleneck_kernel_transpose.npy`),n=await Ln(this.builder,`${this.weightsUrl}/Bottleneck_MatMul_bias.npy`),r={aTranspose:!1,bTranspose:!0,c:n};return this.builder.gemm(e,t,r)}async load(e){const t={windowDimensions:[3,3],strides:il,layout:"nhwc"},n=await this.buildConv(e,"Conv2d_1a_3x3",{strides:il}),r=await this.buildConv(n,"Conv2d_2a_3x3"),a=await this.buildConv(r,"Conv2d_2b_3x3",{autoPad:la}),o=this.builder.maxPool2d(a,t),i=await this.buildConv(o,"Conv2d_3b_1x1"),u=await this.buildConv(i,"Conv2d_4a_3x3"),c=await this.buildConv(u,"Conv2d_4b_3x3",{strides:il}),d=await this.buildBlock35(c,1),h=await this.buildBlock35(d,2),l=await this.buildBlock35(h,3),p=await this.buildBlock35(l,4),f=await this.buildBlock35(p,5),x=await this.buildConv(f,"Mixed_6a_Branch_0_Conv2d_1a_3x3",{strides:il}),b=this.builder.maxPool2d(f,t),m=await this.buildConv(f,"Mixed_6a_Branch_1_Conv2d_0a_1x1",{autoPad:la}),I=await this.buildConv(m,"Mixed_6a_Branch_1_Conv2d_0b_3x3",{autoPad:la}),N=await this.buildConv(I,"Mixed_6a_Branch_1_Conv2d_1a_3x3",{strides:il}),E=this.builder.concat([x,N,b],3),D=await this.buildBlock17(E,1),U=await this.buildBlock17(D,2),L=await this.buildBlock17(U,3),Y=await this.buildBlock17(L,4),V=await this.buildBlock17(Y,5),P=await this.buildBlock17(V,6),oe=await this.buildBlock17(P,7),ne=await this.buildBlock17(oe,8),ge=await this.buildBlock17(ne,9),ye=await this.buildBlock17(ge,10),Ee=this.builder.maxPool2d(ye,t),X=await this.buildConv(ye,"Mixed_7a_Branch_0_Conv2d_0a_1x1",{autoPad:la}),je=await this.buildConv(X,"Mixed_7a_Branch_0_Conv2d_1a_3x3",{strides:il}),Be=await this.buildConv(ye,"Mixed_7a_Branch_1_Conv2d_0a_1x1",{autoPad:la}),tt=await this.buildConv(Be,"Mixed_7a_Branch_1_Conv2d_1a_3x3",{strides:il}),ct=await this.buildConv(ye,"Mixed_7a_Branch_2_Conv2d_0a_1x1",{autoPad:la}),Me=await this.buildConv(ct,"Mixed_7a_Branch_2_Conv2d_0b_3x3",{autoPad:la}),wt=await this.buildConv(Me,"Mixed_7a_Branch_2_Conv2d_1a_3x3",{strides:il}),at=this.builder.concat([je,tt,wt,Ee],3),Gt=await this.buildBlock8(at,1),Ht=await this.buildBlock8(Gt,2),dn=await this.buildBlock8(Ht,3),mn=await this.buildBlock8(dn,4),Rn=await this.buildBlock8(mn,5),ee=await this.buildBlock8(Rn,6,!1),se=this.builder.reduceMean(ee,{axes:[1,2]});return await this.buildFullyConnected(se)}}class aQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=!0,r=void 0){let a=this.weightsUrl,o="_mul_1.npy",i=`_sub__${t[3]}.npy`;t[0].includes("depthwise")?(a+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${t[1]}_depthwise_BatchNorm_batchnorm`,o=`_mul__${t[2]}.npy`):t[0].includes("pointwise")?t[0].includes("_")?a+=`FeatureExtractor_MobilenetV1_Conv2d_13_
${t[0]}_Conv2d_${t[1]}_BatchNorm_batchnorm`:a+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${t[1]}_pointwise_BatchNorm_batchnorm`:t[0].includes("Class")?(a+=`/BoxPredictor_${t[1]}_ClassPredictor`,o="_Conv2D.npy",i=`_biases_read__${t[3]}.npy`):t[0].includes("BoxEncoding")?(a+=`/BoxPredictor_${t[1]}_BoxEncodingPredictor`,o="_Conv2D.npy",i=`_biases_read__${t[3]}.npy`):a+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${t[1]}_BatchNorm_batchnorm`;const u=a+o,c=await Ln(this.builder,u),d=a.replace("nchw","nhwc")+i,h=await Ln(this.builder,d);return r!==void 0?(r.inputLayout="nhwc",r.filterLayout="ohwi",r.autoPad="same-upper"):r={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"},t[0].includes("depthwise")&&(r.filterLayout="ihwo"),r.bias=h,n&&(r.activation=this.builder.clamp({minValue:0,maxValue:6})),this.builder.conv2d(e,c,r)}async load(e){const t=[2,2],n=await this.buildConv(e,["","0","","165__cf__168"],!0,{strides:t}),r=await this.buildConv(n,["depthwise","1","161__cf__164","162__cf__165"],!0,{groups:32}),a=await this.buildConv(r,["pointwise","1","","159__cf__162"]),o=await this.buildConv(a,["depthwise","2","155__cf__158","156__cf__159"],!0,{strides:t,groups:64}),i=await this.buildConv(o,["pointwise","2","","153__cf__156"]),u=await this.buildConv(i,["depthwise","3","149__cf__152","150__cf__153"],!0,{groups:128}),c=await this.buildConv(u,["pointwise","3","","147__cf__150"]),d=await this.buildConv(c,["depthwise","4","143__cf__146","144__cf__147"],!0,{strides:t,groups:128}),h=await this.buildConv(d,["pointwise","4","","141__cf__144"]),l=await this.buildConv(h,["depthwise","5","137__cf__140","138__cf__141"],!0,{groups:256}),p=await this.buildConv(l,["pointwise","5","","135__cf__138"]),f=await this.buildConv(p,["depthwise","6","131__cf__134","132__cf__135"],!0,{strides:t,groups:256}),x=await this.buildConv(f,["pointwise","6","","129__cf__132"]),b=await this.buildConv(x,["depthwise","7","125__cf__128","126__cf__129"],!0,{groups:512}),m=await this.buildConv(b,["pointwise","7","","123__cf__126"]),I=await this.buildConv(m,["depthwise","8","119__cf__122","120__cf__123"],!0,{groups:512}),N=await this.buildConv(I,["pointwise","8","","117__cf__120"]),E=await this.buildConv(N,["depthwise","9","113__cf__116","114__cf__117"],!0,{groups:512}),D=await this.buildConv(E,["pointwise","9","","111__cf__114"]),U=await this.buildConv(D,["depthwise","10","107__cf__110","108__cf__111"],!0,{groups:512}),L=await this.buildConv(U,["pointwise","10","","105__cf__108"]),Y=await this.buildConv(L,["depthwise","11","101__cf__104","102__cf__105"],!0,{groups:512}),V=await this.buildConv(Y,["pointwise","11","","99__cf__102"]),P=await this.buildConv(V,["depthwise","12","95__cf__98","96__cf__99"],!0,{strides:t,groups:512}),oe=await this.buildConv(P,["pointwise","12","","93__cf__96"]),ne=await this.buildConv(oe,["depthwise","13","89__cf__92","90__cf__93"],!0,{groups:1024}),ge=await this.buildConv(ne,["pointwise","13","","87__cf__90"]),ye=await this.buildConv(ge,["pointwise_1","2_1x1_256","","84__cf__87"]),Ee=await this.buildConv(ye,["pointwise_2","2_3x3_s2_512","","81__cf__84"],!0,{strides:t}),X=await this.buildConv(Ee,["pointwise_1","3_1x1_128","","78__cf__81"]),je=await this.buildConv(X,["pointwise_2","3_3x3_s2_256","","75__cf__78"],!0,{strides:t}),Be=await this.buildConv(je,["pointwise_1","4_1x1_128","","72__cf__75"]),tt=await this.buildConv(Be,["pointwise_2","4_3x3_s2_256","","69__cf__72"],!0,{strides:t}),ct=await this.buildConv(tt,["pointwise_1","5_1x1_64","","66__cf__69"]),Me=await this.buildConv(ct,["pointwise_2","5_3x3_s2_128","","63__cf__66"],!0,{strides:t}),wt=await this.buildConv(V,["BoxEncoding","0","","177__cf__180"],!1),at=this.builder.reshape(wt,[1,1083,1,4]),Gt=await this.buildConv(ge,["BoxEncoding","1","","175__cf__178"],!1),Ht=this.builder.reshape(Gt,[1,600,1,4]),dn=await this.buildConv(Ee,["BoxEncoding","2","","173__cf__176"],!1),mn=this.builder.reshape(dn,[1,150,1,4]),Rn=await this.buildConv(je,["BoxEncoding","3","","171__cf__174"],!1),ee=this.builder.reshape(Rn,[1,54,1,4]),se=await this.buildConv(tt,["BoxEncoding","4","","169__cf__172"],!1),we=this.builder.reshape(se,[1,24,1,4]),pt=await this.buildConv(Me,["BoxEncoding","5","","167__cf__170"],!1),bt=this.builder.reshape(pt,[1,6,1,4]),At=this.builder.concat([at,Ht,mn,ee],1),$e=this.builder.concat([At,we,bt],1),ht=await this.buildConv(V,["Class","0","","51__cf__54"],!1),Pt=this.builder.reshape(ht,[1,1083,91]),Ot=await this.buildConv(ge,["Class","1","","49__cf__52"],!1),xn=this.builder.reshape(Ot,[1,600,91]),Dn=await this.buildConv(Ee,["Class","2","","47__cf__50"],!1),pe=this.builder.reshape(Dn,[1,150,91]),be=await this.buildConv(je,["Class","3","","45__cf__48"],!1),Qe=this.builder.reshape(be,[1,54,91]),Un=await this.buildConv(tt,["Class","4","","43__cf__46"],!1),Ws=this.builder.reshape(Un,[1,24,91]),Gs=await this.buildConv(Me,["Class","5","","41__cf__44"],!1),As=this.builder.reshape(Gs,[1,6,91]),xs=this.builder.concat([Pt,xn,pe,Qe],1),ds=this.builder.concat([xs,Ws,As],1);return{boxes:$e,scores:ds}}}class oQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=!0,r=void 0){let a=this.weightsUrl,o="_mul_1.npy",i=`_sub__${t[3]}.npy`;t[0].includes("depthwise")?(a+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${t[1]}_depthwise_BatchNorm_batchnorm`,o=`_mul__${t[2]}.npy`):t[0].includes("pointwise")?t[0].includes("_")?a+=`FeatureExtractor_MobilenetV1_Conv2d_13_
${t[0]}_Conv2d_${t[1]}_BatchNorm_batchnorm`:a+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${t[1]}_pointwise_BatchNorm_batchnorm`:t[0].includes("Class")?(a+=`/BoxPredictor_${t[1]}_ClassPredictor`,o="_Conv2D.npy",i=`_biases_read__${t[3]}.npy`):t[0].includes("BoxEncoding")?(a+=`/BoxPredictor_${t[1]}_BoxEncodingPredictor`,o="_Conv2D.npy",i=`_biases_read__${t[3]}.npy`):a+=`/FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${t[1]}_BatchNorm_batchnorm`;const u=a+o,c=await Ln(this.builder,u),d=a+i,h=await Ln(this.builder,d);return r!==void 0?(r.inputLayout="nhwc",r.filterLayout="ohwi",r.autoPad="same-upper"):r={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"},t[0].includes("depthwise")&&(r.filterLayout="ihwo"),r.bias=h,n&&(r.activation=this.builder.clamp({minValue:0,maxValue:6})),this.builder.conv2d(e,c,r)}async load(e){const t=[2,2],n=await this.buildConv(e,["","0","","165__cf__168"],!0,{strides:t}),r=await this.buildConv(n,["depthwise","1","161__cf__164","162__cf__165"],!0,{groups:32}),a=await this.buildConv(r,["pointwise","1","","159__cf__162"]),o=await this.buildConv(a,["depthwise","2","155__cf__158","156__cf__159"],!0,{strides:t,groups:64}),i=await this.buildConv(o,["pointwise","2","","153__cf__156"]),u=await this.buildConv(i,["depthwise","3","149__cf__152","150__cf__153"],!0,{groups:128}),c=await this.buildConv(u,["pointwise","3","","147__cf__150"]),d=await this.buildConv(c,["depthwise","4","143__cf__146","144__cf__147"],!0,{strides:t,groups:128}),h=await this.buildConv(d,["pointwise","4","","141__cf__144"]),l=await this.buildConv(h,["depthwise","5","137__cf__140","138__cf__141"],!0,{groups:256}),p=await this.buildConv(l,["pointwise","5","","135__cf__138"]),f=await this.buildConv(p,["depthwise","6","131__cf__134","132__cf__135"],!0,{strides:t,groups:256}),x=await this.buildConv(f,["pointwise","6","","129__cf__132"]),b=await this.buildConv(x,["depthwise","7","125__cf__128","126__cf__129"],!0,{groups:512}),m=await this.buildConv(b,["pointwise","7","","123__cf__126"]),I=await this.buildConv(m,["depthwise","8","119__cf__122","120__cf__123"],!0,{groups:512}),N=await this.buildConv(I,["pointwise","8","","117__cf__120"]),E=await this.buildConv(N,["depthwise","9","113__cf__116","114__cf__117"],!0,{groups:512}),D=await this.buildConv(E,["pointwise","9","","111__cf__114"]),U=await this.buildConv(D,["depthwise","10","107__cf__110","108__cf__111"],!0,{groups:512}),L=await this.buildConv(U,["pointwise","10","","105__cf__108"]),Y=await this.buildConv(L,["depthwise","11","101__cf__104","102__cf__105"],!0,{groups:512}),V=await this.buildConv(Y,["pointwise","11","","99__cf__102"]),P=await this.buildConv(V,["depthwise","12","95__cf__98","96__cf__99"],!0,{strides:t,groups:512}),oe=await this.buildConv(P,["pointwise","12","","93__cf__96"]),ne=await this.buildConv(oe,["depthwise","13","89__cf__92","90__cf__93"],!0,{groups:1024}),ge=await this.buildConv(ne,["pointwise","13","","87__cf__90"]),ye=await this.buildConv(ge,["pointwise_1","2_1x1_256","","84__cf__87"]),Ee=await this.buildConv(ye,["pointwise_2","2_3x3_s2_512","","81__cf__84"],!0,{strides:t}),X=await this.buildConv(Ee,["pointwise_1","3_1x1_128","","78__cf__81"]),je=await this.buildConv(X,["pointwise_2","3_3x3_s2_256","","75__cf__78"],!0,{strides:t}),Be=await this.buildConv(je,["pointwise_1","4_1x1_128","","72__cf__75"]),tt=await this.buildConv(Be,["pointwise_2","4_3x3_s2_256","","69__cf__72"],!0,{strides:t}),ct=await this.buildConv(tt,["pointwise_1","5_1x1_64","","66__cf__69"]),Me=await this.buildConv(ct,["pointwise_2","5_3x3_s2_128","","63__cf__66"],!0,{strides:t}),wt=await this.buildConv(V,["BoxEncoding","0","","177__cf__180"],!1),at=this.builder.reshape(wt,[1,1083,1,4]),Gt=await this.buildConv(ge,["BoxEncoding","1","","175__cf__178"],!1),Ht=this.builder.reshape(Gt,[1,600,1,4]),dn=await this.buildConv(Ee,["BoxEncoding","2","","173__cf__176"],!1),mn=this.builder.reshape(dn,[1,150,1,4]),Rn=await this.buildConv(je,["BoxEncoding","3","","171__cf__174"],!1),ee=this.builder.reshape(Rn,[1,54,1,4]),se=await this.buildConv(tt,["BoxEncoding","4","","169__cf__172"],!1),we=this.builder.reshape(se,[1,24,1,4]),pt=await this.buildConv(Me,["BoxEncoding","5","","167__cf__170"],!1),bt=this.builder.reshape(pt,[1,6,1,4]),At=this.builder.concat([at,Ht,mn,ee],1),$e=this.builder.concat([At,we,bt],1),ht=await this.buildConv(V,["Class","0","","51__cf__54"],!1),Pt=this.builder.reshape(ht,[1,1083,91]),Ot=await this.buildConv(ge,["Class","1","","49__cf__52"],!1),xn=this.builder.reshape(Ot,[1,600,91]),Dn=await this.buildConv(Ee,["Class","2","","47__cf__50"],!1),pe=this.builder.reshape(Dn,[1,150,91]),be=await this.buildConv(je,["Class","3","","45__cf__48"],!1),Qe=this.builder.reshape(be,[1,54,91]),Un=await this.buildConv(tt,["Class","4","","43__cf__46"],!1),Ws=this.builder.reshape(Un,[1,24,91]),Gs=await this.buildConv(Me,["Class","5","","41__cf__44"],!1),As=this.builder.reshape(Gs,[1,6,91]),xs=this.builder.concat([Pt,xn,pe,Qe],1),ds=this.builder.concat([xs,Ws,As],1);return{boxes:$e,scores:ds}}}class iQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=!0,r={}){const a=this.weightsUrl+"conv_"+t,o=a+"_weight.npy",i=await Ln(this.builder,o),u=a+"_bias.npy";return r.bias=await Ln(this.builder,u),n?r.activation=this.builder.clamp({minValue:0,maxValue:6}):r.activation=void 0,this.builder.conv2d(e,i,r)}async buildGemm_(e,t){const n=this.weightsUrl+"gemm_"+t,r=n+"_weight.npy",a=await Ln(this.builder,r),o=n+"_bias.npy",u={c:await Ln(this.builder,o),bTranspose:!0};return this.builder.gemm(e,a,u)}async buildLinearBottleneck_(e,t,n,r,a=!0){const o=await this.buildConv(e,t[0]),i={padding:[1,1,1,1],groups:n,strides:[r,r]},u=await this.buildConv(o,t[1],!0,i),c=await this.buildConv(u,t[2],!1);return a?this.builder.add(e,c):c}async load(e){const t=await this.buildConv(e,"0",!0,{padding:[1,1,1,1],strides:[2,2]}),n=await this.buildConv(t,"2",!0,{padding:[1,1,1,1],groups:32}),r=await this.buildConv(n,"4",!1),a=await this.buildLinearBottleneck_(r,["5","7","9"],96,2,!1),o=await this.buildLinearBottleneck_(a,["10","12","14"],144,1),i=await this.buildLinearBottleneck_(o,["16","18","20"],144,2,!1),u=await this.buildLinearBottleneck_(i,["21","23","25"],192,1),c=await this.buildLinearBottleneck_(u,["27","29","31"],192,1),d=await this.buildLinearBottleneck_(c,["33","35","37"],192,2,!1),h=await this.buildLinearBottleneck_(d,["38","40","42"],384,1),l=await this.buildLinearBottleneck_(h,["44","46","48"],384,1),p=await this.buildLinearBottleneck_(l,["50","52","54"],384,1),f=await this.buildLinearBottleneck_(p,["56","58","60"],384,1,!1),x=await this.buildLinearBottleneck_(f,["61","63","65"],576,1),b=await this.buildLinearBottleneck_(x,["67","69","71"],576,1),m=await this.buildLinearBottleneck_(b,["73","75","77"],576,2,!1),I=await this.buildLinearBottleneck_(m,["78","80","82"],960,1),N=await this.buildLinearBottleneck_(I,["84","86","88"],960,1),E=await this.buildLinearBottleneck_(N,["90","92","94"],960,1,!1),D=await this.buildConv(E,"95",!0),U=this.builder.averagePool2d(D),L=this.builder.reshape(U,[1,null]),Y=await this.buildGemm_(L,"104");return this.builder.softmax(Y)}}class uQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n,r,a){const o=this.weightsUrl+"Const_"+t+".npy",i=await Ln(this.builder,o),u=this.weightsUrl+"MobilenetV2_"+n+"_bias.npy",c=await Ln(this.builder,u);return a.inputLayout="nhwc",a.bias=c,r?a.activation=this.builder.clamp({minValue:0,maxValue:6}):a.activation=void 0,this.builder.conv2d(e,i,a)}async buildLinearBottleneck(e,t,n,r,a=!0){const o="same-upper",i="expanded_conv_"+n;r.autoPad=o,r.filterLayout="ihwo";const u={autoPad:o,filterLayout:"ohwi"},c=await this.buildConv(e,t[0],`${i}_expand_Conv2D`,!0,u),d=await this.buildConv(c,t[1],`${i}_depthwise_depthwise`,!0,r),h=await this.buildConv(d,t[2],`${i}_project_Conv2D`,!1,u);return a?this.builder.add(e,h):h}async load(e){const t=[2,2],n="same-upper",r="ohwi",a=await this.buildConv(e,"90","Conv_Conv2D",!0,{strides:t,autoPad:n,filterLayout:r}),o=await this.buildConv(a,"238","expanded_conv_depthwise_depthwise",!0,{autoPad:n,groups:32,filterLayout:"ihwo"}),i=await this.buildConv(o,"167","expanded_conv_project_Conv2D",!1,{autoPad:n,filterLayout:r}),u=await this.buildLinearBottleneck(i,["165","99","73"],"1",{strides:t,groups:96},!1),c=await this.buildLinearBottleneck(u,["3","119","115"],"2",{groups:144}),d=await this.buildLinearBottleneck(c,["255","216","157"],"3",{strides:t,groups:144},!1),h=await this.buildLinearBottleneck(d,["227","221","193"],"4",{groups:192}),l=await this.buildLinearBottleneck(h,["243","102","215"],"5",{groups:192}),p=await this.buildLinearBottleneck(l,["226","163","229"],"6",{strides:t,groups:192},!1),f=await this.buildLinearBottleneck(p,["104","254","143"],"7",{groups:384}),x=await this.buildLinearBottleneck(f,["25","142","202"],"8",{groups:384}),b=await this.buildLinearBottleneck(x,["225","129","98"],"9",{groups:384}),m=await this.buildLinearBottleneck(b,["169","2","246"],"10",{groups:384},!1),I=await this.buildLinearBottleneck(m,["162","87","106"],"11",{groups:576}),N=await this.buildLinearBottleneck(I,["52","22","40"],"12",{groups:576}),E=await this.buildLinearBottleneck(N,["114","65","242"],"13",{strides:t,groups:576},!1),D=await this.buildLinearBottleneck(E,["203","250","92"],"14",{groups:960}),U=await this.buildLinearBottleneck(D,["133","130","258"],"15",{groups:960}),L=await this.buildLinearBottleneck(U,["60","248","100"],"16",{groups:960},!1),Y=await this.buildConv(L,"71","Conv_1_Conv2D",!0,{autoPad:n,filterLayout:r}),V=this.builder.averagePool2d(Y,{windowDimensions:[7,7],layout:"nhwc"}),P=await this.buildConv(V,"222","Logits_Conv2d_1c_1x1_Conv2D",!1,{autoPad:n,filterLayout:r}),oe=this.builder.reshape(P,[1,null]);return this.builder.softmax(oe)}}class cQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n,r=void 0){let a="";n!==""?a=this.weightsUrl+"resnetv24_stage"+n+"_conv"+t:a=this.weightsUrl+"resnetv24_conv"+t;const o=a+"_weight.npy",i=await Ln(this.builder,o);return this.builder.conv2d(e,i,r)}async buildBatchNorm(e,t,n,r=!0){let a="";n!==""?a=this.weightsUrl+"resnetv24_stage"+n+"_batchnorm"+t:a=this.weightsUrl+"resnetv24_batchnorm"+t;const o=a+"_gamma.npy",i=a+"_beta.npy",u=a+"_running_mean.npy",c=a+"_running_var.npy",d=await Ln(this.builder,o),h=await Ln(this.builder,i),l=await Ln(this.builder,u),p=await Ln(this.builder,c),f={scale:d,bias:h};return r&&(f.activation=this.builder.relu()),this.builder.batchNormalization(e,l,p,f)}async buildGemm(e,t){const n=this.weightsUrl+"resnetv24_dense"+t,r=n+"_weight.npy",a=await Ln(this.builder,r),o=n+"_bias.npy",i=await Ln(this.builder,o),u={c:this.builder.reshape(i,[1,null]),bTranspose:!0};return this.builder.gemm(e,a,u)}async buildBottlenectV2(e,t,n,r=!1,a=1){let o=e,i=[1,1];r&&(i=[a,a]);const u=await this.buildBatchNorm(e,n[0],t),c=await this.buildConv(u,n[1],t),d=await this.buildBatchNorm(c,parseInt(n[0])+1,t),h=await this.buildConv(d,n[2],t,{padding:[1,1,1,1],strides:i}),l=await this.buildBatchNorm(h,parseInt(n[0])+2,t),p=await this.buildConv(l,n[3],t);return r&&(o=await this.buildConv(u,parseInt(n[0])+3,t,{strides:i})),this.builder.add(p,o)}async load(e){const t=await this.buildBatchNorm(e,"0","",!1),n=await this.buildConv(t,"0","",{padding:[3,3,3,3],strides:[2,2]}),r=await this.buildBatchNorm(n,"1",""),a=await this.builder.maxPool2d(r,{windowDimensions:[3,3],padding:[1,1,1,1],strides:[2,2]}),o=await this.buildBottlenectV2(a,"1",["0","0","1","2"],!0),i=await this.buildBottlenectV2(o,"1",["3","4","5","6"]),u=await this.buildBottlenectV2(i,"1",["6","7","8","9"]),c=await this.buildBottlenectV2(u,"2",["0","0","1","2"],!0,2),d=await this.buildBottlenectV2(c,"2",["3","4","5","6"]),h=await this.buildBottlenectV2(d,"2",["6","7","8","9"]),l=await this.buildBottlenectV2(h,"2",["9","10","11","12"]),p=await this.buildBottlenectV2(l,"3",["0","0","1","2"],!0,2),f=await this.buildBottlenectV2(p,"3",["3","4","5","6"]),x=await this.buildBottlenectV2(f,"3",["6","7","8","9"]),b=await this.buildBottlenectV2(x,"3",["9","10","11","12"]),m=await this.buildBottlenectV2(b,"3",["12","13","14","15"]),I=await this.buildBottlenectV2(m,"3",["15","16","17","18"]),N=await this.buildBottlenectV2(I,"4",["0","0","1","2"],!0,2),E=await this.buildBottlenectV2(N,"4",["3","4","5","6"]),D=await this.buildBottlenectV2(E,"4",["6","7","8","9"]),U=await this.buildBatchNorm(D,"2",""),L=await this.builder.averagePool2d(U),Y=this.builder.reshape(L,[1,null]),V=await this.buildGemm(Y,"0");return this.builder.softmax(V)}}const Jl="same-upper",xm=[2,2],ym="nhwc";class lQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n={},r=!0){let a=this.weightsUrl+"resnet_v2_50_";t[0]!==""&&t[1]!==""&&(a+=`block${t[0]}_unit_${t[1]}_bottleneck_v2_`),t[2]==="shortcut"?a+="shortcut":t[2]==="logits"?a+=t[2]:a+="conv"+t[2];const o=a+"_weights.npy",i=await Ln(this.builder,o),u=a+"_Conv2D_bias.npy",c=await Ln(this.builder,u);return n.inputLayout=ym,n.filterLayout="ohwi",n.bias=c,r&&(n.activation=this.builder.relu()),this.builder.conv2d(e,i,n)}async buildFusedBatchNorm(e,t){let n=this.weightsUrl+"resnet_v2_50_";t[0]==="postnorm"?n+="postnorm":n+=`block${t[0]}_unit_${t[1]}_bottleneck_v2_preact`;const r=n+"_FusedBatchNorm_mul_0_param.npy",a=await Ln(this.builder,r),o=n+"_FusedBatchNorm_add_param.npy",i=await Ln(this.builder,o);return this.builder.relu(this.builder.add(this.builder.mul(e,a),i))}async buildBottleneckV2(e,t,n=!1,r=!0){let a=e;const o=await this.buildFusedBatchNorm(e,t),i=await this.buildConv(o,t.concat(["1"]),{autoPad:Jl});let u;n&&(a=await this.buildConv(o,t.concat(["shortcut"]),{autoPad:Jl},!1)),!n&&r?(a=this.builder.maxPool2d(e,{windowDimensions:[2,2],strides:xm,layout:ym,autoPad:Jl}),u=await this.buildConv(i,t.concat(["2"]),{strides:xm,padding:[1,1,1,1]})):u=await this.buildConv(i,t.concat(["2"]),{autoPad:Jl});const c=await this.buildConv(u,t.concat(["3"]),{autoPad:Jl},!1);return this.builder.add(c,a)}async load(e){const t=await this.buildConv(e,["","","1"],{strides:xm,padding:[3,3,3,3]},!1),n=this.builder.maxPool2d(t,{windowDimensions:[3,3],strides:xm,layout:ym,autoPad:Jl}),r=await this.buildBottleneckV2(n,["1","1"],!0),a=await this.buildBottleneckV2(r,["1","2"],!1,!1),o=await this.buildBottleneckV2(a,["1","3"]),i=await this.buildBottleneckV2(o,["2","1"],!0),u=await this.buildBottleneckV2(i,["2","2"],!1,!1),c=await this.buildBottleneckV2(u,["2","3"],!1,!1),d=await this.buildBottleneckV2(c,["2","4"]),h=await this.buildBottleneckV2(d,["3","1"],!0),l=async(U,L)=>{if(L>5)return U;{const Y=await this.buildBottleneckV2(U,["3",L.toString()],!1,!1);return L++,l(Y,L)}},p=await l(h,2),f=await this.buildBottleneckV2(p,["3","6"]),x=await this.buildBottleneckV2(f,["4","1"],!0),b=await this.buildBottleneckV2(x,["4","2"],!1,!1),m=await this.buildBottleneckV2(b,["4","3"],!1,!1),I=await this.buildFusedBatchNorm(m,["postnorm"]),N=this.builder.averagePool2d(I,{layout:ym}),E=await this.buildConv(N,["","","logits"],{autoPad:Jl},!1),D=this.builder.reshape(E,[1,null]);return this.builder.softmax(D)}}class dQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n={}){const r=this.weightsUrl+"squeezenet0_"+t,a=r+"_weight.npy",o=await Ln(this.builder,a),i=r+"_bias.npy",u=await Ln(this.builder,i);return n.bias=u,n.activation=this.builder.relu(),this.builder.conv2d(e,o,n)}async buildFire(e,t,n,r){const a=await this.buildConv(e,t),o=await this.buildConv(a,n),i=await this.buildConv(a,r,{padding:[1,1,1,1]});return this.builder.concat([o,i],1)}async load(e){const t=await this.buildConv(e,"conv0",{strides:[2,2]}),n=this.builder.maxPool2d(t,{windowDimensions:[3,3],strides:[2,2]}),r=await this.buildFire(n,"conv1","conv2","conv3"),a=await this.buildFire(r,"conv4","conv5","conv6"),o=this.builder.maxPool2d(a,{windowDimensions:[3,3],strides:[2,2]}),i=await this.buildFire(o,"conv7","conv8","conv9"),u=await this.buildFire(i,"conv10","conv11","conv12"),c=this.builder.maxPool2d(u,{windowDimensions:[3,3],strides:[2,2]}),d=await this.buildFire(c,"conv13","conv14","conv15"),h=await this.buildFire(d,"conv16","conv17","conv18"),l=await this.buildFire(h,"conv19","conv20","conv21"),p=await this.buildFire(l,"conv22","conv23","conv24"),f=await this.buildConv(p,"conv25"),x=this.builder.averagePool2d(f,{windowDimensions:[13,13],strides:[13,13]}),b=this.builder.reshape(x,[1,null]);return this.builder.softmax(b)}}class hQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n={}){const r=this.weightsUrl+t,a=r+"_kernel.npy",o=await Ln(this.builder,a),i=r+"_Conv2D_bias.npy",u=await Ln(this.builder,i);return n.inputLayout="nhwc",n.filterLayout="ohwi",n.bias=u,n.activation=this.builder.relu(),this.builder.conv2d(e,o,n)}async buildFire(e,t){const n=await this.buildConv(e,t+"_squeeze"),r=await this.buildConv(n,t+"_e1x1"),a=await this.buildConv(n,t+"_e3x3",{padding:[1,1,1,1]});return this.builder.concat([r,a],3)}async load(e){const t=[2,2],n="nhwc",r=await this.buildConv(e,"conv1",{strides:t,autoPad:"same-upper"}),a=this.builder.maxPool2d(r,{windowDimensions:[3,3],strides:t,layout:n}),o=await this.buildFire(a,"fire2"),i=await this.buildFire(o,"fire3"),u=await this.buildFire(i,"fire4"),c=this.builder.maxPool2d(u,{windowDimensions:[3,3],strides:t,layout:n}),d=await this.buildFire(c,"fire5"),h=await this.buildFire(d,"fire6"),l=await this.buildFire(h,"fire7"),p=await this.buildFire(l,"fire8"),f=this.builder.maxPool2d(p,{windowDimensions:[3,3],strides:t,layout:n}),x=await this.buildFire(f,"fire9"),b=await this.buildConv(x,"conv10"),m=this.builder.averagePool2d(b,{windowDimensions:[13,13],layout:n}),I=this.builder.reshape(m,[1,null]);return this.builder.softmax(I)}}class pQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=!1){const r=this.weightsUrl+"convolution"+t,a=r+"_W.npy",o=await Ln(this.builder,a),i={autoPad:"same-upper"};if(n){const u=r+"_B.npy";i.bias=await Ln(this.builder,u)}return this.builder.conv2d(e,o,i)}async buildBatchNorm(e,t){const n=this.weightsUrl+"BatchNormalization",r=`${n}_scale${t}.npy`,a=`${n}_B${t}.npy`,o=`${n}_mean${t}.npy`,i=`${n}_variance${t}.npy`,u=await Ln(this.builder,r),c=await Ln(this.builder,a),d=await Ln(this.builder,o),h=await Ln(this.builder,i);return this.builder.batchNormalization(e,d,h,{scale:u,bias:c,activation:this.builder.leakyRelu({alpha:.10000000149011612})})}async buildConvolutional(e,t){const n=await this.buildConv(e,t);return await this.buildBatchNorm(n,t)}async load(e){const t=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([.003921568859368563])),n=this.builder.constant({type:"float32",dimensions:[3,1,1]},new Float32Array([0,0,0])),r={windowDimensions:[2,2],strides:[2,2],autoPad:"same-upper"},a=this.builder.mul(e,t),o=this.builder.add(a,n),i=await this.buildConvolutional(o,""),u=this.builder.maxPool2d(i,r),c=await this.buildConvolutional(u,"1"),d=this.builder.maxPool2d(c,r),h=await this.buildConvolutional(d,"2"),l=this.builder.maxPool2d(h,r),p=await this.buildConvolutional(l,"3"),f=this.builder.maxPool2d(p,r),x=await this.buildConvolutional(f,"4"),b=this.builder.maxPool2d(x,r),m=await this.buildConvolutional(b,"5"),I=this.builder.maxPool2d(m,{windowDimensions:[2,2],autoPad:"same-upper"}),N=await this.buildConvolutional(I,"6"),E=await this.buildConvolutional(N,"7");return await this.buildConv(E,"8",!0)}}class fQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n=!0){const r=this.weightsUrl+"conv2d_"+t,a=r+"_kernel.npy",o=await Ln(this.builder,a),i=r+"_Conv2D_bias.npy",u=await Ln(this.builder,i),c={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"};c.bias=u;let d=this.builder.conv2d(e,o,c);return n&&(d=this.builder.leakyRelu(d,{alpha:.10000000149011612})),d}async load(e){const t={windowDimensions:[2,2],strides:[2,2],autoPad:"same-upper",layout:"nhwc"},n=await this.buildConv(e,"1"),r=this.builder.maxPool2d(n,t),a=await this.buildConv(r,"2"),o=this.builder.maxPool2d(a,t),i=await this.buildConv(o,"3"),u=this.builder.maxPool2d(i,t),c=await this.buildConv(u,"4"),d=this.builder.maxPool2d(c,t),h=await this.buildConv(d,"5"),l=this.builder.maxPool2d(h,t),p=await this.buildConv(l,"6"),f=this.builder.maxPool2d(p,{windowDimensions:[2,2],autoPad:"same-upper",layout:"nhwc"}),x=await this.buildConv(f,"7"),b=await this.buildConv(x,"8");return await this.buildConv(b,"9",!1)}}class mQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n="relu6",r={}){const a=this.weightsUrl.replace("nchw","nhwc")+t[0],o=`${this.weightsUrl}const_fold_opt__${t[2]}.npy`;let i=a+"_bn_offset.npy";t[0].includes("depthwise")?(i=`${a}_bn_offset.npy`,t[1]!==""&&(i=`${a}_${t[1]}.npy`)):t[0]==="logits_semantic"&&(i=a+"_biases.npy");const u=await Ln(this.builder,o),c=await Ln(this.builder,i);return r.bias=c,n==="relu6"?r.activation=this.builder.clamp({minValue:0,maxValue:6}):n==="relu"?r.activation=this.builder.relu():r.activation=void 0,this.builder.conv2d(e,u,r)}async buildLinearBottleneck(e,t,n,r=!0){const a="MobilenetV2_expanded_conv_"+t[0];let o="depthwise_bn_offset";Number.parseInt(t[0])>6&&(o="BatchNorm_FusedBatchNorm");const i=await this.buildConv(e,[`${a}_expand_Conv2D`,o,t[1]]),u=await this.buildConv(i,[`${a}_depthwise`,o,t[2]],"relu6",n),c=await this.buildConv(u,[`${a}_project_Conv2D`,o,t[3]],"none");return r?this.builder.add(e,c):c}async load(e){const t=[2,2],n=await this.buildConv(e,["MobilenetV2_Conv_Conv2D","","551"],"relu6",{strides:t,padding:[1,1,1,1]}),r=await this.buildConv(n,["MobilenetV2_expanded_conv_depthwise_depthwise","","543"],"relu6",{padding:[1,1,1,1],groups:32}),a=await this.buildConv(r,["MobilenetV2_expanded_conv_project_Conv2D","","511"],"none"),o=await this.buildLinearBottleneck(a,["1","537","494","534"],{strides:t,padding:[1,1,1,1],groups:96},!1),i=await this.buildLinearBottleneck(o,["2","447","555","523"],{padding:[1,1,1,1],groups:144}),u=await this.buildLinearBottleneck(i,["3","520","562","542"],{strides:t,padding:[1,1,1,1],groups:144},!1),c=await this.buildLinearBottleneck(u,["4","503","505","489"],{padding:[1,1,1,1],groups:192}),d=await this.buildLinearBottleneck(c,["5","446","530","522"],{padding:[1,1,1,1],groups:192}),h=await this.buildLinearBottleneck(d,["6","491","561","538"],{padding:[1,1,1,1],groups:192},!1),l=await this.buildLinearBottleneck(h,["7","487","560","478"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),p=await this.buildLinearBottleneck(l,["8","467","536","455"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),f=await this.buildLinearBottleneck(p,["9","474","524","558"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),x=await this.buildLinearBottleneck(f,["10","465","556","462"],{padding:[2,2,2,2],groups:384,dilations:[2,2]},!1),b=await this.buildLinearBottleneck(x,["11","453","532","450"],{padding:[2,2,2,2],groups:576,dilations:[2,2]}),m=await this.buildLinearBottleneck(b,["12","441","554","517"],{padding:[2,2,2,2],groups:576,dilations:[2,2]}),I=await this.buildLinearBottleneck(m,["13","544","509","479"],{padding:[2,2,2,2],groups:576,dilations:[2,2]},!1),N=await this.buildLinearBottleneck(I,["14","482","552","512"],{padding:[4,4,4,4],groups:960,dilations:[4,4]}),E=await this.buildLinearBottleneck(N,["15","475","495","563"],{padding:[4,4,4,4],groups:960,dilations:[4,4]}),D=await this.buildLinearBottleneck(E,["16","500","459","539"],{padding:[4,4,4,4],groups:960,dilations:[4,4]},!1),U=await this.buildConv(D,["aspp0_Conv2D","","553"],"relu"),L=this.builder.averagePool2d(D,{windowDimensions:[65,65],layout:"nchw"}),Y=await this.buildConv(L,["image_pooling_Conv2D","","546"],"relu"),V=this.builder.resample2d(Y,{sizes:[65,65],mode:"linear"}),P=this.builder.concat([V,U],1),oe=await this.buildConv(P,["concat_projection_Conv2D","","502"],"relu"),ne=await this.buildConv(oe,["logits_semantic","","541"],"none"),ge=this.builder.resample2d(ne,{sizes:[65,65],mode:"linear"});return this.builder.resample2d(ge,{sizes:[513,513],mode:"linear"})}}class gQ{constructor(e,t){this.weightsUrl=e,this.builder=t}async buildConv(e,t,n="",r=!0,a={}){const o=this.weightsUrl+t;let i=o+".npy",u=o+"_bn_offset.npy";t.includes("depthwise")?(i=o+"_depthwise.npy",u=`${o}_${n}.npy`):t==="logits_semantic"&&(i=o+"_Conv2D.npy",u=o+"_biases.npy");const c=await Ln(this.builder,i),d=await Ln(this.builder,u);return a.inputLayout="nhwc",a.autoPad="same-upper",t.includes("depthwise")?a.filterLayout="ihwo":a.filterLayout="ohwi",a.bias=d,r?a.activation=this.builder.clamp({minValue:0,maxValue:6}):a.activation=void 0,this.builder.conv2d(e,c,a)}async buildLinearBottleneck(e,t,n,r=!0){const a="MobilenetV2_expanded_conv_"+t;let o="depthwise_bn_offset";Number.parseInt(t)>6&&(o="BatchNorm_FusedBatchNorm");const i=await this.buildConv(e,`${a}_expand_Conv2D`),u=await this.buildConv(i,`${a}_depthwise`,o,!0,n),c=await this.buildConv(u,`${a}_project_Conv2D`,"",!1);return r?this.builder.add(e,c):c}async load(e){const t=[2,2],n=await this.buildConv(e,"MobilenetV2_Conv_Conv2D","",!0,{strides:t}),r=await this.buildConv(n,"MobilenetV2_expanded_conv_depthwise","depthwise_bn_offset",!0,{groups:32}),a=await this.buildConv(r,"MobilenetV2_expanded_conv_project_Conv2D","",!1),o=await this.buildLinearBottleneck(a,"1",{strides:t,groups:96},!1),i=await this.buildLinearBottleneck(o,"2",{groups:144}),u=await this.buildLinearBottleneck(i,"3",{strides:t,groups:144},!1),c=await this.buildLinearBottleneck(u,"4",{groups:192}),d=await this.buildLinearBottleneck(c,"5",{groups:192}),h=await this.buildLinearBottleneck(d,"6",{groups:192},!1),l=await this.buildLinearBottleneck(h,"7",{dilations:[2,2],groups:384}),p=await this.buildLinearBottleneck(l,"8",{dilations:[2,2],groups:384}),f=await this.buildLinearBottleneck(p,"9",{dilations:[2,2],groups:384}),x=await this.buildLinearBottleneck(f,"10",{dilations:[2,2],groups:384},!1),b=await this.buildLinearBottleneck(x,"11",{dilations:[2,2],groups:576}),m=await this.buildLinearBottleneck(b,"12",{dilations:[2,2],groups:576}),I=await this.buildLinearBottleneck(m,"13",{dilations:[2,2],groups:576},!1),N=await this.buildLinearBottleneck(I,"14",{dilations:[4,4],groups:960}),E=await this.buildLinearBottleneck(N,"15",{dilations:[4,4],groups:960}),D=await this.buildLinearBottleneck(E,"16",{dilations:[4,4],groups:960},!1),U=await this.buildConv(D,"aspp0_Conv2D"),L=this.builder.averagePool2d(D,{windowDimensions:[65,65],strides:[65,65],layout:"nhwc"}),Y=await this.buildConv(L,"image_pooling_Conv2D"),V=this.builder.resample2d(Y,{sizes:[65,65],mode:"linear",axes:[1,2]}),P=this.builder.concat([V,U],3),oe=await this.buildConv(P,"concat_projection_Conv2D"),ne=await this.buildConv(oe,"logits_semantic","",!1),ge=this.builder.resample2d(ne,{sizes:[65,65],mode:"linear",axes:[1,2]});return this.builder.resample2d(ge,{sizes:[513,513],mode:"linear",axes:[1,2]})}}class bQ{constructor(e,t,n){this.weightsUrl=e,this.builder=t,this.modelId=n}buildInstanceNormalization(e,t,n){if("instanceNormalization"in this.builder)return this.builder.instanceNormalization(e,{scale:this.builder.squeeze(t),bias:this.builder.squeeze(n)});{const r=this.builder.sub(e,this.builder.reduceMean(e,{axes:[2,3],keepDimensions:!0})),a=this.builder.reduceMean(this.builder.mul(r,r),{axes:[2,3],keepDimensions:!0}),o=this.builder.pow(this.builder.add(a,this.constAdd),this.constPow),i=this.builder.mul(t,this.builder.div(r,o));return this.builder.add(i,n)}}async load(e){const t=this.weightsUrl+this.modelId+"/",n=await Ln(this.builder,t+"Variable_read__0__cf__0_0.npy"),r=await Ln(this.builder,t+"Variable_1_read__1__cf__1_0.npy"),a=await Ln(this.builder,t+"Variable_2_read__12__cf__12_0.npy"),o=await Ln(this.builder,t+"Variable_3_read__23__cf__23_0.npy"),i=await Ln(this.builder,t+"Variable_4_read__34__cf__34_0.npy"),u=await Ln(this.builder,t+"Variable_5_read__43__cf__43_0.npy"),c=await Ln(this.builder,t+"Variable_6_read__44__cf__44_0.npy"),d=await Ln(this.builder,t+"Variable_7_read__45__cf__45_0.npy"),h=await Ln(this.builder,t+"Variable_8_read__46__cf__46_0.npy"),l=await Ln(this.builder,t+"Variable_9_read__47__cf__47_0.npy"),p=await Ln(this.builder,t+"Variable_10_read__2__cf__2_0.npy"),f=await Ln(this.builder,t+"Variable_11_read__3__cf__3_0.npy"),x=await Ln(this.builder,t+"Variable_12_read__4__cf__4_0.npy"),b=await Ln(this.builder,t+"Variable_13_read__5__cf__5_0.npy"),m=await Ln(this.builder,t+"Variable_14_read__6__cf__6_0.npy"),I=await Ln(this.builder,t+"Variable_15_read__7__cf__7_0.npy"),N=await Ln(this.builder,t+"Variable_16_read__8__cf__8_0.npy"),E=await Ln(this.builder,t+"Variable_17_read__9__cf__9_0.npy"),D=await Ln(this.builder,t+"Variable_18_read__10__cf__10_0.npy"),U=await Ln(this.builder,t+"Variable_19_read__11__cf__11_0.npy"),L=await Ln(this.builder,t+"Variable_20_read__13__cf__13_0.npy"),Y=await Ln(this.builder,t+"Variable_21_read__14__cf__14_0.npy"),V=await Ln(this.builder,t+"Variable_22_read__15__cf__15_0.npy"),P=await Ln(this.builder,t+"Variable_23_read__16__cf__16_0.npy"),oe=await Ln(this.builder,t+"Variable_24_read__17__cf__17_0.npy"),ne=await Ln(this.builder,t+"Variable_25_read__18__cf__18_0.npy"),ge=await Ln(this.builder,t+"Variable_26_read__19__cf__19_0.npy"),ye=await Ln(this.builder,t+"Variable_27_read__20__cf__20_0.npy"),Ee=await Ln(this.builder,t+"Variable_28_read__21__cf__21_0.npy"),X=await Ln(this.builder,t+"Variable_29_read__22__cf__22_0.npy"),je=await Ln(this.builder,t+"Variable_30_read__24__cf__24_0.npy"),Be=await Ln(this.builder,t+"Variable_31_read__25__cf__25_0.npy"),tt=await Ln(this.builder,t+"Variable_32_read__26__cf__26_0.npy"),ct=await Ln(this.builder,t+"Variable_33_read__27__cf__27_0.npy"),Me=await Ln(this.builder,t+"Variable_34_read__28__cf__28_0.npy"),wt=await Ln(this.builder,t+"Variable_35_read__29__cf__29_0.npy"),at=await Ln(this.builder,t+"Variable_36_read__30__cf__30_0.npy"),Gt=await Ln(this.builder,t+"Variable_37_read__31__cf__31_0.npy"),Ht=await Ln(this.builder,t+"Variable_38_read__32__cf__32_0.npy"),dn=await Ln(this.builder,t+"Variable_39_read__33__cf__33_0.npy"),mn=await Ln(this.builder,t+"Variable_40_read__35__cf__35_0.npy"),Rn=await Ln(this.builder,t+"Variable_41_read__36__cf__36_0.npy"),ee=await Ln(this.builder,t+"Variable_42_read__37__cf__37_0.npy"),se=await Ln(this.builder,t+"Variable_43_read__38__cf__38_0.npy"),we=await Ln(this.builder,t+"Variable_44_read__39__cf__39_0.npy"),pt=await Ln(this.builder,t+"Variable_45_read__40__cf__40_0.npy"),bt=await Ln(this.builder,t+"Variable_46_read__41__cf__41_0.npy"),At=await Ln(this.builder,t+"Variable_47_read__42__cf__42_0.npy"),$e=[0,0,1,1],ht=[0,0,4,4];this.constAdd=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([9999999717180685e-25])),this.constPow=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([.5]));const Pt=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([150])),Ot=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([127.5])),xn=this.builder.conv2d(this.builder.pad(e,ht,ht,{mode:"reflection"}),n),Dn=this.buildInstanceNormalization(xn,a,r),pe=this.builder.relu(Dn),be=this.builder.conv2d(this.builder.pad(pe,$e,$e,{mode:"reflection"}),o,{strides:[2,2]}),Qe=this.buildInstanceNormalization(be,u,i),Un=this.builder.relu(Qe),Ws=this.builder.conv2d(this.builder.pad(Un,$e,$e,{mode:"reflection"}),c,{strides:[2,2]}),Gs=this.buildInstanceNormalization(Ws,h,d),As=this.builder.relu(Gs),xs=this.builder.conv2d(this.builder.pad(As,$e,$e,{mode:"reflection"}),l),ds=this.buildInstanceNormalization(xs,f,p),Ys=this.builder.relu(ds),pn=this.builder.conv2d(this.builder.pad(Ys,$e,$e,{mode:"reflection"}),x),Nn=this.buildInstanceNormalization(pn,m,b),ts=this.builder.add(As,Nn),$s=this.builder.conv2d(this.builder.pad(ts,$e,$e,{mode:"reflection"}),I),Ns=this.buildInstanceNormalization($s,E,N),ys=this.builder.relu(Ns),Vs=this.builder.conv2d(this.builder.pad(ys,$e,$e,{mode:"reflection"}),D),Us=this.buildInstanceNormalization(Vs,L,U),jt=this.builder.add(ts,Us),re=this.builder.conv2d(this.builder.pad(jt,$e,$e,{mode:"reflection"}),Y),de=this.buildInstanceNormalization(re,P,V),ot=this.builder.relu(de),Ct=this.builder.conv2d(this.builder.pad(ot,$e,$e,{mode:"reflection"}),oe),Yt=this.buildInstanceNormalization(Ct,ge,ne),on=this.builder.add(jt,Yt),tn=this.builder.conv2d(this.builder.pad(on,$e,$e,{mode:"reflection"}),ye),bn=this.buildInstanceNormalization(tn,X,Ee),On=this.builder.relu(bn),Mn=this.builder.conv2d(this.builder.pad(On,$e,$e,{mode:"reflection"}),je),wn=this.buildInstanceNormalization(Mn,tt,Be),gs=this.builder.add(on,wn),Hs=this.builder.conv2d(this.builder.pad(gs,$e,$e,{mode:"reflection"}),ct),xr=this.buildInstanceNormalization(Hs,wt,Me),Ir=this.builder.relu(xr),qs=this.builder.conv2d(this.builder.pad(Ir,$e,$e,{mode:"reflection"}),at),ta=this.buildInstanceNormalization(qs,Ht,Gt),pa=this.builder.add(gs,ta),rr=this.builder.convTranspose2d(pa,dn,{strides:[2,2],outputSizes:[270,270]}),eo=this.buildInstanceNormalization(rr,Rn,mn),Qs=this.builder.relu(eo),mr=this.builder.convTranspose2d(Qs,ee,{strides:[2,2],outputSizes:[540,540]}),$r=this.buildInstanceNormalization(mr,we,se),ia=this.builder.relu($r),Pr=this.builder.conv2d(this.builder.pad(ia,ht,ht,{mode:"reflection"}),pt),Cr=this.buildInstanceNormalization(Pr,At,bt);return this.builder.add(this.builder.mul(this.builder.tanh(Cr),Pt),Ot)}}class xQ{constructor(e,t,n){this.context=e,this.builder=t,this.modelName=n}async compile(e){let t;return this.modelName.startsWith("ssdMobilenetV1")?t=e:t={output:e},await this.builder.build(t)}async execute(e,t,n){const r={input:t},a={output:n};return await this.context.compute(e,r,a)}async load(e,t){const n=`https://web102.in-p.de/webnn/models/${this.modelName}/weights/`;let r;switch(this.modelName){case"mobilenetv2_nchw":{r=new iQ(n,this.builder);break}case"mobilenetv2_nhwc":{r=new uQ(n,this.builder);break}case"squeezenet_nchw":{r=new dQ(n,this.builder);break}case"squeezenet_nhwc":{r=new hQ(n,this.builder);break}case"resnet50v2_nchw":{r=new cQ(n,this.builder);break}case"resnet50v2_nhwc":{r=new lQ(n,this.builder);break}case"ssdMobilenetV1_nchw":{r=new aQ(n,this.builder);break}case"ssdMobilenetV1_nhwc":{r=new oQ(n,this.builder);break}case"tinyYoloV2_nchw":{r=new pQ(n,this.builder);break}case"tinyYoloV2_nhwc":{r=new fQ(n,this.builder);break}case"fastStyleTransfer_nchw":{r=new bQ(n,this.builder,t);break}case"deeplabV3_nchw":{r=new mQ(n,this.builder);break}case"deeplabV3_nhwc":{r=new gQ(n,this.builder);break}case"facenet_nchw":{r=new sQ(n,this.builder);break}case"facenet_nhwc":{r=new rQ(n,this.builder);break}default:throw Error(`Model "${this.modelName}" not valid!`)}return await r.load(e)}}let qa={};qa.Array=class{constructor(s){if(s){const e=new qa.Reader(s),t=[147,78,85,77,80,89];if(!e.bytes(6).every((o,i)=>o==t[i]))throw new qa.Error("Invalid signature.");const n=e.byte(),r=e.byte();if(n!==1&&r!==0)throw new qa.Error("Invalid version '"+[n,r].join(".")+"'.");const a=JSON.parse(e.string().trim().replace(/'/g,'"').replace("False","false").replace("(","[").replace(/,*\),*/g,"]"));if(a.fortran_order)throw new qa.Error("Fortran order is not supported.'");if(!a.descr||a.descr.length<2)throw new qa.Error("Missing property 'descr'.");if(!a.shape)throw new qa.Error("Missing property 'shape'.");switch(this._shape=a.shape,this._byteOrder=a.descr[0],this._byteOrder){case"|":{this._dataType=a.descr.substring(1),this._data=e.bytes(e.size-e.position);break}case">":case"<":{if(a.descr.length!==3)throw new qa.Error("Unsupported data type '"+a.descr+"'.");this._dataType=a.descr.substring(1);const o=parseInt(a.descr[2],10)*this._shape.reduce((i,u)=>i*u,1);this._data=e.bytes(o);break}default:throw new qa.Error("Unsupported data type '"+a.descr+"'.")}}}get data(){return this._data}set data(s){this._data=s}get dataType(){return this._dataType}set dataType(s){this._dataType=s}get shape(){return this._shape}set shape(s){this._shape=s}get byteOrder(){return this._byteOrder}set byteOrder(s){this._byteOrder=s}toBuffer(){const s=new qa.Writer;s.bytes([147,78,85,77,80,89]),s.byte(1),s.byte(0);const e={itemSize:1,position:0,dataType:this._dataType,byteOrder:this._byteOrder||"<",shape:this._shape,descr:""};if(e.byteOrder!=="<"&&e.byteOrder!==">")throw new qa.Error("Unknown byte order '"+this._byteOrder+"'.");if(e.dataType.length!==2||e.dataType[0]!=="f"&&e.dataType[0]!=="i"&&e.dataType[0]!=="u")throw new qa.Error("Unsupported data type '"+this._dataType+"'.");e.itemSize=parseInt(e.dataType[1],10);let t="";switch(this._shape.length){case 0:throw new qa.Error("Invalid shape.");case 1:t="("+this._shape[0].toString()+",)";break;default:t="("+this._shape.map(o=>o.toString()).join(", ")+")";break}const n=["'descr': '"+e.byteOrder+e.dataType+"'","'fortran_order': False","'shape': "+t];let r="{ "+n.join(", ")+" }";r+=" ".repeat(16-(r.length+2+8+1&15))+`
`,s.string(r);const a=e.itemSize*this._shape.reduce((o,i)=>o*i);return e.data=new Uint8Array(a),e.view=new DataView(e.data.buffer,e.data.byteOffset,a),qa.Array._encodeDimension(e,this._data,0),s.bytes(e.data),s.toBuffer()}static _encodeDimension(s,e,t){const n=s.shape[t],r=s.byteOrder==="<";if(t==s.shape.length-1)for(let a=0;a<n;a++){switch(s.dataType){case"f2":s.view.setFloat16(s.position,e[a],r);break;case"f4":s.view.setFloat32(s.position,e[a],r);break;case"f8":s.view.setFloat64(s.position,e[a],r);break;case"i1":s.view.setInt8(s.position,e[a],r);break;case"i2":s.view.setInt16(s.position,e[a],r);break;case"i4":s.view.setInt32(s.position,e[a],r);break;case"i8":s.view.setInt64(s.position,e[a],r);break;case"u1":s.view.setUint8(s.position,e[a],r);break;case"u2":s.view.setUint16(s.position,e[a],r);break;case"u4":s.view.setUint32(s.position,e[a],r);break;case"u8":s.view.setUint64(s.position,e[a],r);break}s.position+=s.itemSize}else for(let a=0;a<n;a++)qa.Array._encodeDimension(s,e[a],t+1)}};qa.Reader=class{constructor(s){this._buffer=s,this._position=0}get position(){return this._position}get size(){return this._buffer.length}byte(){return this._buffer[this._position++]}bytes(s){const e=this._buffer.slice(this._position,this._position+s);return this._position+=s,e}uint16(){return this.byte()|this.byte()<<8}string(){const s=this.uint16();let e="";for(let t=0;t<s;t++)e+=String.fromCharCode(this.byte());return e}};qa.Writer=class{constructor(){this._length=0,this._head=null,this._tail=null}byte(s){this.bytes([s])}uint16(s){this.bytes([s&255,s>>8&255])}bytes(s){const e=new Uint8Array(s.length);for(let t=0;t<s.length;t++)e[t]=s[t];this._write(e)}string(s){this.uint16(s.length);const e=new Uint8Array(s.length);for(let t=0;t<s.length;t++)e[t]=s.charCodeAt(t);this._write(e)}_write(s){const e={buffer:s,next:null};this._tail?this._tail.next=e:this._head=e,this._tail=e,this._length+=e.buffer.length}toBuffer(){const s=new Uint8Array(this._length);let e=0,t=this._head;for(;t!=null;)s.set(t.buffer,e),e+=t.buffer.length,t=t.next;return s}};qa.Error=class extends Error{constructor(s){super(s);this.name="NumPy Error"}};function RN(s,e){return function(){return s.apply(e,arguments)}}const{toString:yQ}=Object.prototype,{getPrototypeOf:Mv}=Object,Ob=(s=>e=>{const t=yQ.call(e);return s[t]||(s[t]=t.slice(8,-1).toLowerCase())})(Object.create(null)),Ic=s=>(s=s.toLowerCase(),e=>Ob(e)===s),Fb=s=>e=>typeof e===s,{isArray:Ah}=Array,fp=Fb("undefined");function wQ(s){return s!==null&&!fp(s)&&s.constructor!==null&&!fp(s.constructor)&&ku(s.constructor.isBuffer)&&s.constructor.isBuffer(s)}const AN=Ic("ArrayBuffer");function vQ(s){let e;return typeof ArrayBuffer!="undefined"&&ArrayBuffer.isView?e=ArrayBuffer.isView(s):e=s&&s.buffer&&AN(s.buffer),e}const kQ=Fb("string"),ku=Fb("function"),ON=Fb("number"),Db=s=>s!==null&&typeof s=="object",IQ=s=>s===!0||s===!1,km=s=>{if(Ob(s)!=="object")return!1;const e=Mv(s);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in s)&&!(Symbol.iterator in s)},CQ=Ic("Date"),_Q=Ic("File"),SQ=Ic("Blob"),$Q=Ic("FileList"),TQ=s=>Db(s)&&ku(s.pipe),NQ=s=>{let e;return s&&(typeof FormData=="function"&&s instanceof FormData||ku(s.append)&&((e=Ob(s))==="formdata"||e==="object"&&ku(s.toString)&&s.toString()==="[object FormData]"))},EQ=Ic("URLSearchParams"),RQ=s=>s.trim?s.trim():s.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function Df(s,e,{allOwnKeys:t=!1}={}){if(s===null||typeof s=="undefined")return;let n,r;if(typeof s!="object"&&(s=[s]),Ah(s))for(n=0,r=s.length;n<r;n++)e.call(null,s[n],n,s);else{const a=t?Object.getOwnPropertyNames(s):Object.keys(s),o=a.length;let i;for(n=0;n<o;n++)i=a[n],e.call(null,s[i],i,s)}}function FN(s,e){e=e.toLowerCase();const t=Object.keys(s);let n=t.length,r;for(;n-- >0;)if(r=t[n],e===r.toLowerCase())return r;return null}const DN=(()=>typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:global)(),MN=s=>!fp(s)&&s!==DN;function X0(){const{caseless:s}=MN(this)&&this||{},e={},t=(n,r)=>{const a=s&&FN(e,r)||r;km(e[a])&&km(n)?e[a]=X0(e[a],n):km(n)?e[a]=X0({},n):Ah(n)?e[a]=n.slice():e[a]=n};for(let n=0,r=arguments.length;n<r;n++)arguments[n]&&Df(arguments[n],t);return e}const AQ=(s,e,t,{allOwnKeys:n}={})=>(Df(e,(r,a)=>{t&&ku(r)?s[a]=RN(r,t):s[a]=r},{allOwnKeys:n}),s),OQ=s=>(s.charCodeAt(0)===65279&&(s=s.slice(1)),s),FQ=(s,e,t,n)=>{s.prototype=Object.create(e.prototype,n),s.prototype.constructor=s,Object.defineProperty(s,"super",{value:e.prototype}),t&&Object.assign(s.prototype,t)},DQ=(s,e,t,n)=>{let r,a,o;const i={};if(e=e||{},s==null)return e;do{for(r=Object.getOwnPropertyNames(s),a=r.length;a-- >0;)o=r[a],(!n||n(o,s,e))&&!i[o]&&(e[o]=s[o],i[o]=!0);s=t!==!1&&Mv(s)}while(s&&(!t||t(s,e))&&s!==Object.prototype);return e},MQ=(s,e,t)=>{s=String(s),(t===void 0||t>s.length)&&(t=s.length),t-=e.length;const n=s.indexOf(e,t);return n!==-1&&n===t},PQ=s=>{if(!s)return null;if(Ah(s))return s;let e=s.length;if(!ON(e))return null;const t=new Array(e);for(;e-- >0;)t[e]=s[e];return t},LQ=(s=>e=>s&&e instanceof s)(typeof Uint8Array!="undefined"&&Mv(Uint8Array)),BQ=(s,e)=>{const n=(s&&s[Symbol.iterator]).call(s);let r;for(;(r=n.next())&&!r.done;){const a=r.value;e.call(s,a[0],a[1])}},zQ=(s,e)=>{let t;const n=[];for(;(t=s.exec(e))!==null;)n.push(t);return n},WQ=Ic("HTMLFormElement"),VQ=s=>s.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(t,n,r){return n.toUpperCase()+r}),R2=(({hasOwnProperty:s})=>(e,t)=>s.call(e,t))(Object.prototype),UQ=Ic("RegExp"),PN=(s,e)=>{const t=Object.getOwnPropertyDescriptors(s),n={};Df(t,(r,a)=>{e(r,a,s)!==!1&&(n[a]=r)}),Object.defineProperties(s,n)},jQ=s=>{PN(s,(e,t)=>{if(ku(s)&&["arguments","caller","callee"].indexOf(t)!==-1)return!1;const n=s[t];if(!!ku(n)){if(e.enumerable=!1,"writable"in e){e.writable=!1;return}e.set||(e.set=()=>{throw Error("Can not rewrite read-only method '"+t+"'")})}})},GQ=(s,e)=>{const t={},n=r=>{r.forEach(a=>{t[a]=!0})};return Ah(s)?n(s):n(String(s).split(e)),t},HQ=()=>{},qQ=(s,e)=>(s=+s,Number.isFinite(s)?s:e),a0="abcdefghijklmnopqrstuvwxyz",A2="0123456789",LN={DIGIT:A2,ALPHA:a0,ALPHA_DIGIT:a0+a0.toUpperCase()+A2},KQ=(s=16,e=LN.ALPHA_DIGIT)=>{let t="";const{length:n}=e;for(;s--;)t+=e[Math.random()*n|0];return t};function XQ(s){return!!(s&&ku(s.append)&&s[Symbol.toStringTag]==="FormData"&&s[Symbol.iterator])}const YQ=s=>{const e=new Array(10),t=(n,r)=>{if(Db(n)){if(e.indexOf(n)>=0)return;if(!("toJSON"in n)){e[r]=n;const a=Ah(n)?[]:{};return Df(n,(o,i)=>{const u=t(o,r+1);!fp(u)&&(a[i]=u)}),e[r]=void 0,a}}return n};return t(s,0)},ZQ=Ic("AsyncFunction"),QQ=s=>s&&(Db(s)||ku(s))&&ku(s.then)&&ku(s.catch);var Cn={isArray:Ah,isArrayBuffer:AN,isBuffer:wQ,isFormData:NQ,isArrayBufferView:vQ,isString:kQ,isNumber:ON,isBoolean:IQ,isObject:Db,isPlainObject:km,isUndefined:fp,isDate:CQ,isFile:_Q,isBlob:SQ,isRegExp:UQ,isFunction:ku,isStream:TQ,isURLSearchParams:EQ,isTypedArray:LQ,isFileList:$Q,forEach:Df,merge:X0,extend:AQ,trim:RQ,stripBOM:OQ,inherits:FQ,toFlatObject:DQ,kindOf:Ob,kindOfTest:Ic,endsWith:MQ,toArray:PQ,forEachEntry:BQ,matchAll:zQ,isHTMLForm:WQ,hasOwnProperty:R2,hasOwnProp:R2,reduceDescriptors:PN,freezeMethods:jQ,toObjectSet:GQ,toCamelCase:VQ,noop:HQ,toFiniteNumber:qQ,findKey:FN,global:DN,isContextDefined:MN,ALPHABET:LN,generateString:KQ,isSpecCompliantForm:XQ,toJSONObject:YQ,isAsyncFn:ZQ,isThenable:QQ};function Sr(s,e,t,n,r){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=s,this.name="AxiosError",e&&(this.code=e),t&&(this.config=t),n&&(this.request=n),r&&(this.response=r)}Cn.inherits(Sr,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:Cn.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const BN=Sr.prototype,zN={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(s=>{zN[s]={value:s}});Object.defineProperties(Sr,zN);Object.defineProperty(BN,"isAxiosError",{value:!0});Sr.from=(s,e,t,n,r,a)=>{const o=Object.create(BN);return Cn.toFlatObject(s,o,function(u){return u!==Error.prototype},i=>i!=="isAxiosError"),Sr.call(o,s.message,e,t,n,r),o.cause=s,o.name=s.name,a&&Object.assign(o,a),o};var JQ=null;function Y0(s){return Cn.isPlainObject(s)||Cn.isArray(s)}function WN(s){return Cn.endsWith(s,"[]")?s.slice(0,-2):s}function O2(s,e,t){return s?s.concat(e).map(function(r,a){return r=WN(r),!t&&a?"["+r+"]":r}).join(t?".":""):e}function eJ(s){return Cn.isArray(s)&&!s.some(Y0)}const tJ=Cn.toFlatObject(Cn,{},null,function(e){return/^is[A-Z]/.test(e)});function Mb(s,e,t){if(!Cn.isObject(s))throw new TypeError("target must be an object");e=e||new FormData,t=Cn.toFlatObject(t,{metaTokens:!0,dots:!1,indexes:!1},!1,function(x,b){return!Cn.isUndefined(b[x])});const n=t.metaTokens,r=t.visitor||d,a=t.dots,o=t.indexes,u=(t.Blob||typeof Blob!="undefined"&&Blob)&&Cn.isSpecCompliantForm(e);if(!Cn.isFunction(r))throw new TypeError("visitor must be a function");function c(f){if(f===null)return"";if(Cn.isDate(f))return f.toISOString();if(!u&&Cn.isBlob(f))throw new Sr("Blob is not supported. Use a Buffer instead.");return Cn.isArrayBuffer(f)||Cn.isTypedArray(f)?u&&typeof Blob=="function"?new Blob([f]):Buffer.from(f):f}function d(f,x,b){let m=f;if(f&&!b&&typeof f=="object"){if(Cn.endsWith(x,"{}"))x=n?x:x.slice(0,-2),f=JSON.stringify(f);else if(Cn.isArray(f)&&eJ(f)||(Cn.isFileList(f)||Cn.endsWith(x,"[]"))&&(m=Cn.toArray(f)))return x=WN(x),m.forEach(function(N,E){!(Cn.isUndefined(N)||N===null)&&e.append(o===!0?O2([x],E,a):o===null?x:x+"[]",c(N))}),!1}return Y0(f)?!0:(e.append(O2(b,x,a),c(f)),!1)}const h=[],l=Object.assign(tJ,{defaultVisitor:d,convertValue:c,isVisitable:Y0});function p(f,x){if(!Cn.isUndefined(f)){if(h.indexOf(f)!==-1)throw Error("Circular reference detected in "+x.join("."));h.push(f),Cn.forEach(f,function(m,I){(!(Cn.isUndefined(m)||m===null)&&r.call(e,m,Cn.isString(I)?I.trim():I,x,l))===!0&&p(m,x?x.concat(I):[I])}),h.pop()}}if(!Cn.isObject(s))throw new TypeError("data must be an object");return p(s),e}function F2(s){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(s).replace(/[!'()~]|%20|%00/g,function(n){return e[n]})}function Pv(s,e){this._pairs=[],s&&Mb(s,this,e)}const VN=Pv.prototype;VN.append=function(e,t){this._pairs.push([e,t])};VN.toString=function(e){const t=e?function(n){return e.call(this,n,F2)}:F2;return this._pairs.map(function(r){return t(r[0])+"="+t(r[1])},"").join("&")};function nJ(s){return encodeURIComponent(s).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function UN(s,e,t){if(!e)return s;const n=t&&t.encode||nJ,r=t&&t.serialize;let a;if(r?a=r(e,t):a=Cn.isURLSearchParams(e)?e.toString():new Pv(e,t).toString(n),a){const o=s.indexOf("#");o!==-1&&(s=s.slice(0,o)),s+=(s.indexOf("?")===-1?"?":"&")+a}return s}class sJ{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:n?n.synchronous:!1,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){Cn.forEach(this.handlers,function(n){n!==null&&e(n)})}}var D2=sJ,jN={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},rJ=typeof URLSearchParams!="undefined"?URLSearchParams:Pv,aJ=typeof FormData!="undefined"?FormData:null,oJ=typeof Blob!="undefined"?Blob:null;const iJ=(()=>{let s;return typeof navigator!="undefined"&&((s=navigator.product)==="ReactNative"||s==="NativeScript"||s==="NS")?!1:typeof window!="undefined"&&typeof document!="undefined"})(),uJ=(()=>typeof WorkerGlobalScope!="undefined"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function")();var pc={isBrowser:!0,classes:{URLSearchParams:rJ,FormData:aJ,Blob:oJ},isStandardBrowserEnv:iJ,isStandardBrowserWebWorkerEnv:uJ,protocols:["http","https","file","blob","url","data"]};function cJ(s,e){return Mb(s,new pc.classes.URLSearchParams,Object.assign({visitor:function(t,n,r,a){return pc.isNode&&Cn.isBuffer(t)?(this.append(n,t.toString("base64")),!1):a.defaultVisitor.apply(this,arguments)}},e))}function lJ(s){return Cn.matchAll(/\w+|\[(\w*)]/g,s).map(e=>e[0]==="[]"?"":e[1]||e[0])}function dJ(s){const e={},t=Object.keys(s);let n;const r=t.length;let a;for(n=0;n<r;n++)a=t[n],e[a]=s[a];return e}function GN(s){function e(t,n,r,a){let o=t[a++];const i=Number.isFinite(+o),u=a>=t.length;return o=!o&&Cn.isArray(r)?r.length:o,u?(Cn.hasOwnProp(r,o)?r[o]=[r[o],n]:r[o]=n,!i):((!r[o]||!Cn.isObject(r[o]))&&(r[o]=[]),e(t,n,r[o],a)&&Cn.isArray(r[o])&&(r[o]=dJ(r[o])),!i)}if(Cn.isFormData(s)&&Cn.isFunction(s.entries)){const t={};return Cn.forEachEntry(s,(n,r)=>{e(lJ(n),r,t,0)}),t}return null}const hJ={"Content-Type":void 0};function pJ(s,e,t){if(Cn.isString(s))try{return(e||JSON.parse)(s),Cn.trim(s)}catch(n){if(n.name!=="SyntaxError")throw n}return(t||JSON.stringify)(s)}const Pb={transitional:jN,adapter:["xhr","http"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,a=Cn.isObject(e);if(a&&Cn.isHTMLForm(e)&&(e=new FormData(e)),Cn.isFormData(e))return r&&r?JSON.stringify(GN(e)):e;if(Cn.isArrayBuffer(e)||Cn.isBuffer(e)||Cn.isStream(e)||Cn.isFile(e)||Cn.isBlob(e))return e;if(Cn.isArrayBufferView(e))return e.buffer;if(Cn.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let i;if(a){if(n.indexOf("application/x-www-form-urlencoded")>-1)return cJ(e,this.formSerializer).toString();if((i=Cn.isFileList(e))||n.indexOf("multipart/form-data")>-1){const u=this.env&&this.env.FormData;return Mb(i?{"files[]":e}:e,u&&new u,this.formSerializer)}}return a||r?(t.setContentType("application/json",!1),pJ(e)):e}],transformResponse:[function(e){const t=this.transitional||Pb.transitional,n=t&&t.forcedJSONParsing,r=this.responseType==="json";if(e&&Cn.isString(e)&&(n&&!this.responseType||r)){const o=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(i){if(o)throw i.name==="SyntaxError"?Sr.from(i,Sr.ERR_BAD_RESPONSE,this,null,this.response):i}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:pc.classes.FormData,Blob:pc.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};Cn.forEach(["delete","get","head"],function(e){Pb.headers[e]={}});Cn.forEach(["post","put","patch"],function(e){Pb.headers[e]=Cn.merge(hJ)});var Lv=Pb;const fJ=Cn.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]);var mJ=s=>{const e={};let t,n,r;return s&&s.split(`
`).forEach(function(o){r=o.indexOf(":"),t=o.substring(0,r).trim().toLowerCase(),n=o.substring(r+1).trim(),!(!t||e[t]&&fJ[t])&&(t==="set-cookie"?e[t]?e[t].push(n):e[t]=[n]:e[t]=e[t]?e[t]+", "+n:n)}),e};const M2=Symbol("internals");function qh(s){return s&&String(s).trim().toLowerCase()}function Im(s){return s===!1||s==null?s:Cn.isArray(s)?s.map(Im):String(s)}function gJ(s){const e=Object.create(null),t=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let n;for(;n=t.exec(s);)e[n[1]]=n[2];return e}const bJ=s=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(s.trim());function o0(s,e,t,n,r){if(Cn.isFunction(n))return n.call(this,e,t);if(r&&(e=t),!!Cn.isString(e)){if(Cn.isString(n))return e.indexOf(n)!==-1;if(Cn.isRegExp(n))return n.test(e)}}function xJ(s){return s.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(e,t,n)=>t.toUpperCase()+n)}function yJ(s,e){const t=Cn.toCamelCase(" "+e);["get","set","has"].forEach(n=>{Object.defineProperty(s,n+t,{value:function(r,a,o){return this[n].call(this,e,r,a,o)},configurable:!0})})}class Lb{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function a(i,u,c){const d=qh(u);if(!d)throw new Error("header name must be a non-empty string");const h=Cn.findKey(r,d);(!h||r[h]===void 0||c===!0||c===void 0&&r[h]!==!1)&&(r[h||u]=Im(i))}const o=(i,u)=>Cn.forEach(i,(c,d)=>a(c,d,u));return Cn.isPlainObject(e)||e instanceof this.constructor?o(e,t):Cn.isString(e)&&(e=e.trim())&&!bJ(e)?o(mJ(e),t):e!=null&&a(t,e,n),this}get(e,t){if(e=qh(e),e){const n=Cn.findKey(this,e);if(n){const r=this[n];if(!t)return r;if(t===!0)return gJ(r);if(Cn.isFunction(t))return t.call(this,r,n);if(Cn.isRegExp(t))return t.exec(r);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=qh(e),e){const n=Cn.findKey(this,e);return!!(n&&this[n]!==void 0&&(!t||o0(this,this[n],n,t)))}return!1}delete(e,t){const n=this;let r=!1;function a(o){if(o=qh(o),o){const i=Cn.findKey(n,o);i&&(!t||o0(n,n[i],i,t))&&(delete n[i],r=!0)}}return Cn.isArray(e)?e.forEach(a):a(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const a=t[n];(!e||o0(this,this[a],a,e,!0))&&(delete this[a],r=!0)}return r}normalize(e){const t=this,n={};return Cn.forEach(this,(r,a)=>{const o=Cn.findKey(n,a);if(o){t[o]=Im(r),delete t[a];return}const i=e?xJ(a):String(a).trim();i!==a&&delete t[a],t[i]=Im(r),n[i]=!0}),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const t=Object.create(null);return Cn.forEach(this,(n,r)=>{n!=null&&n!==!1&&(t[r]=e&&Cn.isArray(n)?n.join(", "):n)}),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([e,t])=>e+": "+t).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...t){const n=new this(e);return t.forEach(r=>n.set(r)),n}static accessor(e){const n=(this[M2]=this[M2]={accessors:{}}).accessors,r=this.prototype;function a(o){const i=qh(o);n[i]||(yJ(r,o),n[i]=!0)}return Cn.isArray(e)?e.forEach(a):a(e),this}}Lb.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);Cn.freezeMethods(Lb.prototype);Cn.freezeMethods(Lb);var Bc=Lb;function i0(s,e){const t=this||Lv,n=e||t,r=Bc.from(n.headers);let a=n.data;return Cn.forEach(s,function(i){a=i.call(t,a,r.normalize(),e?e.status:void 0)}),r.normalize(),a}function HN(s){return!!(s&&s.__CANCEL__)}function Mf(s,e,t){Sr.call(this,s==null?"canceled":s,Sr.ERR_CANCELED,e,t),this.name="CanceledError"}Cn.inherits(Mf,Sr,{__CANCEL__:!0});function wJ(s,e,t){const n=t.config.validateStatus;!t.status||!n||n(t.status)?s(t):e(new Sr("Request failed with status code "+t.status,[Sr.ERR_BAD_REQUEST,Sr.ERR_BAD_RESPONSE][Math.floor(t.status/100)-4],t.config,t.request,t))}var vJ=pc.isStandardBrowserEnv?function(){return{write:function(t,n,r,a,o,i){const u=[];u.push(t+"="+encodeURIComponent(n)),Cn.isNumber(r)&&u.push("expires="+new Date(r).toGMTString()),Cn.isString(a)&&u.push("path="+a),Cn.isString(o)&&u.push("domain="+o),i===!0&&u.push("secure"),document.cookie=u.join("; ")},read:function(t){const n=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return n?decodeURIComponent(n[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function kJ(s){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(s)}function IJ(s,e){return e?s.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):s}function qN(s,e){return s&&!kJ(e)?IJ(s,e):e}var CJ=pc.isStandardBrowserEnv?function(){const e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");let n;function r(a){let o=a;return e&&(t.setAttribute("href",o),o=t.href),t.setAttribute("href",o),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:t.pathname.charAt(0)==="/"?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(o){const i=Cn.isString(o)?r(o):o;return i.protocol===n.protocol&&i.host===n.host}}():function(){return function(){return!0}}();function _J(s){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(s);return e&&e[1]||""}function SJ(s,e){s=s||10;const t=new Array(s),n=new Array(s);let r=0,a=0,o;return e=e!==void 0?e:1e3,function(u){const c=Date.now(),d=n[a];o||(o=c),t[r]=u,n[r]=c;let h=a,l=0;for(;h!==r;)l+=t[h++],h=h%s;if(r=(r+1)%s,r===a&&(a=(a+1)%s),c-o<e)return;const p=d&&c-d;return p?Math.round(l*1e3/p):void 0}}function P2(s,e){let t=0;const n=SJ(50,250);return r=>{const a=r.loaded,o=r.lengthComputable?r.total:void 0,i=a-t,u=n(i),c=a<=o;t=a;const d={loaded:a,total:o,progress:o?a/o:void 0,bytes:i,rate:u||void 0,estimated:u&&o&&c?(o-a)/u:void 0,event:r};d[e?"download":"upload"]=!0,s(d)}}const $J=typeof XMLHttpRequest!="undefined";var TJ=$J&&function(s){return new Promise(function(t,n){let r=s.data;const a=Bc.from(s.headers).normalize(),o=s.responseType;let i;function u(){s.cancelToken&&s.cancelToken.unsubscribe(i),s.signal&&s.signal.removeEventListener("abort",i)}Cn.isFormData(r)&&(pc.isStandardBrowserEnv||pc.isStandardBrowserWebWorkerEnv?a.setContentType(!1):a.setContentType("multipart/form-data;",!1));let c=new XMLHttpRequest;if(s.auth){const p=s.auth.username||"",f=s.auth.password?unescape(encodeURIComponent(s.auth.password)):"";a.set("Authorization","Basic "+btoa(p+":"+f))}const d=qN(s.baseURL,s.url);c.open(s.method.toUpperCase(),UN(d,s.params,s.paramsSerializer),!0),c.timeout=s.timeout;function h(){if(!c)return;const p=Bc.from("getAllResponseHeaders"in c&&c.getAllResponseHeaders()),x={data:!o||o==="text"||o==="json"?c.responseText:c.response,status:c.status,statusText:c.statusText,headers:p,config:s,request:c};wJ(function(m){t(m),u()},function(m){n(m),u()},x),c=null}if("onloadend"in c?c.onloadend=h:c.onreadystatechange=function(){!c||c.readyState!==4||c.status===0&&!(c.responseURL&&c.responseURL.indexOf("file:")===0)||setTimeout(h)},c.onabort=function(){!c||(n(new Sr("Request aborted",Sr.ECONNABORTED,s,c)),c=null)},c.onerror=function(){n(new Sr("Network Error",Sr.ERR_NETWORK,s,c)),c=null},c.ontimeout=function(){let f=s.timeout?"timeout of "+s.timeout+"ms exceeded":"timeout exceeded";const x=s.transitional||jN;s.timeoutErrorMessage&&(f=s.timeoutErrorMessage),n(new Sr(f,x.clarifyTimeoutError?Sr.ETIMEDOUT:Sr.ECONNABORTED,s,c)),c=null},pc.isStandardBrowserEnv){const p=(s.withCredentials||CJ(d))&&s.xsrfCookieName&&vJ.read(s.xsrfCookieName);p&&a.set(s.xsrfHeaderName,p)}r===void 0&&a.setContentType(null),"setRequestHeader"in c&&Cn.forEach(a.toJSON(),function(f,x){c.setRequestHeader(x,f)}),Cn.isUndefined(s.withCredentials)||(c.withCredentials=!!s.withCredentials),o&&o!=="json"&&(c.responseType=s.responseType),typeof s.onDownloadProgress=="function"&&c.addEventListener("progress",P2(s.onDownloadProgress,!0)),typeof s.onUploadProgress=="function"&&c.upload&&c.upload.addEventListener("progress",P2(s.onUploadProgress)),(s.cancelToken||s.signal)&&(i=p=>{!c||(n(!p||p.type?new Mf(null,s,c):p),c.abort(),c=null)},s.cancelToken&&s.cancelToken.subscribe(i),s.signal&&(s.signal.aborted?i():s.signal.addEventListener("abort",i)));const l=_J(d);if(l&&pc.protocols.indexOf(l)===-1){n(new Sr("Unsupported protocol "+l+":",Sr.ERR_BAD_REQUEST,s));return}c.send(r||null)})};const Cm={http:JQ,xhr:TJ};Cn.forEach(Cm,(s,e)=>{if(s){try{Object.defineProperty(s,"name",{value:e})}catch{}Object.defineProperty(s,"adapterName",{value:e})}});var NJ={getAdapter:s=>{s=Cn.isArray(s)?s:[s];const{length:e}=s;let t,n;for(let r=0;r<e&&(t=s[r],!(n=Cn.isString(t)?Cm[t.toLowerCase()]:t));r++);if(!n)throw n===!1?new Sr(`Adapter ${t} is not supported by the environment`,"ERR_NOT_SUPPORT"):new Error(Cn.hasOwnProp(Cm,t)?`Adapter '${t}' is not available in the build`:`Unknown adapter '${t}'`);if(!Cn.isFunction(n))throw new TypeError("adapter is not a function");return n},adapters:Cm};function u0(s){if(s.cancelToken&&s.cancelToken.throwIfRequested(),s.signal&&s.signal.aborted)throw new Mf(null,s)}function L2(s){return u0(s),s.headers=Bc.from(s.headers),s.data=i0.call(s,s.transformRequest),["post","put","patch"].indexOf(s.method)!==-1&&s.headers.setContentType("application/x-www-form-urlencoded",!1),NJ.getAdapter(s.adapter||Lv.adapter)(s).then(function(n){return u0(s),n.data=i0.call(s,s.transformResponse,n),n.headers=Bc.from(n.headers),n},function(n){return HN(n)||(u0(s),n&&n.response&&(n.response.data=i0.call(s,s.transformResponse,n.response),n.response.headers=Bc.from(n.response.headers))),Promise.reject(n)})}const B2=s=>s instanceof Bc?s.toJSON():s;function gh(s,e){e=e||{};const t={};function n(c,d,h){return Cn.isPlainObject(c)&&Cn.isPlainObject(d)?Cn.merge.call({caseless:h},c,d):Cn.isPlainObject(d)?Cn.merge({},d):Cn.isArray(d)?d.slice():d}function r(c,d,h){if(Cn.isUndefined(d)){if(!Cn.isUndefined(c))return n(void 0,c,h)}else return n(c,d,h)}function a(c,d){if(!Cn.isUndefined(d))return n(void 0,d)}function o(c,d){if(Cn.isUndefined(d)){if(!Cn.isUndefined(c))return n(void 0,c)}else return n(void 0,d)}function i(c,d,h){if(h in e)return n(c,d);if(h in s)return n(void 0,c)}const u={url:a,method:a,data:a,baseURL:o,transformRequest:o,transformResponse:o,paramsSerializer:o,timeout:o,timeoutMessage:o,withCredentials:o,adapter:o,responseType:o,xsrfCookieName:o,xsrfHeaderName:o,onUploadProgress:o,onDownloadProgress:o,decompress:o,maxContentLength:o,maxBodyLength:o,beforeRedirect:o,transport:o,httpAgent:o,httpsAgent:o,cancelToken:o,socketPath:o,responseEncoding:o,validateStatus:i,headers:(c,d)=>r(B2(c),B2(d),!0)};return Cn.forEach(Object.keys(Object.assign({},s,e)),function(d){const h=u[d]||r,l=h(s[d],e[d],d);Cn.isUndefined(l)&&h!==i||(t[d]=l)}),t}const KN="1.4.0",Bv={};["object","boolean","number","function","string","symbol"].forEach((s,e)=>{Bv[s]=function(n){return typeof n===s||"a"+(e<1?"n ":" ")+s}});const z2={};Bv.transitional=function(e,t,n){function r(a,o){return"[Axios v"+KN+"] Transitional option '"+a+"'"+o+(n?". "+n:"")}return(a,o,i)=>{if(e===!1)throw new Sr(r(o," has been removed"+(t?" in "+t:"")),Sr.ERR_DEPRECATED);return t&&!z2[o]&&(z2[o]=!0,console.warn(r(o," has been deprecated since v"+t+" and will be removed in the near future"))),e?e(a,o,i):!0}};function EJ(s,e,t){if(typeof s!="object")throw new Sr("options must be an object",Sr.ERR_BAD_OPTION_VALUE);const n=Object.keys(s);let r=n.length;for(;r-- >0;){const a=n[r],o=e[a];if(o){const i=s[a],u=i===void 0||o(i,a,s);if(u!==!0)throw new Sr("option "+a+" must be "+u,Sr.ERR_BAD_OPTION_VALUE);continue}if(t!==!0)throw new Sr("Unknown option "+a,Sr.ERR_BAD_OPTION)}}var Z0={assertOptions:EJ,validators:Bv};const ul=Z0.validators;class ng{constructor(e){this.defaults=e,this.interceptors={request:new D2,response:new D2}}request(e,t){typeof e=="string"?(t=t||{},t.url=e):t=e||{},t=gh(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:a}=t;n!==void 0&&Z0.assertOptions(n,{silentJSONParsing:ul.transitional(ul.boolean),forcedJSONParsing:ul.transitional(ul.boolean),clarifyTimeoutError:ul.transitional(ul.boolean)},!1),r!=null&&(Cn.isFunction(r)?t.paramsSerializer={serialize:r}:Z0.assertOptions(r,{encode:ul.function,serialize:ul.function},!0)),t.method=(t.method||this.defaults.method||"get").toLowerCase();let o;o=a&&Cn.merge(a.common,a[t.method]),o&&Cn.forEach(["delete","get","head","post","put","patch","common"],f=>{delete a[f]}),t.headers=Bc.concat(o,a);const i=[];let u=!0;this.interceptors.request.forEach(function(x){typeof x.runWhen=="function"&&x.runWhen(t)===!1||(u=u&&x.synchronous,i.unshift(x.fulfilled,x.rejected))});const c=[];this.interceptors.response.forEach(function(x){c.push(x.fulfilled,x.rejected)});let d,h=0,l;if(!u){const f=[L2.bind(this),void 0];for(f.unshift.apply(f,i),f.push.apply(f,c),l=f.length,d=Promise.resolve(t);h<l;)d=d.then(f[h++],f[h++]);return d}l=i.length;let p=t;for(h=0;h<l;){const f=i[h++],x=i[h++];try{p=f(p)}catch(b){x.call(this,b);break}}try{d=L2.call(this,p)}catch(f){return Promise.reject(f)}for(h=0,l=c.length;h<l;)d=d.then(c[h++],c[h++]);return d}getUri(e){e=gh(this.defaults,e);const t=qN(e.baseURL,e.url);return UN(t,e.params,e.paramsSerializer)}}Cn.forEach(["delete","get","head","options"],function(e){ng.prototype[e]=function(t,n){return this.request(gh(n||{},{method:e,url:t,data:(n||{}).data}))}});Cn.forEach(["post","put","patch"],function(e){function t(n){return function(a,o,i){return this.request(gh(i||{},{method:e,headers:n?{"Content-Type":"multipart/form-data"}:{},url:a,data:o}))}}ng.prototype[e]=t(),ng.prototype[e+"Form"]=t(!0)});var _m=ng;class zv{constructor(e){if(typeof e!="function")throw new TypeError("executor must be a function.");let t;this.promise=new Promise(function(a){t=a});const n=this;this.promise.then(r=>{if(!n._listeners)return;let a=n._listeners.length;for(;a-- >0;)n._listeners[a](r);n._listeners=null}),this.promise.then=r=>{let a;const o=new Promise(i=>{n.subscribe(i),a=i}).then(r);return o.cancel=function(){n.unsubscribe(a)},o},e(function(a,o,i){n.reason||(n.reason=new Mf(a,o,i),t(n.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);t!==-1&&this._listeners.splice(t,1)}static source(){let e;return{token:new zv(function(r){e=r}),cancel:e}}}var RJ=zv;function AJ(s){return function(t){return s.apply(null,t)}}function OJ(s){return Cn.isObject(s)&&s.isAxiosError===!0}const Q0={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Q0).forEach(([s,e])=>{Q0[e]=s});var FJ=Q0;function XN(s){const e=new _m(s),t=RN(_m.prototype.request,e);return Cn.extend(t,_m.prototype,e,{allOwnKeys:!0}),Cn.extend(t,e,null,{allOwnKeys:!0}),t.create=function(r){return XN(gh(s,r))},t}const Qa=XN(Lv);Qa.Axios=_m;Qa.CanceledError=Mf;Qa.CancelToken=RJ;Qa.isCancel=HN;Qa.VERSION=KN;Qa.toFormData=Mb;Qa.AxiosError=Sr;Qa.Cancel=Qa.CanceledError;Qa.all=function(e){return Promise.all(e)};Qa.spread=AJ;Qa.isAxiosError=OJ;Qa.mergeConfig=gh;Qa.AxiosHeaders=Bc;Qa.formToJSON=s=>GN(Cn.isHTMLForm(s)?new FormData(s):s);Qa.HttpStatusCode=FJ;Qa.default=Qa;var DJ=Qa;async function MJ(s,e){return(await DJ.get(s,e)).data}class YN{constructor(e){this.gl_=e,this.fbo_={},this.tex_={}}setTexture(e,t){this.tex_[e]=t}getTexture(e){return this.tex_[e]}setup2dQuad(){const e=new Float32Array([-1,-1,1,-1,1,1,1,1,-1,1,-1,-1]),t=this.gl_.createBuffer();this.gl_.bindBuffer(this.gl_.ARRAY_BUFFER,t),this.gl_.bufferData(this.gl_.ARRAY_BUFFER,e,this.gl_.STATIC_DRAW),this.gl_.enableVertexAttribArray(0),this.gl_.vertexAttribPointer(0,2,this.gl_.FLOAT,!1,0,0)}createAndBindTexture(e){const t=e.name,n=e.filter||this.gl_.LINEAR,r=e.target||this.gl_.TEXTURE_2D,a=e.level||0,o=e.width||1,i=e.height||1,u=e.border||0,c=e.format||this.gl_.RGBA,d=e.internalformat||c,h=e.type||this.gl_.UNSIGNED_BYTE,l=e.format||null,p=this.gl_.createTexture();return this.gl_.bindTexture(this.gl_.TEXTURE_2D,p),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_WRAP_S,this.gl_.CLAMP_TO_EDGE),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_WRAP_T,this.gl_.CLAMP_TO_EDGE),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_MIN_FILTER,n),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_MAG_FILTER,n),this.gl_.texImage2D(r,a,d,o,i,u,c,h,l),this.tex_[t]=p,p}createTextures(e){for(const t of e)this.createAndBindTexture(t)}bindInputTextures(e){for(let t=0;t<e.length;t++)this.gl_.activeTexture(this.gl_.TEXTURE0+t),this.gl_.bindTexture(this.gl_.TEXTURE_2D,this.tex_[e[t]])}bindFramebuffer(e){e===null?this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,null):this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,this.fbo_[e])}bindTexture(e){this.gl_.bindTexture(this.gl_.TEXTURE_2D,this.tex_[e])}createTexInFrameBuffer(e,t){const n=this.gl_.createFramebuffer();this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,n),this.fbo_[e]=n;const r=[];for(let o=0;o<t.length;o++){const i=t[o],u=(i.attach||o)+this.gl_.COLOR_ATTACHMENT0;r.push(u);const c=this.createAndBindTexture(i);this.gl_.framebufferTexture2D(this.gl_.FRAMEBUFFER,u,this.gl_.TEXTURE_2D,c,0)}r.length>1&&this.gl_.drawBuffers(r),this.gl_.checkFramebufferStatus(this.gl_.FRAMEBUFFER)!==this.gl_.FRAMEBUFFER_COMPLETE&&console.warn("FBO is not complete"),this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,null)}setViewport(e,t){this.gl_.viewport(0,0,e,t)}render(){this.gl_.drawArrays(this.gl_.TRIANGLES,0,6)}delete(){this.fbo_={},this.tex_={}}}class mu{constructor(e,t,n){this.gl_=e,this.loc_=[];const r=this.createShader_(this.gl_.VERTEX_SHADER,t),a=this.createShader_(this.gl_.FRAGMENT_SHADER,n);this.prog_=this.createProgram_(r,a);const o=/uniform\s+[^\s]+\s+([_a-zA-Z][_a-zA-Z0-9]*)[=[\s]?[^;]*;/g,i=t+n;for(let u;u=o.exec(i);){const c=u[1];this.loc_[c]=this.gl_.getUniformLocation(this.prog_,c)}}use(){this.gl_.useProgram(this.prog_)}set1i(e,t){this.gl_.uniform1i(this.loc_[e],t)}set4f(e,t,n,r,a){this.gl_.uniform4f(this.loc_[e],t,n,r,a)}set2f(e,t,n){this.gl_.uniform2f(this.loc_[e],t,n)}set1f(e,t){this.gl_.uniform1f(this.loc_[e],t)}set1fv(e,t){this.gl_.uniform1fv(this.loc_[e],t)}createShader_(e,t){const n=this.gl_.createShader(e);if(this.gl_.shaderSource(n,t),this.gl_.compileShader(n),!this.gl_.getShaderParameter(n,this.gl_.COMPILE_STATUS)){const r=this.gl_.getShaderInfoLog(n);throw this.gl_.deleteShader(n),new Error(r)}return n}createProgram_(e,t){const n=this.gl_.createProgram();if(this.gl_.attachShader(n,e),this.gl_.attachShader(n,t),this.gl_.linkProgram(n),!this.gl_.getProgramParameter(n,this.gl_.LINK_STATUS)){const r=this.gl_.getProgramInfoLog(n);throw this.gl_.deleteProgram(n),new Error(r)}return n}}class PJ{constructor(e){if(this.gl=e,this.utils=new YN(e),!this.gl.getExtension("EXT_color_buffer_float"))throw new Error("not support EXT_color_buffer_float");if(!this.gl.getExtension("OES_texture_float_linear"))throw new Error("not support OES_texture_float_linear");this.shaders={},this.width=513,this.height=513,this.subsample=4,this.radius=16,this.epsilon=1e-6,this.radius<4?(this.subRadius=this.radius,this.subWidth=this.width,this.subHeight=this.height):(this.subRadius=this.radius/this.subsample,this.subWidth=this.width/this.subsample,this.subHeight=this.height/this.subsample)}setup(e,t,n,r){this.radius=e,this.epsilon=t,this.width=n,this.height=r,this.radius<4?(this.subRadius=this.radius,this.subWidth=this.width,this.subHeight=this.height):(this.subRadius=this.radius/this.subsample,this.subWidth=this.width/this.subsample,this.subHeight=this.height/this.subsample),this.utils.setup2dQuad(),this.setupHadamard4Shader_(),this.setupBoxFilterShader_(),this.setupHadamard2Shader_(),this.setupCovarShader_(),this.setupFinalShader_()}setupHadamard4Shader_(){const e=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        }`,t=`#version 300 es
        precision highp float;

        out vec4 result;

        uniform sampler2D u_p;
        uniform sampler2D u_I;

        in vec2 v_texcoord;

        void main() {
          float I = texture(u_I, v_texcoord).x;
          float p = texture(u_p, v_texcoord).a;
          float Ip = I * p;
          float II = I * I;
          result = vec4(I, p, Ip, II);
        }`;this.shaders.hadamard4=new mu(this.gl,e,t),this.utils.createAndBindTexture({name:"p",filter:this.gl.NEAREST}),this.utils.createAndBindTexture({name:"I",filter:this.gl.LINEAR}),this.utils.createTexInFrameBuffer("fbo1",[{name:"result1",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.shaders.hadamard4.use(),this.shaders.hadamard4.set1i("u_p",0),this.shaders.hadamard4.set1i("u_I",1)}setupBoxFilterShader_(){const e=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,t=`#version 300 es
        precision highp float;
        out vec4 out_color;
        in vec2 v_texcoord;

        uniform sampler2D bg;
        uniform bool first_pass;
        uniform int radius;

        void main() {
          vec2 tex_offset = 1.0 / vec2(textureSize(bg, 0));
          vec4 result = texture(bg, v_texcoord);
          if (first_pass) {
            for (int i = 1; i <= radius; ++i) {
              result += texture(bg, v_texcoord + vec2(tex_offset.x * float(i), 0.0));
              result += texture(bg, v_texcoord - vec2(tex_offset.x * float(i), 0.0));
            }
          } else {
            for (int i = 1; i <= radius; ++i) {
              result += texture(bg, v_texcoord + vec2(0.0, tex_offset.y * float(i)));
              result += texture(bg, v_texcoord - vec2(0.0, tex_offset.y * float(i)));
            }
          }
          out_color = result / (2.0 * float(radius) + 1.0);
        }`;this.shaders.boxFilter=new mu(this.gl,e,t),this.utils.createTexInFrameBuffer("pingpong",[{name:"pingpongTemp",width:this.subWidth,height:this.subHeight,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.utils.createTexInFrameBuffer("fbo2",[{name:"result2",width:this.subWidth,height:this.subHeight,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.utils.createTexInFrameBuffer("fbo5",[{name:"result5",width:this.width,height:this.height,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupHadamard2Shader_(){const e=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,t=`#version 300 es
        precision highp float;

        in vec2 v_texcoord;
        out vec4 result;

        uniform sampler2D result2;

        void main() {
          vec4 prev = texture(result2, v_texcoord);
          float mean_I = prev.x;
          float mean_p = prev.y;
          result.xy = vec2(mean_I * mean_p, mean_I * mean_I);
        }`;this.shaders.hadamard2=new mu(this.gl,e,t),this.utils.createTexInFrameBuffer("fbo3",[{name:"result3",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupCovarShader_(){const e=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,t=`#version 300 es
        precision highp float;

        in vec2 v_texcoord;
        out vec4 result;

        uniform sampler2D result2;
        uniform sampler2D result3;
        uniform float epsilon;

        void main() {
          vec4 r2 = texture(result2, v_texcoord);
          float meanI = r2.x;
          float meanp = r2.y;
          float meanIp = r2.z;
          float meanII = r2.a;
          vec4 r3 = texture(result3, v_texcoord);
          float meanI_meanp = r3.x;
          float meanI_meanI = r3.y;

          // this is the covariance of (I, p) in each local patch
          float covIp = meanIp - meanI_meanp;
          float varI = meanII - meanI_meanI;
          float a = covIp / (varI + epsilon);
          float b = meanp - a * meanI;
          result.xy = vec2(a, b);
        }`;this.shaders.covar=new mu(this.gl,e,t),this.shaders.covar.use(),this.shaders.covar.set1i("result2",0),this.shaders.covar.set1i("result3",1),this.utils.createTexInFrameBuffer("fbo4",[{name:"result4",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupFinalShader_(){const e=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;
        out vec2 v_flipcord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
          v_flipcord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        }`,t=`#version 300 es
        precision highp float;

        out vec4 result;

        uniform sampler2D result5;
        uniform sampler2D u_I;

        in vec2 v_flipcord;
        in vec2 v_texcoord;

        void main() {
          vec4 r5 = texture(result5, v_texcoord);
          vec4 I = texture(u_I, v_flipcord);
          float mean_a = r5.x;
          float mean_b = r5.y;

          // q = mean_a .* I + mean_b;
          float intensity = mean_a * I.z + mean_b;
          result = vec4(intensity, intensity, intensity, intensity);
        }`;this.shaders.final=new mu(this.gl,e,t),this.shaders.final.use(),this.shaders.final.set1i("result5",0),this.shaders.final.set1i("u_I",1),this.utils.createTexInFrameBuffer("fbo6",[{name:"result6",width:this.width,height:this.height,filter:this.gl.LINEAR}])}apply(e,t,n,r){return this.utils.bindTexture("p"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,n,r,0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,t),this.utils.bindTexture("I"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.LUMINANCE,this.gl.LUMINANCE,this.gl.UNSIGNED_BYTE,e),this.shaders.hadamard4.use(),this.utils.bindFramebuffer("fbo1"),this.utils.bindInputTextures(["p","I"]),this.utils.setViewport(this.subWidth,this.subHeight),this.utils.render(),this.shaders.boxFilter.use(),this.shaders.boxFilter.set1i("first_pass",1),this.shaders.boxFilter.set1i("radius",this.subRadius),this.utils.bindFramebuffer("pingpong"),this.utils.bindInputTextures(["result1"]),this.utils.render(),this.shaders.boxFilter.set1i("first_pass",0),this.utils.bindFramebuffer("fbo2"),this.utils.bindInputTextures(["pingpongTemp"]),this.utils.render(),this.shaders.hadamard2.use(),this.utils.bindFramebuffer("fbo3"),this.utils.bindInputTextures(["result2"]),this.utils.render(),this.shaders.covar.use(),this.shaders.covar.set1f("epsilon",this.epsilon),this.utils.bindFramebuffer("fbo4"),this.utils.bindInputTextures(["result2","result3"]),this.utils.render(),this.shaders.boxFilter.use(),this.shaders.boxFilter.set1i("first_pass",1),this.shaders.boxFilter.set1i("radius",this.subRadius),this.utils.bindFramebuffer("pingpong"),this.utils.bindInputTextures(["result4"]),this.utils.render(),this.shaders.boxFilter.set1i("first_pass",0),this.utils.bindFramebuffer("fbo5"),this.utils.bindInputTextures(["pingpongTemp"]),this.utils.setViewport(this.width,this.height),this.utils.render(),this.shaders.final.use(),this.utils.bindFramebuffer("fbo6"),this.utils.bindInputTextures(["result5","I"]),this.utils.render(),this.utils.getTexture("result6")}}class LJ{constructor(e){if(this.gl=e.getContext("webgl2"),this.gl===null)throw new Error("Unable to initialize WebGL.");this.guidedFilter=new PJ(this.gl),this.utils=new YN(this.gl),this.shaders={},this.segMap_=null,this.predictions_=null,this.fixedSize_=513,this.clippedSize_=[this.fixedSize_,this.fixedSize_],this.imageSource_=null,this.effect_="label",this.zoom_=1,this.bgColor_=[57,135,189],this.colorMapAlpha_=.7,this.blurRadius_=30,this.backgroundImageSource_=null;const t=this.generateGaussianKernel1D_(this.blurRadius_*2+1);this.halfKernel_=t.slice(this.blurRadius_),this.guidedFilterRadius_=0,this.colorPalette_=new Uint8Array([45,52,54,85,239,196,129,236,236,116,185,255,162,155,254,223,230,233,0,184,148,0,206,201,9,132,227,39,60,117,108,92,231,178,190,195,255,234,167,250,177,160,255,118,117,253,121,168,99,110,114,253,203,110,225,112,85,214,48,49,232,67,147])}setup(){switch(this.guidedFilter.setup(this.guidedFilterRadius_,1e-6,this.clippedSize_[0]*this.zoom_,this.clippedSize_[1]*this.zoom_),this.utils.setup2dQuad(),this.effect_){case"label":this.setupColorizeShader_();break;case"blur":this.setupExtractShader_(),this.setupBlurShader_(),this.setupBlendShader_();break;case"image":this.setupExtractShader_(),this.setupImageShader_(),this.setupBlendShader_();break;case"fill":this.setupExtractShader_(),this.setupFillShader_(),this.setupBlendShader_();break;default:console.warn("Unknown effect")}}setupColorizeShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = v_texcoord;
      }`,t=`#version 300 es
      precision highp float;
      out vec4 out_color;

      uniform sampler2D u_image;
      uniform sampler2D upredictions_;
      uniform sampler2D u_palette;
      uniform int u_length;
      uniform float u_alpha;

      in vec2 v_maskcord;
      in vec2 v_texcoord;

      void main() {
        float label_index = texture(upredictions_, v_maskcord).a * 255.0;
        vec4 label_color = texture(u_palette, vec2((label_index + 0.5) / float(u_length), 0.5));
        vec4 im_color = texture(u_image, v_texcoord);
        out_color = mix(im_color, label_color, u_alpha);
      }`;this.shaders.colorize=new mu(this.gl,e,t),this.shaders.colorize.use(),this.shaders.colorize.set1i("u_image",0),this.shaders.colorize.set1i("upredictions_",1),this.shaders.colorize.set1i("u_palette",2),this.shaders.colorize.set1i("u_length",this.colorPalette_.length/3),typeof this.utils.getTexture("image")=="undefined"&&this.utils.createAndBindTexture({name:"image",filter:this.gl.LINEAR}),this.utils.createAndBindTexture({name:"predictions",filter:this.gl.NEAREST}),this.utils.createAndBindTexture({name:"palette",filter:this.gl.NEAREST}),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGB,this.colorPalette_.length/3,1,0,this.gl.RGB,this.gl.UNSIGNED_BYTE,this.colorPalette_)}setupExtractShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = v_texcoord;
      }`,t=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,n=`#version 300 es
      precision highp float;
      layout(location = 0) out vec4 fg_color;
      layout(location = 1) out vec4 bg_color;

      uniform sampler2D u_mask;
      uniform sampler2D u_image;

      in vec2 v_maskcord;
      in vec2 v_texcoord;

      void main() {
        float fg_alpha = texture(u_mask, v_maskcord).a;
        float bg_alpha = 1.0 - fg_alpha;

        vec4 pixel = texture(u_image, v_texcoord);
        fg_color = vec4(pixel.xyz * fg_alpha, fg_alpha);
        bg_color = vec4(pixel.xyz * bg_alpha, bg_alpha);
      }`;this.guidedFilterRadius_===0?this.shaders.extract=new mu(this.gl,e,n):this.shaders.extract=new mu(this.gl,t,n),typeof this.utils.getTexture("image")=="undefined"&&this.utils.createAndBindTexture({name:"image",filter:this.gl.LINEAR}),this.utils.createAndBindTexture({name:"predictions",filter:this.gl.NEAREST}),this.utils.createTexInFrameBuffer("extract",[{name:"fg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_},{name:"bg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.shaders.extract.use(),this.shaders.extract.set1i("u_image",0),this.shaders.extract.set1i("u_mask",1)}setupBlurShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,t=`#version 300 es
      precision highp float;
      out vec4 out_color;
      in vec2 v_texcoord;

      uniform sampler2D bg;
      uniform bool first_pass;
      uniform float kernel[${this.blurRadius_+1}];

      // https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/7.bloom/7.blur.fs

      void main() {
        vec2 tex_offset = 1.0 / vec2(textureSize(bg, 0)); // gets size of single texel
        vec4 bg_color = texture(bg, v_texcoord);
        vec4 result = bg_color * kernel[0];
        if (first_pass) {
          for (int i = 1; i < ${this.blurRadius_+1}; ++i) {
            result += texture(bg, v_texcoord + vec2(tex_offset.x * float(i), 0.0)) * kernel[i];
            result += texture(bg, v_texcoord - vec2(tex_offset.x * float(i), 0.0)) * kernel[i];
          }
        } else {
          for (int i = 1; i < ${this.blurRadius_+1}; ++i) {
            result += texture(bg, v_texcoord + vec2(0.0, tex_offset.y * float(i))) * kernel[i];
            result += texture(bg, v_texcoord - vec2(0.0, tex_offset.y * float(i))) * kernel[i];
          }
        }
        out_color = result;
      }`;this.shaders.blur=new mu(this.gl,e,t),this.shaders.blur.use(),this.shaders.blur.set1fv("kernel",this.halfKernel_),this.utils.createTexInFrameBuffer("blurFirstPassResult",[{name:"blurFirstPassResult",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}])}setupFillShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
      }`,t=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;
      uniform vec4 fill_color;

      void main() {
        // solid color background
        out_color = fill_color;
      }`;this.shaders.fill=new mu(this.gl,e,t),this.shaders.fill.use();const n=this.bgColor_.map(r=>r/255);this.shaders.fill.set4f("fill_color",...n,1),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}])}setupImageShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
      }`,t=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;
      uniform int has_bg;
      uniform vec2 canvas_size;

      uniform sampler2D bg_image;

      void main() {
        if (has_bg != 0) {
          // stretch the background image to fit the viewport
          vec2 image_size = vec2(textureSize(bg_image, 0));
          float image_ratio = image_size.x / image_size.y;
          float canvas_ratio = canvas_size.x / canvas_size.y;
          vec2 bgcoord = (v_texcoord / image_size) * canvas_size;
          if (image_ratio > canvas_ratio) {
            bgcoord *= image_size.y / canvas_size.y;
          } else {
            bgcoord *= image_size.x / canvas_size.x;
          }
          out_color = texture(bg_image, bgcoord);
        } else {
          // checkerboard background
          vec2 offset = floor(v_texcoord * canvas_size / 5.0);
          if (mod(offset.x, 2.0) == 0.0) {
            if (mod(offset.y, 2.0) == 0.0) {
              out_color = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
              out_color = vec4(0.8, 0.8, 0.8, 1.0);
            }
          } else {
            if (mod(offset.y, 2.0) != 0.0) {
              out_color = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
              out_color = vec4(0.8, 0.8, 0.8, 1.0);
            }
          }
        }
      }`;this.shaders.image=new mu(this.gl,e,t),this.utils.createAndBindTexture({name:"bgImage"}),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.shaders.image.use(),this.shaders.image.set2f("canvas_size",this.clippedSize_[0],this.clippedSize_[1]),this.backgroundImageSource_?(this.shaders.image.set1i("has_bg",1),this.utils.bindTexture("bgImage"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.backgroundImageSource_)):this.shaders.image.set1i("has_bg",0)}setupBlendShader_(){const e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,t=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;

      uniform sampler2D fg;
      uniform sampler2D bg;
      uniform sampler2D orig;

      void main() {
        vec4 fg_color = texture(fg, v_texcoord);
        vec4 bg_color = texture(bg, v_texcoord);
        vec4 orig_color = texture(orig, vec2(v_texcoord.x, (1.0-v_texcoord.y)));
        bg_color = bg_color + (1.0 - bg_color.a) * orig_color;
        out_color = fg_color + (1.0 - fg_color.a) * bg_color;
      }`;this.shaders.blend=new mu(this.gl,e,t),this.shaders.blend.use(),this.shaders.blend.set1i("fg",0),this.shaders.blend.set1i("bg",1),this.shaders.blend.set1i("orig",2)}async uploadNewTexture(e,t){(this.clippedSize_[0]!==t[0]||this.clippedSize_[1]!==t[1])&&(this.clippedSize_=t,this.zoom_=this.fixedSize_/this.clippedSize_[0],this.setup()),this.imageSource_=e,this.utils.bindTexture("image"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e)}async drawOutputs(e){if(!!e){if(this.gl.canvas.width=this.clippedSize_[0]*this.zoom_,this.gl.canvas.height=this.clippedSize_[1]*this.zoom_,this.utils.setViewport(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight),this.effect_==="label")return this.segMap_=e,this.predictions_=this.maskSegMap_(e),this.utils.bindTexture("predictions"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,this.clippedSize_[0],this.clippedSize_[1],0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,this.predictions_),this.drawColorLabel_();if(this.segMap_=e,this.predictions_=this.maskSegMapPerson_(e),this.guidedFilterRadius_===0)this.utils.bindTexture("predictions"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,this.clippedSize_[0],this.clippedSize_[1],0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,this.predictions_);else{const t=this.guidedFilter.apply(this.imageSource_,this.predictions_,this.clippedSize_[0],this.clippedSize_[1]);this.utils.setTexture("predictions",t)}return this.drawPerson_()}}drawColorLabel_(){const e=this.shaders.colorize;e.use(),e.set1f("u_alpha",this.colorMapAlpha_),this.utils.bindFramebuffer(null),this.utils.bindInputTextures(["image","predictions","palette"]),this.utils.render();const t=new Set(this.predictions_),n={};for(const r of t){const a=this.segMap_.labels[r],o=this.colorPalette_.slice(r*3,(r+1)*3);a&&(n[r]=[a,o])}return n}drawPerson_(){let e;switch(this.shaders.extract.use(),this.utils.bindFramebuffer("extract"),this.utils.bindInputTextures(["image","predictions"]),this.utils.render(),this.effect_){case"blur":e=this.shaders.blur,e.use(),e.set1i("first_pass",1),this.utils.bindFramebuffer("blurFirstPassResult"),this.utils.bindInputTextures(["bg"]),this.utils.render(),e.set1i("first_pass",0),this.utils.bindFramebuffer("styledBg"),this.utils.bindInputTextures(["blurFirstPassResult"]),this.utils.render();break;case"image":e=this.shaders.image,e.use(),this.utils.bindFramebuffer("styledBg"),this.utils.bindInputTextures(["bgImage"]),this.utils.render();break;case"fill":e=this.shaders.fill,e.use(),this.utils.bindFramebuffer("styledBg"),this.utils.render()}this.shaders.blend.use(),this.utils.bindFramebuffer(null),this.utils.bindInputTextures(["fg","styledBg","image"]),this.utils.render()}maskSegMap_(e){const t=this.clippedSize_[1],n=this.clippedSize_[0],r=e.outputShape[1],a=e.data,o=new Uint8Array(t*n);let i=0;for(let u=0;u<t;u++)for(let c=0;c<n;c++)o[i++]=a[u*r+c];return o}maskSegMapPerson_(e){const n=this.clippedSize_[1],r=this.clippedSize_[0],a=e.outputShape[1],o=e.data,i=new Uint8Array(n*r);let u=0;for(let c=0;c<n;c++)for(let d=0;d<r;d++)i[u++]=o[c*a+d]===15?255:0;return i}generateGaussianKernel1D_(e,t=30){const n=(i,u)=>1/(Math.sqrt(2*Math.PI)*u)*Math.exp(-i*i/(2*u*u)),r=[],a=(e-1)/2;for(let i=-a;i<=a;i++)r.push(n(i,t));const o=r.reduce((i,u)=>i+u);return r.map(i=>i/o)}}async function ZN(s={}){return await navigator.ml.createContext(B1({powerPreference:"low-power"},s))}async function UJ(s,e){const n=await ZN(),r=new MLGraphBuilder(n),a=eh(s),o={type:"float32",dimensions:s},u=s.map((f,x)=>r.input(`input_${x}`,o)).reduce((f,x,b,m)=>{const I=Math.floor(b/2);return f[I]||(f[I]=[]),f[I].push(x),f},[]).filter(f=>!!f[0]&&!!f[1]).map(f=>r.add(f[0],f[1])),c=r.mul(u[0],u[1]),d=await r.build({output:c}),h=[...d.inputs_.keys()].reduce((f,x,b)=>Uv(B1({},f),{[x]:new Float32Array(a).fill(e[b])}),{}),l=new Float32Array(a);return(await n.compute(d,h,{output:l})).outputs.output}function jJ(s,e,t){let n=[1,3,t.height,t.width];const r=new Float32Array(n.slice(1).reduce((I,N)=>I*N));let[a,o,i]=n.slice(1);t.layout==="nhwc"&&(n=[1,t.height,t.width,3],[o,i,a]=n.slice(1));const u=t.mean||[0,0,0,0],c=t.std||[1,1,1,1],d=t.normalize||!1,h=t.channelScheme||"RGB",l=t.scaled||!1,p=t.layout,f=4,x=e;s.width=s.videoWidth||s.naturalWidth,s.height=s.videoHeight||s.naturalHeight,x.width=i,x.height=o;const b=x.getContext("2d");if(l){const I=Math.max(Math.max(s.width/i,s.height/o),1),N=Math.floor(s.width/I),E=Math.floor(s.height/I);b.drawImage(s,0,0,N,E)}else b.drawImage(s,0,0,i,o);let m=b.getImageData(0,0,i,o).data;d&&(m=new Float32Array(m).map(I=>I/255));for(let I=0;I<a;++I)for(let N=0;N<o;++N)for(let E=0;E<i;++E){let D;h==="BGR"?D=m[N*i*f+E*f+(a-I-1)]:D=m[N*i*f+E*f+I],p==="nchw"?r[I*i*o+N*i+E]=(D-u[I])/c[I]:r[N*i*a+E*a+I]=(D-u[I])/c[I]}return{tensor:r,dimensions:n}}async function GJ(s,e,t,n,r,a){const o=await ZN(),i=new MLGraphBuilder(o),u=i.input("input",{type:"float32",dimensions:t});let c;s==="objectDetection"&&n.startsWith("ssdMobilenetV1")?c={boxes:new Float32Array(eh([1,1917,1,4])),scores:new Float32Array(eh([1,1917,91]))}:c=new Float32Array(eh(r));const d=new xQ(o,i,n),h=await d.load(u,a),l=await d.compile(h);return(await d.execute(l,e,c)).outputs.output}async function HJ(s,e,t,n,r,a,o,i=3){if(s==="imageClassification")return Array.from(t).map((h,l)=>[h,l]).sort((h,l)=>h[0]-l[0]).reverse().slice(0,i).map(([h,l])=>({label:n[l],value:(h*100).toFixed(2)}));if(s==="objectDetection"){const[u,c]=e.split("_");if(u==="tinyYoloV2"){c==="nchw"&&(t=Qt(()=>{const l=Am(t,r,"float32");return br(l,[0,2,3,1]).dataSync()}));const d=ZZ({numClasses:20},t,a.anchors),h=QZ(d,a.margin);return h.length===0?!1:(JZ(o.input,o.output,h,n),h.map(l=>({label:n[l[0]],value:Math.round(l.pop()*100).toFixed(2)})))}else console.log(s,u,c,t)}else if(s==="semanticSegmentation"){const[u,c]=Qt(()=>{const N=Am(t,r,"float32"),E=a.layout==="nchw"?1:3,D=ah(N,E);return[D.dataSync(),D.shape]}),d=o.input,h=a.dimensions[2],l=d.naturalWidth|d.width,p=d.naturalHeight|d.height,f=Math.max(Math.max(l,p)/h,1),x=Math.floor(l/f),b=Math.floor(p/f),m={data:u,outputShape:c,labels:n},I=new LJ(o.segCanvas);I.setup(),await I.uploadNewTexture(d,[x,b]),await I.drawOutputs(m)}else console.log(s,t);return[{label:"TEST",value:0}]}async function Ln(s,e){const t=new Map([["f2",{type:"float16",array:Uint16Array}],["f4",{type:"float32",array:Float32Array}],["f8",{type:"float64",array:Float64Array}],["i1",{type:"int8",array:Int8Array}],["i2",{type:"int16",array:Int16Array}],["i4",{type:"int32",array:Int32Array}],["i8",{type:"int64",array:BigInt64Array}],["u1",{type:"uint8",array:Uint8Array}],["u2",{type:"uint16",array:Uint16Array}],["u4",{type:"uint32",array:Uint32Array}],["u8",{type:"uint64",array:BigUint64Array}]]),n=await MJ(e,{responseType:"arraybuffer"}),r=new qa.Array(new Uint8Array(n));if(!t.has(r.dataType))throw new Error(`Data type ${r.dataType} is not supported.`);const a=r.shape,o=t.get(r.dataType).type,i=t.get(r.dataType).array,u=new i(eh(a)),c=new DataView(r.data.buffer),d=r.byteOrder==="<";for(let h=0;h<eh(a);++h)u[h]=c["get"+o[0].toUpperCase()+o.substr(1)](h*i.BYTES_PER_ELEMENT,d);return s.constant({type:o,dimensions:a},u)}function eh(s){return s.reduce((e,t)=>e*t)}export{MJ as G,UJ as b,GJ as c,jJ as g,HJ as m};
