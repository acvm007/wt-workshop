var Ed=Object.defineProperty,Ad=Object.defineProperties;var Nd=Object.getOwnPropertyDescriptors;var Wl=Object.getOwnPropertySymbols;var Rd=Object.prototype.hasOwnProperty,Fd=Object.prototype.propertyIsEnumerable;var Vl=(I,n,e)=>n in I?Ed(I,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):I[n]=e,Tl=(I,n)=>{for(var e in n||(n={}))Rd.call(n,e)&&Vl(I,e,n[e]);if(Wl)for(var e of Wl(n))Fd.call(n,e)&&Vl(I,e,n[e]);return I},Ol=(I,n)=>Ad(I,Nd(n));import{ar as Gl,as as Hl,at as Md,au as Dd}from"./index.9c8d56d9.js";import"./autoprefixer.5023fe33.js";(function(I){var n={};function e(t){if(n[t])return n[t].exports;var m=n[t]={i:t,l:!1,exports:{}};return I[t].call(m.exports,m,m.exports,e),m.l=!0,m.exports}e.m=I,e.c=n,e.d=function(t,m,h){e.o(t,m)||Object.defineProperty(t,m,{enumerable:!0,get:h})},e.r=function(t){typeof Symbol!="undefined"&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,m){if(1&m&&(t=e(t)),8&m||4&m&&typeof t=="object"&&t&&t.__esModule)return t;var h=Object.create(null);if(e.r(h),Object.defineProperty(h,"default",{enumerable:!0,value:t}),2&m&&typeof t!="string")for(var b in t)e.d(h,b,function(A){return t[A]}.bind(null,b));return h},e.n=function(t){var m=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(m,"a",m),m},e.o=function(t,m){return Object.prototype.hasOwnProperty.call(t,m)},e.p="",e(e.s=103)})([function(I,n,e){e.r(n),e.d(n,"AdadeltaOptimizer",function(){return Rs}),e.d(n,"AdagradOptimizer",function(){return ws}),e.d(n,"AdamOptimizer",function(){return Fs}),e.d(n,"AdamaxOptimizer",function(){return Ms}),e.d(n,"MomentumOptimizer",function(){return ti}),e.d(n,"Optimizer",function(){return Ka}),e.d(n,"OptimizerConstructors",function(){return ns}),e.d(n,"RMSPropOptimizer",function(){return Ps}),e.d(n,"SGDOptimizer",function(){return Ds}),e.d(n,"Tensor",function(){return un.a}),e.d(n,"TensorBuffer",function(){return un.b}),e.d(n,"Variable",function(){return un.c}),e.d(n,"Rank",function(){return Bs.a}),e.d(n,"sumOutType",function(){return Bs.b}),e.d(n,"upcastType",function(){return Bs.c}),e.d(n,"abs",function(){return va}),e.d(n,"acos",function(){return Ai}),e.d(n,"acosh",function(){return Ls}),e.d(n,"add",function(){return Yn}),e.d(n,"addN",function(){return rs}),e.d(n,"all",function(){return ni}),e.d(n,"any",function(){return js}),e.d(n,"argMax",function(){return Ni}),e.d(n,"argMin",function(){return _s}),e.d(n,"asin",function(){return zs}),e.d(n,"asinh",function(){return ri}),e.d(n,"atan",function(){return vi}),e.d(n,"atan2",function(){return Ri}),e.d(n,"atanh",function(){return Fi}),e.d(n,"avgPool",function(){return _t}),e.d(n,"avgPool3d",function(){return jt}),e.d(n,"basicLSTMCell",function(){return Fn}),e.d(n,"batchToSpaceND",function(){return nr}),e.d(n,"batchNorm",function(){return dr}),e.d(n,"batchNorm2d",function(){return hr}),e.d(n,"batchNorm3d",function(){return cr}),e.d(n,"batchNorm4d",function(){return Mr}),e.d(n,"bincount",function(){return Sr}),e.d(n,"broadcastArgs",function(){return Dr}),e.d(n,"broadcastTo",function(){return Ar}),e.d(n,"buffer",function(){return Rn}),e.d(n,"cast",function(){return Mn}),e.d(n,"ceil",function(){return aa}),e.d(n,"clipByValue",function(){return ya}),e.d(n,"clone",function(){return zr}),e.d(n,"complex",function(){return wa.a}),e.d(n,"concat",function(){return Xt}),e.d(n,"concat1d",function(){return Xa}),e.d(n,"concat2d",function(){return as}),e.d(n,"concat3d",function(){return Us}),e.d(n,"concat4d",function(){return Is}),e.d(n,"conv1d",function(){return ds}),e.d(n,"conv2d",function(){return Ya}),e.d(n,"conv2dTranspose",function(){return Ws}),e.d(n,"conv3d",function(){return fa}),e.d(n,"conv3dTranspose",function(){return wi}),e.d(n,"cos",function(){return Gs}),e.d(n,"cosh",function(){return ki}),e.d(n,"cumprod",function(){return no}),e.d(n,"cumsum",function(){return Wi}),e.d(n,"denseBincount",function(){return ro}),e.d(n,"depthToSpace",function(){return Vi}),e.d(n,"depthwiseConv2d",function(){return Mi}),e.d(n,"diag",function(){return _i}),e.d(n,"dilation2d",function(){return Gi}),e.d(n,"div",function(){return Fr}),e.d(n,"divNoNan",function(){return ao}),e.d(n,"dot",function(){return so}),e.d(n,"einsum",function(){return io}),e.d(n,"elu",function(){return Hi}),e.d(n,"equal",function(){return Di}),e.d(n,"erf",function(){return Ii}),e.d(n,"euclideanNorm",function(){return Xi}),e.d(n,"exp",function(){return ps}),e.d(n,"expandDims",function(){return ve}),e.d(n,"expm1",function(){return Oe}),e.d(n,"eye",function(){return ie}),e.d(n,"fill",function(){return Js}),e.d(n,"floor",function(){return F}),e.d(n,"floorDiv",function(){return In}),e.d(n,"gather",function(){return ne}),e.d(n,"greater",function(){return ge}),e.d(n,"greaterEqual",function(){return Ee}),e.d(n,"imag",function(){return Ga}),e.d(n,"isFinite",function(){return $e}),e.d(n,"isInf",function(){return be}),e.d(n,"isNaN",function(){return ye}),e.d(n,"leakyRelu",function(){return Ue}),e.d(n,"less",function(){return Re}),e.d(n,"lessEqual",function(){return Ve}),e.d(n,"linspace",function(){return st}),e.d(n,"localResponseNormalization",function(){return tt}),e.d(n,"log",function(){return at}),e.d(n,"log1p",function(){return ot}),e.d(n,"logSigmoid",function(){return St}),e.d(n,"logSoftmax",function(){return R}),e.d(n,"logSumExp",function(){return v}),e.d(n,"logicalAnd",function(){return x}),e.d(n,"logicalNot",function(){return M}),e.d(n,"logicalOr",function(){return N}),e.d(n,"logicalXor",function(){return H}),e.d(n,"lowerBound",function(){return ce}),e.d(n,"matMul",function(){return rn}),e.d(n,"max",function(){return si}),e.d(n,"maxPool",function(){return xe}),e.d(n,"maxPool3d",function(){return De}),e.d(n,"maxPoolWithArgmax",function(){return Ke}),e.d(n,"maximum",function(){return ei}),e.d(n,"mean",function(){return Ze}),e.d(n,"meshgrid",function(){return Je}),e.d(n,"min",function(){return Si}),e.d(n,"minimum",function(){return yt}),e.d(n,"mirrorPad",function(){return gt}),e.d(n,"mod",function(){return kt}),e.d(n,"moments",function(){return Tt}),e.d(n,"mul",function(){return Sn}),e.d(n,"multiRNNCell",function(){return Rt}),e.d(n,"multinomial",function(){return Yt}),e.d(n,"neg",function(){return Xr}),e.d(n,"notEqual",function(){return Ht}),e.d(n,"oneHot",function(){return Xn}),e.d(n,"ones",function(){return nt}),e.d(n,"onesLike",function(){return nn}),e.d(n,"outerProduct",function(){return gn}),e.d(n,"pad",function(){return ln}),e.d(n,"pad1d",function(){return Bn}),e.d(n,"pad2d",function(){return wn}),e.d(n,"pad3d",function(){return $n}),e.d(n,"pad4d",function(){return Wn}),e.d(n,"pool",function(){return Dn}),e.d(n,"pow",function(){return ks}),e.d(n,"prelu",function(){return er}),e.d(n,"print",function(){return Ur}),e.d(n,"prod",function(){return yr}),e.d(n,"raggedTensorToTensor",function(){return la}),e.d(n,"rand",function(){return Or}),e.d(n,"randomGamma",function(){return Ra}),e.d(n,"randomNormal",function(){return Qa}),e.d(n,"randomStandardNormal",function(){return Ss}),e.d(n,"randomUniform",function(){return Cs}),e.d(n,"range",function(){return Li}),e.d(n,"real",function(){return ka}),e.d(n,"reciprocal",function(){return Yi}),e.d(n,"relu",function(){return Qi}),e.d(n,"relu6",function(){return ko}),e.d(n,"reshape",function(){return We}),e.d(n,"reverse",function(){return Ts}),e.d(n,"reverse1d",function(){return Tu}),e.d(n,"reverse2d",function(){return Ou}),e.d(n,"reverse3d",function(){return $u}),e.d(n,"reverse4d",function(){return Eu}),e.d(n,"round",function(){return Go}),e.d(n,"rsqrt",function(){return Au}),e.d(n,"scalar",function(){return Tr}),e.d(n,"selu",function(){return Nu}),e.d(n,"separableConv2d",function(){return Ru}),e.d(n,"setdiff1dAsync",function(){return Fu}),e.d(n,"sigmoid",function(){return on}),e.d(n,"sign",function(){return Mu}),e.d(n,"sin",function(){return Du}),e.d(n,"sinh",function(){return Pu}),e.d(n,"slice",function(){return Pt}),e.d(n,"slice1d",function(){return Bu}),e.d(n,"slice2d",function(){return Lu}),e.d(n,"slice3d",function(){return ju}),e.d(n,"slice4d",function(){return zu}),e.d(n,"softmax",function(){return Uu}),e.d(n,"softplus",function(){return bt}),e.d(n,"spaceToBatchND",function(){return Hn}),e.d(n,"fft",function(){return Eo}),e.d(n,"ifft",function(){return lo}),e.d(n,"irfft",function(){return Ho}),e.d(n,"rfft",function(){return Ao}),e.d(n,"split",function(){return ho}),e.d(n,"sqrt",function(){return Sa}),e.d(n,"square",function(){return na}),e.d(n,"squaredDifference",function(){return qo}),e.d(n,"squeeze",function(){return No}),e.d(n,"stack",function(){return po}),e.d(n,"step",function(){return Ko}),e.d(n,"stridedSlice",function(){return Wu}),e.d(n,"sub",function(){return ur}),e.d(n,"sum",function(){return Br}),e.d(n,"tan",function(){return Vu}),e.d(n,"tanh",function(){return hn}),e.d(n,"tensor",function(){return Ro.a}),e.d(n,"tensor1d",function(){return Hs}),e.d(n,"tensor2d",function(){return fo}),e.d(n,"tensor3d",function(){return ba}),e.d(n,"tensor4d",function(){return Gu}),e.d(n,"tensor5d",function(){return Hu}),e.d(n,"tensor6d",function(){return qu}),e.d(n,"tile",function(){return j}),e.d(n,"topk",function(){return Ku}),e.d(n,"truncatedNormal",function(){return Xu}),e.d(n,"unique",function(){return Yu}),e.d(n,"unsortedSegmentSum",function(){return Qu}),e.d(n,"unstack",function(){return Fo}),e.d(n,"upperBound",function(){return Xo}),e.d(n,"variable",function(){return Zu}),e.d(n,"where",function(){return ai}),e.d(n,"whereAsync",function(){return Do}),e.d(n,"zeros",function(){return Ge}),e.d(n,"zerosLike",function(){return pa}),e.d(n,"booleanMaskAsync",function(){return Ju}),e.d(n,"transpose",function(){return _a}),e.d(n,"norm",function(){return bi}),e.d(n,"movingAverage",function(){return Yo}),e.d(n,"scatterND",function(){return ec}),e.d(n,"searchSorted",function(){return se}),e.d(n,"sparseToDense",function(){return tc}),e.d(n,"gatherND",function(){return nc}),e.d(n,"dropout",function(){return rc}),e.d(n,"enclosingPowerOfTwo",function(){return Qo}),e.d(n,"cosineWindow",function(){return Po}),e.d(n,"inTopKAsync",function(){return ac}),e.d(n,"op",function(){return qe.b}),e.d(n,"OP_SCOPE_SUFFIX",function(){return qe.a}),e.d(n,"image",function(){return Xc}),e.d(n,"linalg",function(){return Yc}),e.d(n,"losses",function(){return Qc}),e.d(n,"spectral",function(){return qc}),e.d(n,"fused",function(){return l}),e.d(n,"signal",function(){return Kc}),e.d(n,"sparse",function(){return Zc}),e.d(n,"string",function(){return Jc}),e.d(n,"Reduction",function(){return Wa}),e.d(n,"train",function(){return el}),e.d(n,"enableProdMode",function(){return xr}),e.d(n,"enableDebugMode",function(){return Lr}),e.d(n,"disableDeprecationWarnings",function(){return Wr}),e.d(n,"deprecationWarn",function(){return vr}),e.d(n,"disposeVariables",function(){return ua}),e.d(n,"engine",function(){return ma}),e.d(n,"memory",function(){return Cr}),e.d(n,"profile",function(){return Da}),e.d(n,"tidy",function(){return kr}),e.d(n,"dispose",function(){return Pr}),e.d(n,"keep",function(){return qr}),e.d(n,"time",function(){return ha}),e.d(n,"setBackend",function(){return Zr}),e.d(n,"ready",function(){return Vr}),e.d(n,"getBackend",function(){return Ca}),e.d(n,"removeBackend",function(){return Ta}),e.d(n,"findBackend",function(){return Pa}),e.d(n,"findBackendFactory",function(){return is}),e.d(n,"registerBackend",function(){return ms}),e.d(n,"backend",function(){return Va}),e.d(n,"setPlatform",function(){return Ba}),e.d(n,"getKernel",function(){return sa.c}),e.d(n,"getGradient",function(){return sa.b}),e.d(n,"getKernelsForBackend",function(){return sa.d}),e.d(n,"registerKernel",function(){return sa.f}),e.d(n,"registerGradient",function(){return sa.e}),e.d(n,"unregisterKernel",function(){return sa.h}),e.d(n,"unregisterGradient",function(){return sa.g}),e.d(n,"copyRegisteredKernels",function(){return sa.a}),e.d(n,"customGrad",function(){return Ua}),e.d(n,"grad",function(){return Zs}),e.d(n,"grads",function(){return ys}),e.d(n,"valueAndGrad",function(){return cs}),e.d(n,"valueAndGrads",function(){return xi}),e.d(n,"variableGrads",function(){return ra}),e.d(n,"Environment",function(){return g.b}),e.d(n,"env",function(){return g.c}),e.d(n,"ENV",function(){return g.a}),e.d(n,"version_core",function(){return vs}),e.d(n,"nextFrame",function(){return ou.a}),e.d(n,"browser",function(){return b}),e.d(n,"io",function(){return t}),e.d(n,"math",function(){return m}),e.d(n,"serialization",function(){return E}),e.d(n,"test_util",function(){return S}),e.d(n,"util",function(){return es}),e.d(n,"backend_util",function(){return O}),e.d(n,"broadcast_util",function(){return h}),e.d(n,"tensor_util",function(){return xn}),e.d(n,"slice_util",function(){return y}),e.d(n,"gather_util",function(){return A}),e.d(n,"scatter_util",function(){return D}),e.d(n,"device_util",function(){return Jn}),e.d(n,"kernel_impls",function(){return V}),e.d(n,"KernelBackend",function(){return qn.b}),e.d(n,"DataStorage",function(){return qn.a}),e.d(n,"Abs",function(){return oe.a}),e.d(n,"Acos",function(){return oe.b}),e.d(n,"Acosh",function(){return oe.c}),e.d(n,"Add",function(){return oe.d}),e.d(n,"AddN",function(){return oe.e}),e.d(n,"All",function(){return oe.f}),e.d(n,"Any",function(){return oe.g}),e.d(n,"ArgMax",function(){return oe.h}),e.d(n,"ArgMin",function(){return oe.i}),e.d(n,"Asin",function(){return oe.j}),e.d(n,"Asinh",function(){return oe.k}),e.d(n,"Atan",function(){return oe.l}),e.d(n,"Atanh",function(){return oe.n}),e.d(n,"Atan2",function(){return oe.m}),e.d(n,"AvgPool",function(){return oe.o}),e.d(n,"AvgPoolGrad",function(){return oe.r}),e.d(n,"AvgPool3D",function(){return oe.p}),e.d(n,"AvgPool3DGrad",function(){return oe.q}),e.d(n,"BatchMatMul",function(){return oe.s}),e.d(n,"BatchToSpaceND",function(){return oe.t}),e.d(n,"Bincount",function(){return oe.u}),e.d(n,"BroadcastTo",function(){return oe.w}),e.d(n,"BroadcastArgs",function(){return oe.v}),e.d(n,"Cast",function(){return oe.x}),e.d(n,"Ceil",function(){return oe.y}),e.d(n,"ClipByValue",function(){return oe.z}),e.d(n,"Complex",function(){return oe.A}),e.d(n,"ComplexAbs",function(){return oe.B}),e.d(n,"Concat",function(){return oe.C}),e.d(n,"Conv2D",function(){return oe.D}),e.d(n,"Conv2DBackpropFilter",function(){return oe.E}),e.d(n,"Conv2DBackpropInput",function(){return oe.F}),e.d(n,"Conv3D",function(){return oe.G}),e.d(n,"Conv3DBackpropFilterV2",function(){return oe.H}),e.d(n,"Conv3DBackpropInputV2",function(){return oe.I}),e.d(n,"Cos",function(){return oe.J}),e.d(n,"Cosh",function(){return oe.K}),e.d(n,"Cumprod",function(){return oe.M}),e.d(n,"Cumsum",function(){return oe.N}),e.d(n,"CropAndResize",function(){return oe.L}),e.d(n,"DenseBincount",function(){return oe.O}),e.d(n,"DepthToSpace",function(){return oe.P}),e.d(n,"DepthwiseConv2dNative",function(){return oe.Q}),e.d(n,"DepthwiseConv2dNativeBackpropFilter",function(){return oe.R}),e.d(n,"DepthwiseConv2dNativeBackpropInput",function(){return oe.S}),e.d(n,"Diag",function(){return oe.T}),e.d(n,"Dilation2D",function(){return oe.U}),e.d(n,"Dilation2DBackpropInput",function(){return oe.W}),e.d(n,"Dilation2DBackpropFilter",function(){return oe.V}),e.d(n,"RealDiv",function(){return oe.qc}),e.d(n,"Einsum",function(){return oe.X}),e.d(n,"Elu",function(){return oe.Y}),e.d(n,"EluGrad",function(){return oe.Z}),e.d(n,"Erf",function(){return oe.bb}),e.d(n,"Equal",function(){return oe.ab}),e.d(n,"Exp",function(){return oe.cb}),e.d(n,"ExpandDims",function(){return oe.db}),e.d(n,"Expm1",function(){return oe.eb}),e.d(n,"FFT",function(){return oe.fb}),e.d(n,"Fill",function(){return oe.gb}),e.d(n,"FlipLeftRight",function(){return oe.hb}),e.d(n,"Floor",function(){return oe.ib}),e.d(n,"FloorDiv",function(){return oe.jb}),e.d(n,"FusedBatchNorm",function(){return oe.lb}),e.d(n,"GatherV2",function(){return oe.pb}),e.d(n,"GatherNd",function(){return oe.ob}),e.d(n,"Greater",function(){return oe.qb}),e.d(n,"GreaterEqual",function(){return oe.rb}),e.d(n,"Identity",function(){return oe.tb}),e.d(n,"IFFT",function(){return oe.sb}),e.d(n,"Imag",function(){return oe.ub}),e.d(n,"IsFinite",function(){return oe.vb}),e.d(n,"IsInf",function(){return oe.wb}),e.d(n,"IsNan",function(){return oe.xb}),e.d(n,"LeakyRelu",function(){return oe.Ab}),e.d(n,"Less",function(){return oe.Bb}),e.d(n,"LessEqual",function(){return oe.Cb}),e.d(n,"LinSpace",function(){return oe.Db}),e.d(n,"Log",function(){return oe.Eb}),e.d(n,"Log1p",function(){return oe.Fb}),e.d(n,"LogicalAnd",function(){return oe.Hb}),e.d(n,"LogicalNot",function(){return oe.Ib}),e.d(n,"LogicalOr",function(){return oe.Jb}),e.d(n,"LogicalXor",function(){return oe.Kb}),e.d(n,"LogSoftmax",function(){return oe.Gb}),e.d(n,"LowerBound",function(){return oe.Lb}),e.d(n,"LRN",function(){return oe.yb}),e.d(n,"LRNGrad",function(){return oe.zb}),e.d(n,"Max",function(){return oe.Mb}),e.d(n,"Maximum",function(){return oe.Sb}),e.d(n,"MaxPool",function(){return oe.Nb}),e.d(n,"MaxPoolGrad",function(){return oe.Qb}),e.d(n,"MaxPool3D",function(){return oe.Ob}),e.d(n,"MaxPool3DGrad",function(){return oe.Pb}),e.d(n,"MaxPoolWithArgmax",function(){return oe.Rb}),e.d(n,"Mean",function(){return oe.Tb}),e.d(n,"Min",function(){return oe.Ub}),e.d(n,"Minimum",function(){return oe.Vb}),e.d(n,"MirrorPad",function(){return oe.Wb}),e.d(n,"Mod",function(){return oe.Xb}),e.d(n,"Multinomial",function(){return oe.Yb}),e.d(n,"Multiply",function(){return oe.Zb}),e.d(n,"Neg",function(){return oe.ac}),e.d(n,"NotEqual",function(){return oe.ec}),e.d(n,"NonMaxSuppressionV3",function(){return oe.bc}),e.d(n,"NonMaxSuppressionV4",function(){return oe.cc}),e.d(n,"NonMaxSuppressionV5",function(){return oe.dc}),e.d(n,"OnesLike",function(){return oe.gc}),e.d(n,"OneHot",function(){return oe.fc}),e.d(n,"Pack",function(){return oe.hc}),e.d(n,"PadV2",function(){return oe.ic}),e.d(n,"Pool",function(){return oe.jc}),e.d(n,"Pow",function(){return oe.kc}),e.d(n,"Prelu",function(){return oe.lc}),e.d(n,"Prod",function(){return oe.mc}),e.d(n,"RaggedTensorToTensor",function(){return oe.nc}),e.d(n,"Range",function(){return oe.oc}),e.d(n,"Real",function(){return oe.pc}),e.d(n,"Reciprocal",function(){return oe.rc}),e.d(n,"Relu",function(){return oe.sc}),e.d(n,"Reshape",function(){return oe.uc}),e.d(n,"ResizeNearestNeighbor",function(){return oe.xc}),e.d(n,"ResizeNearestNeighborGrad",function(){return oe.yc}),e.d(n,"ResizeBilinear",function(){return oe.vc}),e.d(n,"ResizeBilinearGrad",function(){return oe.wc}),e.d(n,"Relu6",function(){return oe.tc}),e.d(n,"Reverse",function(){return oe.zc}),e.d(n,"Round",function(){return oe.Bc}),e.d(n,"Rsqrt",function(){return oe.Cc}),e.d(n,"ScatterNd",function(){return oe.Dc}),e.d(n,"SearchSorted",function(){return oe.Ec}),e.d(n,"Select",function(){return oe.Fc}),e.d(n,"Selu",function(){return oe.Gc}),e.d(n,"Slice",function(){return oe.Lc}),e.d(n,"Sin",function(){return oe.Jc}),e.d(n,"Sinh",function(){return oe.Kc}),e.d(n,"Sign",function(){return oe.Ic}),e.d(n,"Sigmoid",function(){return oe.Hc}),e.d(n,"Softplus",function(){return oe.Nc}),e.d(n,"Sqrt",function(){return oe.Vc}),e.d(n,"Sum",function(){return oe.ed}),e.d(n,"SpaceToBatchND",function(){return oe.Oc}),e.d(n,"SplitV",function(){return oe.Uc}),e.d(n,"Softmax",function(){return oe.Mc}),e.d(n,"SparseFillEmptyRows",function(){return oe.Pc}),e.d(n,"SparseReshape",function(){return oe.Qc}),e.d(n,"SparseSegmentMean",function(){return oe.Rc}),e.d(n,"SparseSegmentSum",function(){return oe.Sc}),e.d(n,"SparseToDense",function(){return oe.Tc}),e.d(n,"SquaredDifference",function(){return oe.Xc}),e.d(n,"Square",function(){return oe.Wc}),e.d(n,"StridedSlice",function(){return oe.Zc}),e.d(n,"StringNGrams",function(){return oe.ad}),e.d(n,"StringSplit",function(){return oe.bd}),e.d(n,"StringToHashBucketFast",function(){return oe.cd}),e.d(n,"Sub",function(){return oe.dd}),e.d(n,"Tan",function(){return oe.fd}),e.d(n,"Tanh",function(){return oe.gd}),e.d(n,"Tile",function(){return oe.hd}),e.d(n,"TopK",function(){return oe.id}),e.d(n,"Transform",function(){return oe.jd}),e.d(n,"Transpose",function(){return oe.kd}),e.d(n,"Unique",function(){return oe.ld}),e.d(n,"Unpack",function(){return oe.md}),e.d(n,"UnsortedSegmentSum",function(){return oe.nd}),e.d(n,"UpperBound",function(){return oe.od}),e.d(n,"ZerosLike",function(){return oe.pd}),e.d(n,"Step",function(){return oe.Yc}),e.d(n,"FromPixels",function(){return oe.kb}),e.d(n,"RotateWithOffset",function(){return oe.Ac}),e.d(n,"_FusedMatMul",function(){return oe.qd}),e.d(n,"FusedConv2D",function(){return oe.mb}),e.d(n,"FusedDepthwiseConv2D",function(){return oe.nb});var t={};e.r(t),e.d(t,"copyModel",function(){return mt}),e.d(t,"listModels",function(){return Ot}),e.d(t,"moveModel",function(){return Mt}),e.d(t,"removeModel",function(){return Ae}),e.d(t,"browserFiles",function(){return en}),e.d(t,"browserHTTPRequest",function(){return ae}),e.d(t,"concatenateArrayBuffers",function(){return W.d}),e.d(t,"decodeWeights",function(){return W.e}),e.d(t,"encodeWeights",function(){return W.f}),e.d(t,"fromMemory",function(){return Kt}),e.d(t,"fromMemorySync",function(){return Ut}),e.d(t,"getLoadHandlers",function(){return Q}),e.d(t,"getModelArtifactsForJSON",function(){return W.g}),e.d(t,"getModelArtifactsInfoForJSON",function(){return W.h}),e.d(t,"getSaveHandlers",function(){return he}),e.d(t,"http",function(){return q}),e.d(t,"isHTTPScheme",function(){return gr}),e.d(t,"loadWeights",function(){return lr}),e.d(t,"registerLoadRouter",function(){return Ie}),e.d(t,"registerSaveRouter",function(){return ke}),e.d(t,"weightsLoaderFactory",function(){return Qn}),e.d(t,"withSaveHandler",function(){return tn}),e.d(t,"withSaveHandlerSync",function(){return bn});var m={};e.r(m),e.d(m,"confusionMatrix",function(){return os});var h={};e.r(h),e.d(h,"getBroadcastDims",function(){return Za}),e.d(h,"getReductionAxes",function(){return La}),e.d(h,"assertAndGetBroadcastShape",function(){return wr});var b={};e.r(b),e.d(b,"fromPixelsAsync",function(){return dt}),e.d(b,"toPixels",function(){return Et}),e.d(b,"fromPixels",function(){return Vt});var A={};e.r(A),e.d(A,"prepareAndValidate",function(){return an});var D={};e.r(D),e.d(D,"validateUpdateShape",function(){return Zt}),e.d(D,"validateInput",function(){return _n}),e.d(D,"calculateShapes",function(){return Gn});var y={};e.r(y),e.d(y,"assertParamsValid",function(){return ar}),e.d(y,"maskToAxes",function(){return Rr}),e.d(y,"computeOutShape",function(){return Ir}),e.d(y,"stridesWithElidedDims",function(){return xa}),e.d(y,"getNormalizedAxes",function(){return ja}),e.d(y,"startIndicesWithElidedDims",function(){return Oa}),e.d(y,"stopIndicesWithElidedDims",function(){return $a}),e.d(y,"stridesForAxis",function(){return Xs}),e.d(y,"startForAxis",function(){return $s}),e.d(y,"stopForAxis",function(){return bs}),e.d(y,"isSliceContinous",function(){return di}),e.d(y,"computeFlatOffset",function(){return Ha}),e.d(y,"parseSliceParams",function(){return qa}),e.d(y,"sliceInfo",function(){return Ea});var E={};e.r(E),e.d(E,"Serializable",function(){return Ys}),e.d(E,"SerializationMap",function(){return ia}),e.d(E,"registerClass",function(){return Aa});var S={};e.r(S),e.d(S,"TEST_EPSILON_FLOAT16",function(){return gs}),e.d(S,"expectArraysClose",function(){return hi}),e.d(S,"testEpsilon",function(){return xs}),e.d(S,"expectPromiseToFail",function(){return pi}),e.d(S,"expectArraysEqual",function(){return pr}),e.d(S,"expectNumbersClose",function(){return Jr}),e.d(S,"expectValuesInRange",function(){return Es}),e.d(S,"expectArrayBuffersEqual",function(){return Qs}),e.d(S,"encodeStrings",function(){return ts}),e.d(S,"createVideoElement",function(){return As}),e.d(S,"play",function(){return Ns});var l={};e.r(l),e.d(l,"conv2d",function(){return ic}),e.d(l,"depthwiseConv2d",function(){return cc}),e.d(l,"matMul",function(){return lc});var B={};e.r(B),e.d(B,"segOpComputeOptimalWindowSize",function(){return vn}),e.d(B,"computeOutShape",function(){return En}),e.d(B,"collectGatherOpShapeInfo",function(){return Cn});var O={};e.r(O),e.d(O,"axesAreInnerMostDims",function(){return Pi}),e.d(O,"combineLocations",function(){return qi}),e.d(O,"computeOutAndReduceShapes",function(){return oo}),e.d(O,"expandShapeToKeepDim",function(){return fi}),e.d(O,"assertAxesAreInnerMostDims",function(){return uo}),e.d(O,"getAxesPermutation",function(){return co}),e.d(O,"getUndoAxesPermutation",function(){return Ki}),e.d(O,"getInnerMostAxes",function(){return mi}),e.d(O,"getBroadcastDims",function(){return Za}),e.d(O,"getReductionAxes",function(){return La}),e.d(O,"assertAndGetBroadcastShape",function(){return wr}),e.d(O,"assertParamsConsistent",function(){return tl}),e.d(O,"computeOutShape",function(){return nl}),e.d(O,"computeDilation2DInfo",function(){return yi}),e.d(O,"computePool2DInfo",function(){return Ne}),e.d(O,"computePool3DInfo",function(){return ue}),e.d(O,"computeConv2DInfo",function(){return Be}),e.d(O,"computeConv3DInfo",function(){return Xe}),e.d(O,"computeDefaultPad",function(){return Te}),e.d(O,"tupleValuesAreOne",function(){return ft}),e.d(O,"eitherStridesOrDilationsAreOne",function(){return pt}),e.d(O,"convertConv2DDataFormat",function(){return zt}),e.d(O,"checkPadOnDimRoundingMode",function(){return Dt}),e.d(O,"getFusedDyActivation",function(){return _o}),e.d(O,"getFusedBiasGradient",function(){return Io}),e.d(O,"applyActivation",function(){return So}),e.d(O,"shouldFuse",function(){return ji}),e.d(O,"RowPartitionType",function(){return oi}),e.d(O,"combineRaggedTensorToTensorShapes",function(){return rl}),e.d(O,"getRowPartitionTypesHelper",function(){return al}),e.d(O,"getRaggedRank",function(){return uu}),e.d(O,"validateDefaultValueShape",function(){return sl}),e.d(O,"PARALLELIZE_THRESHOLD",function(){return Lo}),e.d(O,"computeOptimalWindowSize",function(){return il}),e.d(O,"slice_util",function(){return y}),e.d(O,"upcastType",function(){return Bs.c}),e.d(O,"getImageCenter",function(){return ol}),e.d(O,"getReshaped",function(){return ul}),e.d(O,"getPermuted",function(){return cl}),e.d(O,"getReshapedPermuted",function(){return ll}),e.d(O,"getSliceBeginCoords",function(){return dl}),e.d(O,"getSliceSize",function(){return hl}),e.d(O,"prepareAndValidate",function(){return an}),e.d(O,"validateUpdateShape",function(){return Zt}),e.d(O,"validateInput",function(){return _n}),e.d(O,"calculateShapes",function(){return Gn}),e.d(O,"SELU_SCALEALPHA",function(){return pl}),e.d(O,"SELU_SCALE",function(){return fl}),e.d(O,"ERF_P",function(){return ml}),e.d(O,"ERF_A1",function(){return bl}),e.d(O,"ERF_A2",function(){return cu}),e.d(O,"ERF_A3",function(){return gl}),e.d(O,"ERF_A4",function(){return xl}),e.d(O,"ERF_A5",function(){return vl}),e.d(O,"warn",function(){return Ci.b}),e.d(O,"log",function(){return Ci.a}),e.d(O,"mergeRealAndImagArrays",function(){return lu}),e.d(O,"splitRealAndImagArrays",function(){return yl}),e.d(O,"complexWithEvenIndex",function(){return wl}),e.d(O,"complexWithOddIndex",function(){return kl}),e.d(O,"getComplexWithIndex",function(){return _l}),e.d(O,"assignToTypedArray",function(){return Il}),e.d(O,"exponents",function(){return Sl}),e.d(O,"exponent",function(){return Cl}),e.d(O,"decodeEinsumEquation",function(){return o}),e.d(O,"getEinsumPermutation",function(){return d}),e.d(O,"checkEinsumDimSizes",function(){return c}),e.d(O,"getEinsumComputePath",function(){return f}),e.d(O,"isIdentityPermutation",function(){return w}),e.d(O,"prepareSplitSize",function(){return T}),e.d(O,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",function(){return P}),e.d(O,"getSparseFillEmptyRowsNegativeIndexErrorMessage",function(){return z}),e.d(O,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",function(){return te}),e.d(O,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",function(){return Y}),e.d(O,"getSparseReshapeNegativeOutputDimErrorMessage",function(){return Ce}),e.d(O,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",function(){return fe}),e.d(O,"getSparseReshapeInputOutputMultipleErrorMessage",function(){return Pe}),e.d(O,"getSparseReshapeInputOutputMismatchErrorMessage",function(){return Le}),e.d(O,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",function(){return _e}),e.d(O,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",function(){return je}),e.d(O,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",function(){return qt}),e.d(O,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",function(){return sn}),e.d(O,"segment_util",function(){return B}),e.d(O,"fromUint8ToStringArray",function(){return An}),e.d(O,"fromStringArrayToUint8",function(){return kn});var V={};e.r(V),e.d(V,"nonMaxSuppressionV3Impl",function(){return nu}),e.d(V,"nonMaxSuppressionV4Impl",function(){return ru}),e.d(V,"nonMaxSuppressionV5Impl",function(){return au}),e.d(V,"whereImpl",function(){return Mo});var L=e(3),g=(e(50),e(9)),W=e(17);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class de{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return de.instance==null&&(de.instance=new de),de.instance}static registerSaveRouter(r){de.getInstance().saveRouters.push(r)}static registerLoadRouter(r){de.getInstance().loadRouters.push(r)}static getSaveHandlers(r){return de.getHandlers(r,"save")}static getLoadHandlers(r,i){return de.getHandlers(r,"load",i)}static getHandlers(r,i,u){const p=[];return(i==="load"?de.getInstance().loadRouters:de.getInstance().saveRouters).forEach(_=>{const $=_(r,u);$!==null&&p.push($)}),p}}const ke=s=>de.registerSaveRouter(s),Ie=s=>de.registerLoadRouter(s),he=s=>de.getSaveHandlers(s),Q=(s,r)=>de.getLoadHandlers(s,r),Se="tensorflowjs",Z="models_store",G="model_info_store";function He(){if(!Object(g.c)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const s=typeof window=="undefined"?self:window,r=s.indexedDB||s.mozIndexedDB||s.webkitIndexedDB||s.msIndexedDB||s.shimIndexedDB;if(r==null)throw new Error("The current browser does not appear to support IndexedDB.");return r}function me(s){const r=s.result;r.createObjectStore(Z,{keyPath:"modelPath"}),r.createObjectStore(G,{keyPath:"modelPath"})}class et{constructor(r){if(this.indexedDB=He(),r==null||!r)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=r}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,r)}async load(){return this.databaseAction(this.modelPath)}databaseAction(r,i){return new Promise((u,p)=>{const _=this.indexedDB.open(Se,1);_.onupgradeneeded=()=>me(_),_.onsuccess=()=>{const $=_.result;if(i==null){const U=$.transaction(Z,"readonly"),re=U.objectStore(Z).get(this.modelPath);re.onsuccess=()=>{if(re.result==null)return $.close(),p(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));u(re.result.modelArtifacts)},re.onerror=pe=>($.close(),p(re.error)),U.oncomplete=()=>$.close()}else{const U=Object(W.h)(i),re=$.transaction(G,"readwrite");let pe=re.objectStore(G);const ze=pe.put({modelPath:this.modelPath,modelArtifactsInfo:U});let Me;ze.onsuccess=()=>{Me=$.transaction(Z,"readwrite");const ct=Me.objectStore(Z).put({modelPath:this.modelPath,modelArtifacts:i,modelArtifactsInfo:U});ct.onsuccess=()=>u({modelArtifactsInfo:U}),ct.onerror=Lt=>{pe=re.objectStore(G);const Jt=pe.delete(this.modelPath);Jt.onsuccess=()=>($.close(),p(ct.error)),Jt.onerror=fn=>($.close(),p(ct.error))}},ze.onerror=ct=>($.close(),p(ze.error)),re.oncomplete=()=>{Me==null?$.close():Me.oncomplete=()=>$.close()}}},_.onerror=$=>p(_.error)})}}et.URL_SCHEME="indexeddb://";const rt=s=>{return Object(g.c)().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(et.URL_SCHEME)?(r=s.slice(et.URL_SCHEME.length),new et(r)):null;var r};de.registerSaveRouter(rt),de.registerLoadRouter(rt);class It{constructor(){this.indexedDB=He()}async listModels(){return new Promise((r,i)=>{const u=this.indexedDB.open(Se,1);u.onupgradeneeded=()=>me(u),u.onsuccess=()=>{const p=u.result,_=p.transaction(G,"readonly"),$=_.objectStore(G).getAll();$.onsuccess=()=>{const U={};for(const re of $.result)U[re.modelPath]=re.modelArtifactsInfo;r(U)},$.onerror=U=>(p.close(),i($.error)),_.oncomplete=()=>p.close()},u.onerror=p=>i(u.error)})}async removeModel(r){var i;return r=(i=r).startsWith(et.URL_SCHEME)?i.slice(et.URL_SCHEME.length):i,new Promise((u,p)=>{const _=this.indexedDB.open(Se,1);_.onupgradeneeded=()=>me(_),_.onsuccess=()=>{const $=_.result,U=$.transaction(G,"readwrite"),re=U.objectStore(G),pe=re.get(r);let ze;pe.onsuccess=()=>{if(pe.result==null)return $.close(),p(new Error(`Cannot find model with path '${r}' in IndexedDB.`));{const Me=re.delete(r),ct=()=>{ze=$.transaction(Z,"readwrite");const Lt=ze.objectStore(Z).delete(r);Lt.onsuccess=()=>u(pe.result.modelArtifactsInfo),Lt.onerror=Jt=>p(pe.error)};Me.onsuccess=ct,Me.onerror=Lt=>(ct(),$.close(),p(pe.error))}},pe.onerror=Me=>($.close(),p(pe.error)),U.oncomplete=()=>{ze==null?$.close():ze.oncomplete=()=>$.close()}},_.onerror=$=>p(_.error)})}}var X=e(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $t="/",Ct="tensorflowjs_models",Gt="info",Wt="model_topology",lt="weight_specs",Qt="weight_data",Ft="model_metadata";function yn(s){return{info:[Ct,s,Gt].join($t),topology:[Ct,s,Wt].join($t),weightSpecs:[Ct,s,lt].join($t),weightData:[Ct,s,Qt].join($t),modelMetadata:[Ct,s,Ft].join($t)}}function Nn(s){for(const r of Object.values(s))window.localStorage.removeItem(r)}function Kn(s){const r=s.split($t);if(r.length<3)throw new Error(`Invalid key format: ${s}`);return r.slice(1,r.length-1).join($t)}class zn{constructor(r){if(!Object(g.c)().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,r==null||!r)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=r,this.keys=yn(this.modelPath)}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(r.modelTopology),u=JSON.stringify(r.weightSpecs),p=Object(W.h)(r);try{this.LS.setItem(this.keys.info,JSON.stringify(p)),this.LS.setItem(this.keys.topology,i),this.LS.setItem(this.keys.weightSpecs,u),this.LS.setItem(this.keys.weightData,Object(W.a)(r.weightData));const _={format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,signature:r.signature!=null?r.signature:void 0,userDefinedMetadata:r.userDefinedMetadata!=null?r.userDefinedMetadata:void 0,modelInitializer:r.modelInitializer!=null?r.modelInitializer:void 0,trainingConfig:r.trainingConfig!=null?r.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(_)),{modelArtifactsInfo:p}}catch{throw Nn(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${p.modelTopologyBytes}, weightSpecsBytes=${p.weightSpecsBytes}, weightDataBytes=${p.weightDataBytes}.`)}}}async load(){const r=JSON.parse(this.LS.getItem(this.keys.info));if(r==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(r.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const i={},u=JSON.parse(this.LS.getItem(this.keys.topology));if(u==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);i.modelTopology=u;const p=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(p==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);i.weightSpecs=p;const _=this.LS.getItem(this.keys.modelMetadata);if(_!=null){const U=JSON.parse(_);i.format=U.format,i.generatedBy=U.generatedBy,i.convertedBy=U.convertedBy,U.signature!=null&&(i.signature=U.signature),U.userDefinedMetadata!=null&&(i.userDefinedMetadata=U.userDefinedMetadata),U.modelInitializer!=null&&(i.modelInitializer=U.modelInitializer),U.trainingConfig!=null&&(i.trainingConfig=U.trainingConfig)}const $=this.LS.getItem(this.keys.weightData);if($==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return i.weightData=Object(W.b)($),i}}zn.URL_SCHEME="localstorage://";const sr=s=>{return Object(g.c)().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(zn.URL_SCHEME)?(r=s.slice(zn.URL_SCHEME.length),new zn(r)):null;var r};de.registerSaveRouter(sr),de.registerLoadRouter(sr);class K{constructor(){Object(X.b)(Object(g.c)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Object(X.b)(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const r={},i=Ct+$t,u=$t+Gt;for(let p=0;p<this.LS.length;++p){const _=this.LS.key(p);_.startsWith(i)&&_.endsWith(u)&&(r[Kn(_)]=JSON.parse(this.LS.getItem(_)))}return r}async removeModel(r){var i;const u=yn(r=(i=r).startsWith(zn.URL_SCHEME)?i.slice(zn.URL_SCHEME.length):i);if(this.LS.getItem(u.info)==null)throw new Error(`Cannot find model at path '${r}'`);const p=JSON.parse(this.LS.getItem(u.info));return Nn(u),p}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J="://";class we{constructor(){this.managers={}}static getInstance(){return we.instance==null&&(we.instance=new we),we.instance}static registerManager(r,i){Object(X.b)(r!=null,()=>"scheme must not be undefined or null."),r.endsWith(J)&&(r=r.slice(0,r.indexOf(J))),Object(X.b)(r.length>0,()=>"scheme must not be an empty string.");const u=we.getInstance();Object(X.b)(u.managers[r]==null,()=>`A model store manager is already registered for scheme '${r}'.`),u.managers[r]=i}static getManager(r){const i=we.getInstance().managers[r];if(i==null)throw new Error(`Cannot find model manager for scheme '${r}'`);return i}static getSchemes(){return Object.keys(we.getInstance().managers)}}function vt(s){if(s.indexOf(J)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${we.getSchemes().join(",")}`);return{scheme:s.split(J)[0],path:s.split(J)[1]}}async function wt(s,r,i=!1){Object(X.b)(s!==r,()=>`Old path and new path are the same: '${s}'`);const u=de.getLoadHandlers(s);Object(X.b)(u.length>0,()=>`Copying failed because no load handler is found for source URL ${s}.`),Object(X.b)(u.length<2,()=>`Copying failed because more than one (${u.length}) load handlers for source URL ${s}.`);const p=u[0],_=de.getSaveHandlers(r);Object(X.b)(_.length>0,()=>`Copying failed because no save handler is found for destination URL ${r}.`),Object(X.b)(_.length<2,()=>`Copying failed because more than one (${u.length}) save handlers for destination URL ${r}.`);const $=_[0],U=vt(s).scheme,re=vt(s).path,pe=U===vt(s).scheme,ze=await p.load();i&&pe&&await we.getManager(U).removeModel(re);const Me=await $.save(ze);return i&&!pe&&await we.getManager(U).removeModel(re),Me.modelArtifactsInfo}async function Ot(){const s=we.getSchemes(),r={};for(const i of s){const u=await we.getManager(i).listModels();for(const p in u)r[i+J+p]=u[p]}return r}async function Ae(s){const r=vt(s);return we.getManager(r.scheme).removeModel(r.path)}async function mt(s,r){return wt(s,r,!1)}async function Mt(s,r){return wt(s,r,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nt{fetch(r,i){return fetch(r,i)}now(){return performance.now()}encode(r,i){if(i!=="utf-8"&&i!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${i}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(r)}decode(r,i){return new TextDecoder(i).decode(r)}}if(Object(g.c)().get("IS_BROWSER")){Object(g.c)().setPlatform("browser",new Nt);try{we.registerManager(zn.URL_SCHEME,new K)}catch{}try{we.registerManager(et.URL_SCHEME,new It)}catch{}}e(109);var un=e(14);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(s,r="float32",i){return r=r||"float32",X.c(s),new un.b(s,r,i)}var oe=e(4),le=e(1),qe=e(2);const Mn=Object(qe.b)({cast_:function(s,r){const i=Object(le.a)(s,"x","cast");if(!X.B(r))throw new Error(`Failed to cast to unknown dtype ${r}`);if(r==="string"&&i.dtype!=="string"||r!=="string"&&i.dtype==="string")throw new Error("Only strings can be casted to strings");const u={x:i},p={dtype:r};return L.a.runKernel(oe.x,u,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr=Object(qe.b)({clone_:function(s){const r={x:Object(le.a)(s,"x","clone","string_or_numeric")};return L.a.runKernel(oe.tb,r)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(s,r=!1){console.log(s.toString(r))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Object(L.b)();const _r={buffer:Rn,cast:Mn,clone:zr,print:Ur};Object(un.e)(_r);function ir(s){return new Promise(r=>setTimeout(r)).then(s)}class Zn{constructor(r){if(!Object(g.c)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");r.startsWith(Zn.URL_SCHEME)&&(r=r.slice(Zn.URL_SCHEME.length)),r!=null&&r.length!==0||(r="model"),this.modelJsonFileName=r+".json",this.weightDataFileName=r+".weights.bin"}async save(r){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const i=window.URL.createObjectURL(new Blob([r.weightData],{type:"application/octet-stream"}));if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const u=[{paths:["./"+this.weightDataFileName],weights:r.weightSpecs}],p=Object(W.i)(r,u),_=window.URL.createObjectURL(new Blob([JSON.stringify(p)],{type:"application/json"})),$=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if($.download=this.modelJsonFileName,$.href=_,await ir(()=>$.dispatchEvent(new MouseEvent("click"))),r.weightData!=null){const U=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;U.download=this.weightDataFileName,U.href=i,await ir(()=>U.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Object(W.h)(r)}}}}Zn.URL_SCHEME="downloads://";class $r{constructor(r){if(r==null||r.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${r}`);this.jsonFile=r[0],this.weightsFiles=r.slice(1)}async load(){return new Promise((r,i)=>{const u=new FileReader;u.onload=p=>{const _=JSON.parse(p.target.result),$=_.modelTopology;if($==null)return void i(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(_.weightsManifest==null)return void i(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(this.weightsFiles.length===0)return void r({modelTopology:$});const U=Object(W.g)(_,re=>this.loadWeights(re));r(U)},u.onerror=p=>i(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),u.readAsText(this.jsonFile)})}loadWeights(r){const i=[],u=[];for(const $ of r)i.push(...$.weights),u.push(...$.paths);const p=this.checkManifestAndWeightFiles(r),_=u.map($=>this.loadWeightsFile($,p[$]));return Promise.all(_).then($=>[i,Object(W.d)($)])}loadWeightsFile(r,i){return new Promise((u,p)=>{const _=new FileReader;_.onload=$=>{const U=$.target.result;u(U)},_.onerror=$=>p(`Failed to weights data from file of path '${r}'.`),_.readAsArrayBuffer(i)})}checkManifestAndWeightFiles(r){const i=[],u=this.weightsFiles.map(_=>Object(W.c)(_.name)),p={};for(const _ of r)_.paths.forEach($=>{const U=Object(W.c)($);if(i.indexOf(U)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${U}'`);if(i.push(U),u.indexOf(U)===-1)throw new Error(`Weight file with basename '${U}' is not provided.`);p[$]=this.weightsFiles[u.indexOf(U)]});if(i.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${i.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return p}}function en(s){return new $r(s)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(s,r,i,u){(function(_){Object(X.b)(_!=null&&Array.isArray(_)&&_.length>0,()=>"promises must be a none empty array")})(s),function(_,$){Object(X.b)(_>=0&&_<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${_}`),Object(X.b)($>=0&&$<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${$}`),Object(X.b)($>=_,()=>`startFraction must be no more than endFraction, but got startFraction ${_} and endFraction ${$}`)}(i=i==null?0:i,u=u==null?1:u);let p=0;return Promise.all(s.map(_=>(_.then($=>{const U=i+ ++p/s.length*(u-i);return r(U),$}),_)))}de.registerSaveRouter(s=>Object(g.c)().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Zn.URL_SCHEME)?function(r="model"){return new Zn(r)}(s.slice(Zn.URL_SCHEME.length)):null);var Ln=e(52);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function or(s,r){r==null&&(r={});const i=r.fetchFunc==null?Object(g.c)().platform.fetch:r.fetchFunc,u=s.map(_=>i(_,r.requestInit,{isBinary:!0})),p=(r.onProgress==null?await Promise.all(u):await mn(u,r.onProgress,0,.5)).map(_=>_.arrayBuffer());return r.onProgress==null?await Promise.all(p):await mn(p,r.onProgress,.5,1)}async function lr(s,r="",i,u){return Qn(p=>or(p,{requestInit:u}))(s,r,i)}function Qn(s){return async(r,i="",u)=>{const p=r.map(()=>!1),_={},$=u!=null?u.map(()=>!1):[],U=[];if(r.forEach((Lt,Jt)=>{let fn=0;Lt.weights.forEach(On=>{const tr="quantization"in On?On.quantization.dtype:On.dtype,dn=Ln.a[tr]*X.O(On.shape),pn=()=>{p[Jt]=!0,_[Jt]==null&&(_[Jt]=[]),_[Jt].push({manifestEntry:On,groupOffset:fn,sizeBytes:dn})};u!=null?u.forEach((Pn,Un)=>{Pn===On.name&&(pn(),$[Un]=!0)}):pn(),U.push(On.name),fn+=dn})}),!$.every(Lt=>Lt)){const Lt=u.filter((Jt,fn)=>!$[fn]);throw new Error(`Could not find weights in manifest with names: ${Lt.join(", ")}. 
Manifest JSON has weights with names: ${U.join(", ")}.`)}const re=p.reduce((Lt,Jt,fn)=>(Jt&&Lt.push(fn),Lt),[]),pe=[];re.forEach(Lt=>{r[Lt].paths.forEach(Jt=>{const fn=i+(i.endsWith("/")?"":"/")+Jt;pe.push(fn)})});const ze=await s(pe),Me={};let ct=0;return re.forEach(Lt=>{const Jt=r[Lt].paths.length;let fn=0;for(let pn=0;pn<Jt;pn++)fn+=ze[ct+pn].byteLength;const On=new ArrayBuffer(fn),tr=new Uint8Array(On);let dn=0;for(let pn=0;pn<Jt;pn++){const Pn=new Uint8Array(ze[ct+pn]);tr.set(Pn,dn),dn+=Pn.byteLength}_[Lt].forEach(pn=>{const Pn=On.slice(pn.groupOffset,pn.groupOffset+pn.sizeBytes),Un=Object(W.e)(Pn,[pn.manifestEntry]);for(const Vn in Un)Me[Vn]=Un[Vn]}),ct+=Jt}),Me}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class br{constructor(r,i){if(this.DEFAULT_METHOD="POST",i==null&&(i={}),this.weightPathPrefix=i.weightPathPrefix,this.onProgress=i.onProgress,this.weightUrlConverter=i.weightUrlConverter,i.fetchFunc!=null?(Object(X.b)(typeof i.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=i.fetchFunc):this.fetch=Object(g.c)().platform.fetch,Object(X.b)(r!=null&&r.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(r)&&Object(X.b)(r.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${r.length}).`),this.path=r,i.requestInit!=null&&i.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=i.requestInit||{}}async save(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const i=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);i.body=new FormData;const u=[{paths:["./model.weights.bin"],weights:r.weightSpecs}],p=Object(W.i)(r,u);i.body.append("model.json",new Blob([JSON.stringify(p)],{type:"application/json"}),"model.json"),r.weightData!=null&&i.body.append("model.weights.bin",new Blob([r.weightData],{type:"application/octet-stream"}),"model.weights.bin");const _=await this.fetch(this.path,i);if(_.ok)return{modelArtifactsInfo:Object(W.h)(r),responses:[_]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${_.status}.`)}async load(){const r=await this.fetch(this.path,this.requestInit);if(!r.ok)throw new Error(`Request to ${this.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let i;try{i=await r.json()}catch{let $=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?$+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":$+=" Please make sure the server is serving valid JSON for this request.",new Error($)}const u=i.modelTopology,p=i.weightsManifest;if(u==null&&p==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Object(W.g)(i,_=>this.loadWeights(_))}async loadWeights(r){const i=Array.isArray(this.path)?this.path[1]:this.path,[u,p]=function(ze){const Me=ze.lastIndexOf("/"),ct=ze.lastIndexOf("?"),Lt=ze.substring(0,Me),Jt=ct>Me?ze.substring(ct):"";return[Lt+"/",Jt]}(i),_=this.weightPathPrefix||u,$=[];for(const ze of r)$.push(...ze.weights);const U=[],re=[];for(const ze of r)for(const Me of ze.paths)this.weightUrlConverter!=null?re.push(this.weightUrlConverter(Me)):U.push(_+Me+p);this.weightUrlConverter&&U.push(...await Promise.all(re));const pe=await or(U,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[$,Object(W.d)(pe)]}}function gr(s){return s.match(br.URL_SCHEME_REGEX)!=null}br.URL_SCHEME_REGEX=/^https?:\/\//;const At=(s,r)=>{if(typeof fetch=="undefined"&&(r==null||r.fetchFunc==null))return null;{let i=!0;if(i=Array.isArray(s)?s.every(u=>gr(u)):gr(s),i)return q(s,r)}return null};function q(s,r){return new br(s,r)}function ae(s,r){return q(s,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */de.registerSaveRouter(At),de.registerLoadRouter(At);class Qe{constructor(r){this.modelArtifacts=r}load(){return this.modelArtifacts}}class ht{constructor(r){this.saveHandler=r}save(r){return this.saveHandler(r)}}class Bt{constructor(r){r.load&&(this.load=()=>Promise.resolve(r.load())),r.save&&(this.save=i=>Promise.resolve(r.save(i)))}}function Kt(s,r,i,u){const p=arguments;return new Bt(Ut(...p))}function Ut(s,r,i,u){return arguments.length===1?s.modelTopology!=null||s.weightSpecs!=null?new Qe(s):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qe({modelTopology:s})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Qe({modelTopology:s,weightSpecs:r,weightData:i,trainingConfig:u}))}function tn(s){return new ht(s)}function bn(s){return new ht(s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var xn=e(10);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rn=Object(qe.b)({matMul_:function(s,r,i=!1,u=!1){let p=Object(le.a)(s,"a","matMul"),_=Object(le.a)(r,"b","matMul");[p,_]=Object(xn.makeTypesMatch)(p,_);const $={a:p,b:_},U={transposeA:i,transposeB:u};return L.a.runKernel(oe.s,$,U)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xn=Object(qe.b)({oneHot_:function(s,r,i=1,u=0,p="int32"){if(r<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${r}`);const _={indices:Object(le.a)(s,"indices","oneHot","int32")},$={dtype:p,depth:r,onValue:i,offValue:u};return L.a.runKernel(oe.fc,_,$)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(){Object(g.c)().set("PROD",!0)}function Lr(){Object(g.c)().set("DEBUG",!0)}function Wr(){Object(g.c)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function vr(s){Object(g.c)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(s+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function ua(){L.a.disposeVariables()}function ma(){return L.a}function Cr(){return L.a.memory()}function Da(s){return L.a.profile(s)}function kr(s,r){return L.a.tidy(s,r)}function Pr(s){Object(xn.getTensorsInContainer)(s).forEach(r=>r.dispose())}function qr(s){return L.a.keep(s)}function ha(s){return L.a.time(s)}function Zr(s){return L.a.setBackend(s)}function Vr(){return L.a.ready()}function Ca(){return L.a.backendName}function Ta(s){L.a.removeBackend(s)}function Pa(s){return L.a.findBackend(s)}function is(s){return L.a.findBackendFactory(s)}function ms(s,r,i=1){return L.a.registerBackend(s,r,i)}function Va(){return L.a.backend}function Ba(s,r){Object(g.c)().setPlatform(s,r)}Object(un.d)(vr);var wa=e(22);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ga=Object(qe.b)({imag_:function(s){const r={input:Object(le.a)(s,"input","imag")};return L.a.runKernel(oe.ub,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xr=Object(qe.b)({neg_:function(s){const r={x:Object(le.a)(s,"x","neg")};return L.a.runKernel(oe.ac,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ka=Object(qe.b)({real_:function(s){const r={input:Object(le.a)(s,"input","real")};return L.a.runKernel(oe.pc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _a=Object(qe.b)({transpose_:function(s,r,i){const u=Object(le.a)(s,"x","transpose");if(r==null&&(r=u.shape.map(($,U)=>U).reverse()),X.b(u.rank===r.length,()=>`Error in transpose: rank of input ${u.rank} must match length of perm ${r}.`),r.forEach($=>{X.b($>=0&&$<u.rank,()=>"All entries in 'perm' must be between 0 and "+(u.rank-1)+` but got ${r}`)}),u.rank<=1)return u.clone();const p={x:u},_={perm:r};return u.dtype==="complex64"?kr(()=>{let $=ka(u),U=Ga(u);return $=L.a.runKernel(oe.kd,{x:$},_),U=L.a.runKernel(oe.kd,{x:U},_),i&&(U=Xr(U)),Object(wa.a)($,U)}):L.a.runKernel(oe.kd,p,_)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const os=Object(qe.b)({confusionMatrix_:function(s,r,i){const u=Object(le.a)(s,"labels","confusionMatrix"),p=Object(le.a)(r,"predictions","confusionMatrix");X.b(i==null||i>0&&Number.isInteger(i),()=>`If provided, numClasses must be a positive integer, but got ${i}`),X.b(u.rank===1,()=>`Expected the rank of labels to be 1, but got ${u.rank}`),X.b(p.rank===1,()=>`Expected the rank of predictions to be 1, but got ${p.rank}`),X.b(u.shape[0]===p.shape[0],()=>`Mismatch in the number of examples: ${u.shape[0]} vs. ${p.shape[0]}. Labels and predictions should have the same number of elements.`),X.b(i>0&&Number.isInteger(i),()=>`numClasses is required to be a positive integer, but got ${i}`);const _=Xn(Mn(u,"int32"),i),$=Xn(Mn(p,"int32"),i),U=_a(_),re=rn(U,$);return Mn(re,"int32")}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(s,r){const i=s.length,u=[];for(let p=0;p<i;p++){const _=i-1-p,$=s[_]||1;(r[r.length-1-p]||1)>1&&$===1&&u.unshift(_)}return u}function La(s,r){const i=[];for(let u=0;u<r.length;u++){const p=s[s.length-u-1],_=r.length-u-1,$=r[_];(p==null||p===1&&$>1)&&i.unshift(_)}return i}function wr(s,r){const i=[],u=Math.max(s.length,r.length);for(let p=0;p<u;p++){let _=s[s.length-p-1];_==null&&(_=1);let $=r[r.length-p-1];if($==null&&($=1),_===1)i.unshift($);else if($===1)i.unshift(_);else{if(_!==$)throw Error(`Operands could not be broadcast together with shapes ${s} and ${r}.`);i.unshift(_)}}return i}var sa=e(31),Ia=e(20);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(s,r,i){if(Object(X.d)(s),r!=null&&r.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const u=Object(le.c)(s,i);if(u.length!==3&&u.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(u.length===1&&r==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Object(Ia.a)(s,r,u,i)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ca;function Ja(s,r=3){if(r>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let i=!1,u=!1,p=!1,_=!1,$=!1,U=!1;if(s.data instanceof Uint8Array)i=!0;else if(typeof ImageData!="undefined"&&s instanceof ImageData)u=!0;else if(typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement)p=!0;else if(typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement)_=!0;else if(s.getContext!=null)$=!0;else{if(!(typeof ImageBitmap!="undefined"&&s instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${s.constructor.name}`);U=!0}if(Object(sa.c)(oe.kb,L.a.backendName)!=null){const ct={pixels:s},Lt={numChannels:r};return L.a.runKernel(oe.kb,ct,Lt)}const[re,pe]=p?[s.videoWidth,s.videoHeight]:[s.width,s.height];let ze,Me;if($)ze=s.getContext("2d").getImageData(0,0,re,pe).data;else if(u||i)ze=s.data;else if(_||p||U){if(ca==null)if(typeof document=="undefined"){if(typeof OffscreenCanvas=="undefined"||typeof OffscreenCanvasRenderingContext2D=="undefined")throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ca=new OffscreenCanvas(1,1).getContext("2d")}else ca=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ca.canvas.width=re,ca.canvas.height=pe,ca.drawImage(s,0,0,re,pe),ze=ca.getImageData(0,0,re,pe).data}if(r===4)Me=new Int32Array(ze);else{const ct=re*pe;Me=new Int32Array(ct*r);for(let Lt=0;Lt<ct;Lt++)for(let Jt=0;Jt<r;++Jt)Me[Lt*r+Jt]=ze[4*Lt+Jt]}return ba(Me,[pe,re,r],"int32")}function Fe(s){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")&&!(s instanceof ImageBitmap)&&function(r){return r!=null&&r.width!==0&&r.height!==0}(s)&&!function(r){return r!=null&&r.data instanceof Uint8Array}(s)}async function dt(s,r=3){let i=null;if(Object(g.c)().getBool("WRAP_TO_IMAGEBITMAP")&&Fe(s)){let u;try{u=await createImageBitmap(s,{premultiplyAlpha:"none"})}catch{u=null}i=u!=null&&u.width===s.width&&u.height===s.height?u:s}else i=s;return Ja(i,r)}async function Et(s,r){let i=Object(le.a)(s,"img","toPixels");if(!(s instanceof un.a)){const pe=i;i=Mn(pe,"int32"),pe.dispose()}if(i.rank!==2&&i.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${i.rank}.`);const[u,p]=i.shape.slice(0,2),_=i.rank===2?1:i.shape[2];if(_>4||_===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${_}`);if(i.dtype!=="float32"&&i.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${i.dtype}. Please use float32 or int32 tensors.`);const $=await i.data(),U=i.dtype==="float32"?255:1,re=new Uint8ClampedArray(p*u*4);for(let pe=0;pe<u*p;++pe){const ze=[0,0,0,255];for(let ct=0;ct<_;ct++){const Lt=$[pe*_+ct];if(i.dtype==="float32"){if(Lt<0||Lt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Lt}.`)}else if(i.dtype==="int32"&&(Lt<0||Lt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Lt}.`);_===1?(ze[0]=Lt*U,ze[1]=Lt*U,ze[2]=Lt*U):ze[ct]=Lt*U}const Me=4*pe;re[Me+0]=Math.round(ze[0]),re[Me+1]=Math.round(ze[1]),re[Me+2]=Math.round(ze[2]),re[Me+3]=Math.round(ze[3])}if(r!=null){r.width=p,r.height=u;const pe=r.getContext("2d"),ze=new ImageData(re,p,u);pe.putImageData(ze,0,0)}return i!==s&&i.dispose(),re}const Vt=Object(qe.b)({fromPixels_:Ja});function an(s,r){const i=s.shape.length,u=r.shape.length;if(i<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${i}.`);if(u<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${u}.`);if(r.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.shape[u-1]>i)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${r.shape[u-1]} vs. ${i}`);if(Object(X.O)(s.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${s.shape}.`);const p=r.shape,_=p[p.length-1];let $=1;for(let Me=0;Me<p.length-1;++Me)$*=p[Me];const U=s.shape,re=p.slice();re.pop();let pe=1;for(let Me=_;Me<i;++Me)pe*=U[Me],re.push(U[Me]);const ze=[...Object(X.j)(s.shape).map(Me=>Me/pe),1].slice(0,_);return[re,$,pe,ze]}function Zt(s,r,i){const u=r.rank>1?r.shape[r.rank-1]:1,p=r.rank>1?r.rank-1:1,_=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${i.shape}, indices.shape: ${r.shape}, shape: ${s}, sliceDim: ${u}, and batchDim: ${p}.`;if(i.rank<p)throw new Error(_+` update.rank < ${p}. `);if(s.length<u+(i.rank-p))throw new Error(_+` Output shape length < ${u+(i.rank-p)}`);if(i.rank!==p+s.length-u)throw new Error(_+" update.rank != "+(p+s.length-u));for(let $=0;$<p;++$)if(i.shape[$]!==r.shape[$])throw new Error(_+` updates.shape[${$}] (${i.shape[$]}) != indices.shape[${$}] (${r.shape[$]}).`);for(let $=0;$<i.rank-p;++$)if(i.shape[$+p]!==s[$+u])throw new Error(_+` updates.shape[${$+p}] (${i.shape[$+p]}) != shape[${$+p}] (${s[$+p]})`)}function _n(s,r,i){if(r.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${r.rank}.`);if(s.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${s.rank}.`);if(r.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${r.dtype}`);if(i.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${i}`);if(i.length===0){if(r.size===0)throw new Error(`Indices specified for empty output. indices shape: ${r.shape}`);if(s.size===0)throw new Error(`Updates specified for empty output. updates shape: ${s.shape}`)}Zt(i,r,s)}function Gn(s,r,i){const u=r.shape.length,p=u>1?r.shape[u-1]:1,_=i.length;let $=1;for(let re=p;re<_;++re)$*=i[re];const U=p<1?1:p;return{sliceRank:p,numUpdates:Object(X.O)(r.shape)/U,sliceSize:$,strides:[...Object(X.j)(i.slice(0,p)),1],outputSize:Object(X.O)(i)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(s,r,i){const u=s.shape.length;X.b(u===r.length,()=>`Error in slice${u}D: Length of begin ${r} must match the rank of the array (${u}).`),X.b(u===i.length,()=>`Error in slice${u}D: Length of size ${i} must match the rank of the array (${u}).`);for(let p=0;p<u;++p)X.b(r[p]+i[p]<=s.shape[p],()=>`Error in slice${u}D: begin[${p}] + size[${p}] (${r[p]+i[p]}) would overflow input.shape[${p}] (${s.shape[p]})`)}function Rr(s){const r=[];let i=0;for(;s>0;)1&s&&r.push(i),s/=2,i++;return r}function Ir(s,r,i){const u=[];for(let p=0;p<s.length;p++)u[p]=Math.ceil((r[p]-s[p])/i[p]);return u}function xa(s,r,i,u){const p=[...s];for(let _=p.length;_<u.length;_++)p.push(1);for(let _=0;_<i;_++)_===0?p[r]=1:(p.splice(r,0,1),p.pop());return p}function Er(s,r,i){return i<=s?i:i-(r-1)}function Yr(s,r){const i=[];for(let u=0;u<s;u++)i.push(r+u);return i}function ja(s,r,i,u,p,_,$,U,re){const pe=s.length;let ze=new Array(pe),Me=new Array(pe),ct=new Array(pe);if(r.length&&i>0){const Lt=r[0],Jt=i+1;ze=Oa($,Lt,Jt,u,s),Me=$a(U,Lt,Jt,p,s),ct=xa(_,Lt,Jt,s)}else for(let Lt=0;Lt<pe;Lt++)ze[Lt]=$s($,u,_,s,Lt,re),Me[Lt]=bs(U,p,_,s,Lt,re),ct[Lt]=Xs(_,Lt,re);return{begin:ze,end:Me,strides:ct}}function Oa(s,r,i,u,p){const _=[...p],$=Yr(i,r);for(let U=0;U<_.length;U++)if($.indexOf(U)>-1)_[U]=0;else{const re=Er(r,i,U);let pe=u[re];s&1<<re&&(pe=0),_[U]=pe}return _}function $a(s,r,i,u,p){const _=[...p],$=Yr(i,r);for(let U=0;U<_.length;U++)if($.indexOf(U)>-1)_[U]=Number.MAX_SAFE_INTEGER;else{const re=Er(r,i,U);let pe=u[re];s&1<<re&&(pe=Number.MAX_SAFE_INTEGER),_[U]=pe}for(let U=0;U<_.length;U++){const re=p[U];_[U]<0&&(_[U]+=re),_[U]=X.i(0,_[U],p[U])}return _}function Xs(s,r,i){let u=s[r];return(i&1<<r||u==null)&&(u=1),u}function $s(s,r,i,u,p,_){let $=r[p];const U=i[p]||1;(s&1<<p||_&1<<p||$==null)&&($=U>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const re=u[p];return $<0&&($+=re),$=X.i(0,$,re-1),$}function bs(s,r,i,u,p,_){let $=r[p];const U=i[p]||1;(s&1<<p||_&1<<p||$==null)&&($=U>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const re=u[p];return $<0&&($+=re),$=U>0?X.i(0,$,re):X.i(-1,$,re-1),$}function di(s,r,i){let u=i.length;for(let p=0;p<i.length;p++)if(i[p]>1){u=p;break}for(let p=u+1;p<i.length;p++)if(r[p]>0||i[p]!==s[p])return!1;return!0}function Ha(s,r){let i=s.length>0?s[s.length-1]:1;for(let u=0;u<s.length-1;u++)i+=s[u]*r[u];return i}function qa(s,r,i){let u;const p=s.shape.length;let _;return u=typeof r=="number"?[r,...new Array(p-1).fill(0)]:r.length<p?r.concat(new Array(p-r.length).fill(0)):r.slice(),u.forEach($=>{X.b($!==-1,()=>"slice() does not support negative begin indexing.")}),_=i==null?new Array(p).fill(-1):typeof i=="number"?[i,...new Array(p-1).fill(-1)]:i.length<p?i.concat(new Array(p-i.length).fill(-1)):i,_=_.map(($,U)=>$>=0?$:(X.b($===-1,()=>`Negative size values should be exactly -1 but got ${$} for the slice() size at index ${U}.`),s.shape[U]-u[U])),[u,_]}function Ea(s,r,i,u,p,_,$,U,re){let pe;if(u==null?(pe=new Array(r.length),pe.fill(1)):pe=u,$!=null&&($&$-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let ze=!1;const Me={dims:pe.length,numAddAxisAfterEllipsis:0,begin:r.slice(),end:i.slice(),strides:pe.slice(),beginMask:p,endMask:_,ellipsisMask:$,newAxisMask:U,shrinkAxisMask:re};for(let dn=0;dn<Me.dims;dn++)ze&&(1<<dn&U)!=0&&Me.numAddAxisAfterEllipsis++,1<<dn&$&&(ze=!0);ze||(Me.ellipsisMask|=1<<Me.dims,Me.dims++);const ct={dims:s.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};(function(dn,pn){pn.beginMask=0,pn.endMask=0,pn.shrinkAxisMask=0;let Pn=0;pn.beginValid=dn.begin!=null,pn.endValid=dn.end!=null,pn.begin=new Array(pn.dims),pn.end=new Array(pn.dims),pn.strides=new Array(pn.dims),pn.finalShapeGatherIndices=[],pn.finalShapeGatherIndicesSparse=[],pn.inputShapeGatherIndicesSparse=new Array(pn.dims);for(let Un=0;Un<dn.dims;Un++)if(1<<Un&dn.ellipsisMask){const Vn=Math.min(pn.dims-(dn.dims-Un)+1+dn.numAddAxisAfterEllipsis,pn.dims);for(;Pn<Vn;Pn++)pn.begin[Pn]=0,pn.end[Pn]=0,pn.strides[Pn]=1,pn.beginMask|=1<<Pn,pn.endMask|=1<<Pn,pn.finalShapeGatherIndices.push(Pn),pn.finalShapeGatherIndicesSparse.push(-1),pn.inputShapeGatherIndicesSparse[Pn]=Un}else if(1<<Un&dn.newAxisMask)pn.finalShapeGatherIndices.push(-2),pn.finalShapeGatherIndicesSparse.push(-1);else{if(Pn===pn.begin.length)throw Error(`Index out of range using input dim ${Pn}; input has only ${pn.dims} dims, ${pn.begin.length}.`);dn.begin!=null&&(pn.begin[Pn]=dn.begin[Un]),dn.end!=null&&(pn.end[Pn]=dn.end[Un]),pn.strides[Pn]=dn.strides[Un],dn.beginMask&1<<Un&&(pn.beginMask|=1<<Pn),dn.endMask&1<<Un&&(pn.endMask|=1<<Pn),dn.shrinkAxisMask&1<<Un?(pn.finalShapeGatherIndices.push(-1),pn.finalShapeGatherIndicesSparse.push(-1),pn.shrinkAxisMask|=1<<Pn):(pn.finalShapeGatherIndices.push(Pn),pn.finalShapeGatherIndicesSparse.push(Un)),pn.inputShapeGatherIndicesSparse[Pn]=Un,Pn++}})(Me,ct);let Lt=!0,Jt=!0,fn=!0;const On=[],tr=[];for(let dn=0;dn<s.length;++dn){if(ct.strides[dn]===0)throw Error(`strides[${dn}] must be non-zero`);const pn=!!(ct.shrinkAxisMask&1<<dn),Pn=s[dn];if(Pn===-1){On.push(pn?1:-1);continue}const Un=[ct.beginMask&1<<dn,ct.endMask&1<<dn],Vn=[ct.strides[dn]>0?0:-1,ct.strides[dn]>0?Pn:Pn-1];if(pn&&ct.strides[dn]<=0)throw Error("only stride 1 allowed on non-range indexing.");fn=fn&&ct.strides[dn]===1;const fr=!!(ct.beginMask&1<<dn&&ct.endMask&1<<dn);if(ct.beginValid&&ct.endValid){if(pn){const Nr=ct.begin[dn]<0?Pn+ct.begin[dn]:ct.begin[dn];if(ct.begin[dn]=Nr,ct.end[dn]=ct.begin[dn]+1,Nr<0||Nr>=Pn)throw Error(`slice index ${ct.begin[dn]} of dimension ${dn} out of bounds.`)}else ct.begin[dn]=ta(ct.begin[dn],0,ct.strides[dn],Pn,Un,Vn),ct.end[dn]=ta(ct.end[dn],1,ct.strides[dn],Pn,Un,Vn);const jn=ct.strides[dn]===1&&ct.begin[dn]===0&&ct.end[dn]===Pn;Lt=Lt&&jn,Jt=Jt&&(dn===0&&ct.strides[dn]===1||jn)}else Lt=Lt&&ct.strides[dn]===1&&fr,Jt=Jt&&(dn===0&&ct.strides[dn]===1||fr);let mr,rr=!1;if(ct.beginValid&&ct.endValid?(mr=ct.end[dn]-ct.begin[dn],rr=!0):pn?(mr=1,rr=!0):fr&&Pn>=0&&(mr=ct.strides[dn]<0?-Pn:Pn,rr=!0),rr){let jn;jn=mr===0||mr<0!=ct.strides[dn]<0?0:Math.trunc(mr/ct.strides[dn])+(mr%ct.strides[dn]!=0?1:0),On.push(jn)}else On.push(-1)}for(let dn=0;dn<ct.finalShapeGatherIndices.length;++dn){const pn=ct.finalShapeGatherIndices[dn];pn>=0?tr.push(On[pn]):pn===-2&&tr.push(1)}return{finalShapeSparse:tr.filter((dn,pn)=>ct.finalShapeGatherIndices[pn]!==-2),finalShape:tr,isIdentity:Lt,sliceDim0:Jt,isSimpleSlice:fn,begin:ct.begin,end:ct.end,strides:ct.strides}}function ta(s,r,i,u,p,_){if(p[r])return i>0?_[r]:_[r+1&1];{const $=s<0?u+s:s;return $<_[0]?_[0]:$>_[1]?_[1]:$}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ys{getClassName(){return this.constructor.className}static fromConfig(r,i){return new r(i)}}class ia{constructor(){this.classNameMap={}}static getMap(){return ia.instance==null&&(ia.instance=new ia),ia.instance}static register(r){ia.getMap().classNameMap[r.className]=[r,r.fromConfig]}}function Aa(s){Object(X.b)(s.className!=null,()=>"Class being registered does not have the static className property defined."),Object(X.b)(typeof s.className=="string",()=>"className is required to be a string, but got type "+typeof s.className),Object(X.b)(s.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),ia.register(s)}var es=e(6);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gs=.1;function hi(s,r,i){return i==null&&(i=xs()),us(s,r,(u,p)=>za(u,p,i))}function xs(){return L.a.backend.floatPrecision()===32?.001:gs}function us(s,r,i){let u=!0;if((Object(X.A)(s)||Object(X.A)(r))&&(u=!1),Object(X.A)(s)&&Object(X.A)(r)&&(u=!0),u){const $=s.constructor.name,U=r.constructor.name;if($!==U)throw new Error(`Arrays are of different type. Actual: ${$}. Expected: ${U}`)}if(Array.isArray(s)&&Array.isArray(r)){const $=Object(le.c)(s),U=Object(le.c)(r);if(!Object(X.a)($,U))throw new Error(`Arrays have different shapes. Actual: [${$}]. Expected: [${U}]`)}const p=Object(X.A)(s)?s:Object(X.m)(s),_=Object(X.A)(r)?r:Object(X.m)(r);if(p.length!==_.length)throw new Error(`Arrays have different lengths actual: ${p.length} vs expected: ${_.length}.
Actual:   ${p}.
Expected: ${_}.`);for(let $=0;$<_.length;++$){const U=p[$],re=_[$];if(!i(U,re))throw new Error(`Arrays differ: actual[${$}] = ${U}, expected[${$}] = ${re}.
Actual:   ${p}.
Expected: ${_}.`)}typeof expect!="undefined"&&expect().nothing()}function pi(s,r){s().then(()=>r.fail(),()=>r()),typeof expect!="undefined"&&expect().nothing()}function pr(s,r){const i=typeof r=="string"||typeof r=="number"||typeof r=="boolean"?[r]:r;return Object(X.z)(s)||Object(X.z)(s[0])||Object(X.z)(r)||Object(X.z)(r[0])?us(s,i,(u,p)=>u==p):us(s,r,(u,p)=>za(u,p,0))}function Jr(s,r,i){if(i==null&&(i=xs()),!za(s,r,i))throw new Error(`Numbers differ: actual === ${s}, expected === ${r}`);typeof expect!="undefined"&&expect().nothing()}function za(s,r,i){return!isFinite(s)&&!isFinite(r)||!(isNaN(s)||isNaN(r)||Math.abs(s-r)>i)}function Es(s,r,i){for(let u=0;u<s.length;u++)if(s[u]<r||s[u]>i)throw new Error(`Value out of range:${s[u]} low: ${r}, high: ${i}`)}function Qs(s,r){const i=new Float32Array(s),u=new Float32Array(r);if(i.length!==u.length)throw new Error(`Expected ArrayBuffer to be of length ${u.length}, but it was ${i.length}`);for(let p=0;p<u.length;p++)if(i[p]!==u[p])throw new Error(`Expected ArrayBuffer value at ${p} to be ${u[p]} but got ${i[p]} instead`)}function ts(s){for(let r=0;r<s.length;r++){const i=s[r];Array.isArray(i)?ts(i):s[r]=Object(es.encodeString)(i)}return s}function As(s){const r=document.createElement("video");return"playsInline"in r&&(r.playsInline=!0),r.muted=!0,r.loop=!0,r.style.position="fixed",r.style.left="0px",r.style.top="0px",r.preload="auto",r.appendChild(s),new Promise(i=>{r.addEventListener("loadeddata",u=>i(r)),r.load()})}async function Ns(s){await s.play(),"requestVideoFrameCallback"in s&&await new Promise(r=>{s.requestVideoFrameCallback(r)})}/** @license See the LICENSE file. */const vs="3.20.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yn=Object(qe.b)({add_:function(s,r){let i=Object(le.a)(s,"a","add"),u=Object(le.a)(r,"b","add");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.d,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const In=Object(qe.b)({floorDiv_:function(s,r){let i=Object(le.a)(s,"a","floorDiv"),u=Object(le.a)(r,"b","floorDiv");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.jb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fr=Object(qe.b)({div_:function(s,r){let i=Object(le.a)(s,"a","div"),u=Object(le.a)(r,"b","div");if([i,u]=Object(xn.makeTypesMatch)(i,u),i.dtype==="int32"&&u.dtype==="int32")return In(i,u);const p={a:i,b:u};return L.a.runKernel(oe.qc,p,{})}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sn=Object(qe.b)({mul_:function(s,r){let i=Object(le.a)(s,"a","mul"),u=Object(le.a)(r,"b","mul");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.Zb,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sa=Object(qe.b)({sqrt_:function(s){const r={x:Object(le.a)(s,"x","sqrt","float32")};return L.a.runKernel(oe.Vc,r)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const na=Object(qe.b)({square_:function(s){const r=Object(le.a)(s,"x","square");return L.a.runKernel("Square",{x:r},{})}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pa=Object(qe.b)({zerosLike_:function(s){const r={x:Object(le.a)(s,"x","zerosLike")};return L.a.runKernel(oe.pd,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(s){return X.b(X.u(s),()=>"The f passed in grad(f) must be a function"),(r,i)=>{const u=Object(le.a)(r,"x","tf.grad","string_or_numeric"),p=i!=null?Object(le.a)(i,"dy","tf.grad"):null;return L.a.tidy(()=>{const{value:_,grads:$}=L.a.gradients(()=>s(u),[u],p);return p!=null&&X.e(_.shape,p.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ls($),$[0]})}}function ys(s){return X.b(X.u(s),()=>"The f passed in grads(f) must be a function"),(r,i)=>{X.b(Array.isArray(r),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const u=Object(le.b)(r,"args","tf.grads","string_or_numeric"),p=i!=null?Object(le.a)(i,"dy","tf.grads"):null;return L.a.tidy(()=>{const{value:_,grads:$}=L.a.gradients(()=>s(...u),u,p);return p!=null&&X.e(_.shape,p.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ls($),$})}}function cs(s){return X.b(X.u(s),()=>"The f passed in valueAndGrad(f) must be a function"),(r,i)=>{X.b(r instanceof un.a,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),X.b(i==null||i instanceof un.a,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:u,value:p}=L.a.gradients(()=>s(r),[r],i);return ls(u),{grad:u[0],value:p}}}function xi(s){return X.b(X.u(s),()=>"The f passed in valueAndGrads(f) must be a function"),(r,i)=>{X.b(Array.isArray(r)&&r.every(p=>p instanceof un.a),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),X.b(i==null||i instanceof un.a,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const u=L.a.gradients(()=>s(...r),r,i);return i!=null&&X.e(u.value.shape,i.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ls(u.grads),u}}function ra(s,r){X.b(X.u(s),()=>"The f passed in variableGrads(f) must be a function"),X.b(r==null||Array.isArray(r)&&r.every(re=>re instanceof un.c),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const i=r!=null;if(!i){r=[];for(const re in L.a.registeredVariables)r.push(L.a.registeredVariables[re])}const u=i?r.filter(re=>!re.trainable):null,p=r.length;r=r.filter(re=>re.trainable),X.b(r.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${p} variables is trainable.`);const{value:_,grads:$}=L.a.gradients(s,r,null,!0);X.b($.some(re=>re!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),X.b(_.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${_.rank} tensor`);const U={};return r.forEach((re,pe)=>{$[pe]!=null&&(U[re.name]=$[pe])}),u!=null&&u.forEach(re=>U[re.name]=null),{value:_,grads:U}}function Ua(s){return L.a.customGrad(s)}function ls(s){if(s.filter(r=>r==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(s,r){if((Object(X.A)(s)&&r!=="string"||Array.isArray(s))&&r!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(r==="string"&&Object(X.A)(s)&&!(s instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(Ia.a)(s,[],[],r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ka extends Ys{minimize(r,i=!1,u){const{value:p,grads:_}=this.computeGradients(r,u);if(u!=null){const $=u.map(U=>({name:U.name,tensor:_[U.name]}));this.applyGradients($)}else this.applyGradients(_);return Pr(_),i?p:(p.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(r,i){return ra(r,i)}dispose(){this.iterations_!=null&&Pr(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Tr(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(r){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(r){return this.iterations_=(await r[0].tensor.data())[0],r.slice(1)}}Object.defineProperty(Ka,Symbol.hasInstance,{value:s=>s.minimize!=null&&s.computeGradients!=null&&s.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rs extends Ka{constructor(r,i,u=null){super(),this.learningRate=r,this.rho=i,this.epsilon=u,this.accumulatedGrads=[],this.accumulatedUpdates=[],u==null&&(this.epsilon=L.a.backend.epsilon())}applyGradients(r){(Array.isArray(r)?r.map(i=>i.name):Object.keys(r)).forEach((i,u)=>{const p=L.a.registeredVariables[i];this.accumulatedGrads[u]==null&&(this.accumulatedGrads[u]={originalName:`${i}/accum_grad`,variable:kr(()=>pa(p).variable(!1))}),this.accumulatedUpdates[u]==null&&(this.accumulatedUpdates[u]={originalName:`${i}/accum_var`,variable:kr(()=>pa(p).variable(!1))});const _=Array.isArray(r)?r[u].tensor:r[i];if(_==null)return;const $=this.accumulatedGrads[u].variable,U=this.accumulatedUpdates[u].variable;kr(()=>{const re=Yn(Sn($,this.rho),Sn(na(_),1-this.rho)),pe=Sn(Fr(Sa(Yn(U,this.epsilon)),Sa(Yn($,this.epsilon))),_),ze=Yn(Sn(U,this.rho),Sn(na(pe),1-this.rho));$.assign(re),U.assign(ze);const Me=Yn(Sn(pe,-this.learningRate),p);p.assign(Me)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Pr(this.accumulatedGrads.map(r=>r.variable)),Pr(this.accumulatedUpdates.map(r=>r.variable)))}async getWeights(){const r=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(r.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(r){const i=(r=await this.extractIterations(r)).length/2;this.accumulatedGrads=r.slice(0,i).map(u=>({originalName:u.name,variable:u.tensor.variable(!1)})),this.accumulatedUpdates=r.slice(i,2*i).map(u=>({originalName:u.name,variable:u.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(r,i){return new r(i.learningRate,i.rho,i.epsilon)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Js(s,r,i){const u={shape:s,value:r,dtype:i};return L.a.runKernel(oe.gb,{},u)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Rs.className="Adadelta",Aa(Rs);class ws extends Ka{constructor(r,i=.1){super(),this.learningRate=r,this.initialAccumulatorValue=i,this.accumulatedGrads=[]}applyGradients(r){(Array.isArray(r)?r.map(i=>i.name):Object.keys(r)).forEach((i,u)=>{const p=L.a.registeredVariables[i];this.accumulatedGrads[u]==null&&(this.accumulatedGrads[u]={originalName:`${i}/accumulator`,variable:kr(()=>Js(p.shape,this.initialAccumulatorValue).variable(!1))});const _=Array.isArray(r)?r[u].tensor:r[i];if(_==null)return;const $=this.accumulatedGrads[u].variable;kr(()=>{const U=Yn($,na(_));$.assign(U);const re=Yn(Sn(Fr(_,Sa(Yn(U,L.a.backend.epsilon()))),-this.learningRate),p);p.assign(re)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Pr(this.accumulatedGrads.map(r=>r.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(r){r=await this.extractIterations(r),this.accumulatedGrads=r.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(r,i){return new r(i.learningRate,i.initialAccumulatorValue)}}ws.className="Adagrad",Aa(ws);const ks=Object(qe.b)({pow_:function(s,r){let i=Object(le.a)(s,"base","pow"),u=Object(le.a)(r,"exp","pow");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.kc,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ur=Object(qe.b)({sub_:function(s,r){let i=Object(le.a)(s,"a","sub"),u=Object(le.a)(r,"b","sub");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.dd,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fs extends Ka{constructor(r,i,u,p=null){super(),this.learningRate=r,this.beta1=i,this.beta2=u,this.epsilon=p,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],kr(()=>{this.accBeta1=Tr(i).variable(),this.accBeta2=Tr(u).variable()}),p==null&&(this.epsilon=L.a.backend.epsilon())}applyGradients(r){const i=Array.isArray(r)?r.map(u=>u.name):Object.keys(r);kr(()=>{const u=ur(1,this.accBeta1),p=ur(1,this.accBeta2);i.forEach((_,$)=>{const U=L.a.registeredVariables[_];this.accumulatedFirstMoment[$]==null&&(this.accumulatedFirstMoment[$]={originalName:`${_}/m`,variable:kr(()=>pa(U).variable(!1))}),this.accumulatedSecondMoment[$]==null&&(this.accumulatedSecondMoment[$]={originalName:`${_}/v`,variable:kr(()=>pa(U).variable(!1))});const re=Array.isArray(r)?r[$].tensor:r[_];if(re==null)return;const pe=this.accumulatedFirstMoment[$].variable,ze=this.accumulatedSecondMoment[$].variable,Me=Yn(Sn(pe,this.beta1),Sn(re,1-this.beta1)),ct=Yn(Sn(ze,this.beta2),Sn(na(re),1-this.beta2)),Lt=Fr(Me,u),Jt=Fr(ct,p);pe.assign(Me),ze.assign(ct);const fn=Yn(Sn(Fr(Lt,Yn(Sa(Jt),this.epsilon)),-this.learningRate),U);U.assign(fn)}),this.accBeta1.assign(Sn(this.accBeta1,this.beta1)),this.accBeta2.assign(Sn(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Pr(this.accumulatedFirstMoment.map(r=>r.variable)),this.accumulatedSecondMoment!=null&&Pr(this.accumulatedSecondMoment.map(r=>r.variable))}async getWeights(){const r=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(r.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(r){r=await this.extractIterations(r),kr(()=>{this.accBeta1.assign(ks(this.beta1,this.iterations_+1)),this.accBeta2.assign(ks(this.beta2,this.iterations_+1))});const i=r.length/2;this.accumulatedFirstMoment=r.slice(0,i).map(u=>({originalName:u.name,variable:u.tensor.variable(!1)})),this.accumulatedSecondMoment=r.slice(i,2*i).map(u=>({originalName:u.name,variable:u.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(r,i){return new r(i.learningRate,i.beta1,i.beta2,i.epsilon)}}Fs.className="Adam",Aa(Fs);const va=Object(qe.b)({abs_:function(s){const r=Object(le.a)(s,"x","abs");if(r.dtype==="complex64"){const i={x:r};return L.a.runKernel(oe.B,i)}{const i={x:r};return L.a.runKernel(oe.a,i)}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ei=Object(qe.b)({maximum_:function(s,r){let i=Object(le.a)(s,"a","maximum"),u=Object(le.a)(r,"b","maximum");[i,u]=Object(xn.makeTypesMatch)(i,u),i.dtype==="bool"&&(i=Mn(i,"int32"),u=Mn(u,"int32")),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Sb,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ms extends Ka{constructor(r,i,u,p=null,_=0){super(),this.learningRate=r,this.beta1=i,this.beta2=u,this.epsilon=p,this.decay=_,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],kr(()=>{this.iteration=Tr(0).variable(),this.accBeta1=Tr(i).variable()}),p==null&&(this.epsilon=L.a.backend.epsilon())}applyGradients(r){const i=Array.isArray(r)?r.map(u=>u.name):Object.keys(r);kr(()=>{const u=ur(1,this.accBeta1),p=Fr(-this.learningRate,Yn(Sn(this.iteration,this.decay),1));i.forEach((_,$)=>{const U=L.a.registeredVariables[_];this.accumulatedFirstMoment[$]==null&&(this.accumulatedFirstMoment[$]={originalName:`${_}/m`,variable:pa(U).variable(!1)}),this.accumulatedWeightedInfNorm[$]==null&&(this.accumulatedWeightedInfNorm[$]={originalName:`${_}/v`,variable:pa(U).variable(!1)});const re=Array.isArray(r)?r[$].tensor:r[_];if(re==null)return;const pe=this.accumulatedFirstMoment[$].variable,ze=this.accumulatedWeightedInfNorm[$].variable,Me=Yn(Sn(pe,this.beta1),Sn(re,1-this.beta1)),ct=Sn(ze,this.beta2),Lt=va(re),Jt=ei(ct,Lt);pe.assign(Me),ze.assign(Jt);const fn=Yn(Sn(Fr(p,u),Fr(Me,Yn(Jt,this.epsilon))),U);U.assign(fn)}),this.iteration.assign(Yn(this.iteration,1)),this.accBeta1.assign(Sn(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Pr(this.accumulatedFirstMoment.map(r=>r.variable)),this.accumulatedWeightedInfNorm!=null&&Pr(this.accumulatedWeightedInfNorm.map(r=>r.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(r){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(r,i){return new r(i.learningRate,i.beta1,i.beta2,i.epsilon,i.decay)}}Ms.className="Adamax",Aa(Ms);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ds extends Ka{constructor(r){super(),this.learningRate=r,this.setLearningRate(r)}applyGradients(r){(Array.isArray(r)?r.map(i=>i.name):Object.keys(r)).forEach((i,u)=>{const p=Array.isArray(r)?r[u].tensor:r[i];if(p==null)return;const _=L.a.registeredVariables[i];kr(()=>{const $=Yn(Sn(this.c,p),_);_.assign($)})}),this.incrementIterations()}setLearningRate(r){this.learningRate=r,this.c!=null&&this.c.dispose(),this.c=qr(Tr(-r))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(r){if((r=await this.extractIterations(r)).length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(r,i){return new r(i.learningRate)}}Ds.className="SGD",Aa(Ds);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ti extends Ds{constructor(r,i,u=!1){super(r),this.learningRate=r,this.momentum=i,this.useNesterov=u,this.accumulations=[],this.m=Tr(this.momentum)}applyGradients(r){(Array.isArray(r)?r.map(i=>i.name):Object.keys(r)).forEach((i,u)=>{const p=L.a.registeredVariables[i];this.accumulations[u]==null&&(this.accumulations[u]={originalName:`${i}/momentum`,variable:kr(()=>pa(p).variable(!1))});const _=this.accumulations[u].variable,$=Array.isArray(r)?r[u].tensor:r[i];$!=null&&kr(()=>{let U;const re=Yn(Sn(this.m,_),$);U=this.useNesterov?Yn(Sn(this.c,Yn($,Sn(re,this.m))),p):Yn(Sn(this.c,re),p),_.assign(re),p.assign(U)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Pr(this.accumulations.map(r=>r.variable))}setMomentum(r){this.momentum=r}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))}async setWeights(r){r=await this.extractIterations(r),this.accumulations=r.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(r,i){return new r(i.learningRate,i.momentum,i.useNesterov)}}ti.className="Momentum",Aa(ti);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ps extends Ka{constructor(r,i=.9,u=0,p=null,_=!1){if(super(),this.learningRate=r,this.decay=i,this.momentum=u,this.epsilon=p,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=_,p==null&&(this.epsilon=L.a.backend.epsilon()),r==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(r){(Array.isArray(r)?r.map(i=>i.name):Object.keys(r)).forEach((i,u)=>{const p=L.a.registeredVariables[i],_=!1;this.accumulatedMeanSquares[u]==null&&(this.accumulatedMeanSquares[u]={originalName:`${i}/rms`,variable:kr(()=>pa(p).variable(_))}),this.accumulatedMoments[u]==null&&(this.accumulatedMoments[u]={originalName:`${i}/momentum`,variable:kr(()=>pa(p).variable(_))}),this.accumulatedMeanGrads[u]==null&&this.centered&&(this.accumulatedMeanGrads[u]={originalName:`${i}/mg`,variable:kr(()=>pa(p).variable(_))});const $=Array.isArray(r)?r[u].tensor:r[i];if($==null)return;const U=this.accumulatedMeanSquares[u].variable,re=this.accumulatedMoments[u].variable;kr(()=>{const pe=Yn(Sn(U,this.decay),Sn(na($),1-this.decay));if(this.centered){const ze=this.accumulatedMeanGrads[u].variable,Me=Yn(Sn(ze,this.decay),Sn($,1-this.decay)),ct=Fr(Sn($,this.learningRate),Sa(ur(pe,Yn(na(Me),this.epsilon)))),Lt=Yn(Sn(re,this.momentum),ct);U.assign(pe),ze.assign(Me),re.assign(Lt);const Jt=ur(p,Lt);p.assign(Jt)}else{const ze=Yn(Sn(U,this.decay),Sn(na($),1-this.decay)),Me=Yn(Sn(re,this.momentum),Fr(Sn($,this.learningRate),Sa(Yn(ze,this.epsilon))));U.assign(ze),re.assign(Me);const ct=ur(p,Me);p.assign(ct)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Pr(this.accumulatedMeanSquares.map(r=>r.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Pr(this.accumulatedMeanGrads.map(r=>r.variable)),this.accumulatedMoments!=null&&Pr(this.accumulatedMoments.map(r=>r.variable))}async getWeights(){const r=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&r.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(r.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(r){r=await this.extractIterations(r);const i=this.centered?r.length/3:r.length/2,u=!1;this.accumulatedMeanSquares=r.slice(0,i).map(p=>({originalName:p.name,variable:p.tensor.variable(u)})),this.accumulatedMoments=r.slice(i,2*i).map(p=>({originalName:p.name,variable:p.tensor.variable(u)})),this.centered&&(this.accumulatedMeanGrads=r.slice(2*i,3*i).map(p=>({originalName:p.name,variable:p.tensor.variable(u)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(r,i){return new r(i.learningRate,i.decay,i.momentum,i.epsilon,i.centered)}}Ps.className="RMSProp",Aa(Ps);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ns{static sgd(r){return new Ds(r)}static momentum(r,i,u=!1){return new ti(r,i,u)}static rmsprop(r,i=.9,u=0,p=null,_=!1){return new Ps(r,i,u,p,_)}static adam(r=.001,i=.9,u=.999,p=null){return new Fs(r,i,u,p)}static adadelta(r=.001,i=.95,u=null){return new Rs(r,i,u)}static adamax(r=.002,i=.9,u=.999,p=null,_=0){return new Ms(r,i,u,p,_)}static adagrad(r,i=.1){return new ws(r,i)}}var Bs=e(34);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ai=Object(qe.b)({acos_:function(s){const r={x:Object(le.a)(s,"x","acos")};return L.a.runKernel(oe.b,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ls=Object(qe.b)({acosh_:function(s){const r={x:Object(le.a)(s,"x","acosh")};return L.a.runKernel(oe.c,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rs=Object(qe.b)({addN_:function(s){X.b(Array.isArray(s),()=>"The argument passed to tf.addN() must be a list of tensors"),X.b(s.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${s.length}`);const r=s.map((p,_)=>Object(le.a)(p,`tensors${_}`,"addN")),i=r[0];r.forEach(p=>{if(p.dtype!==i.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),r.forEach(p=>{if(!X.a(p.shape,i.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const u=r;return L.a.runKernel(oe.e,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ni=Object(qe.b)({all_:function(s,r=null,i=!1){const u={x:Object(le.a)(s,"x","all","bool")},p={axis:r,keepDims:i};return L.a.runKernel(oe.f,u,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const js=Object(qe.b)({any_:function(s,r=null,i=!1){const u={x:Object(le.a)(s,"x","any","bool")},p={axis:r,keepDims:i};return L.a.runKernel(oe.g,u,p)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni=Object(qe.b)({argMax_:function(s,r=0){const i={x:Object(le.a)(s,"x","argMax")},u={axis:r};return L.a.runKernel(oe.h,i,u)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _s=Object(qe.b)({argMin_:function(s,r=0){const i={x:Object(le.a)(s,"x","argMin")},u={axis:r};return L.a.runKernel(oe.i,i,u)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zs=Object(qe.b)({asin_:function(s){const r={x:Object(le.a)(s,"x","asin")};return L.a.runKernel(oe.j,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri=Object(qe.b)({asinh_:function(s){const r={x:Object(le.a)(s,"x","asinh")};return L.a.runKernel(oe.k,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vi=Object(qe.b)({atan_:function(s){const r={x:Object(le.a)(s,"x","atan")};return L.a.runKernel(oe.l,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ri=Object(qe.b)({atan2_:function(s,r){let i=Object(le.a)(s,"a","atan2"),u=Object(le.a)(r,"b","atan2");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.m,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=Object(qe.b)({atanh_:function(s){const r={x:Object(le.a)(s,"x","atanh")};return L.a.runKernel(oe.n,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yi(s,r,i,u,p="NHWC",_){return Be(s,[...r,s[3]],i,_,u,null,null,zt(p))}function Ne(s,r,i,u,p,_,$="channelsLast"){const[U,re]=Ye(r);let pe;if($==="channelsLast")pe=[U,re,s[3],s[3]];else{if($!=="channelsFirst")throw new Error(`Unknown dataFormat ${$}`);pe=[U,re,s[1],s[1]]}return Be(s,pe,i,u,p,_,!1,$)}function ue(s,r,i,u,p,_,$="NDHWC"){const[U,re,pe]=it(r);let ze,Me;if($==="NDHWC")Me="channelsLast",ze=[U,re,pe,s[4],s[4]];else{if($!=="NCDHW")throw new Error(`Unknown dataFormat ${$}`);Me="channelsFirst",ze=[U,re,pe,s[1],s[1]]}return Xe(s,ze,i,u,p,!1,Me,_)}function Be(s,r,i,u,p,_,$=!1,U="channelsLast"){let[re,pe,ze,Me]=[-1,-1,-1,-1];if(U==="channelsLast")[re,pe,ze,Me]=s;else{if(U!=="channelsFirst")throw new Error(`Unknown dataFormat ${U}`);[re,Me,pe,ze]=s}const[ct,Lt,,Jt]=r,[fn,On]=Ye(i),[tr,dn]=Ye(u),pn=xt(ct,tr),Pn=xt(Lt,dn),{padInfo:Un,outHeight:Vn,outWidth:fr}=function(jn,Nr,Qr,ea,Kr,da,oa,fs,ss){let Ti,gi,Oi;if(typeof jn=="number"){Ti={top:jn,bottom:jn,left:jn,right:jn,type:jn===0?"VALID":"NUMBER"};const qs=function(Os,Ks,ui,zi,mo){zi==null&&(zi=Te(Os,Ks,ui));const bo=Os[0],go=Os[1],xo=ut((bo-Ks+2*zi)/ui+1,mo),Ji=ut((go-Ks+2*zi)/ui+1,mo);return[xo,Ji]}([Nr,Qr],da,ea,jn,fs);gi=qs[0],Oi=qs[1]}else if(jn==="same"){gi=Math.ceil(Nr/ea),Oi=Math.ceil(Qr/Kr);const qs=Math.max(0,(gi-1)*ea+da-Nr),Os=Math.max(0,(Oi-1)*Kr+oa-Qr),Ks=Math.floor(qs/2),ui=qs-Ks,zi=Math.floor(Os/2);Ti={top:Ks,bottom:ui,left:zi,right:Os-zi,type:"SAME"}}else if(jn==="valid")Ti={top:0,bottom:0,left:0,right:0,type:"VALID"},gi=Math.ceil((Nr-da+1)/ea),Oi=Math.ceil((Qr-oa+1)/Kr);else{if(typeof jn!="object")throw Error(`Unknown padding parameter: ${jn}`);{const qs=ss==="channelsLast"?jn[1][0]:jn[2][0],Os=ss==="channelsLast"?jn[1][1]:jn[2][1],Ks=ss==="channelsLast"?jn[2][0]:jn[3][0],ui=ss==="channelsLast"?jn[2][1]:jn[3][1];Ti={top:qs,bottom:Os,left:Ks,right:ui,type:qs===0&&Os===0&&Ks===0&&ui===0?"VALID":"EXPLICIT"},gi=ut((Nr-da+qs+Os)/ea+1,fs),Oi=ut((Qr-oa+Ks+ui)/Kr+1,fs)}}return{padInfo:Ti,outHeight:gi,outWidth:Oi}}(p,pe,ze,fn,On,pn,Pn,_,U),mr=$?Jt*Me:Jt;let rr;return U==="channelsFirst"?rr=[re,mr,Vn,fr]:U==="channelsLast"&&(rr=[re,Vn,fr,mr]),{batchSize:re,dataFormat:U,inHeight:pe,inWidth:ze,inChannels:Me,outHeight:Vn,outWidth:fr,outChannels:mr,padInfo:Un,strideHeight:fn,strideWidth:On,filterHeight:ct,filterWidth:Lt,effectiveFilterHeight:pn,effectiveFilterWidth:Pn,dilationHeight:tr,dilationWidth:dn,inShape:s,outShape:rr,filterShape:r}}function Xe(s,r,i,u,p,_=!1,$="channelsLast",U){let[re,pe,ze,Me,ct]=[-1,-1,-1,-1,-1];if($==="channelsLast")[re,pe,ze,Me,ct]=s;else{if($!=="channelsFirst")throw new Error(`Unknown dataFormat ${$}`);[re,ct,pe,ze,Me]=s}const[Lt,Jt,fn,,On]=r,[tr,dn,pn]=it(i),[Pn,Un,Vn]=it(u),fr=xt(Lt,Pn),mr=xt(Jt,Un),rr=xt(fn,Vn),{padInfo:jn,outDepth:Nr,outHeight:Qr,outWidth:ea}=function(oa,fs,ss,Ti,gi,Oi,qs,Os,Ks,ui,zi){let mo,bo,go,xo;if(typeof oa=="number"){mo={top:oa,bottom:oa,left:oa,right:oa,front:oa,back:oa,type:oa===0?"VALID":"NUMBER"};const Ji=function(vo,yo,du,Co,eo,jo){eo==null&&(eo=Te(vo,yo,Co));const hu=vo[0],Sd=vo[1],Cd=vo[2],Td=ut((hu-yo+2*eo)/Co+1,jo),Od=ut((Sd-yo+2*eo)/Co+1,jo),$d=ut((Cd-yo+2*eo)/Co+1,jo);return[Td,Od,$d,du]}([fs,ss,Ti,1],Os,1,gi,oa,zi);bo=Ji[0],go=Ji[1],xo=Ji[2]}else if(oa==="same"){bo=Math.ceil(fs/gi),go=Math.ceil(ss/Oi),xo=Math.ceil(Ti/qs);const Ji=(bo-1)*gi+Os-fs,vo=(go-1)*Oi+Ks-ss,yo=(xo-1)*qs+ui-Ti,du=Math.floor(Ji/2),Co=Ji-du,eo=Math.floor(vo/2),jo=vo-eo,hu=Math.floor(yo/2);mo={top:eo,bottom:jo,left:hu,right:yo-hu,front:du,back:Co,type:"SAME"}}else{if(oa!=="valid")throw Error(`Unknown padding parameter: ${oa}`);mo={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},bo=Math.ceil((fs-Os+1)/gi),go=Math.ceil((ss-Ks+1)/Oi),xo=Math.ceil((Ti-ui+1)/qs)}return{padInfo:mo,outDepth:bo,outHeight:go,outWidth:xo}}(p,pe,ze,Me,tr,dn,pn,fr,mr,rr,U),Kr=_?On*ct:On;let da;return $==="channelsFirst"?da=[re,Kr,Nr,Qr,ea]:$==="channelsLast"&&(da=[re,Nr,Qr,ea,Kr]),{batchSize:re,dataFormat:$,inDepth:pe,inHeight:ze,inWidth:Me,inChannels:ct,outDepth:Nr,outHeight:Qr,outWidth:ea,outChannels:Kr,padInfo:jn,strideDepth:tr,strideHeight:dn,strideWidth:pn,filterDepth:Lt,filterHeight:Jt,filterWidth:fn,effectiveFilterDepth:fr,effectiveFilterHeight:mr,effectiveFilterWidth:rr,dilationDepth:Pn,dilationHeight:Un,dilationWidth:Vn,inShape:s,outShape:da,filterShape:r}}function Te(s,r,i,u=1){const p=xt(r,u);return Math.floor((s[0]*(i-1)-i+p)/2)}function Ye(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s}function it(s){return typeof s=="number"?[s,s,s]:s}function xt(s,r){return r<=1?s:s+(s-1)*(r-1)}function ut(s,r){if(!r)return Math.trunc(s);switch(r){case"round":return Math.round(s);case"ceil":return Math.ceil(s);case"floor":return Math.floor(s);default:throw new Error(`Unknown roundingMode ${r}`)}}function ft(s){const[r,i,u]=Ye(s);return r===1&&i===1&&u===1}function pt(s,r){return ft(s)||ft(r)}function zt(s){if(s==="NHWC")return"channelsLast";if(s==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${s}`)}function Dt(s,r,i){if(i!=null){if(typeof r=="string")throw Error(`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);if(typeof r=="number")X.b(X.v(r),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);else{if(typeof r!="object")throw Error(`Error in ${s}: Unknown padding parameter: ${r}`);r.forEach(u=>{u.forEach(p=>{X.b(X.v(p),()=>`Error in ${s}: pad must be an integer when using dimRoundingMode ${i} but got pad ${p}.`)})})}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const We=Object(qe.b)({reshape_:function(s,r){const i={x:Object(le.a)(s,"x","reshape","string_or_numeric")},u={shape:r};return L.a.runKernel(oe.uc,i,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _t=Object(qe.b)({avgPool_:function(s,r,i,u,p){const _=Object(le.a)(s,"x","avgPool","float32");X.b(pt(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);let $=_,U=!1;_.rank===3&&(U=!0,$=We(_,[1,_.shape[0],_.shape[1],_.shape[2]])),X.b($.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${$.rank}.`),Dt("avgPool",u,p);const re={x:$},pe={filterSize:r,strides:i,pad:u,dimRoundingMode:p};let ze=L.a.runKernel(oe.o,re,pe);return ze=Mn(ze,_.dtype),U?We(ze,[ze.shape[1],ze.shape[2],ze.shape[3]]):ze}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jt=Object(qe.b)({avgPool3d_:function(s,r,i,u,p,_="NDHWC"){const $=Object(le.a)(s,"x","avgPool3d","float32");let U=$,re=!1;$.rank===4&&(re=!0,U=We($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]])),X.b(U.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${U.rank}.`),X.b(_==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${_}`),Dt("avgPool3d",u,p);const pe={x:U},ze={filterSize:r,strides:i,pad:u,dimRoundingMode:p,dataFormat:_};let Me=L.a.runKernel(oe.p,pe,ze);return Me=Mn(Me,U.dtype),re?We(Me,[Me.shape[1],Me.shape[2],Me.shape[3],Me.shape[4]]):Me}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xt=Object(qe.b)({concat_:function(s,r=0){Object(X.b)(s.length>=1,()=>"Pass at least one tensor to concat");const i=Object(le.b)(s,"tensors","concat","string_or_numeric");if(i[0].dtype==="complex64"&&i.forEach(_=>{if(_.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${_.dtype}. `)}),i.length===1)return zr(i[0]);const u=i,p={axis:r};return L.a.runKernel(oe.C,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const on=Object(qe.b)({sigmoid_:function(s){const r={x:Object(le.a)(s,"x","sigmoid","float32")};return L.a.runKernel(oe.Hc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pt=Object(qe.b)({slice_:function(s,r,i){const u=Object(le.a)(s,"x","slice","string_or_numeric");if(u.rank===0)throw new Error("Slicing scalar is not possible");const p={x:u},_={begin:r,size:i};return L.a.runKernel(oe.Lc,p,_)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hn=Object(qe.b)({tanh_:function(s){const r={x:Object(le.a)(s,"x","tanh","float32")};return L.a.runKernel(oe.gd,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fn=Object(qe.b)({basicLSTMCell_:function(s,r,i,u,p,_){const $=Object(le.a)(s,"forgetBias","basicLSTMCell"),U=Object(le.a)(r,"lstmKernel","basicLSTMCell"),re=Object(le.a)(i,"lstmBias","basicLSTMCell"),pe=Object(le.a)(u,"data","basicLSTMCell"),ze=Object(le.a)(p,"c","basicLSTMCell"),Me=Object(le.a)(_,"h","basicLSTMCell"),ct=Xt([pe,Me],1),Lt=rn(ct,U),Jt=Yn(Lt,re),fn=Jt.shape[0],On=Jt.shape[1]/4,tr=[fn,On],dn=Pt(Jt,[0,0],tr),pn=Pt(Jt,[0,On],tr),Pn=Pt(Jt,[0,2*On],tr),Un=Pt(Jt,[0,3*On],tr),Vn=Yn(Sn(on(dn),hn(pn)),Sn(ze,on(Yn($,Pn))));return[Vn,Sn(hn(Vn),on(Un))]}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nr=Object(qe.b)({batchToSpaceND_:function(s,r,i){const u=Object(le.a)(s,"x","batchToSpaceND"),p=r.reduce((U,re)=>U*re);X.b(u.rank>=1+r.length,()=>`input rank is ${u.rank} but should be > than blockShape.length ${r.length}`),X.b(i.length===r.length,()=>`crops.length is ${i.length} but should be equal to blockShape.length  ${r.length}`),X.b(u.shape[0]%p==0,()=>`input tensor batch is ${u.shape[0]} but is not divisible by the product of the elements of blockShape ${r.join(" * ")} === ${p}`);const _={x:u},$={blockShape:r,crops:i};return L.a.runKernel(oe.t,_,$)}}),dr=Object(qe.b)({batchNorm_:function(s,r,i,u,p,_){_==null&&(_=.001);const $=Object(le.a)(s,"x","batchNorm"),U=Object(le.a)(r,"mean","batchNorm"),re=Object(le.a)(i,"variance","batchNorm");let pe,ze;p!=null&&(pe=Object(le.a)(p,"scale","batchNorm")),u!=null&&(ze=Object(le.a)(u,"offset","batchNorm")),X.b(U.rank===re.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),X.b(ze==null||U.rank===ze.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),X.b(pe==null||U.rank===pe.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const Me=function(fn){let On;return On=fn.rank===0||fn.rank===1?We(fn,[1,1,1,fn.size]):fn.rank===2?We(fn,[1,1,fn.shape[0],fn.shape[1]]):fn.rank===3?We(fn,[1,fn.shape[0],fn.shape[1],fn.shape[2]]):fn,On}($),ct={x:Me,scale:pe,offset:ze,mean:U,variance:re},Lt={varianceEpsilon:_},Jt=L.a.runKernel(oe.lb,ct,Lt);return We(Jt,$.shape)}}),hr=Object(qe.b)({batchNorm2d_:function(s,r,i,u,p,_){const $=Object(le.a)(s,"x","batchNorm"),U=Object(le.a)(r,"mean","batchNorm"),re=Object(le.a)(i,"variance","batchNorm");let pe,ze;return p!=null&&(pe=Object(le.a)(p,"scale","batchNorm")),u!=null&&(ze=Object(le.a)(u,"offset","batchNorm")),X.b($.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${$.rank}.`),X.b(U.rank===2||U.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${U.rank}.`),X.b(re.rank===2||re.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${re.rank}.`),pe!=null&&X.b(pe.rank===2||pe.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${pe.rank}.`),ze!=null&&X.b(ze.rank===2||ze.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ze.rank}.`),dr($,U,re,ze,pe,_)}}),cr=Object(qe.b)({batchNorm3d_:function(s,r,i,u,p,_){const $=Object(le.a)(s,"x","batchNorm"),U=Object(le.a)(r,"mean","batchNorm"),re=Object(le.a)(i,"variance","batchNorm");let pe,ze;return p!=null&&(pe=Object(le.a)(p,"scale","batchNorm")),u!=null&&(ze=Object(le.a)(u,"offset","batchNorm")),X.b($.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${$.rank}.`),X.b(U.rank===3||U.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${U.rank}.`),X.b(re.rank===3||re.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${re.rank}.`),pe!=null&&X.b(pe.rank===3||pe.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${pe.rank}.`),ze!=null&&X.b(ze.rank===3||ze.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ze.rank}.`),dr($,U,re,ze,pe,_)}}),Mr=Object(qe.b)({batchNorm4d_:function(s,r,i,u,p,_){const $=Object(le.a)(s,"x","batchNorm"),U=Object(le.a)(r,"mean","batchNorm"),re=Object(le.a)(i,"variance","batchNorm");let pe,ze;return p!=null&&(pe=Object(le.a)(p,"scale","batchNorm")),u!=null&&(ze=Object(le.a)(u,"offset","batchNorm")),X.b($.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${$.rank}.`),X.b(U.rank===4||U.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${U.rank}.`),X.b(re.rank===4||re.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${re.rank}.`),pe!=null&&X.b(pe.rank===4||pe.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${pe.rank}.`),ze!=null&&X.b(ze.rank===4||ze.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ze.rank}.`),dr($,U,re,ze,pe,_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sr=Object(qe.b)({bincount_:function(s,r,i){const u=Object(le.a)(s,"x","bincount"),p=Object(le.a)(r,"weights","bincount");X.b(u.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${u.dtype}`),X.b(i>=0,()=>`size must be non-negative, but got ${i}.`),X.b(p.size===u.size||p.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${u.shape}, weights shape: ${p.shape}.`);const _={x:u,weights:p},$={size:i};return L.a.runKernel(oe.u,_,$)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dr=Object(qe.b)({broadcastArgs_:function(s,r){const i=Object(le.a)(s,"s0","broadcastArgs","int32"),u=Object(le.a)(r,"s1","broadcastArgs","int32");if(i.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${i.rank}`);if(u.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${u.rank}`);const p={s0:i,s1:u};return L.a.runKernel(oe.v,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ar=Object(qe.b)({broadcastTo_:function(s,r){let i=Object(le.a)(s,"broadcastTo","x");const u=i.shape;if(r.some(re=>!(re>0)||re%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${r}].`);if(r.length<i.rank)throw new Error(`broadcastTo(): shape.length=${r.length} < input.rank=${i.rank}.`);if(r.length>i.rank){const re=i.shape.slice();for(;re.length<r.length;)re.unshift(1);i=We(i,re)}const p=i.shape,_=Array.from(r);for(let re=r.length-1;re>=0;re--)if(p[re]===r[re])_[re]=1;else if(i.shape[re]!==1)throw new Error(`broadcastTo(): [${u}] cannot be broadcast to [${r}].`);if(_.map((re,pe)=>re>1?pe:-1).filter(re=>re>=0).length===0)return zr(i);const $={x:i},U={reps:_};return L.a.runKernel(oe.hd,$,U)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aa=Object(qe.b)({ceil_:function(s){const r={x:Object(le.a)(s,"x","ceil","float32")};return L.a.runKernel(oe.y,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ya=Object(qe.b)({clipByValue_:function(s,r,i){const u=Object(le.a)(s,"x","clipByValue");X.b(r<=i,()=>`Error in clip: min (${r}) must be less than or equal to max (${i}).`);const p={x:u},_={clipValueMin:r,clipValueMax:i};return L.a.runKernel(oe.z,p,_)}}),Xa=Object(qe.b)({concat1d_:function(s){return Xt(s,0)}}),as=Object(qe.b)({concat2d_:function(s,r){return Xt(s,r)}}),Us=Object(qe.b)({concat3d_:function(s,r){return Xt(s,r)}}),Is=Object(qe.b)({concat4d_:function(s,r){return Xt(s,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ya=Object(qe.b)({conv2d_:function(s,r,i,u,p="NHWC",_=[1,1],$){const U=Object(le.a)(s,"x","conv2d","float32"),re=Object(le.a)(r,"filter","conv2d","float32");let pe=U,ze=!1;U.rank===3&&(ze=!0,pe=We(U,[1,U.shape[0],U.shape[1],U.shape[2]])),X.b(pe.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${pe.rank}.`),X.b(re.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${re.rank}.`),Dt("conv2d",u,$);const Me=p==="NHWC"?pe.shape[3]:pe.shape[1];X.b(Me===re.shape[2],()=>`Error in conv2d: depth of input (${Me}) must match input depth for filter ${re.shape[2]}.`),X.b(pt(i,_),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${_}'`);const ct={x:pe,filter:re},Lt={strides:i,pad:u,dataFormat:p,dilations:_,dimRoundingMode:$},Jt=L.a.runKernel(oe.D,ct,Lt);return ze?We(Jt,[Jt.shape[1],Jt.shape[2],Jt.shape[3]]):Jt}}),ds=Object(qe.b)({conv1d_:function(s,r,i,u,p="NWC",_=1,$){const U=Object(le.a)(s,"x","conv1d"),re=Object(le.a)(r,"filter","conv1d");let pe=U,ze=!1;U.rank===2&&(ze=!0,pe=We(U,[1,U.shape[0],U.shape[1]])),X.b(pe.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${pe.rank}.`),X.b(re.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${re.rank}.`),Dt("conv1d",u,$),X.b(pe.shape[2]===re.shape[1],()=>`Error in conv1d: depth of input (${pe.shape[2]}) must match input depth for filter ${re.shape[1]}.`),X.b(pt(i,_),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${i} and dilation '${_}'`),X.b(p==="NWC",()=>`Error in conv1d: got dataFormat of ${p} but only NWC is currently supported.`);const Me=We(re,[1,re.shape[0],re.shape[1],re.shape[2]]),ct=We(pe,[pe.shape[0],1,pe.shape[1],pe.shape[2]]),Lt=Ya(ct,Me,[1,i],u,"NHWC",[1,_],$);return We(Lt,ze?[Lt.shape[2],Lt.shape[3]]:[Lt.shape[0],Lt.shape[2],Lt.shape[3]])}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hs=Object(qe.b)({conv2DBackpropInput_:function(s,r,i,u,p,_="NHWC",$){X.b(s.length===r.rank,()=>`Length of inShape (${s.length}) and rank of dy (${r.rank}) must match`);let U=s,re=r,pe=!1;r.rank===3&&(pe=!0,re=We(r,[1,r.shape[0],r.shape[1],r.shape[2]]),U=[1,s[0],s[1],s[2]]),X.b(U.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${U.length}.`),X.b(re.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${re.rank}`),X.b(i.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${i.rank}`);const ze=_==="NHWC"?U[3]:U[1],Me=_==="NHWC"?re.shape[3]:re.shape[1];X.b(ze===i.shape[2],()=>`Error in conv2dDerInput: depth of input (${ze}) must match input depth for filter ${i.shape[2]}.`),X.b(Me===i.shape[3],()=>`Error in conv2dDerInput: depth of output (${Me}) must match output depth for filter ${i.shape[3]}.`),Dt("conv2dDerInput",p,$);const ct={dy:re,filter:i},Lt={strides:u,pad:p,dataFormat:_,dimRoundingMode:$,inputShape:U},Jt=L.a.runKernel(oe.F,ct,Lt);return pe?We(Jt,[Jt.shape[1],Jt.shape[2],Jt.shape[3]]):Jt}}),Ws=Object(qe.b)({conv2dTranspose_:function(s,r,i,u,p,_){const $=Object(le.a)(s,"x","conv2dTranspose"),U=Object(le.a)(r,"filter","conv2dTranspose");return hs(i,$,U,u,p,"NHWC",_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa=Object(qe.b)({conv3d_:function(s,r,i,u,p="NDHWC",_=[1,1,1]){const $=Object(le.a)(s,"x","conv3d"),U=Object(le.a)(r,"filter","conv3d");let re=$,pe=!1;$.rank===4&&(pe=!0,re=We($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]])),X.b(re.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${re.rank}.`),X.b(U.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${U.rank}.`),X.b(re.shape[4]===U.shape[3],()=>`Error in conv3d: depth of input (${re.shape[4]}) must match input depth for filter ${U.shape[3]}.`),X.b(pt(i,_),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${i} and dilations '${_}'`),X.b(p==="NDHWC",()=>`Error in conv3d: got dataFormat of ${p} but only NDHWC is currently supported.`);const ze={x:re,filter:U},Me={strides:i,pad:u,dataFormat:p,dilations:_},ct=L.a.runKernel(oe.G,ze,Me);return pe?We(ct,[ct.shape[1],ct.shape[2],ct.shape[3],ct.shape[4]]):ct}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vs=Object(qe.b)({conv3DBackpropInput_:function(s,r,i,u,p){X.b(s.length===r.rank,()=>`Length of inShape (${s.length}) and rank of dy (${r.rank}) must match`);let _=s,$=r,U=!1;r.rank===4&&(U=!0,$=We(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]),_=[1,s[0],s[1],s[2],s[3]]);const re=_[4],pe=$.shape[4];X.b(_.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${_.length}.`),X.b($.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${$.rank}`),X.b(i.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${i.rank}`),X.b(re===i.shape[3],()=>`Error in conv3dDerInput: depth of input (${re}) must match input depth for filter ${i.shape[3]}.`),X.b(pe===i.shape[4],()=>`Error in conv3dDerInput: depth of output (${pe}) must match output depth for filter ${i.shape[4]}.`);const ze={dy:$,filter:i},Me={pad:p,strides:u,inputShape:_},ct=L.a.runKernel(oe.I,ze,Me);return U?We(ct,[ct.shape[1],ct.shape[2],ct.shape[3],ct.shape[4]]):ct}}),wi=Object(qe.b)({conv3dTranspose_:function(s,r,i,u,p){const _=Object(le.a)(s,"x","conv3dTranspose"),$=Object(le.a)(r,"filter","conv3dTranspose");return Vs(i,_,$,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gs=Object(qe.b)({cos_:function(s){const r={x:Object(le.a)(s,"x","cos","float32")};return L.a.runKernel(oe.J,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ki=Object(qe.b)({cosh_:function(s){const r={x:Object(le.a)(s,"x","cosh","float32")};return L.a.runKernel(oe.K,r)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const no=Object(qe.b)({cumprod_:function(s,r=0,i=!1,u=!1){const p={x:Object(le.a)(s,"x","cumprod")},_={axis:r,exclusive:i,reverse:u};return L.a.runKernel(oe.M,p,_)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wi=Object(qe.b)({cumsum_:function(s,r=0,i=!1,u=!1){const p={x:Object(le.a)(s,"x","cumsum")},_={axis:r,exclusive:i,reverse:u};return L.a.runKernel(oe.N,p,_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ro=Object(qe.b)({denseBincount_:function(s,r,i,u=!1){const p=Object(le.a)(s,"x","denseBincount"),_=Object(le.a)(r,"weights","denseBincount");X.b(p.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${p.dtype}`),X.b(p.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${p.rank}.`),X.b(i>=0,()=>`size must be non-negative, but got ${i}.`),X.b(_.size===p.size||_.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${p.shape}, weights shape: ${_.shape}.`);const $={x:p,weights:_},U={size:i,binaryOutput:u};return L.a.runKernel(oe.O,$,U)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vi=Object(qe.b)({depthToSpace_:function(s,r,i="NHWC"){const u=Object(le.a)(s,"x","depthToSpace","float32"),p=i==="NHWC"?u.shape[1]:u.shape[2],_=i==="NHWC"?u.shape[2]:u.shape[3],$=i==="NHWC"?u.shape[3]:u.shape[1];X.b(r>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${r}`),X.b(p*r>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${p} and ${r}  for depthToSpace with input shape
    ${u.shape}`),X.b(_*r>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${_} and ${r} for depthToSpace with input shape
        ${u.shape}`),X.b($%(r*r)==0,()=>`Dimension size must be evenly divisible by ${r*r} but is ${$} for depthToSpace with input shape ${u.shape}`);const U={x:u},re={blockSize:r,dataFormat:i};return L.a.runKernel(oe.P,U,re)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mi=Object(qe.b)({depthwiseConv2d_:function(s,r,i,u,p="NHWC",_=[1,1],$){const U=Object(le.a)(s,"x","depthwiseConv2d","float32"),re=Object(le.a)(r,"filter","depthwiseConv2d","float32");let pe=U,ze=!1;U.rank===3&&(ze=!0,pe=We(U,[1,U.shape[0],U.shape[1],U.shape[2]])),X.b(pe.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${pe.rank}.`),X.b(re.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${re.rank}.`);const Me=p==="NHWC"?pe.shape[3]:pe.shape[1];X.b(Me===re.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${Me}) must match the inChannels dimension in filter ${re.shape[2]}.`),Dt("depthwiseConv2d",u,$);const ct={x:pe,filter:re},Lt={strides:i,pad:u,dataFormat:p,dilations:_,dimRoundingMode:$},Jt=L.a.runKernel(oe.Q,ct,Lt);return ze?We(Jt,[Jt.shape[1],Jt.shape[2],Jt.shape[3]]):Jt}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _i=Object(qe.b)({diag_:function(s){const r={x:Object(le.a)(s,"x","diag")};return L.a.runKernel(oe.T,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gi=Object(qe.b)({dilation2d_:function(s,r,i,u,p=[1,1],_="NHWC"){const $=Object(le.a)(s,"x","dilation2d"),U=Object(le.a)(r,"filter","dilation2d");X.b($.rank===3||$.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${$.rank}.`),X.b(U.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${U.rank}.`),X.b(_==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${_}`);let re=$,pe=!1;$.rank===3&&(re=We($,[1,$.shape[0],$.shape[1],$.shape[2]]),pe=!0);const ze={x:re,filter:U},Me={strides:i,pad:u,dilations:p},ct=L.a.runKernel(oe.U,ze,Me);return pe?We(ct,[ct.shape[1],ct.shape[2],ct.shape[3]]):ct}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Di=Object(qe.b)({equal_:function(s,r){let i=Object(le.a)(s,"a","equal","string_or_numeric"),u=Object(le.a)(r,"b","equal","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.ab,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai=Object(qe.b)({where_:function(s,r,i){const u=Object(le.a)(r,"a","where"),p=Object(le.a)(i,"b","where"),_=Object(le.a)(s,"condition","where","bool"),$=wr(wr(_.shape,u.shape),p.shape),U={condition:Ar(_,$),t:Ar(u,$),e:Ar(p,$)};return L.a.runKernel(oe.Fc,U)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao=Object(qe.b)({divNoNan_:function(s,r){let i=Object(le.a)(s,"a","div"),u=Object(le.a)(r,"b","div");[i,u]=Object(xn.makeTypesMatch)(i,u);const p=Fr(i,u),_=pa(p),$=Di(u,_);return ai($,_,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const so=Object(qe.b)({dot_:function(s,r){const i=Object(le.a)(s,"t1","dot"),u=Object(le.a)(r,"t2","dot");X.b(!(i.rank!==1&&i.rank!==2||u.rank!==1&&u.rank!==2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${i.rank} and ${u.rank}.`);const p=i.rank===1?i.size:i.shape[1],_=u.rank===1?u.size:u.shape[0];if(X.b(p===_,()=>`Error in dot: inner dimensions of inputs must match, but got ${p} and ${_}.`),i.rank===1&&u.rank===1){const $=We(i,[1,-1]),U=We(u,[-1,1]),re=rn($,U);return We(re,[])}if(i.rank===1&&u.rank===2){const $=We(i,[1,-1]),U=We(u,[u.shape[0],u.shape[1]]),re=rn($,U);return We(re,[re.size])}if(i.rank===2&&u.rank===1){const $=We(u,[-1,1]),U=rn(i,$);return We(U,[U.size])}{const $=We(u,[u.shape[0],u.shape[1]]);return rn(i,$)}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const io=Object(qe.b)({einsum_:function(s,...r){const i=r.map((p,_)=>Object(le.a)(p,`tensors${_}`,"einsum")),u={equation:s};return L.a.runKernel(oe.X,i,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hi=Object(qe.b)({elu_:function(s){const r={x:Object(le.a)(s,"x","elu","float32")};return L.a.runKernel(oe.Y,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ii=Object(qe.b)({erf_:function(s){let r=Object(le.a)(s,"x","erf");X.b(r.dtype==="int32"||r.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),r.dtype==="int32"&&(r=Mn(r,"float32"));const i={x:r};return L.a.runKernel(oe.bb,i)}});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(s,r){for(let i=0;i<s.length;++i)if(s[s.length-i-1]!==r-1-i)return!1;return!0}function qi(s,r,i){const u=s.length+r.length,p=[];let _=0,$=0;for(let U=0;U<u;U++)i.indexOf(U)===-1?p.push(s[_++]):p.push(r[$++]);return p}function oo(s,r){const i=[],u=s.length;for(let p=0;p<u;p++)r.indexOf(p)===-1&&i.push(s[p]);return[i,r.map(p=>s[p])]}function fi(s,r){return qi(s,r.map(i=>1),r)}function uo(s,r,i){X.b(Pi(r,i),()=>`${s} supports only inner-most axes for now. Got axes ${r} and rank-${i} input.`)}function co(s,r){if(Pi(s,r))return null;const i=[];for(let u=0;u<r;++u)s.indexOf(u)===-1&&i.push(u);return s.forEach(u=>i.push(u)),i}function Ki(s){return s.map((r,i)=>[i,r]).sort((r,i)=>r[1]-i[1]).map(r=>r[0])}function mi(s,r){const i=[];for(let u=r-s;u<r;++u)i.push(u);return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const si=Object(qe.b)({max_:function(s,r=null,i=!1){const u={x:Object(le.a)(s,"x","max")},p={reductionIndices:r,keepDims:i};return L.a.runKernel(oe.Mb,u,p)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Si=Object(qe.b)({min_:function(s,r=null,i=!1){const u={x:Object(le.a)(s,"x","min")},p={axis:r,keepDims:i};return L.a.runKernel(oe.Ub,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Br=Object(qe.b)({sum_:function(s,r=null,i=!1){let u=Object(le.a)(s,"x","sum");u.dtype==="bool"&&(u=Mn(u,"int32"));const p={x:u},_={axis:r,keepDims:i};return L.a.runKernel(oe.ed,p,_)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(s,r,i=null){if(s.rank===0)return va(s);if(s.rank!==1&&i===null)return Bi(We(s,[-1]),r,i);if(s.rank===1||typeof i=="number"||Array.isArray(i)&&i.length===1){if(r===1)return Br(va(s),i);if(r===1/0)return si(va(s),i);if(r===-1/0)return Si(va(s),i);if(r==="euclidean"||r===2)return Sa(Br(ks(va(s),Tr(2,"int32")),i));throw new Error(`Error in norm: invalid ord value: ${r}`)}if(Array.isArray(i)&&i.length===2){if(r===1)return si(Br(va(s),i[0]),i[1]-1);if(r===1/0)return si(Br(va(s),i[1]),i[0]);if(r===-1/0)return Si(Br(va(s),i[1]),i[0]);if(r==="fro"||r==="euclidean")return Sa(Br(na(s),i));throw new Error(`Error in norm: invalid ord value: ${r}`)}throw new Error(`Error in norm: invalid axis: ${i}`)}const bi=Object(qe.b)({norm_:function(s,r="euclidean",i=null,u=!1){const p=Bi(s=Object(le.a)(s,"x","norm"),r,i);let _=p.shape;if(u){const $=Object(X.I)(i,s.shape);_=fi(p.shape,$)}return We(p,_)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xi=Object(qe.b)({euclideanNorm_:function(s,r=null,i=!1){return bi(s,"euclidean",r,i)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ps=Object(qe.b)({exp_:function(s){const r={x:Object(le.a)(s,"x","exp")};return L.a.runKernel(oe.cb,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ve=Object(qe.b)({expandDims_:function(s,r=0){const i=Object(le.a)(s,"x","expandDims","string_or_numeric");X.b(r<=i.rank,()=>"Axis must be <= rank of the tensor");const u={input:i},p={dim:r};return L.a.runKernel(oe.db,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe=Object(qe.b)({expm1_:function(s){const r={x:Object(le.a)(s,"x","expm1")};return L.a.runKernel(oe.eb,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j=Object(qe.b)({tile_:function(s,r){const i=Object(le.a)(s,"x","tile","string_or_numeric");X.b(i.rank===r.length,()=>`Error in transpose: rank of input ${i.rank} must match length of reps ${r}.`);const u={x:i},p={reps:r};return L.a.runKernel(oe.hd,u,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ie=Object(qe.b)({eye_:function(s,r,i,u="float32"){r==null&&(r=s);const p=Rn([s,r],u),_=s<=r?s:r;for(let U=0;U<_;++U)p.set(1,U,U);const $=We(p.toTensor(),[s,r]);if(i==null)return $;if(i.length===1)return j(ve($,0),[i[0],1,1]);if(i.length===2)return j(ve(ve($,0),0),[i[0],i[1],1,1]);if(i.length===3)return j(ve(ve(ve($,0),0),0),[i[0],i[1],i[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${i.length}D.`)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F=Object(qe.b)({floor_:function(s){const r={x:Object(le.a)(s,"x","floor","float32")};return L.a.runKernel(oe.ib,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ne=Object(qe.b)({gather_:function(s,r,i=0,u=0){const p={x:Object(le.a)(s,"x","gather"),indices:Object(le.a)(r,"indices","gather","int32")},_={axis:i,batchDims:u};return L.a.runKernel(oe.pb,p,_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ge=Object(qe.b)({greater_:function(s,r){let i=Object(le.a)(s,"a","greater","string_or_numeric"),u=Object(le.a)(r,"b","greater","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.qb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ee=Object(qe.b)({greaterEqual_:function(s,r){let i=Object(le.a)(s,"a","greaterEqual","string_or_numeric"),u=Object(le.a)(r,"b","greaterEqual","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.rb,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $e=Object(qe.b)({isFinite_:function(s){const r={x:Object(le.a)(s,"x","isFinite")};return L.a.runKernel(oe.vb,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const be=Object(qe.b)({isInf_:function(s){const r={x:Object(le.a)(s,"x","isInf")};return L.a.runKernel(oe.wb,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ye=Object(qe.b)({isNaN_:function(s){const r={x:Object(le.a)(s,"x","isNaN")};return L.a.runKernel(oe.xb,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ue=Object(qe.b)({leakyRelu_:function(s,r=.2){const i={x:Object(le.a)(s,"x","leakyRelu")},u={alpha:r};return L.a.runKernel(oe.Ab,i,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Re=Object(qe.b)({less_:function(s,r){let i=Object(le.a)(s,"a","less","string_or_numeric"),u=Object(le.a)(r,"b","less","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Bb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=Object(qe.b)({lessEqual_:function(s,r){let i=Object(le.a)(s,"a","lessEqual","string_or_numeric"),u=Object(le.a)(r,"b","lessEqual","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Cb,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(s,r,i){if(i<=0)throw new Error("The number of values should be positive.");const u={start:s,stop:r,num:i};return L.a.runKernel(oe.Db,{},u)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tt=Object(qe.b)({localResponseNormalization_:function(s,r=5,i=1,u=1,p=.5){const _=Object(le.a)(s,"x","localResponseNormalization");X.b(_.rank===4||_.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${_.rank}.`),X.b(X.v(r),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${r}.`);let $=_,U=!1;_.rank===3&&(U=!0,$=We(_,[1,_.shape[0],_.shape[1],_.shape[2]]));const re={x:$},pe={depthRadius:r,bias:i,alpha:u,beta:p},ze=L.a.runKernel(oe.yb,re,pe);return U?We(ze,[ze.shape[1],ze.shape[2],ze.shape[3]]):ze}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at=Object(qe.b)({log_:function(s){const r={x:Object(le.a)(s,"x","log","float32")};return L.a.runKernel(oe.Eb,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ot=Object(qe.b)({log1p_:function(s){const r={x:Object(le.a)(s,"x","log1p")};return L.a.runKernel(oe.Fb,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bt=Object(qe.b)({softplus_:function(s){const r={x:Object(le.a)(s,"x","softplus")};return L.a.runKernel(oe.Nc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const St=Object(qe.b)({logSigmoid_:function(s){const r=Object(le.a)(s,"x","logSigmoid");return Ua(u=>({value:Xr(bt(Xr(u))),gradFunc:p=>Sn(p,on(Xr(u)))}))(r)}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R=Object(qe.b)({logSoftmax_:function(s,r=-1){const i=Object(le.a)(s,"logits","logSoftmax");if(r===-1&&(r=i.rank-1),r!==i.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and axis was ${r}`);return Ua((p,_)=>{const $=si(p,r,!0),U=ur(p,$),re=ur(Mn(U,"float32"),at(Br(ps(U),r,!0)));return _([re]),{value:re,gradFunc:(pe,ze)=>{const[Me]=ze,ct=ps(Me);return ur(pe,Sn(Br(pe,r,!0),ct))}}})(i)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v=Object(qe.b)({logSumExp_:function(s,r=null,i=!1){const u=Object(le.a)(s,"x","logSumExp"),p=Object(X.I)(r,u.shape),_=si(u,p,!0),$=ur(u,_),U=ps($),re=Br(U,p),pe=at(re),ze=Yn(We(_,pe.shape),pe);if(i){const Me=fi(ze.shape,p);return We(ze,Me)}return ze}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x=Object(qe.b)({logicalAnd_:function(s,r){const i=Object(le.a)(s,"a","logicalAnd","bool"),u=Object(le.a)(r,"b","logicalAnd","bool");wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Hb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M=Object(qe.b)({logicalNot_:function(s){const r={x:Object(le.a)(s,"x","logicalNot","bool")};return L.a.runKernel(oe.Ib,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N=Object(qe.b)({logicalOr_:function(s,r){const i=Object(le.a)(s,"a","logicalOr","bool"),u=Object(le.a)(r,"b","logicalOr","bool");wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Jb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H=Object(qe.b)({logicalXor_:function(s,r){const i=Object(le.a)(s,"a","logicalXor","bool"),u=Object(le.a)(r,"b","logicalXor","bool");return wr(i.shape,u.shape),x(N(s,r),M(x(s,r)))}}),ee=2147483648;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const se=Object(qe.b)({searchSorted_:function(s,r,i="left"){const u=Object(le.a)(s,"sortedSequence","searchSorted"),p=Object(le.a)(r,"values","searchSorted"),_=u.shape[u.shape.length-1],$=p.shape[p.shape.length-1],U=We(u,[-1,_]),re=We(p,[-1,$]);if(U.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(U.shape[0]!==re.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Object(X.O)(re.shape)>=ee)throw new Error("values tensor size must less than 2147483648");if(U.shape[1]>=ee)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${U.shape[1]}`);const pe={sortedSequence:U,values:re},ze={side:i};return L.a.runKernel(oe.Ec,pe,ze)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ce(s,r){return se(s,r,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xe=Object(qe.b)({maxPool_:function(s,r,i,u,p){const _=Object(le.a)(s,"x","maxPool");let $=_,U=!1;_.rank===3&&(U=!0,$=We(_,[1,_.shape[0],_.shape[1],_.shape[2]])),X.b($.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${$.rank}.`),X.b(pt(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`),Dt("maxPool",u,p);const re={x:$},pe={filterSize:r,strides:i,pad:u,dimRoundingMode:p},ze=L.a.runKernel(oe.Nb,re,pe);return U?We(ze,[ze.shape[1],ze.shape[2],ze.shape[3]]):ze}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const De=Object(qe.b)({maxPool3d_:function(s,r=[1,1,1],i,u,p,_="NDHWC"){const $=Object(le.a)(s,"x","maxPool3d");let U=$,re=!1;$.rank===4&&(re=!0,U=We($,[1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]])),X.b(U.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${U.rank}.`),X.b(_==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${_}`),Dt("maxPool3d",u,p);const pe={x:U},ze={filterSize:r,strides:i,pad:u,dimRoundingMode:p,dataFormat:_},Me=L.a.runKernel(oe.Ob,pe,ze);return re?We(Me,[Me.shape[1],Me.shape[2],Me.shape[3],Me.shape[4]]):Me}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ke=Object(qe.b)({maxPoolWithArgmax_:function(s,r,i,u,p=!1){const _={x:Object(le.a)(s,"x","maxPoolWithArgmax")},$={filterSize:r,strides:i,pad:u,includeBatchInIndex:p},U=L.a.runKernel(oe.Rb,_,$);return{result:U[0],indexes:U[1]}}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ze=Object(qe.b)({mean_:function(s,r=null,i=!1){const u={x:Object(le.a)(s,"x","mean")},p={axis:r,keepDims:i};return L.a.runKernel(oe.Tb,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(s,r="float32"){if(r==="complex64"){const u=Ge(s,"float32"),p=Ge(s,"float32");return Object(wa.a)(u,p)}const i=Object(X.F)(Object(X.O)(s),r);return L.a.makeTensor(i,s,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nt(s,r="float32"){if(r==="complex64"){const u=nt(s,"float32"),p=Ge(s,"float32");return Object(wa.a)(u,p)}const i=Object(X.D)(Object(X.O)(s),r);return L.a.makeTensor(i,s,r)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(s,r,{indexing:i="xy"}={}){if(i!=="xy"&&i!=="ij")throw new TypeError(`${i} is not a valid third argument to meshgrid`);if(s===void 0)return[];let u=Object(le.a)(s,"x","meshgrid",s instanceof un.a?s.dtype:"float32");if(r===void 0)return[u];let p=Object(le.a)(r,"y","meshgrid",r instanceof un.a?r.dtype:"float32");const _=Object(X.O)(u.shape),$=Object(X.O)(p.shape);return i==="xy"?(u=We(u,[1,-1]),p=We(p,[-1,1]),[rn(nt([$,1],u.dtype),u),rn(p,nt([1,_],p.dtype))]):(u=We(u,[-1,1]),p=We(p,[1,-1]),[rn(u,nt([1,$],u.dtype)),rn(nt([_,1],p.dtype),p)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yt=Object(qe.b)({minimum_:function(s,r){let i=Object(le.a)(s,"a","minimum"),u=Object(le.a)(r,"b","minimum");[i,u]=Object(xn.makeTypesMatch)(i,u),i.dtype==="bool"&&(i=Mn(i,"int32"),u=Mn(u,"int32")),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Vb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gt=Object(qe.b)({mirrorPad_:function(s,r,i){X.b(i==="reflect"||i==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${i}.`);const u=Object(le.a)(s,"x","mirrorPad");if(u.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");X.b(r.length===u.rank,()=>`Padding doesn't match input. Must be ${u.rank}. Got ${r.length}.`);const p=i==="reflect"?1:0;for(let U=0;U<u.rank;U++)X.b(r[U].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),X.b(r[U][0]>=0&&r[U][0]<=u.shape[U]-p&&r[U][1]>=0&&r[U][1]<=u.shape[U]-p,()=>`Padding in dimension ${U} cannot be greater than or equal to ${u.shape[U]-p} or less than 0 for input of shape ${u.shape}`);const _={paddings:r,mode:i},$={x:u};return L.a.runKernel(oe.Wb,$,_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kt=Object(qe.b)({mod_:function(s,r){let i=Object(le.a)(s,"a","mod"),u=Object(le.a)(r,"b","mod");[i,u]=Object(xn.makeTypesMatch)(i,u);const p={a:i,b:u};return L.a.runKernel(oe.Xb,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tt=Object(qe.b)({moments_:function(s,r=null,i=!1){s=Object(le.a)(s,"x","moments");const u=Object(X.I)(r,s.shape),p=Ze(s,u,i);let _=p.shape;i||(_=fi(p.shape,u));const $=na(ur(Mn(s,"float32"),We(p,_)));return{mean:p,variance:Ze($,u,i)}}}),Rt=Object(qe.b)({multiRNNCell_:function(s,r,i,u){const p=Object(le.a)(r,"data","multiRNNCell"),_=Object(le.b)(i,"c","multiRNNCell"),$=Object(le.b)(u,"h","multiRNNCell");let U=p;const re=[];for(let Me=0;Me<s.length;Me++){const ct=s[Me](U,_[Me],$[Me]);re.push(ct[0]),re.push(ct[1]),U=ct[1]}const pe=[],ze=[];for(let Me=0;Me<re.length;Me+=2)pe.push(re[Me]),ze.push(re[Me+1]);return[pe,ze]}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt=Object(qe.b)({multinomial_:function(s,r,i,u=!1){const p=Object(le.a)(s,"logits","multinomial"),_=p.size,$=p.rank;if(_<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${_}.`);if($>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${$}`);i=i||Math.random();const U={logits:$===1?We(p,[1,-1]):p},re={numSamples:r,seed:i,normalized:u},pe=L.a.runKernel(oe.Yb,U,re);return $===1?We(pe,[pe.size]):pe}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ht=Object(qe.b)({notEqual_:function(s,r){let i=Object(le.a)(s,"a","notEqual","string_or_numeric"),u=Object(le.a)(r,"b","notEqual","string_or_numeric");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.ec,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nn=Object(qe.b)({onesLike_:function(s){const r={x:Object(le.a)(s,"x","onesLike")};return L.a.runKernel(oe.gc,r)}}),gn=Object(qe.b)({outerProduct_:function(s,r){const i=Object(le.a)(s,"v1","outerProduct"),u=Object(le.a)(r,"v2","outerProduct");X.b(i.rank===1&&u.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${i.rank} and ${u.rank}.`);const p=We(i,[-1,1]),_=We(u,[1,-1]);return rn(p,_)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ln=Object(qe.b)({pad_:function(s,r,i=0){const u=Object(le.a)(s,"x","pad");if(u.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const p={paddings:r,constantValue:i},_={x:u};return L.a.runKernel(oe.ic,_,p)}}),Bn=Object(qe.b)({pad1d_:function(s,r,i=0){return Object(X.b)(r.length===2,()=>"Invalid number of paddings. Must be length of 2."),ln(s,[r],i)}}),wn=Object(qe.b)({pad2d_:function(s,r,i=0){return Object(X.b)(r.length===2&&r[0].length===2&&r[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ln(s,r,i)}}),$n=Object(qe.b)({pad3d_:function(s,r,i=0){return Object(X.b)(r.length===3&&r[0].length===2&&r[1].length===2&&r[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ln(s,r,i)}}),Wn=Object(qe.b)({pad4d_:function(s,r,i=0){return Object(X.b)(r.length===4&&r[0].length===2&&r[1].length===2&&r[2].length===2&&r[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ln(s,r,i)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn=Object(qe.b)({spaceToBatchND_:function(s,r,i){const u=Object(le.a)(s,"x","spaceToBatchND");X.b(u.rank>=1+r.length,()=>`input rank ${u.rank} should be > than [blockShape] ${r.length}`),X.b(i.length===r.length,()=>`paddings.shape[0] ${i.length} must be equal to [blockShape] ${r.length}`),X.b(u.shape.reduce(($,U,re)=>re>0&&re<=r.length?$&&(U+i[re-1][0]+i[re-1][1])%r[re-1]==0:$,!0),()=>`input spatial dimensions ${u.shape.slice(1)} with paddings ${i.toString()} must be divisible by blockShapes ${r.toString()}`);const p={x:u},_={blockShape:r,paddings:i};return L.a.runKernel(oe.Oc,p,_)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dn=Object(qe.b)({pool_:function(s,r,i,u,p,_,$){p==null&&(p=[1,1]),_==null&&(_=1),u===0&&(u="valid");const U=Object(le.a)(s,"x","maxPool");let re=U,pe=!1;U.rank===3&&(pe=!0,re=We(U,[1,U.shape[0],U.shape[1],U.shape[2]])),X.b(pt(_,p),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${_} and dilations '${p}'`);const ze=Ne(re.shape,r,_,p,u),Me=[ze.dilationHeight,ze.dilationWidth];let ct;ct=u==="same"?function(Pn,Un){const Vn=Pn.map((rr,jn)=>rr+(rr-1)*(Un[jn]-1)).map(rr=>rr-1),fr=Vn.map(rr=>Math.floor(rr/2)),mr=Vn.map((rr,jn)=>rr-fr[jn]);return Vn.map((rr,jn)=>[fr[jn],mr[jn]])}([ze.filterHeight,ze.filterWidth],Me):[[0,0],[0,0]];const Lt=Me[0]===1&&Me[1]===1,[Jt,fn]=function(Pn,Un,Vn){const fr=Vn.map(Kr=>Kr[0]),mr=Vn.map(Kr=>Kr[1]),rr=Pn.concat(fr,mr),jn=Un.map((Kr,da)=>(Kr-rr[da]%Kr)%Kr),Nr=mr.map((Kr,da)=>Kr+jn[da]),Qr=Un.map((Kr,da)=>[fr[da],Nr[da]]),ea=Un.map((Kr,da)=>[0,jn[da]]);return[Qr,ea]}([ze.inHeight,ze.inWidth],Me,ct),On=Lt?u:"valid",tr=Lt?re:Hn(re,Me,Jt),dn=(i==="avg"?()=>_t(tr,r,_,On,$):()=>xe(tr,r,_,On,$))(),pn=Lt?dn:nr(dn,Me,fn);return pe?We(pn,[pn.shape[1],pn.shape[2],pn.shape[3]]):pn}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er=Object(qe.b)({prelu_:function(s,r){const i={x:Object(le.a)(s,"x","prelu"),alpha:Object(le.a)(r,"alpha","prelu")};return L.a.runKernel(oe.lc,i)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yr=Object(qe.b)({prod_:function(s,r=null,i=!1){let u=Object(le.a)(s,"x","prod");u.dtype==="bool"&&(u=Mn(u,"int32"));const p={x:u},_={axis:r,keepDims:i};return L.a.runKernel(oe.mc,p,_)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const la=Object(qe.b)({raggedTensorToTensor_:function(s,r,i,u,p){const _=Object(le.a)(s,"shape","raggedTensorToTensor","int32"),$=Object(le.a)(r,"values","raggedTensorToTensor"),U={shape:_,values:$,defaultValue:Object(le.a)(i,"defaultValue","raggedTensorToTensor",$.dtype),rowPartitionTensors:u.map((pe,ze)=>Object(le.a)(pe,`tensors${ze}`,"raggedTensorToTensor","int32"))},re={rowPartitionTypes:p};return L.a.runKernel(oe.nc,U,re)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Or=Object(qe.b)({rand_:function(s,r,i){const u=Object(X.O)(s);let p=null;if(i==null||i==="float32")p=new Float32Array(u);else if(i==="int32")p=new Int32Array(u);else{if(i!=="bool")throw new Error(`Unknown data type ${i}`);p=new Uint8Array(u)}for(let _=0;_<u;_++)p[_]=r();return L.a.makeTensor(p,s,i)}});var Gr=e(49);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jr{constructor(r,i,u,p,_){this.mean=r,this.stdDev=i,this.dtype=u,this.nextVal=NaN,this.truncated=p,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const $=_||Math.random();this.random=Gr.alea($.toString())}nextValue(){if(!isNaN(this.nextVal)){const p=this.nextVal;return this.nextVal=NaN,p}let r,i,u=!1;for(;!u;){let p,_,$;do p=2*this.random()-1,_=2*this.random()-1,$=p*p+_*_;while($>=1||$===0);const U=Math.sqrt(-2*Math.log($)/$);r=this.mean+this.stdDev*p*U,i=this.mean+this.stdDev*_*U,this.truncated&&!this.isValidTruncated(r)||(u=!0)}return this.truncated&&!this.isValidTruncated(i)||(this.nextVal=this.convertValue(i)),this.convertValue(r)}convertValue(r){return this.dtype==null||this.dtype==="float32"?r:Math.round(r)}isValidTruncated(r){return r<=this.upper&&r>=this.lower}}class Na{constructor(r,i,u,p){this.alpha=r,this.beta=1/i,this.dtype=u;const _=p||Math.random();this.randu=Gr.alea(_.toString()),this.randn=new jr(0,1,u,!1,this.randu()),this.d=r<1?r+2/3:r-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let r,i,u,p,_,$;for(;;){do p=this.randn.nextValue(),$=1+this.c*p;while($<=0);if($*=$*$,r=p*p,i=1-.331*r*r,u=.5*r+this.d*(1-$+Math.log($)),_=this.randu(),_<i||Math.log(_)<u)break}return $=1/this.beta*this.d*$,this.alpha<1&&($*=Math.pow(this.randu(),1/this.alpha)),this.convertValue($)}convertValue(r){return this.dtype==="float32"?r:Math.round(r)}}class ga{constructor(r=0,i=1,u,p){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=r,this.range=i-r,this.dtype=u,p==null&&(p=Math.random()),typeof p=="number"&&(p=p.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${r} - ${i} <= 1 and dtype is not float`);this.random=Gr.alea(p)}convertValue(r){return this.canReturnFloat()?r:Math.round(r)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ra=Object(qe.b)({randomGamma_:function(s,r,i=1,u="float32",p){if(i==null&&(i=1),u==null&&(u="float32"),u!=="float32"&&u!=="int32")throw new Error(`Unsupported data type ${u}`);const _=new Na(r,i,u,p),$=Rn(s,u);for(let U=0;U<$.values.length;U++)$.values[U]=_.nextValue();return $.toTensor()}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qa=Object(qe.b)({randomNormal_:function(s,r=0,i=1,u,p){if(u!=null&&u==="bool")throw new Error(`Unsupported data type ${u}`);const _=new jr(r,i,u,!1,p),$=Rn(s,u);for(let U=0;U<$.values.length;U++)$.values[U]=_.nextValue();return $.toTensor()}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ss=Object(qe.b)({randomStandardNormal_:function(s,r,i){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);return Qa(s,0,1,r,i)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cs=Object(qe.b)({randomUniform_:function(s,r=0,i=1,u="float32",p){const _=Rn(s,u),$=new ga(r,i,null,p);for(let U=0;U<_.values.length;U++)_.values[U]=$.nextValue();return _.toTensor()}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Li(s,r,i=1,u="float32"){if(i===0)throw new Error("Cannot have a step of zero");const p={start:s,stop:r,step:i,dtype:u};return L.a.runKernel(oe.oc,{},p)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yi=Object(qe.b)({reciprocal_:function(s){const r={x:Object(le.a)(s,"x","reciprocal")};return L.a.runKernel(oe.rc,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qi=Object(qe.b)({relu_:function(s){const r={x:Object(le.a)(s,"x","relu")};return L.a.runKernel(oe.sc,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ko=Object(qe.b)({relu6_:function(s){const r={x:Object(le.a)(s,"x","relu6")};return L.a.runKernel(oe.tc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ts=Object(qe.b)({reverse_:function(s,r){const i={x:Object(le.a)(s,"x","reverse")},u={dims:r};return L.a.runKernel(oe.zc,i,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=Object(qe.b)({reverse1d_:function(s){const r=Object(le.a)(s,"x","reverse");return X.b(r.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${r.rank}.`),Ts(r,0)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ou=Object(qe.b)({reverse2d_:function(s,r){const i=Object(le.a)(s,"x","reverse");return X.b(i.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${i.rank}.`),Ts(i,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $u=Object(qe.b)({reverse3d_:function(s,r){const i=Object(le.a)(s,"x","reverse");return X.b(i.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${i.rank}.`),Ts(i,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eu=Object(qe.b)({reverse4d_:function(s,r){const i=Object(le.a)(s,"x","reverse");return X.b(i.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${i.rank}.`),Ts(i,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Go=Object(qe.b)({round_:function(s){const r={x:Object(le.a)(s,"x","round")};return L.a.runKernel(oe.Bc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Au=Object(qe.b)({rsqrt_:function(s){const r={x:Object(le.a)(s,"x","rsqrt","float32")};return L.a.runKernel(oe.Cc,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu=Object(qe.b)({selu_:function(s){const r={x:Object(le.a)(s,"x","selu")};return L.a.runKernel(oe.Gc,r)}}),Ru=Object(qe.b)({separableConv2d_:function(s,r,i,u,p,_=[1,1],$="NHWC"){const U=Object(le.a)(s,"x","separableConv2d"),re=Object(le.a)(r,"depthwiseFilter","separableConv2d"),pe=Object(le.a)(i,"pointwiseFilter","separableConv2d");let ze=U,Me=!1;if(U.rank===3&&(Me=!0,ze=We(U,[1,U.shape[0],U.shape[1],U.shape[2]])),$==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");X.b(ze.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${ze.rank}.`),X.b(re.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${re.rank}.`),X.b(pe.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${re.rank}.`),X.b(pe.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${pe.shape[0]}.`),X.b(pe.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${pe.shape[1]}.`);const ct=re.shape[2],Lt=re.shape[3];X.b(pe.shape[2]===ct*Lt,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${ct*Lt}, but got ${pe.shape[2]}.`);const Jt=Mi(ze,re,u,p,$,_),fn=Ya(Jt,pe,1,"valid",$);return Me?We(fn,[fn.shape[1],fn.shape[2],fn.shape[3]]):fn}});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fu=async function(s,r){const i=Object(le.a)(s,"x","setdiff1d"),u=Object(le.a)(r,"y","setdiff1d");X.b(i.dtype===u.dtype,()=>`x and y should have the same dtype, but got x (${i.dtype}) and y (${u.dtype}).`),X.b(i.rank===1,()=>`x should be 1D tensor, but got x (${i.shape}).`),X.b(u.rank===1,()=>`y should be 1D tensor, but got y (${u.shape}).`);const p=await i.data(),_=await u.data(),$=new Set(_);let U=0;for(let ze=0;ze<p.length;ze++)$.has(p[ze])||U++;const re=new un.b([U],i.dtype),pe=new un.b([U],"int32");for(let ze=0,Me=0;ze<p.length;ze++)$.has(p[ze])||(re.values[Me]=p[ze],pe.values[Me]=ze,Me++);return[re.toTensor(),pe.toTensor()]};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mu=Object(qe.b)({sign_:function(s){const r={x:Object(le.a)(s,"x","sign")};return L.a.runKernel(oe.Ic,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Du=Object(qe.b)({sin_:function(s){const r={x:Object(le.a)(s,"x","sin","float32")};return L.a.runKernel(oe.Jc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pu=Object(qe.b)({sinh_:function(s){const r={x:Object(le.a)(s,"x","sinh")};return L.a.runKernel(oe.Kc,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bu=Object(qe.b)({slice1d_:function(s,r,i){const u=Object(le.a)(s,"x","slice1d");return X.b(u.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${u.rank} tensor`),Pt(u,[r],[i])}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lu=Object(qe.b)({slice2d_:function(s,r,i){const u=Object(le.a)(s,"x","slice2d");return X.b(u.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${u.rank} tensor`),Pt(u,r,i)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ju=Object(qe.b)({slice3d_:function(s,r,i){const u=Object(le.a)(s,"x","slice3d");return X.b(u.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${u.rank} tensor`),Pt(u,r,i)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zu=Object(qe.b)({slice4d_:function(s,r,i){const u=Object(le.a)(s,"x","slice4d");return X.b(u.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${u.rank} tensor`),Pt(u,r,i)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uu=Object(qe.b)({softmax_:function(s,r=-1){const i=Object(le.a)(s,"logits","softmax","float32");if(r===-1&&(r=i.rank-1),r!==i.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and dim was ${r}`);const u={logits:i},p={dim:r};return L.a.runKernel(oe.Mc,u,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo=Object(qe.b)({fft_:function(s){Object(X.b)(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const r={input:s};return L.a.runKernel(oe.fb,r)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lo=Object(qe.b)({ifft_:function(s){Object(X.b)(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const r={input:s};return L.a.runKernel(oe.sb,r)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ho=Object(qe.b)({irfft_:function(s){const r=s.shape[s.shape.length-1],i=s.size/r;let u;if(r<=2){const p=We(s,[i,r]);u=lo(p)}else{const p=[i,2*(r-1)],_=We(ka(s),[i,r]),$=We(Ga(s),[i,r]),U=Ts(Pt(_,[0,1],[i,r-2]),1),re=Sn(Ts(Pt($,[0,1],[i,r-2]),1),Tr(-1)),pe=Xt([_,U],1),ze=Xt([$,re],1),Me=We(Object(wa.a)(pe,ze),[p[0],p[1]]);u=lo(Me)}if(u=ka(u),s.rank===3&&s.shape[0]!==0){const p=u,_=s.shape[0];u=We(u,[_,u.shape[0]/_,u.shape[1]]),p.dispose()}return u}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ho=Object(qe.b)({split_:function(s,r,i=0){const u={x:Object(le.a)(s,"x","split")},p={numOrSizeSplits:r,axis:i};return L.a.runKernel(oe.Uc,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ao=Object(qe.b)({rfft_:function(s,r){Object(X.b)(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let i=s.shape[s.shape.length-1];const u=s.size/i;let p;if(r!=null&&r<i){const Jt=s.shape.map(On=>0),fn=s.shape.map(On=>On);fn[s.shape.length-1]=r,p=Pt(s,Jt,fn),i=r}else if(r!=null&&r>i){const Jt=s.shape.map(fn=>fn);Jt[s.shape.length-1]=r-i,p=Xt([s,Ge(Jt)],s.shape.length-1),i=r}else p=s;const _=pa(p),$=We(Object(wa.a)(p,_),[u,i]),U=Eo($),re=Math.floor(i/2)+1,pe=ka(U),ze=Ga(U),Me=ho(pe,[re,i-re],pe.shape.length-1),ct=ho(ze,[re,i-re],ze.shape.length-1),Lt=p.shape.slice();return Lt[p.shape.length-1]=re,We(Object(wa.a)(Me[0],ct[0]),Lt)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo=Object(qe.b)({squaredDifference_:function(s,r){let i=Object(le.a)(s,"a","squaredDifference"),u=Object(le.a)(r,"b","squaredDifference");[i,u]=Object(xn.makeTypesMatch)(i,u),wr(i.shape,u.shape);const p={a:i,b:u};return L.a.runKernel(oe.Xc,p,{})}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No=Object(qe.b)({squeeze_:function(s,r){const i=Object(le.a)(s,"x","squeeze","string_or_numeric");return We(i,Object(X.Q)(i.shape,r).newShape)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const po=Object(qe.b)({stack_:function(s,r=0){const i=Object(le.b)(s,"tensors","stack","string_or_numeric");X.b(i.length>=1,()=>"Pass at least one tensor to tf.stack"),i.length>0&&X.b(r<=i[0].rank,()=>"Axis must be <= rank of the tensor");const u=i,p={axis:r};return L.a.runKernel(oe.hc,u,p)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ko=Object(qe.b)({step_:function(s,r=0){const i={x:Object(le.a)(s,"x","step")},u={alpha:r};return L.a.runKernel(oe.Yc,i,u)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wu=Object(qe.b)({stridedSlice_:function(s,r,i,u,p=0,_=0,$=0,U=0,re=0){const pe={x:Object(le.a)(s,"x","stridedSlice","string_or_numeric")},ze={begin:r,end:i,strides:u,beginMask:p,endMask:_,ellipsisMask:$,newAxisMask:U,shrinkAxisMask:re};return L.a.runKernel(oe.Zc,pe,ze)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vu=Object(qe.b)({tan_:function(s){const r={x:Object(le.a)(s,"x","tan","float32")};return L.a.runKernel(oe.fd,r)}});var Ro=e(32);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(s,r){Object(X.d)(s);const i=Object(le.c)(s,r);if(i.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(Ia.a)(s,null,i,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fo(s,r,i){if(Object(X.d)(s),r!=null&&r.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const u=Object(le.c)(s,i);if(u.length!==2&&u.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(u.length===1&&r==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(Ia.a)(s,r,u,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gu(s,r,i){if(Object(X.d)(s),r!=null&&r.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const u=Object(le.c)(s,i);if(u.length!==4&&u.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(u.length===1&&r==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Object(Ia.a)(s,r,u,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hu(s,r,i){if(Object(X.d)(s),r!=null&&r.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const u=Object(le.c)(s,i);if(u.length!==5&&u.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(u.length===1&&r==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Object(Ia.a)(s,r,u,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qu(s,r,i){if(Object(X.d)(s),r!=null&&r.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const u=Object(le.c)(s,i);if(u.length!==6&&u.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(u.length===1&&r==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return r=r||u,Object(Ia.a)(s,r,u,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ku=Object(qe.b)({topk_:function(s,r=1,i=!0){const u=Object(le.a)(s,"x","topk");if(u.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const p=u.shape[u.shape.length-1];if(r<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${r}`);if(r>p)throw new Error(`'k' passed to topk() must be <= the last dimension (${p}) but got ${r}`);const _={x:u},$={k:r,sorted:i},[U,re]=L.a.runKernel(oe.id,_,$);return{values:U,indices:re}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xu=Object(qe.b)({truncatedNormal_:function(s,r=0,i=1,u,p){if(u!=null&&u==="bool")throw new Error("Unsupported data type $ { dtype }");const _=new jr(r,i,u,!0,p),$=Rn(s,u);for(let U=0;U<$.values.length;U++)$.values[U]=_.nextValue();return $.toTensor()}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yu=Object(qe.b)({unique_:function(s,r=0){const i=Object(le.a)(s,"x","unique","string_or_numeric");Object(X.b)(i.rank>0,()=>"The input tensor must be at least 1D");const u={x:i},p={axis:r},[_,$]=L.a.runKernel(oe.ld,u,p);return{values:_,indices:$}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qu=Object(qe.b)({unsortedSegmentSum_:function(s,r,i){const u=Object(le.a)(s,"x","unsortedSegmentSum"),p=Object(le.a)(r,"segmentIds","unsortedSegmentSum","int32");Object(X.b)(Object(X.v)(i),()=>"numSegments must be of dtype int");const _={x:u,segmentIds:p},$={numSegments:i};return L.a.runKernel(oe.nd,_,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fo=Object(qe.b)({unstack_:function(s,r=0){const i=Object(le.a)(s,"x","unstack","string_or_numeric");X.b(r>=-i.shape.length&&r<i.shape.length,()=>`Axis = ${r} is not in [-${i.shape.length}, ${i.shape.length})`);const u={value:i},p={axis:r};return L.a.runKernel(oe.md,u,p)}});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xo(s,r){return se(s,r,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zu(s,r=!0,i,u){return L.a.makeVariable(s,r,i,u)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(s,r){const i=[];for(let _=0;_<r.length;_++)r[_]&&i.push(_);const u=Rn(s,"int32"),p=Rn([i.length,s.length],"int32");for(let _=0;_<i.length;_++){const $=u.indexToLoc(i[_]),U=_*s.length;p.values.set($,U)}return p.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Do=async function(s){const r=Object(le.a)(s,"condition","whereAsync","bool"),i=await r.data(),u=Mo(r.shape,i);return s!==r&&r.dispose(),u};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ju=async function(s,r,i){const u=Object(le.a)(s,"tensor","boolMask"),p=Object(le.a)(r,"mask","boolMask","bool"),_=i==null?0:i,$=p.rank,U=u.shape;X.b($>0,()=>"mask cannot be scalar"),X.e(U.slice(_,_+$),p.shape,"mask's shape must match the first K dimensions of tensor's shape,");let re=1;for(let fn=_;fn<_+$;fn++)re*=U[fn];const pe=U.slice(0,_).concat([re],U.slice(_+$)),ze=We(u,pe),Me=We(p,[-1]),ct=await Do(Me),Lt=No(ct,[1]),Jt=ne(ze,Lt,_);return s!==u&&u.dispose(),r!==p&&p.dispose(),Lt.dispose(),ze.dispose(),Me.dispose(),ct.dispose(),Jt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yo=Object(qe.b)({movingAverage_:function(s,r,i,u,p=!0){const _=Object(le.a)(s,"v","movingAverage"),$=Object(le.a)(r,"x","movingAverage"),U=Object(le.a)(i,"decay","movingAverage");Object(xn.assertTypesMatch)(_,$),X.b(X.a(_.shape,$.shape),()=>"Shape mismatch in v and x");const re=Tr(1),pe=ur(re,U);let ze=Sn(ur($,_),pe);if(p){X.b(u!=null,()=>"When using zeroDebias: true, step is required.");const Me=Object(le.a)(u,"step","movingAverage");ze=Fr(ze,ur(re,ks(U,Me)))}return Yn(_,ze)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ec=Object(qe.b)({scatterND_:function(s,r,i){const u=Object(le.a)(s,"indices","scatterND","int32"),p=Object(le.a)(r,"updates","scatterND");_n(p,u,i);const _={indices:u,updates:p},$={shape:i};return L.a.runKernel(oe.Dc,_,$)}}),tc=Object(qe.b)({sparseToDense_:function(s,r,i,u=0){const p=Object(le.a)(s,"sparseIndices","sparseToDense","int32"),_=Object(le.a)(r,"sparseValues","sparseToDense","string_or_numeric"),$=Object(le.a)(u,"defaultValue","sparseToDense",_.dtype);(function(pe,ze,Me,ct){if(pe.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${pe.dtype}.`);if(pe.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${pe.shape}.`);const Lt=pe.rank>0?pe.shape[0]:1,Jt=pe.rank>1?pe.shape[1]:1;if(Me.length!==Jt)throw new Error(`outputShape has incorrect number of elements:, ${Me.length}, should be: ${Jt}.`);const fn=ze.size;if(ze.rank!==0&&(ze.rank!==1||fn!==Lt))throw new Error(`sparseValues has incorrect shape ${ze.shape}, should be [] or [${Lt}]`);if(ze.dtype!==ct.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")})(p,_,i,$);const U={sparseIndices:p,sparseValues:_,defaultValue:$},re={outputShape:i};return L.a.runKernel(oe.Tc,U,re)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nc=Object(qe.b)({gatherND_:function(s,r){const i=Object(le.a)(r,"indices","gatherND","int32"),u={params:Object(le.a)(s,"x","gatherND","string_or_numeric"),indices:i};return L.a.runKernel(oe.ob,u)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rc=Object(qe.b)({dropout_:function(s,r,i,u){const p=Object(le.a)(s,"x","dropout");if(X.b(p.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${p.dtype} tensor instead.`),X.b(r>=0&&r<1,()=>`rate must be a float in the range [0, 1), but got ${r}.`),r===0)return s instanceof un.a?p.clone():p;const _=function(re,pe){if(pe==null)return re.shape.slice();if(X.a(re.shape,pe))return pe;if(re.shape.length===pe.length){const ze=[];for(let Me=0;Me<re.shape.length;Me++)pe[Me]==null&&re.shape[Me]!=null?ze.push(re.shape[Me]):ze.push(pe[Me]);return ze}return pe}(p,i),$=1-r,U=Fr(F(Yn(Cs(_,0,1,"float32",u),$)),$);return Sn(p,U)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qo(s){return Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2))))}function Po(s,r,i){const u=1-s%2,p=new Float32Array(s);for(let _=0;_<s;++_){const $=2*Math.PI*_/(s+u-1);p[_]=r-i*Math.cos($)}return Hs(p,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ac=async function(s,r,i=1){const u=Object(le.a)(s,"predictions","inTopK"),p=Object(le.a)(r,"targets","inTopK");Object(X.b)(u.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${u.rank}`),Object(X.b)(u.rank-1===p.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${u.rank} and targets rank ${p.rank}`),Object(X.e)(u.shape.slice(0,u.shape.length-1),p.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const _=u.shape[u.shape.length-1];Object(X.b)(i>0&&i<=_,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${_}), but got ${i}`);const $=await u.data(),U=await p.data(),[re,pe]=[$.length/_,_],ze=Object(X.o)("bool",re);for(let Me=0;Me<re;Me++){const ct=Me*pe,Lt=$.subarray(ct,ct+pe),Jt=[];for(let fn=0;fn<Lt.length;fn++)Jt.push({value:Lt[fn],index:fn});Jt.sort((fn,On)=>On.value-fn.value),ze[Me]=0;for(let fn=0;fn<i;fn++)if(Jt[fn].index===U[Me]){ze[Me]=1;break}}return s!==u&&u.dispose(),r!==p&&p.dispose(),Object(Ro.a)(ze,p.shape,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sc=Object(qe.b)({conv2DBackpropFilter_:function(s,r,i,u,p,_="NHWC",$){let U=s;s.rank===3&&(U=We(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let re=r;re.rank===3&&(re=We(r,[1,r.shape[0],r.shape[1],r.shape[2]])),X.b(U.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${U.shape}.`),X.b(re.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${re.shape}.`),X.b(i.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${i}.`);const pe=_==="NHWC"?U.shape[3]:U.shape[1],ze=_==="NHWC"?re.shape[3]:re.shape[1];X.b(pe===i[2],()=>`Error in conv2dDerFilter: depth of input ${pe}) must match input depth in filter (${i[2]}.`),X.b(ze===i[3],()=>`Error in conv2dDerFilter: depth of dy (${ze}) must match output depth for filter (${i[3]}).`),Dt("conv2dDerFilter",p,$);const Me={x:U,dy:re},ct={strides:u,pad:p,dataFormat:_,dimRoundingMode:$,filterShape:i};return L.a.runKernel(oe.E,Me,ct)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _o(s,r,i){if(i==null||i==="linear")return s;if(i==="relu")return Sn(s,Ko(r));throw new Error(`Cannot compute gradient for fused activation ${i}.`)}function Io(s,r){let i=r;const u=La(s.shape,r.shape);return u.length>0&&(i=Br(i,u)),We(i,s.shape)}function So(s,r,i,u){if(r==="linear")return s;if(r==="relu")return Qi(s);if(r==="elu")return Hi(s);if(r==="relu6")return ko(s);if(r==="prelu")return er(s,i);if(r==="leakyrelu")return Ue(s,u);if(r==="sigmoid")return on(s);throw new Error(`Unknown fused activation ${r}.`)}const ji=(s,r)=>!(s>0)||r==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ic=Object(qe.b)({fusedConv2d_:function({x:s,filter:r,strides:i,pad:u,dataFormat:p="NHWC",dilations:_=[1,1],dimRoundingMode:$,bias:U,activation:re="linear",preluActivationWeights:pe,leakyreluAlpha:ze}){if(re=re||"linear",ji(L.a.state.gradientDepth,re)===!1){X.b(p==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${p} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Vn=Ya(s,r,i,u,p,_,$);return U!=null&&(Vn=Yn(Vn,U)),So(Vn,re,pe,ze)}const Me=Object(le.a)(s,"x","conv2d","float32"),ct=Object(le.a)(r,"filter","conv2d","float32");let Lt=Me,Jt=!1;Me.rank===3&&(Jt=!0,Lt=We(Me,[1,Me.shape[0],Me.shape[1],Me.shape[2]])),X.b(Lt.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Lt.rank}.`),X.b(ct.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${ct.rank}.`),Dt("fused conv2d",u,$);const fn=p==="NHWC"?Lt.shape[3]:Lt.shape[1];X.b(ct.shape[2]===fn,()=>`Error in conv2d: depth of input (${fn}) must match input depth for filter ${ct.shape[2]}.`),X.b(pt(i,_),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${_}'`);const On=Be(Lt.shape,ct.shape,i,_,u,$);let tr,dn;if(U!=null&&(tr=Object(le.a)(U,"bias","fused conv2d"),[tr]=Object(xn.makeTypesMatch)(tr,Me),p==="NHWC"?wr(On.outShape,tr.shape):(X.b(tr.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${tr.shape.length}.`),X.b(tr.shape.length===0||tr.shape[0]===On.outChannels||tr.shape[0]===1,()=>`Error in fused conv2d: bias shape (${tr.shape}) is not compatible with the number of output channels (${On.outChannels})`))),pe!=null){const Vn=pe.shape;if(X.b(Vn.length<=1||Vn.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Vn.length}.`),Vn.length===1)X.b(Vn[0]===1||Vn[0]===On.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Vn}) is not compatible with the number of output channels (${On.outChannels}).`);else if(Vn.length===3)try{wr(Vn,On.outShape)}catch{const mr=`Error in fused conv2d: PReLU activation weights (${Vn}) is not compatible with the output shape of the conv2d (${On.outShape}).`;throw Error(mr)}dn=Object(le.a)(pe,"prelu weights","fused conv2d")}const pn=(Vn,fr)=>{X.b(p==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${p} but only NHWC is currently supported.`);const[mr,rr,jn,Nr]=fr,Qr=_o(Vn,jn,re);X.b(ft(_),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${_}'`);const ea=[hs(rr.shape,Qr,mr,i,u),sc(rr,Qr,mr.shape,i,u)];if(Nr!=null){const Kr=Io(Nr,Qr);ea.push(Kr)}return ea},Pn={x:Lt,filter:ct,bias:tr,preluActivationWeights:dn},Un={strides:i,pad:u,dataFormat:p,dilations:_,dimRoundingMode:$,activation:re,leakyreluAlpha:ze};return U==null?Ua((fr,mr,rr)=>{let jn=L.a.runKernel(oe.mb,Pn,Un);return rr([mr,fr,jn]),Jt&&(jn=We(jn,[jn.shape[1],jn.shape[2],jn.shape[3]])),{value:jn,gradFunc:pn}})(Lt,ct):Ua((fr,mr,rr,jn)=>{let Nr=L.a.runKernel(oe.mb,Pn,Un);return jn([mr,fr,Nr,rr]),Jt&&(Nr=We(Nr,[Nr.shape[1],Nr.shape[2],Nr.shape[3]])),{value:Nr,gradFunc:pn}})(Lt,ct,tr)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oc=Object(qe.b)({depthwiseConv2dNativeBackpropFilter_:function(s,r,i,u,p,_=[1,1],$){let U=s;s.rank===3&&(U=We(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let re=r;re.rank===3&&(re=We(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const pe={x:U,dy:re},ze={strides:u,pad:p,dimRoundingMode:$,dilations:_,filterShape:i};return L.a.runKernel(oe.R,pe,ze)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uc=Object(qe.b)({depthwiseConv2dNativeBackpropInput_:function(s,r,i,u,p,_=[1,1],$){let U=r,re=!1;r.rank===3&&(re=!0,U=We(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const pe={dy:U,filter:i},ze={strides:u,pad:p,dimRoundingMode:$,dilations:_,inputShape:s},Me=L.a.runKernel(oe.S,pe,ze);return re?We(Me,[Me.shape[1],Me.shape[2],Me.shape[3]]):Me}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cc=Object(qe.b)({fusedDepthwiseConv2d_:function({x:s,filter:r,strides:i,pad:u,dataFormat:p="NHWC",dilations:_=[1,1],dimRoundingMode:$,bias:U,activation:re="linear",preluActivationWeights:pe,leakyreluAlpha:ze}){if(ji(L.a.state.gradientDepth,re)===!1){let Un=Mi(s,r,i,u,p,_,$);return U!=null&&(Un=Yn(Un,U)),So(Un,re,pe,ze)}const Me=Object(le.a)(s,"x","depthwiseConv2d","float32"),ct=Object(le.a)(r,"filter","depthwiseConv2d","float32");let Lt=Me,Jt=!1;Me.rank===3&&(Jt=!0,Lt=We(Me,[1,Me.shape[0],Me.shape[1],Me.shape[2]])),X.b(Lt.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Lt.rank}.`),X.b(ct.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${ct.rank}.`),X.b(Lt.shape[3]===ct.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Lt.shape[3]}) must match the inChannels dimension in filter ${ct.shape[2]}.`),_==null&&(_=[1,1]),X.b(pt(i,_),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${_}'`),Dt("fused depthwiseConv2d",u,$);const fn=Be(Lt.shape,ct.shape,i,_,u,$,!0);let On,tr;U!=null&&(On=Object(le.a)(U,"bias","fused conv2d"),[On]=Object(xn.makeTypesMatch)(On,Me),wr(fn.outShape,On.shape)),pe!=null&&(tr=Object(le.a)(pe,"prelu weights","fused depthwiseConv2d"));const dn=(Un,Vn)=>{X.b(ft(_),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${_}'`);const[fr,mr,rr,jn]=Vn,Nr=_o(Un,rr,re),Qr=uc(mr.shape,Nr,fr,i,u,_,$),ea=oc(mr,Nr,fr.shape,i,u,_,$);return jn!=null?[Qr,ea,Io(On,Nr)]:[Qr,ea]},pn={x:Lt,filter:ct,bias:On,preluActivationWeights:tr},Pn={strides:i,pad:u,dataFormat:p,dilations:_,dimRoundingMode:$,activation:re,leakyreluAlpha:ze};return U==null?Ua((Vn,fr,mr)=>{let rr=L.a.runKernel(oe.nb,pn,Pn);return mr([fr,Vn,rr]),Jt&&(rr=We(rr,[rr.shape[1],rr.shape[2],rr.shape[3]])),{value:rr,gradFunc:dn}})(Lt,ct):Ua((Vn,fr,mr,rr)=>{let jn=L.a.runKernel(oe.nb,pn,Pn);return rr([fr,Vn,jn,mr]),Jt&&(jn=We(jn,[jn.shape[1],jn.shape[2],jn.shape[3]])),{value:jn,gradFunc:dn}})(Lt,ct,On)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lc=Object(qe.b)({fusedMatMul_:function({a:s,b:r,transposeA:i=!1,transposeB:u=!1,bias:p,activation:_="linear",preluActivationWeights:$,leakyreluAlpha:U=.2}){if(ji(L.a.state.gradientDepth,_)===!1){let jn=rn(s,r,i,u);return p!=null&&(jn=Yn(jn,p)),So(jn,_,$,U)}let re=Object(le.a)(s,"a","fused matMul"),pe=Object(le.a)(r,"b","fused matMul");[re,pe]=Object(xn.makeTypesMatch)(re,pe);const ze=i?re.shape[re.rank-2]:re.shape[re.rank-1],Me=u?pe.shape[pe.rank-1]:pe.shape[pe.rank-2],ct=i?re.shape[re.rank-1]:re.shape[re.rank-2],Lt=u?pe.shape[pe.rank-2]:pe.shape[pe.rank-1],Jt=re.shape.slice(0,-2),fn=pe.shape.slice(0,-2),On=X.O(Jt),tr=X.O(fn);X.b(ze===Me,()=>`Error in fused matMul: inner shapes (${ze}) and (${Me}) of Tensors with shapes ${re.shape} and ${pe.shape} and transposeA=${i} and transposeB=${u} must match.`);const dn=wr(re.shape.slice(0,-2),pe.shape.slice(0,-2)).concat([ct,Lt]),pn=We(re,i?[On,ze,ct]:[On,ct,ze]),Pn=We(pe,u?[tr,Lt,Me]:[tr,Me,Lt]);let Un,Vn;p!=null&&(Un=Object(le.a)(p,"bias","fused matMul"),[Un]=Object(xn.makeTypesMatch)(Un,re),wr(dn,Un.shape)),$!=null&&(Vn=Object(le.a)($,"prelu weights","fused matMul"));const fr=(jn,Nr)=>{const[Qr,ea,Kr,da]=Nr,oa=_o(We(jn,Kr.shape),Kr,_);let fs,ss;return i||u?!i&&u?(fs=rn(oa,ea,!1,!1),ss=rn(oa,Qr,!0,!1)):i&&!u?(fs=rn(ea,oa,!1,!0),ss=rn(Qr,oa,!1,!1)):(fs=rn(ea,oa,!0,!0),ss=rn(oa,Qr,!0,!0)):(fs=rn(oa,ea,!1,!0),ss=rn(Qr,oa,!0,!1)),p!=null?[fs,ss,Io(da,oa)]:[fs,ss]},mr={a:pn,b:Pn,bias:Un,preluActivationWeights:Vn},rr={transposeA:i,transposeB:u,activation:_,leakyreluAlpha:U};return p==null?Ua((Nr,Qr,ea)=>{const Kr=L.a.runKernel(oe.qd,mr,rr);return ea([Nr,Qr,Kr]),{value:We(Kr,dn),gradFunc:fr}})(pn,Pn):Ua((Nr,Qr,ea,Kr)=>{const da=L.a.runKernel(oe.qd,mr,rr);return Kr([Nr,Qr,da,ea]),{value:We(da,dn),gradFunc:fr}})(pn,Pn,Un)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zo=Object(qe.b)({hammingWindow_:function(s){return Po(s,.54,.46)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jo=Object(qe.b)({hannWindow_:function(s){return Po(s,.5,.5)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu=Object(qe.b)({frame_:function(s,r,i,u=!1,p=0){let _=0;const $=[];for(;_+r<=s.size;)$.push(Pt(s,_,r)),_+=i;if(u)for(;_<s.size;){const U=_+r-s.size,re=Xt([Pt(s,_,r-U),Js([U],p)]);$.push(re),_+=i}return $.length===0?fo([],[0,r]):We(Xt($),[$.length,r])}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dc=Object(qe.b)({stft_:function(s,r,i,u,p=Jo){u==null&&(u=Qo(r));const _=eu(s,r,i),$=Sn(_,p(r));return Ao($,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hc=Object(qe.b)({cropAndResize_:function(s,r,i,u,p="bilinear",_=0){const $=Object(le.a)(s,"image","cropAndResize"),U=Object(le.a)(r,"boxes","cropAndResize","float32"),re=Object(le.a)(i,"boxInd","cropAndResize","int32"),pe=U.shape[0];X.b($.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${$.rank}.`),X.b(U.rank===2&&U.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${pe},4] but had shape ${U.shape}.`),X.b(re.rank===1&&re.shape[0]===pe,()=>`Error in cropAndResize: boxInd must be have size [${pe}] but had shape ${U.shape}.`),X.b(u.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${u.length}.`),X.b(u[0]>=1&&u[1]>=1,()=>`cropSize must be atleast [1,1], but was ${u}`),X.b(p==="bilinear"||p==="nearest",()=>`method must be bilinear or nearest, but was ${p}`);const ze={image:$,boxes:U,boxInd:re},Me={method:p,extrapolationValue:_,cropSize:u};return L.a.runKernel(oe.L,ze,Me)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pc=Object(qe.b)({flipLeftRight_:function(s){const r=Object(le.a)(s,"image","flipLeftRight","float32");X.b(r.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${r.rank}.`);const i={image:r};return L.a.runKernel(oe.hb,i,{})}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tu=Object(qe.b)({grayscaleToRGB_:function(s){const r=Object(le.a)(s,"image","grayscaleToRGB"),i=r.rank-1,u=r.shape[i];X.b(r.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${r.rank}.`),X.b(u===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${u}.`);const p=new Array(r.rank);return p.fill(1,0,i),p[i]=3,j(r,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fc=Object(qe.b)({rotateWithOffset_:function(s,r,i=0,u=.5){const p=Object(le.a)(s,"image","rotateWithOffset","float32");X.b(p.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${p.rank}.`);const _={image:p},$={radians:r,fillValue:i,center:u};return L.a.runKernel(oe.Ac,_,$)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(s,r,i,u,p,_){u==null&&(u=.5),p==null&&(p=Number.NEGATIVE_INFINITY),_==null&&(_=0);const $=s.shape[0];return i=Math.min(i,$),X.b(0<=u&&u<=1,()=>`iouThreshold must be in [0, 1], but was '${u}'`),X.b(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),X.b(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),X.b(r.rank===1,()=>"scores must be a 1D tensor"),X.b(r.shape[0]===$,()=>`scores has incompatible shape with boxes. Expected ${$}, but was ${r.shape[0]}`),X.b(0<=_&&_<=1,()=>`softNmsSigma must be in [0, 1], but was '${_}'`),{maxOutputSize:i,iouThreshold:u,scoreThreshold:p,softNmsSigma:_}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mc=Object(qe.b)({nonMaxSuppression_:function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY){const _=Object(le.a)(s,"boxes","nonMaxSuppression","float32"),$=Object(le.a)(r,"scores","nonMaxSuppression","float32"),U=Zi(_,$,i,u,p),re={maxOutputSize:i=U.maxOutputSize,iouThreshold:u=U.iouThreshold,scoreThreshold:p=U.scoreThreshold};return L.a.runKernel(oe.bc,{boxes:_,scores:$},re)}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bc(s,r,i){const u=function(_,$,U){return function(re,pe,ze){let Me=0,ct=re.length,Lt=0,Jt=!1;for(;Me<ct;){Lt=Me+(ct-Me>>>1);const fn=ze(pe,re[Lt]);fn>0?Me=Lt+1:(ct=Lt,Jt=!fn)}return Jt?Me:-Me-1}(_,$,U||gc)}(s,r,i),p=u<0?-(u+1):u;s.splice(p,0,r)}function gc(s,r){return s>r?1:s<r?-1:0}function nu(s,r,i,u,p){return Bo(s,r,i,u,p,0)}function ru(s,r,i,u,p,_){return Bo(s,r,i,u,p,0,!1,_,!0)}function au(s,r,i,u,p,_){return Bo(s,r,i,u,p,_,!0)}function Bo(s,r,i,u,p,_,$=!1,U=!1,re=!1){const pe=[];for(let On=0;On<r.length;On++)r[On]>p&&pe.push({score:r[On],boxIndex:On,suppressBeginIndex:0});pe.sort(su);const ze=_>0?-.5/_:0,Me=[],ct=[];for(;Me.length<i&&pe.length>0;){const On=pe.pop(),{score:tr,boxIndex:dn,suppressBeginIndex:pn}=On;if(tr<p)break;let Pn=!1;for(let Un=Me.length-1;Un>=pn;--Un){const Vn=xc(s,dn,Me[Un]);if(Vn>=u){Pn=!0;break}if(On.score=On.score*vc(u,ze,Vn),On.score<=p)break}On.suppressBeginIndex=Me.length,Pn||(On.score===tr?(Me.push(dn),ct.push(On.score)):On.score>p&&bc(pe,On,su))}const Lt=Me.length,Jt=i-Lt;U&&Jt>0&&(Me.push(...new Array(Jt).fill(0)),ct.push(...new Array(Jt).fill(0)));const fn={selectedIndices:Me};return $&&(fn.selectedScores=ct),re&&(fn.validOutputs=Lt),fn}function xc(s,r,i){const u=s.subarray(4*r,4*r+4),p=s.subarray(4*i,4*i+4),_=Math.min(u[0],u[2]),$=Math.min(u[1],u[3]),U=Math.max(u[0],u[2]),re=Math.max(u[1],u[3]),pe=Math.min(p[0],p[2]),ze=Math.min(p[1],p[3]),Me=Math.max(p[0],p[2]),ct=Math.max(p[1],p[3]),Lt=(U-_)*(re-$),Jt=(Me-pe)*(ct-ze);if(Lt<=0||Jt<=0)return 0;const fn=Math.max(_,pe),On=Math.max($,ze),tr=Math.min(U,Me),dn=Math.min(re,ct),pn=Math.max(tr-fn,0)*Math.max(dn-On,0);return pn/(Lt+Jt-pn)}function vc(s,r,i){const u=Math.exp(r*i*i);return i<=s?u:0}function su(s,r){return s.score-r.score||s.score===r.score&&r.boxIndex-s.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yc=async function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY){const _=Object(le.a)(s,"boxes","nonMaxSuppressionAsync"),$=Object(le.a)(r,"scores","nonMaxSuppressionAsync"),U=Zi(_,$,i,u,p);i=U.maxOutputSize,u=U.iouThreshold,p=U.scoreThreshold;const re=await Promise.all([_.data(),$.data()]),pe=re[0],ze=re[1],{selectedIndices:Me}=nu(pe,ze,i,u,p);return _!==s&&_.dispose(),$!==r&&$.dispose(),Hs(Me,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wc=Object(qe.b)({nonMaxSuppressionWithScore_:function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY,_=0){const $=Object(le.a)(s,"boxes","nonMaxSuppression"),U=Object(le.a)(r,"scores","nonMaxSuppression"),re=Zi($,U,i,u,p,_),pe={boxes:$,scores:U},ze={maxOutputSize:i=re.maxOutputSize,iouThreshold:u=re.iouThreshold,scoreThreshold:p=re.scoreThreshold,softNmsSigma:_=re.softNmsSigma},Me=L.a.runKernel(oe.dc,pe,ze);return{selectedIndices:Me[0],selectedScores:Me[1]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc=async function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY,_=0){const $=Object(le.a)(s,"boxes","nonMaxSuppressionAsync"),U=Object(le.a)(r,"scores","nonMaxSuppressionAsync"),re=Zi($,U,i,u,p,_);i=re.maxOutputSize,u=re.iouThreshold,p=re.scoreThreshold,_=re.softNmsSigma;const pe=await Promise.all([$.data(),U.data()]),ze=pe[0],Me=pe[1],{selectedIndices:ct,selectedScores:Lt}=au(ze,Me,i,u,p,_);return $!==s&&$.dispose(),U!==r&&U.dispose(),{selectedIndices:Hs(ct,"int32"),selectedScores:Hs(Lt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _c=Object(qe.b)({nonMaxSuppressionPadded_:function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY,_=!1){const $=Object(le.a)(s,"boxes","nonMaxSuppression"),U=Object(le.a)(r,"scores","nonMaxSuppression"),re=Zi($,U,i,u,p,null),pe={boxes:$,scores:U},ze={maxOutputSize:re.maxOutputSize,iouThreshold:re.iouThreshold,scoreThreshold:re.scoreThreshold,padToMaxOutputSize:_},Me=L.a.runKernel(oe.cc,pe,ze);return{selectedIndices:Me[0],validOutputs:Me[1]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ic=async function(s,r,i,u=.5,p=Number.NEGATIVE_INFINITY,_=!1){const $=Object(le.a)(s,"boxes","nonMaxSuppressionAsync"),U=Object(le.a)(r,"scores","nonMaxSuppressionAsync"),re=Zi($,U,i,u,p,null),pe=re.maxOutputSize,ze=re.iouThreshold,Me=re.scoreThreshold,[ct,Lt]=await Promise.all([$.data(),U.data()]),{selectedIndices:Jt,validOutputs:fn}=ru(ct,Lt,pe,ze,Me,_);return $!==s&&$.dispose(),U!==r&&U.dispose(),{selectedIndices:Hs(Jt,"int32"),validOutputs:Tr(fn,"int32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sc=Object(qe.b)({resizeBilinear_:function(s,r,i=!1,u=!1){const p=Object(le.a)(s,"images","resizeBilinear");X.b(p.rank===3||p.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${p.rank}.`),X.b(r.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${r}.`),X.b(u===!1||i===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let _=p,$=!1;p.rank===3&&($=!0,_=We(p,[1,p.shape[0],p.shape[1],p.shape[2]]));const U={images:_},re={alignCorners:i,halfPixelCenters:u,size:r},pe=L.a.runKernel(oe.vc,U,re);return $?We(pe,[pe.shape[1],pe.shape[2],pe.shape[3]]):pe}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cc=Object(qe.b)({resizeNearestNeighbor_:function(s,r,i=!1,u=!1){const p=Object(le.a)(s,"images","resizeNearestNeighbor");X.b(p.rank===3||p.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${p.rank}.`),X.b(r.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${r}.`),X.b(p.dtype==="float32"||p.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),X.b(u===!1||i===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let _=p,$=!1;p.rank===3&&($=!0,_=We(p,[1,p.shape[0],p.shape[1],p.shape[2]]));const U={images:_},re={alignCorners:i,halfPixelCenters:u,size:r},pe=L.a.runKernel(oe.xc,U,re);return $?We(pe,[pe.shape[1],pe.shape[2],pe.shape[3]]):pe}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc=Object(qe.b)({threshold_:function(s,r="binary",i=!1,u=.5){const p=Object(le.a)(s,"image","threshold"),_=p.shape[0]*p.shape[1];let $,U,re,pe,ze=Sn(Hs([u]),255);if(X.b(p.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${p.rank}.`),X.b(p.shape[2]===3||p.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${p.shape[2]}.`),X.b(p.dtype==="int32"||p.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${p.dtype}.`),X.b(r==="otsu"||r==="binary",()=>`Method must be binary or otsu, but was ${r}`),p.shape[2]===3){[$,U,re]=ho(p,[1,1,1],-1);const ct=Sn($,.2989),Lt=Sn(U,.587),Jt=Sn(re,.114);pe=Yn(Yn(ct,Lt),Jt)}else pe=s;r==="otsu"&&(ze=function(ct,Lt){let Jt,fn,On,tr,dn,pn,Pn=Hs([-1]),Un=Hs([0]),Vn=Hs([0]);for(let fr=0;fr<ct.size-1;fr++){Jt=Pt(ct,0,fr+1),fn=Pt(ct,fr+1),dn=Fr(Br(Jt),Lt),pn=Fr(Br(fn),Lt);const mr=Br(Sn(Jt,Li(0,Jt.size)));On=Fr(mr,Br(Jt));const rr=Js(fn.shape,Jt.size),jn=Yn(Li(0,fn.size),rr),Nr=Sn(fn,jn);tr=Fr(Br(Nr),Br(fn));const Qr=ur(On,tr),ea=ur(On,tr),Kr=Sn(dn,pn);Vn=Sn(Sn(Kr,Qr),ea);const da=ge(Vn,Un);Un=ai(da,Vn,Un),Pn=ai(da,Hs([fr]),Pn)}return Pn}(Sr(Mn(Go(pe),"int32"),Object(Ro.a)([]),256),_));const Me=i?Ve(pe,ze):ge(pe,ze);return Mn(Sn(Me,255),"int32")}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oc=Object(qe.b)({transform_:function(s,r,i="nearest",u="constant",p=0,_){const $=Object(le.a)(s,"image","transform","float32"),U=Object(le.a)(r,"transforms","transform","float32");X.b($.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${$.rank}.`),X.b(U.rank===2&&(U.shape[0]===$.shape[0]||U.shape[0]===1)&&U.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),X.b(_==null||_.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${_}.`);const re={image:$,transforms:U},pe={interpolation:i,fillMode:u,fillValue:p,outputShape:_};return L.a.runKernel(oe.jd,re,pe)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $c=Object(qe.b)({bandPart_:function(s,r,i){Object(X.b)(r%1==0,()=>`bandPart(): numLower must be an integer, got ${r}.`),Object(X.b)(i%1==0,()=>`bandPart(): numUpper must be an integer, got ${i}.`);const u=Object(le.a)(s,"a","bandPart");Object(X.b)(u.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${u.rank}.`);const p=u.shape,[_,$]=u.shape.slice(-2);if(!(r<=_))throw new Error(`bandPart(): numLower (${r}) must not be greater than the number of rows (${_}).`);if(!(i<=$))throw new Error(`bandPart(): numUpper (${i}) must not be greater than the number of columns (${$}).`);r<0&&(r=_),i<0&&(i=$);const U=We(Li(0,_,1,"int32"),[-1,1]),re=Li(0,$,1,"int32"),pe=ur(U,re),ze=x(Ve(pe,Tr(+r,"int32")),Ee(pe,Tr(-i,"int32"))),Me=Ge([_,$],u.dtype);return We(po(Fo(We(u,[-1,_,$])).map(ct=>ai(ze,ct,Me))),p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ec=Object(qe.b)({gramSchmidt_:function(s){let r;if(Array.isArray(s)){r=!1,Object(X.b)(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const p=s[0].shape[0];for(let _=1;_<s.length;++_)Object(X.b)(s[_].shape[0]===p,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[_].shape[0]} vs. ${p})`)}else r=!0,s=ho(s,s.shape[0],0).map(p=>No(p,[0]));Object(X.b)(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const i=[],u=s;for(let p=0;p<s.length;++p)i.push(L.a.tidy(()=>{let _=u[p];if(p>0)for(let $=0;$<p;++$){const U=Sn(Br(Sn(i[$],_)),i[$]);_=ur(_,U)}return Fr(_,bi(_,"euclidean"))}));return r?po(i,0):i}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iu(s,r=!1){return L.a.tidy(()=>{Object(X.b)(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const i=s.shape[0],u=s.shape[1];let p=ie(i),_=zr(s);const $=fo([[1]],[1,1]);let U=zr($);const re=i>=u?u:i;for(let pe=0;pe<re;++pe){const ze=_,Me=U,ct=p;[U,_,p]=L.a.tidy(()=>{const Lt=Pt(_,[pe,pe],[i-pe,1]),Jt=bi(Lt),fn=Pt(_,[pe,pe],[1,1]),On=ai(ge(fn,0),fo([[-1]]),fo([[1]])),tr=ur(fn,Sn(On,Jt)),dn=Fr(Lt,tr);U=dn.shape[0]===1?zr($):Xt([$,Pt(dn,[1,0],[dn.shape[0]-1,dn.shape[1]])],0);const pn=Xr(Fr(rn(On,tr),Jt)),Pn=Pt(_,[pe,0],[i-pe,u]),Un=Sn(pn,U),Vn=_a(U);if(pe===0)_=ur(Pn,rn(Un,rn(Vn,Pn)));else{const rr=ur(Pn,rn(Un,rn(Vn,Pn)));_=Xt([Pt(_,[0,0],[pe,u]),rr],0)}const fr=_a(Un),mr=Pt(p,[0,pe],[i,p.shape[1]-pe]);if(pe===0)p=ur(mr,rn(rn(mr,U),fr));else{const rr=ur(mr,rn(rn(mr,U),fr));p=Xt([Pt(p,[0,0],[i,pe]),rr],1)}return[U,_,p]}),Pr([ze,Me,ct])}return!r&&i>u&&(p=Pt(p,[0,0],[i,u]),_=Pt(_,[0,0],[u,u])),[p,_]})}const Ac=Object(qe.b)({qr_:function(s,r=!1){if(Object(X.b)(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return iu(s,r);{const i=s.shape.slice(0,s.shape.length-2).reduce(($,U)=>$*U),u=Fo(We(s,[i,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),p=[],_=[];return u.forEach($=>{const[U,re]=iu($,r);p.push(U),_.push(re)}),[We(po(p,0),s.shape),We(po(_,0),s.shape)]}}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Wa;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Wa||(Wa={}));const ii=Object(qe.b)({computeWeightedLoss_:function(s,r,i=Wa.SUM_BY_NONZERO_WEIGHTS){const u=Object(le.a)(s,"losses","computeWeightedLoss");let p=null;r!=null&&(p=Object(le.a)(r,"weights","computeWeightedLoss"));const _=p==null?u:Sn(u,p);if(i===Wa.NONE)return _;if(i===Wa.SUM)return Br(_);if(i===Wa.MEAN){if(p==null)return Ze(_);{const $=u.size/p.size,U=Fr(Br(_),Br(p));return $>1?Fr(U,Tr($)):U}}if(i===Wa.SUM_BY_NONZERO_WEIGHTS){if(p==null)return Fr(Br(_),Tr(u.size));{const $=Sn(p,nt(u.shape)),U=Mn(Br(Ht($,Tr(0))),"float32");return Fr(Br(_),U)}}throw Error(`Unknown reduction: ${i}`)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nc=Object(qe.b)({absoluteDifference_:function(s,r,i,u=Wa.SUM_BY_NONZERO_WEIGHTS){const p=Object(le.a)(s,"labels","absoluteDifference"),_=Object(le.a)(r,"predictions","absoluteDifference");let $=null;i!=null&&($=Object(le.a)(i,"weights","absoluteDifference")),Object(X.e)(p.shape,_.shape,"Error in absoluteDifference: ");const U=va(ur(p,_));return ii(U,$,u)}}),Rc=Object(qe.b)({cosineDistance_:function(s,r,i,u,p=Wa.SUM_BY_NONZERO_WEIGHTS){const _=Object(le.a)(s,"labels","cosineDistance"),$=Object(le.a)(r,"predictions","cosineDistance");let U=null;u!=null&&(U=Object(le.a)(u,"weights","cosineDistance")),Object(X.e)(_.shape,$.shape,"Error in cosineDistance: ");const re=Tr(1),pe=ur(re,Br(Sn(_,$),i,!0));return ii(pe,U,p)}}),Fc=Object(qe.b)({hingeLoss_:function(s,r,i,u=Wa.SUM_BY_NONZERO_WEIGHTS){let p=Object(le.a)(s,"labels","hingeLoss");const _=Object(le.a)(r,"predictions","hingeLoss");let $=null;i!=null&&($=Object(le.a)(i,"weights","hingeLoss")),Object(X.e)(p.shape,_.shape,"Error in hingeLoss: ");const U=Tr(1);p=ur(Sn(Tr(2),p),U);const re=Qi(ur(U,Sn(p,_)));return ii(re,$,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mc=Object(qe.b)({huberLoss_:function(s,r,i,u=1,p=Wa.SUM_BY_NONZERO_WEIGHTS){const _=Object(le.a)(s,"labels","huberLoss"),$=Object(le.a)(r,"predictions","huberLoss");let U=null;i!=null&&(U=Object(le.a)(i,"weights","huberLoss")),Object(X.e)(_.shape,$.shape,"Error in huberLoss: ");const re=Tr(u),pe=va(ur($,_)),ze=yt(pe,re),Me=ur(pe,ze),ct=Yn(Sn(Tr(.5),na(ze)),Sn(re,Me));return ii(ct,U,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dc=Object(qe.b)({logLoss_:function(s,r,i,u=1e-7,p=Wa.SUM_BY_NONZERO_WEIGHTS){const _=Object(le.a)(s,"labels","logLoss"),$=Object(le.a)(r,"predictions","logLoss");let U=null;i!=null&&(U=Object(le.a)(i,"weights","logLoss")),Object(X.e)(_.shape,$.shape,"Error in logLoss: ");const re=Tr(1),pe=Tr(u),ze=Xr(Sn(_,at(Yn($,pe)))),Me=Sn(ur(re,_),at(Yn(ur(re,$),pe))),ct=ur(ze,Me);return ii(ct,U,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pc=Object(qe.b)({meanSquaredError_:function(s,r,i,u=Wa.SUM_BY_NONZERO_WEIGHTS){const p=Object(le.a)(s,"labels","meanSquaredError"),_=Object(le.a)(r,"predictions","meanSquaredError");let $=null;i!=null&&($=Object(le.a)(i,"weights","meanSquaredError")),Object(X.e)(p.shape,_.shape,"Error in meanSquaredError: ");const U=qo(p,_);return ii(U,$,u)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bc=Object(qe.b)({sigmoidCrossEntropy_:function(s,r,i,u=0,p=Wa.SUM_BY_NONZERO_WEIGHTS){let _=Object(le.a)(s,"multiClassLabels","sigmoidCrossEntropy");const $=Object(le.a)(r,"logits","sigmoidCrossEntropy");let U=null;if(i!=null&&(U=Object(le.a)(i,"weights","sigmoidCrossEntropy")),Object(X.e)(_.shape,$.shape,"Error in sigmoidCrossEntropy: "),u>0){const pe=Tr(u),ze=Tr(1),Me=Tr(.5);_=Yn(Sn(_,ur(ze,pe)),Sn(Me,pe))}const re=function(pe,ze){const Me=Object(le.a)(pe,"labels","sigmoidCrossEntropyWithLogits"),ct=Object(le.a)(ze,"logits","sigmoidCrossEntropyWithLogits");Object(X.e)(Me.shape,ct.shape,"Error in sigmoidCrossEntropyWithLogits: ");const Lt=Qi(ct),Jt=Sn(ct,Me),fn=ot(ps(Xr(va(ct))));return Yn(ur(Lt,Jt),fn)}(_,$);return ii(re,U,p)}});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lc=Object(qe.b)({softmaxCrossEntropy_:function(s,r,i,u=0,p=Wa.SUM_BY_NONZERO_WEIGHTS){let _=Object(le.a)(s,"onehotLabels","softmaxCrossEntropy");const $=Object(le.a)(r,"logits","softmaxCrossEntropy");let U=null;if(i!=null&&(U=Object(le.a)(i,"weights","softmaxCrossEntropy")),Object(X.e)(_.shape,$.shape,"Error in softmaxCrossEntropy: "),u>0){const pe=Tr(u),ze=Tr(1),Me=Tr(_.shape[1]);_=Yn(Sn(_,ur(ze,pe)),Fr(pe,Me))}const re=function(pe,ze,Me=-1){if(Me===-1&&(Me=ze.rank-1),Me!==ze.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${ze.rank} and dim was ${Me}`);return Ua((Lt,Jt,fn)=>{const On=v(Jt,[Me],!0),tr=ur(Mn(Jt,"float32"),On);fn([Lt,tr]);const dn=Xr(Sn(tr,Lt));return{value:Br(dn,[Me]),gradFunc:(pn,Pn)=>{const[Un,Vn]=Pn,fr=fi(pn.shape,[Me]);return[Sn(We(pn,fr),ur(Mn(Un,"float32"),ps(Vn))),Sn(We(pn,fr),ur(ps(Vn),Mn(Un,"float32")))]}}})(pe,ze)}(_,$);return ii(re,U,p)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jc=Object(qe.b)({sparseFillEmptyRows_:function(s,r,i,u){const p=Object(le.a)(s,"indices","sparseFillEmptyRows","int32"),_=Object(le.a)(r,"values","sparseFillEmptyRows"),$=Object(le.a)(i,"denseShape","sparseFillEmptyRows","int32"),U=Object(le.a)(u,"defaultValue","sparseFillEmptyRows",_.dtype);if(p.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${p.shape}`);if(_.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${_.shape}`);if($.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${$.shape}`);if(U.rank!==0)throw new Error(`Default value should be a scalar but received shape ${U.shape}`);const re={indices:p,values:_,denseShape:$,defaultValue:U},pe=L.a.runKernel(oe.Pc,re);return{outputIndices:pe[0],outputValues:pe[1],emptyRowIndicator:pe[2],reverseIndexMap:pe[3]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zc=Object(qe.b)({sparseReshape_:function(s,r,i){const u=Object(le.a)(s,"inputIndices","sparseReshape","int32"),p=Object(le.a)(r,"inputShape","sparseReshape","int32"),_=Object(le.a)(i,"newShape","sparseReshape","int32");if(u.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${u.shape}`);if(p.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${p.shape}`);if(_.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${_.shape}`);const $={inputIndices:u,inputShape:p,newShape:_},U=L.a.runKernel(oe.Qc,$);return{outputIndices:U[0],outputShape:U[1]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uc=Object(qe.b)({sparseSegmentMean_:function(s,r,i){const u=Object(le.a)(s,"data","sparseSegmentMean"),p=Object(le.a)(r,"indices","sparseSegmentMean","int32"),_=Object(le.a)(i,"segmentIds","sparseSegmentMean","int32");if(u.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(p.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${p.shape}`);if(_.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${_.shape}`);const $={data:u,indices:p,segmentIds:_};return L.a.runKernel(oe.Rc,$)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wc=Object(qe.b)({sparseSegmentSum_:function(s,r,i){const u=Object(le.a)(s,"data","sparseSegmentSum"),p=Object(le.a)(r,"indices","sparseSegmentSum","int32"),_=Object(le.a)(i,"segmentIds","sparseSegmentSum","int32");if(u.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(p.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${p.shape}`);if(_.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${_.shape}`);const $={data:u,indices:p,segmentIds:_};return L.a.runKernel(oe.Sc,$)}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vc=Object(qe.b)({stringNGrams_:function(s,r,i,u,p,_,$,U){const re=Object(le.a)(s,"data","stringNGrams","string");if(re.dtype!=="string")throw new Error("Data must be of datatype string");if(re.shape.length!==1)throw new Error(`Data must be a vector, saw: ${re.shape}`);const pe=Object(le.a)(r,"dataSplits","stringNGrams");if(pe.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const ze={separator:i,nGramWidths:u,leftPad:p,rightPad:_,padWidth:$,preserveShortSequences:U},Me={data:re,dataSplits:pe},ct=L.a.runKernel(oe.ad,Me,ze);return{nGrams:ct[0],nGramsSplits:ct[1]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gc=Object(qe.b)({stringSplit_:function(s,r,i=!0){const u=Object(le.a)(s,"input","stringSplit","string"),p=Object(le.a)(r,"delimiter","stringSplit","string");if(u.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${u.shape}`);if(p.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${p.shape}`);const _={skipEmpty:i},$={input:u,delimiter:p},U=L.a.runKernel(oe.bd,$,_);return{indices:U[0],values:U[1],shape:U[2]}}});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hc=Object(qe.b)({stringToHashBucketFast_:function(s,r){const i=Object(le.a)(s,"input","stringToHashBucketFast","string"),u={numBuckets:r};if(r<=0)throw new Error("Number of buckets must be at least 1");const p={input:i};return L.a.runKernel(oe.cd,p,u)}}),qc={fft:Eo,ifft:lo,rfft:Ao,irfft:Ho},Kc={hammingWindow:Zo,hannWindow:Jo,frame:eu,stft:dc},Xc={flipLeftRight:pc,grayscaleToRGB:tu,resizeNearestNeighbor:Cc,resizeBilinear:Sc,rotateWithOffset:fc,cropAndResize:hc,nonMaxSuppression:mc,nonMaxSuppressionAsync:yc,nonMaxSuppressionWithScore:wc,nonMaxSuppressionWithScoreAsync:kc,nonMaxSuppressionPadded:_c,nonMaxSuppressionPaddedAsync:Ic,threshold:Tc,transform:Oc},Yc={bandPart:$c,gramSchmidt:Ec,qr:Ac},Qc={absoluteDifference:Nc,computeWeightedLoss:ii,cosineDistance:Rc,hingeLoss:Fc,huberLoss:Mc,logLoss:Dc,meanSquaredError:Pc,sigmoidCrossEntropy:Bc,softmaxCrossEntropy:Lc},Zc={sparseFillEmptyRows:jc,sparseReshape:zc,sparseSegmentMean:Uc,sparseSegmentSum:Wc},Jc={stringNGrams:Vc,stringSplit:Gc,stringToHashBucketFast:Hc},el={sgd:ns.sgd,momentum:ns.momentum,adadelta:ns.adadelta,adagrad:ns.adagrad,rmsprop:ns.rmsprop,adamax:ns.adamax,adam:ns.adam};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oi,ou=e(95);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(s,r){const i=s[0].length;s.forEach((p,_)=>{X.b(p.length===i,()=>`Error in concat${i}D: rank of tensors[${_}] must be the same as the rank of the rest (${i})`)}),X.b(r>=0&&r<i,()=>`Error in concat${i}D: axis must be between 0 and ${i-1}.`);const u=s[0];s.forEach((p,_)=>{for(let $=0;$<i;$++)X.b($===r||p[$]===u[$],()=>`Error in concat${i}D: Shape of tensors[${_}] (${p}) does not match the shape of the rest (${u}) along the non-concatenated axis ${_}.`)})}function nl(s,r){const i=s[0].slice();for(let u=1;u<s.length;u++)i[r]+=s[u][r];return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(s,r,i){let u=new Array;if(i==null&&r==null)return u;if(r==null)for(;u.length<s+i.length;)u.push(-1);else u=r.slice();if(i==null)return u;if(s+i.length!==u.length)throw new Error(`rt input.shape and shape=${r} are incompatible: rt input.rank = ${s+i.length}, but shape.rank = ${u.length}`);for(let p=1;p<i.length;++p){const _=i[p],$=u[u.length-i.length+p],U=u[$];if(_>=0)if(U>=0){if(U!==_)throw new Error(`rt input.shape and shape=${r} are incompatible: rt input.shape[${p+s}] = ${_} but shape[${p+s}] = ${U}`)}else u[$]=_}return u}function al(s){const r={FIRST_DIM_SIZE:oi.FIRST_DIM_SIZE,VALUE_ROWIDS:oi.VALUE_ROWIDS,ROW_LENGTHS:oi.ROW_LENGTHS,ROW_SPLITS:oi.ROW_SPLITS,ROW_LIMITS:oi.ROW_LIMITS,ROW_STARTS:oi.ROW_STARTS},i=[];for(const u of s){if(!(u in r))break;i.push(r[u])}return i}function uu(s){return s.length===0?0:s[0]===oi.FIRST_DIM_SIZE?s.length-1:s.length}function sl(s,r){if(s==null||r==null)return;const i=s.length,u=r.length;if(i>=u)throw new Error(`defaultValue.shape=${s} and ragged tensor flatValues.shape=${r}, are incompatible: defaultValue.rank = ${i} must be less than ragged tensor input flatValues.rank = ${u})`);for(let p=0;p<Math.min(i,u-1);++p){const _=s[p],$=r[p+1];if(_>=0&&$>=0&&_!==1&&_!==$)throw new Error(`defaultValue.shape=${s}, and ragged tensor input flatValues.shape=${r} are incompatible: defaultValue.shape[${p-s.length}] = ${_} but ragged tensor input.flatValues.shape[${p-s.length}] = ${$}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(s){s[s.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",s[s.VALUE_ROWIDS=1]="VALUE_ROWIDS",s[s.ROW_LENGTHS=2]="ROW_LENGTHS",s[s.ROW_SPLITS=3]="ROW_SPLITS",s[s.ROW_LIMITS=4]="ROW_LIMITS",s[s.ROW_STARTS=5]="ROW_STARTS"})(oi||(oi={}));const Lo=30;function il(s){return s<=Lo?s:Object(X.G)(s,Math.floor(Math.sqrt(s)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(s,r,i){return[i*(typeof s=="number"?s:s[0]),r*(typeof s=="number"?s:s[1])]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(s,r,i,u=!0){let p=[];if(u)p=p.concat(r.slice(0)),p.push(s[0]/i),p=p.concat(s.slice(1));else{p=p.concat(s[0]);const _=r.length;for(let $=0;$<_;++$)p=p.concat([s[$+1]/r[$],r[$]]);p=p.concat(s.slice(_+1))}return p}function cl(s,r,i=!0){const u=[];if(i){u.push(r);for(let p=r+1;p<s;++p)p<=2*r?(u.push(p),u.push(p-(r+1))):u.push(p)}else{const p=[],_=[];for(let $=1;$<s;++$)$>=2*r+1||$%2==1?_.push($):p.push($);u.push(...p),u.push(0),u.push(..._)}return u}function ll(s,r,i,u=!0){const p=[];u?p.push(s[0]/i):p.push(s[0]*i);for(let _=1;_<s.length;++_)_<=r.length?u?p.push(r[_-1]*s[_]):p.push(s[_]/r[_-1]):p.push(s[_]);return p}function dl(s,r){const i=[0];for(let u=0;u<r;++u)i.push(s[u][0]);return i}function hl(s,r,i){const u=s.slice(0,1);for(let p=0;p<i;++p)u.push(s[p+1]-r[p][0]-r[p][1]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pl=1.7580993408473768,fl=1.0507009873554805,ml=.3275911,bl=.254829592,cu=-.284496736,gl=1.421413741,xl=-1.453152027,vl=1.061405429;var Ci=e(30);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lu(s,r){if(s.length!==r.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${s.length}, imag: ${r.length}.`);const i=new Float32Array(2*s.length);for(let u=0;u<i.length;u+=2)i[u]=s[u/2],i[u+1]=r[u/2];return i}function yl(s){const r=new Float32Array(s.length/2),i=new Float32Array(s.length/2);for(let u=0;u<s.length;u+=2)r[u/2]=s[u],i[u/2]=s[u+1];return{real:r,imag:i}}function wl(s){const r=Math.ceil(s.length/4),i=new Float32Array(r),u=new Float32Array(r);for(let p=0;p<s.length;p+=4)i[Math.floor(p/4)]=s[p],u[Math.floor(p/4)]=s[p+1];return{real:i,imag:u}}function kl(s){const r=Math.floor(s.length/4),i=new Float32Array(r),u=new Float32Array(r);for(let p=2;p<s.length;p+=4)i[Math.floor(p/4)]=s[p],u[Math.floor(p/4)]=s[p+1];return{real:i,imag:u}}function _l(s,r){return{real:s[2*r],imag:s[2*r+1]}}function Il(s,r,i,u){s[2*u]=r,s[2*u+1]=i}function Sl(s,r){const i=new Float32Array(s/2),u=new Float32Array(s/2);for(let p=0;p<Math.ceil(s/2);p++){const _=(r?2:-2)*Math.PI*(p/s);i[p]=Math.cos(_),u[p]=Math.sin(_)}return{real:i,imag:u}}function Cl(s,r,i){const u=(i?2:-2)*Math.PI*(s/r);return{real:Math.cos(u),imag:Math.sin(u)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k="->",a=/->/g;function o(s,r){const i=((s=s.replace(/\s/g,"")).length-s.replace(a,"").length)/k.length;if(i<1)throw new Error("Equations without an arrow are not supported.");if(i>1)throw new Error('Equation must contain exactly one arrow ("->").');const[u,p]=s.split(k);Object(X.b)(u.indexOf("...")===-1,()=>'The ellipsis notation ("...") is not supported yet.');const _=u.split(","),$=_.length;if(r!==$)throw new Error(`Expected ${$} input tensors, received ${r}`);if($>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const U=[];for(let Me=0;Me<p.length;++Me){const ct=p[Me];if(!_.some(Lt=>Lt.indexOf(ct)!==-1))throw new Error(`Output subscripts contain the label ${ct} not present in the input subscripts.`);U.indexOf(ct)===-1&&U.push(ct)}for(let Me=0;Me<u.length;++Me){const ct=u[Me];U.indexOf(ct)===-1&&ct!==","&&U.push(ct)}const re=new Array(_.length);for(let Me=0;Me<$;++Me){if(new Set(_[Me].split("")).size!==_[Me].length)throw new Error(`Found duplicate axes in input component ${_[Me]}. Support for duplicate axes in input is not implemented yet.`);re[Me]=[];for(let ct=0;ct<_[Me].length;++ct)re[Me].push(U.indexOf(_[Me][ct]))}const pe=U.length,ze=[];for(let Me=p.length;Me<pe;++Me)ze.push(Me);return{allDims:U,summedDims:ze,idDims:re}}function d(s,r){let i=new Array(s);i.fill(-1);for(let p=0;p<r.length;++p)i[r[p]]=p;const u=[];for(let p=0;p<s;++p)i[p]===-1&&u.push(p);return i=i.filter(p=>p!==-1),{permutationIndices:i,expandDims:u}}function c(s,r,i){const u=new Array(s);for(let p=0;p<i.length;++p){const _=i[p].shape;for(let $=0;$<r[p].length;++$)u[r[p][$]]===void 0?u[r[p][$]]=_[$]:Object(X.b)(u[r[p][$]]===_[$],()=>`Expected dimension ${u[r[p][$]]} at axis ${$} of input shaped ${JSON.stringify(_)}, but got dimension ${_[$]}`)}}function f(s,r){const i=s,u=[];let p=0;s.length===0&&i.push(-1),p=s.length+1;for(let $=0;$<p;++$)u.push([]);const _=[];for(let $=0;$<i.length;++$){const U=C(r,i[$]);for(const re of U)_.indexOf(re)===-1&&(u[$].push(re),_.push(re))}return{path:i,steps:u}}function w(s){return s.every((r,i)=>r===i)}function C(s,r){const i=[];for(let u=0;u<s.length;++u)s[u].length!==0&&s[u].indexOf(r)===-1&&r!==-1||i.push(u);return i}function T(s,r,i=0){let u=[];if(typeof r=="number")Object(X.b)(s.shape[i]%r==0,()=>"Number of splits must evenly divide the axis."),u=new Array(r).fill(s.shape[i]/r);else{const p=r.reduce(($,U)=>(U===-1&&($+=1),$),0);Object(X.b)(p<=1,()=>"There should be only one negative value in split array.");const _=r.indexOf(-1);if(_!==-1){const $=r.reduce((U,re)=>re>0?U+re:U);r[_]=s.shape[i]-$}Object(X.b)(s.shape[i]===r.reduce(($,U)=>$+U),()=>"The sum of sizes must match the size of the axis dimension."),u=r}return u}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P(s){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${s}`}function z(s,r){return`indices(${s}, 0) is invalid: ${r} < 0`}function te(s,r,i){return`indices(${s}, 0) is invalid: ${r} >= ${i}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y(s,r){return`only one output dimension may be -1, not both ${s} and ${r}`}function Ce(s,r){return`size ${s} must be non-negative, not ${r}`}function fe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Pe(s,r){return`Input to reshape is a SparseTensor with ${Object(X.O)(s)}
  dense values, but the requested shape requires a multiple of ${Object(X.O)(r)}. inputShape=${s} outputShape= ${r}`}function Le(s,r){return`Input to reshape is a tensor with ${Object(X.O)(s)} dense values, but the requested shape has ${Object(X.O)(r)}. inputShape=${s} outputShape=${r}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _e(){return"segment ids must be >= 0"}function je(){return"segment ids are not increasing"}function qt(s,r){return`Segment id ${s} out of range [0, ${r}), possibly because segmentIds input is not sorted.`}function sn(s,r,i){return`Bad: indices[${s}] == ${r} out of range [0, ${i})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vn(s,r){let i,u=!1;for(s<=Lo?(i=s,u=!0):i=Object(X.G)(s,Math.floor(Math.sqrt(s)));!u;)i>r||i===s?u=!0:i=Object(X.G)(s,i+1);return i}function En(s,r,i){const u=[],p=s.length;for(let _=0;_<p;_++)_!==r?u.push(s[_]):u.push(i);return u}function Cn(s,r,i,u){const p=r.shape.length,_=s.shape.length;if(u!==0&&(u<-p||u>p))throw new Error(`Expect batchDims in the range of [-${p}, ${p}], but got ${u}`);if(u<0&&(u+=p),u>_)throw new Error(`batchDims (${u}) must be less than rank(x) (
    ${_}).`);if(i<u)throw new Error(`batchDims (${u}) must be less than or equal to axis (${i}).`);for(let Me=0;Me<u;++Me)if(s.shape[Me]!==r.shape[Me])throw new Error(`x.shape[${Me}]: ${s.shape[Me]} should be equal to indices.shape[${Me}]: ${r.shape[Me]}.`);const $=s.shape[i],U=[];let re=1,pe=1,ze=1;for(let Me=0;Me<u;++Me)U.push(s.shape[Me]),re*=s.shape[Me];for(let Me=u;Me<i;Me++)U.push(s.shape[Me]),pe*=s.shape[Me];for(let Me=u;Me<p;Me++)U.push(r.shape[Me]);for(let Me=i+1;Me<_;Me++)U.push(s.shape[Me]),ze*=s.shape[Me];return{batchSize:re,sliceSize:ze,outerSize:pe,dimSize:$,outputShape:U}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function An(s){try{return s.map(r=>Object(es.decodeString)(r))}catch(r){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${r}`)}}function kn(s){return s.map(r=>Object(es.encodeString)(r))}var Jn=e(55),qn=e(51);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(I,n,e){e.d(n,"c",function(){return D}),e.d(n,"a",function(){return S}),e.d(n,"b",function(){return l});var t=e(3),m=e(9),h=e(14),b=e(15),A=e(6);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D(B,O){let V=B;if(Object(b.A)(B))return O==="string"?[]:[B.length];if(!Array.isArray(B))return[];const L=[];for(;Array.isArray(V)||Object(b.A)(V)&&O!=="string";)L.push(V.length),V=V[0];return Array.isArray(B)&&Object(m.c)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&y(B,L,[]),L}function y(B,O,V){if(V=V||[],!Array.isArray(B)&&!Object(b.A)(B))return void Object(b.b)(O.length===0,()=>`Element arr[${V.join("][")}] is a primitive, but should be an array/TypedArray of ${O[0]} elements`);Object(b.b)(O.length>0,()=>`Element arr[${V.join("][")}] should be a primitive, but is an array of ${B.length} elements`),Object(b.b)(B.length===O[0],()=>`Element arr[${V.join("][")}] should have ${O[0]} elements, but has ${B.length} elements`);const L=O.slice(1);for(let g=0;g<B.length;++g)y(B[g],L,V.concat(g))}function E(B,O,V,L){if(B!=="string_or_numeric"){if(B==null)throw new Error("Expected dtype cannot be null.");if(B!=="numeric"&&B!==O||B==="numeric"&&O==="string")throw new Error(`Argument '${V}' passed to '${L}' must be ${B} tensor, but got ${O} tensor`)}}function S(B,O,V,L="numeric"){if(B instanceof h.a)return E(L,B.dtype,O,V),B;let g=Object(b.r)(B);if(g!=="string"&&["bool","int32","float32"].indexOf(L)>=0&&(g=L),E(L,g,O,V),B==null||!Object(b.A)(B)&&!Array.isArray(B)&&typeof B!="number"&&typeof B!="boolean"&&typeof B!="string"){const ke=B==null?"null":B.constructor.name;throw new Error(`Argument '${O}' passed to '${V}' must be a Tensor or TensorLike, but got '${ke}'`)}const W=D(B,g);Object(b.A)(B)||Array.isArray(B)||(B=[B]);const de=g!=="string"?Object(A.toTypedArray)(B,g):Object(b.m)(B,[],!0);return t.a.makeTensor(de,W,g)}function l(B,O,V,L="numeric"){if(!Array.isArray(B))throw new Error(`Argument ${O} passed to ${V} must be a \`Tensor[]\` or \`TensorLike[]\``);return B.map((g,W)=>S(g,`${O}[${W}]`,V,L))}},function(I,n,e){e.d(n,"a",function(){return h}),e.d(n,"b",function(){return b});var t=e(3),m=e(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h="__op";function b(A){const D=Object.keys(A);if(D.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${D.length} keys.`);let y=D[0];const E=A[y];y.endsWith("_")&&(y=y.substring(0,y.length-1)),y+=h;const S=(...l)=>{t.a.startScope(y);try{const B=E(...l);return Object(m.x)(B)&&console.error("Cannot return a Promise inside of tidy."),t.a.endScope(B),B}catch(B){throw t.a.endScope(null),B}};return Object.defineProperty(S,"name",{value:y,configurable:!0}),S}},function(I,n,e){e.d(n,"b",function(){return de}),e.d(n,"a",function(){return ke});var t=e(51),m=e(9),h=e(38),b=e(4),A=e(31),D=e(30),y=e(6),E=e(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S{constructor(Q,Se){this.backendTimer=Q,this.logger=Se,Se==null&&(this.logger=new B)}profileKernel(Q,Se,Z){let G;const He=()=>{G=Z()};let me;const et=y.now();if(this.backendTimer.timerAvailable())me=this.backendTimer.time(He);else{He();for(const rt of G)rt.dataSync();me=Promise.resolve({kernelMs:y.now()-et})}if(Object(m.c)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let rt=0;rt<G.length;rt++){const It=G[rt];It.data().then(X=>{l(X,It.dtype,Q)})}return{kernelName:Q,outputs:G,inputs:Se,timeMs:me.then(rt=>rt.kernelMs),extraInfo:me.then(rt=>rt.getExtraProfileInfo!=null?rt.getExtraProfileInfo():"")}}logKernelProfile(Q){const{kernelName:Se,outputs:Z,timeMs:G,inputs:He,extraInfo:me}=Q;Z.forEach(et=>{Promise.all([et.data(),G,me]).then(rt=>{this.logger.logKernelProfile(Se,et,rt[0],rt[1],He,rt[2])})})}}function l(he,Q,Se){if(Q!=="float32")return!1;for(let Z=0;Z<he.length;Z++){const G=he[Z];if(isNaN(G)||!isFinite(G))return console.warn(`Found ${G} in the result of '${Se}'`),!0}return!1}class B{logKernelProfile(Q,Se,Z,G,He,me){const et=typeof G=="number"?E.L(`${G}ms`,9):G.error,rt=E.L(Q,25),It=Se.rank,X=Se.size,$t=E.L(Se.shape.toString(),14);let Ct="";for(const Gt in He){const Wt=He[Gt];if(Wt!=null){const lt=Wt.shape||Se.shape,Qt=lt.length;Ct+=`${Gt}: ${Qt}D ${Qt>0?lt:""} `}}console.log(`%c${rt}	%c${et}	%c${It}D ${$t}	%c${X}	%c${Ct}	%c${me}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var O=e(14),V=e(10);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L(he){return he.kernelName!=null}class g{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(Q=>Q.name)))}}}dispose(){for(const Q in this.registeredVariables)this.registeredVariables[Q].dispose()}}class W{constructor(Q){this.ENV=Q,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new g}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const Q=this.getSortedBackends();for(let Se=0;Se<Q.length;Se++){const Z=Q[Se];if(await this.initializeBackend(Z).success)return void await this.setBackend(Z)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:Q,asyncInit:Se}=this.initializeBackendsAndReturnBest();if(Se)throw new Error(`The highest priority backend '${Q}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(Q)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(Q){if(!(Q in this.registry)){if(!(Q in this.registryFactory))return null;{const{asyncInit:Se}=this.initializeBackend(Q);if(Se)return null}}return this.registry[Q]}findBackendFactory(Q){return Q in this.registryFactory?this.registryFactory[Q].factory:null}registerBackend(Q,Se,Z=1){return Q in this.registryFactory?(D.b(`${Q} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[Q]={factory:Se,priority:Z},!0)}async setBackend(Q){if(this.registryFactory[Q]==null)throw new Error(`Backend name '${Q}' not found in registry`);if(this.backendName=Q,this.registry[Q]==null){this.backendInstance=null;const{success:Se,asyncInit:Z}=this.initializeBackend(Q);if(!(Z?await Se:Se))return!1}return this.backendInstance=this.registry[Q],this.setupRegisteredKernels(),this.profiler=new S(this.backendInstance),!0}setupRegisteredKernels(){Object(A.d)(this.backendName).forEach(Q=>{Q.setupFunc!=null&&Q.setupFunc(this.backendInstance)})}disposeRegisteredKernels(Q){Object(A.d)(Q).forEach(Se=>{Se.disposeFunc!=null&&Se.disposeFunc(this.registry[Q])})}initializeBackend(Q){const Se=this.registryFactory[Q];if(Se==null)throw new Error(`Cannot initialize backend ${Q}, no registration found.`);try{const Z=Se.factory();if(!Z||Z instanceof t.b||typeof Z.then!="function")return this.registry[Q]=Z,{success:!0,asyncInit:!1};{const G=++this.pendingBackendInitId,He=Z.then(me=>!(G<this.pendingBackendInitId)&&(this.registry[Q]=me,this.pendingBackendInit=null,!0)).catch(me=>(G<this.pendingBackendInitId||(this.pendingBackendInit=null,D.b(`Initialization of backend ${Q} failed`),D.b(me.stack||me.message)),!1));return this.pendingBackendInit=He,{success:He,asyncInit:!0}}}catch(Z){return D.b(`Initialization of backend ${Q} failed`),D.b(Z.stack||Z.message),{success:!1,asyncInit:!1}}}removeBackend(Q){if(!(Q in this.registryFactory))throw new Error(`${Q} backend not found in registry`);this.backendName===Q&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,Q in this.registry&&(this.disposeRegisteredKernels(Q),this.registry[Q].dispose(),delete this.registry[Q]),delete this.registryFactory[Q],this.backendName===Q&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((Q,Se)=>this.registryFactory[Se].priority-this.registryFactory[Q].priority)}initializeBackendsAndReturnBest(){const Q=this.getSortedBackends();for(let Se=0;Se<Q.length;Se++){const Z=Q[Se],{success:G,asyncInit:He}=this.initializeBackend(Z);if(He||G)return{name:Z,asyncInit:He}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(Q,Se){const Z=this.state.tensorInfo.get(Se),G=Z.backend,He=this.readSync(Se),me=G.refCount(Se);G.disposeData(Se,!0),Z.backend=Q,Q.move(Se,He,Z.shape,Z.dtype,me),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(Q,Se){let Z,G=null;if(Se==null){if(typeof Q!="function")throw new Error("Please provide a function to tidy()");Se=Q}else{if(typeof Q!="string"&&!(Q instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof Se!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");G=Q}return this.scopedRun(()=>this.startScope(G),()=>this.endScope(Z),()=>(Z=Se(),Z instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),Z))}scopedRun(Q,Se,Z){Q();try{const G=Z();return Se(),G}catch(G){throw Se(),G}}nextTensorId(){return W.nextTensorId++}nextVariableId(){return W.nextVariableId++}clone(Q){const Se=ke.runKernel(b.tb,{x:Q}),Z={x:Q};return this.addTapeNode(this.state.activeScope.name,Z,[Se],G=>({x:()=>{const He={x:G},me={dtype:"float32"};return ke.runKernel(b.x,He,me)}}),[],{}),Se}runKernel(Q,Se,Z){if(this.backendName==null&&this.backend,Object(A.c)(Q,this.backendName)==null)throw new Error(`Kernel '${Q}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:Q,inputs:Se,attrs:Z})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(Q,Se,Z){const G=this.backend.numDataIds();let He=0;Z.forEach(rt=>{He+=rt.dtype==="complex64"?3:1});const me=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],et=G-Se-He-me;if(et>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${et} data ids) after running '${Q}'`)}runKernelFunc(Q){let Se,Z=[];const G=this.isTapeOn(),He=this.state.numBytes,me=this.state.numTensors;let et,rt;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),this.backendName==null&&this.backend;const It=L(Q)?Q.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(L(Q)){const{kernelName:Wt,inputs:lt,attrs:Qt}=Q;this.backendName==null&&this.backend;const Ft=Object(A.c)(Wt,this.backendName);E.b(Ft!=null,()=>`Cannot find registered kernel '${Wt}' for backend '${this.backendName}'`),et=()=>{const yn=this.backend.numDataIds();rt=Ft.kernelFunc({inputs:lt,attrs:Qt,backend:this.backend});const Nn=Array.isArray(rt)?rt:[rt];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Wt,yn,Nn);const Kn=Nn.map(zn=>zn.rank!=null?zn:this.makeTensorFromTensorInfo(zn));if(G){const zn=this.getTensorsForGradient(Wt,lt,Kn);Z=this.saveTensorsForBackwardMode(zn)}return Kn}}else{const{forwardFunc:Wt}=Q,lt=Qt=>{G&&(Z=Qt.map(Ft=>this.keep(this.clone(Ft))))};et=()=>{const Qt=this.backend.numDataIds();rt=this.tidy(()=>Wt(this.backend,lt));const Ft=Array.isArray(rt)?rt:[rt];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(It,Qt,Ft),Ft}}const{inputs:X,attrs:$t}=Q,Ct=L(Q)?null:Q.backwardsFunc;let Gt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Gt=this.profiler.profileKernel(It,X,()=>et()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Gt),Se=Gt.outputs):Se=et()}),G&&this.addTapeNode(It,X,Se,Ct,Z,$t),this.state.profiling&&this.state.activeProfile.kernels.push({name:It,bytesAdded:this.state.numBytes-He,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-me,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(X).map(Wt=>X[Wt]!=null?X[Wt].shape:null),outputShapes:Se.map(Wt=>Wt.shape),kernelTimeMs:Gt.timeMs,extraInfo:Gt.extraInfo}),Array.isArray(rt)?Se:Se[0]}saveTensorsForBackwardMode(Q){return Q.map(Z=>this.keep(this.clone(Z)))}getTensorsForGradient(Q,Se,Z){const G=Object(A.b)(Q);if(G!=null){const He=G.inputsToSave||[],me=G.outputsToSave||[];let et;G.saveAllInputs?(E.b(Array.isArray(Se),()=>"saveAllInputs is true, expected inputs to be an array."),et=Object.keys(Se).map(It=>Se[It])):et=He.map(It=>Se[It]);const rt=Z.filter((It,X)=>me[X]);return et.concat(rt)}return[]}makeTensor(Q,Se,Z,G){if(Q==null)throw new Error("Values passed to engine.makeTensor() are null");Z=Z||"float32",G=G||this.backend;let He=Q;Z==="string"&&E.z(Q[0])&&(He=Q.map(rt=>y.encodeString(rt)));const me=G.write(He,Se,Z),et=new O.a(Se,Z,me,this.nextTensorId());if(this.trackTensor(et,G),Z==="string"){const rt=this.state.tensorInfo.get(me),It=Object(E.f)(He);this.state.numBytes+=It-rt.bytes,rt.bytes=It}return et}makeTensorFromDataId(Q,Se,Z,G){const He={dataId:Q,shape:Se,dtype:Z=Z||"float32"};return this.makeTensorFromTensorInfo(He,G)}makeTensorFromTensorInfo(Q,Se){const{dataId:Z,shape:G,dtype:He}=Q,me=new O.a(G,He,Z,this.nextTensorId());return this.trackTensor(me,Se),me}makeVariable(Q,Se=!0,Z,G){Z=Z||this.nextVariableId().toString(),G!=null&&G!==Q.dtype&&(Q=Q.cast(G));const He=new O.c(Q,Se,Z,this.nextTensorId());if(this.state.registeredVariables[He.name]!=null)throw new Error(`Variable with name ${He.name} was already registered`);return this.state.registeredVariables[He.name]=He,this.incRef(He,this.backend),He}trackTensor(Q,Se){this.state.numTensors++,Q.dtype==="string"&&this.state.numStringTensors++;let Z=0;Q.dtype!=="complex64"&&Q.dtype!=="string"&&(Z=Q.size*E.g(Q.dtype)),this.state.numBytes+=Z,this.state.tensorInfo.has(Q.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(Q.dataId,{backend:Se||this.backend,dtype:Q.dtype,shape:Q.shape,bytes:Z})),Q instanceof O.c||this.track(Q)}incRef(Q,Se){this.trackTensor(Q,Se),this.backend.incRef(Q.dataId)}removeDataId(Q,Se){this.state.tensorInfo.has(Q)&&this.state.tensorInfo.get(Q).backend===Se&&(this.state.tensorInfo.delete(Q),this.state.numDataBuffers--)}disposeTensor(Q){if(!this.state.tensorInfo.has(Q.dataId))return;const Se=this.state.tensorInfo.get(Q.dataId);if(this.state.numTensors--,Q.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=Se.bytes),Q.dtype!=="complex64"&&Q.dtype!=="string"){const Z=Q.size*E.g(Q.dtype);this.state.numBytes-=Z}Se.backend.disposeData(Q.dataId)&&this.removeDataId(Q.dataId,Se.backend)}disposeVariables(){for(const Q in this.state.registeredVariables){const Se=this.state.registeredVariables[Q];this.disposeVariable(Se)}}disposeVariable(Q){this.disposeTensor(Q),this.state.registeredVariables[Q.name]!=null&&delete this.state.registeredVariables[Q.name]}memory(){const Q=this.backend.memory();return Q.numTensors=this.state.numTensors,Q.numDataBuffers=this.state.numDataBuffers,Q.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(Q.unreliable=!0,Q.reasons==null&&(Q.reasons=[]),Q.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),Q}async profile(Q){this.state.profiling=!0;const Se=this.state.numBytes,Z=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await Q(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(G=>G.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-Se,this.state.activeProfile.newTensors=this.state.numTensors-Z;for(const G of this.state.activeProfile.kernels)G.kernelTimeMs=await G.kernelTimeMs,G.extraInfo=await G.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(Q,Se,Z,G,He,me){const et={id:this.state.nextTapeNodeId++,kernelName:Q,inputs:Se,outputs:Z,saved:He},rt=Object(A.b)(Q);rt!=null&&(G=rt.gradFunc),G!=null&&(et.gradient=It=>(It=It.map((X,$t)=>{if(X==null){const Ct=Z[$t],Gt=E.F(Ct.size,Ct.dtype);return this.makeTensor(Gt,Ct.shape,Ct.dtype)}return X}),G(It.length>1?It:It[0],He,me))),this.state.activeTape.push(et)}keep(Q){return Q.kept=!0,Q}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(Q){const Se={track:[],name:"unnamed scope",id:this.state.nextScopeId++};Q&&(Se.name=Q),this.state.scopeStack.push(Se),this.state.activeScope=Se}endScope(Q){const Se=Object(V.getTensorsInContainer)(Q),Z=new Set(Se.map(He=>He.id));for(let He=0;He<this.state.activeScope.track.length;He++){const me=this.state.activeScope.track[He];me.kept||Z.has(me.id)||me.dispose()}const G=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],Se.forEach(He=>{He.kept||He.scopeId!==G.id||this.track(He)})}gradients(Q,Se,Z,G=!1){if(E.b(Se.length>0,()=>"gradients() received an empty list of xs."),Z!=null&&Z.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${Z.dtype}'`);const He=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",Q));E.b(He instanceof O.a,()=>"The result y returned by f() must be a tensor.");const me=function(et,rt,It){const X={},$t={};for(let lt=0;lt<rt.length;lt++)X[rt[lt].id]=!0;for(let lt=0;lt<et.length;lt++){const Qt=et[lt],Ft=Qt.inputs;for(const yn in Ft){const Nn=Ft[yn];let Kn=!1;for(let zn=0;zn<rt.length;zn++)if(X[Nn.id]){Qt.outputs.forEach(sr=>X[sr.id]=!0),Kn=!0,$t[Qt.id]=!0;break}if(Kn)break}}const Ct={};Ct[It.id]=!0;const Gt={};for(let lt=et.length-1;lt>=0;lt--){const Qt=et[lt],Ft=Qt.inputs;for(let yn=0;yn<Qt.outputs.length;yn++)if(Ct[Qt.outputs[yn].id]){for(const Nn in Ft)Ct[Ft[Nn].id]=!0,Gt[Qt.id]=!0;break}}const Wt=[];for(let lt=0;lt<et.length;lt++){const Qt=et[lt];if($t[Qt.id]&&Gt[Qt.id]){const Ft={};for(const Nn in Qt.inputs){const Kn=Qt.inputs[Nn];X[Kn.id]&&(Ft[Nn]=Kn)}const yn=Object.assign({},Qt);yn.inputs=Ft,yn.outputs=Qt.outputs,Wt.push(yn)}}return Wt}(this.state.activeTape,Se,He);if(!G&&me.length===0&&Se.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const et={};et[He.id]=Z==null?function(It){const X=Object(E.D)(Object(E.O)(It),"float32");return ke.makeTensor(X,It,"float32")}(He.shape):Z,function(It,X,$t,Ct){for(let Gt=X.length-1;Gt>=0;Gt--){const Wt=X[Gt],lt=[];if(Wt.outputs.forEach(Ft=>{const yn=It[Ft.id];yn!=null?lt.push(yn):lt.push(null)}),Wt.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${Wt.kernelName}.`);const Qt=Wt.gradient(lt);for(const Ft in Wt.inputs){if(!(Ft in Qt))throw new Error(`Cannot backprop through input ${Ft}. Available gradients found: ${Object.keys(Qt)}.`);const yn=$t(()=>Qt[Ft]());if(yn.dtype!=="float32")throw new Error(`Error in gradient for op ${Wt.kernelName}. The gradient of input ${Ft} must have 'float32' dtype, but has '${yn.dtype}'`);const Nn=Wt.inputs[Ft];if(!E.a(yn.shape,Nn.shape))throw new Error(`Error in gradient for op ${Wt.kernelName}. The gradient of input '${Ft}' has shape '${yn.shape}', which does not match the shape of the input '${Nn.shape}'`);if(It[Nn.id]==null)It[Nn.id]=yn;else{const Kn=It[Nn.id];It[Nn.id]=Ct(Kn,yn),Kn.dispose()}}}}(et,me,It=>this.tidy(It),Ie);const rt=Se.map(It=>et[It.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(It=>{for(const X of It.saved)X.dispose()}),this.state.activeTape=null),{value:He,grads:rt}})}customGrad(Q){return E.b(E.u(Q),()=>"The f passed in customGrad(f) must be a function."),(...Se)=>{let Z;E.b(Se.every(He=>He instanceof O.a),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const G={};return Se.forEach((He,me)=>{G[me]=He}),this.runKernelFunc({forwardFunc:(He,me)=>(Z=Q(...Se,me),E.b(Z.value instanceof O.a,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),E.b(E.u(Z.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),Z.value),backwardsFunc:(He,me)=>{const et=Z.gradFunc(He,me),rt=Array.isArray(et)?et:[et];E.b(rt.length===Se.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),E.b(rt.every(X=>X instanceof O.a),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const It={};return rt.forEach((X,$t)=>{It[$t]=()=>X}),It},inputs:G})}}readSync(Q){return this.state.tensorInfo.get(Q).backend.readSync(Q)}read(Q){return this.state.tensorInfo.get(Q).backend.read(Q)}readToGPU(Q,Se){return this.state.tensorInfo.get(Q).backend.readToGPU(Q,Se)}async time(Q){const Se=Object(y.now)(),Z=await this.backend.time(Q);return Z.wallMs=Object(y.now)()-Se,Z}track(Q){return this.state.activeScope!=null&&(Q.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(Q)),Q}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new g;for(const Q in this.registry)this.disposeRegisteredKernels(Q),this.registry[Q].dispose(),delete this.registry[Q];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function de(){const he=Object(h.b)();if(he._tfengine==null){const Q=new m.b(he);he._tfengine=new W(Q)}return Object(m.d)(he._tfengine.ENV),Object(O.f)(()=>he._tfengine),he._tfengine}W.nextTensorId=0,W.nextVariableId=0;const ke=de();function Ie(he,Q){const Se={a:he,b:Q};return ke.runKernel(b.d,Se)}},function(I,n,e){e.d(n,"a",function(){return t}),e.d(n,"b",function(){return m}),e.d(n,"c",function(){return h}),e.d(n,"d",function(){return b}),e.d(n,"e",function(){return A}),e.d(n,"f",function(){return D}),e.d(n,"g",function(){return y}),e.d(n,"h",function(){return E}),e.d(n,"i",function(){return S}),e.d(n,"j",function(){return l}),e.d(n,"k",function(){return B}),e.d(n,"l",function(){return O}),e.d(n,"n",function(){return V}),e.d(n,"m",function(){return L}),e.d(n,"o",function(){return g}),e.d(n,"r",function(){return W}),e.d(n,"p",function(){return de}),e.d(n,"q",function(){return ke}),e.d(n,"s",function(){return Ie}),e.d(n,"t",function(){return he}),e.d(n,"u",function(){return Q}),e.d(n,"w",function(){return Se}),e.d(n,"v",function(){return Z}),e.d(n,"x",function(){return G}),e.d(n,"y",function(){return He}),e.d(n,"z",function(){return me}),e.d(n,"A",function(){return et}),e.d(n,"B",function(){return rt}),e.d(n,"C",function(){return It}),e.d(n,"D",function(){return X}),e.d(n,"E",function(){return $t}),e.d(n,"F",function(){return Ct}),e.d(n,"G",function(){return Gt}),e.d(n,"H",function(){return Wt}),e.d(n,"I",function(){return lt}),e.d(n,"J",function(){return Qt}),e.d(n,"K",function(){return Ft}),e.d(n,"M",function(){return yn}),e.d(n,"N",function(){return Nn}),e.d(n,"L",function(){return Kn}),e.d(n,"O",function(){return zn}),e.d(n,"P",function(){return sr}),e.d(n,"Q",function(){return K}),e.d(n,"R",function(){return J}),e.d(n,"S",function(){return we}),e.d(n,"T",function(){return vt}),e.d(n,"U",function(){return wt}),e.d(n,"W",function(){return Ot}),e.d(n,"V",function(){return Ae}),e.d(n,"qc",function(){return mt}),e.d(n,"X",function(){return Mt}),e.d(n,"Y",function(){return Nt}),e.d(n,"Z",function(){return un}),e.d(n,"bb",function(){return Rn}),e.d(n,"ab",function(){return oe}),e.d(n,"cb",function(){return le}),e.d(n,"db",function(){return qe}),e.d(n,"eb",function(){return Mn}),e.d(n,"fb",function(){return zr}),e.d(n,"gb",function(){return Ur}),e.d(n,"hb",function(){return _r}),e.d(n,"ib",function(){return ir}),e.d(n,"jb",function(){return Zn}),e.d(n,"lb",function(){return $r}),e.d(n,"pb",function(){return en}),e.d(n,"ob",function(){return mn}),e.d(n,"qb",function(){return Ln}),e.d(n,"rb",function(){return or}),e.d(n,"tb",function(){return lr}),e.d(n,"sb",function(){return Qn}),e.d(n,"ub",function(){return br}),e.d(n,"vb",function(){return gr}),e.d(n,"wb",function(){return At}),e.d(n,"xb",function(){return q}),e.d(n,"Ab",function(){return ae}),e.d(n,"Bb",function(){return Qe}),e.d(n,"Cb",function(){return ht}),e.d(n,"Db",function(){return Bt}),e.d(n,"Eb",function(){return Kt}),e.d(n,"Fb",function(){return Ut}),e.d(n,"Hb",function(){return tn}),e.d(n,"Ib",function(){return bn}),e.d(n,"Jb",function(){return xn}),e.d(n,"Kb",function(){return rn}),e.d(n,"Gb",function(){return Xn}),e.d(n,"Lb",function(){return xr}),e.d(n,"yb",function(){return Lr}),e.d(n,"zb",function(){return Wr}),e.d(n,"Mb",function(){return vr}),e.d(n,"Sb",function(){return ua}),e.d(n,"Nb",function(){return ma}),e.d(n,"Qb",function(){return Cr}),e.d(n,"Ob",function(){return Da}),e.d(n,"Pb",function(){return kr}),e.d(n,"Rb",function(){return Pr}),e.d(n,"Tb",function(){return qr}),e.d(n,"Ub",function(){return ha}),e.d(n,"Vb",function(){return Zr}),e.d(n,"Wb",function(){return Vr}),e.d(n,"Xb",function(){return Ca}),e.d(n,"Yb",function(){return Ta}),e.d(n,"Zb",function(){return Pa}),e.d(n,"ac",function(){return is}),e.d(n,"ec",function(){return ms}),e.d(n,"bc",function(){return Va}),e.d(n,"cc",function(){return Ba}),e.d(n,"dc",function(){return wa}),e.d(n,"gc",function(){return Ga}),e.d(n,"fc",function(){return Xr}),e.d(n,"hc",function(){return ka}),e.d(n,"ic",function(){return _a}),e.d(n,"jc",function(){return os}),e.d(n,"kc",function(){return Za}),e.d(n,"lc",function(){return La}),e.d(n,"mc",function(){return wr}),e.d(n,"nc",function(){return sa}),e.d(n,"oc",function(){return Ia}),e.d(n,"pc",function(){return ba}),e.d(n,"rc",function(){return ca}),e.d(n,"sc",function(){return Ja}),e.d(n,"uc",function(){return Fe}),e.d(n,"xc",function(){return dt}),e.d(n,"yc",function(){return Et}),e.d(n,"vc",function(){return Vt}),e.d(n,"wc",function(){return an}),e.d(n,"tc",function(){return Zt}),e.d(n,"zc",function(){return _n}),e.d(n,"Bc",function(){return Gn}),e.d(n,"Cc",function(){return ar}),e.d(n,"Dc",function(){return Rr}),e.d(n,"Ec",function(){return Ir}),e.d(n,"Fc",function(){return xa}),e.d(n,"Gc",function(){return Er}),e.d(n,"Lc",function(){return Yr}),e.d(n,"Jc",function(){return ja}),e.d(n,"Kc",function(){return Oa}),e.d(n,"Ic",function(){return $a}),e.d(n,"Hc",function(){return Xs}),e.d(n,"Nc",function(){return $s}),e.d(n,"Vc",function(){return bs}),e.d(n,"ed",function(){return di}),e.d(n,"Oc",function(){return Ha}),e.d(n,"Uc",function(){return qa}),e.d(n,"Mc",function(){return Ea}),e.d(n,"Pc",function(){return ta}),e.d(n,"Qc",function(){return Ys}),e.d(n,"Rc",function(){return ia}),e.d(n,"Sc",function(){return Aa}),e.d(n,"Tc",function(){return es}),e.d(n,"Xc",function(){return gs}),e.d(n,"Wc",function(){return hi}),e.d(n,"Zc",function(){return xs}),e.d(n,"ad",function(){return us}),e.d(n,"bd",function(){return pi}),e.d(n,"cd",function(){return pr}),e.d(n,"dd",function(){return Jr}),e.d(n,"fd",function(){return za}),e.d(n,"gd",function(){return Es}),e.d(n,"hd",function(){return Qs}),e.d(n,"id",function(){return ts}),e.d(n,"jd",function(){return As}),e.d(n,"kd",function(){return Ns}),e.d(n,"ld",function(){return vs}),e.d(n,"md",function(){return Yn}),e.d(n,"nd",function(){return In}),e.d(n,"od",function(){return Fr}),e.d(n,"pd",function(){return Sn}),e.d(n,"Yc",function(){return Sa}),e.d(n,"kb",function(){return na}),e.d(n,"Ac",function(){return pa}),e.d(n,"qd",function(){return Zs}),e.d(n,"mb",function(){return ys}),e.d(n,"nb",function(){return cs});const t="Abs",m="Acos",h="Acosh",b="Add",A="AddN",D="All",y="Any",E="ArgMax",S="ArgMin",l="Asin",B="Asinh",O="Atan",V="Atanh",L="Atan2",g="AvgPool",W="AvgPoolGrad",de="AvgPool3D",ke="AvgPool3DGrad",Ie="BatchMatMul",he="BatchToSpaceND",Q="Bincount",Se="BroadcastTo",Z="BroadcastArgs",G="Cast",He="Ceil",me="ClipByValue",et="Complex",rt="ComplexAbs",It="Concat",X="Conv2D",$t="Conv2DBackpropFilter",Ct="Conv2DBackpropInput",Gt="Conv3D",Wt="Conv3DBackpropFilterV2",lt="Conv3DBackpropInputV2",Qt="Cos",Ft="Cosh",yn="Cumprod",Nn="Cumsum",Kn="CropAndResize",zn="DenseBincount",sr="DepthToSpace",K="DepthwiseConv2dNative",J="DepthwiseConv2dNativeBackpropFilter",we="DepthwiseConv2dNativeBackpropInput",vt="Diag",wt="Dilation2D",Ot="Dilation2DBackpropInput",Ae="Dilation2DBackpropFilter",mt="RealDiv",Mt="Einsum",Nt="Elu",un="EluGrad",Rn="Erf",oe="Equal",le="Exp",qe="ExpandDims",Mn="Expm1",zr="FFT",Ur="Fill",_r="FlipLeftRight",ir="Floor",Zn="FloorDiv",$r="FusedBatchNorm",en="GatherV2",mn="GatherNd",Ln="Greater",or="GreaterEqual",lr="Identity",Qn="IFFT",br="Imag",gr="IsFinite",At="IsInf",q="IsNan",ae="LeakyRelu",Qe="Less",ht="LessEqual",Bt="LinSpace",Kt="Log",Ut="Log1p",tn="LogicalAnd",bn="LogicalNot",xn="LogicalOr",rn="LogicalXor",Xn="LogSoftmax",xr="LowerBound",Lr="LRN",Wr="LRNGrad",vr="Max",ua="Maximum",ma="MaxPool",Cr="MaxPoolGrad",Da="MaxPool3D",kr="MaxPool3DGrad",Pr="MaxPoolWithArgmax",qr="Mean",ha="Min",Zr="Minimum",Vr="MirrorPad",Ca="Mod",Ta="Multinomial",Pa="Multiply",is="Neg",ms="NotEqual",Va="NonMaxSuppressionV3",Ba="NonMaxSuppressionV4",wa="NonMaxSuppressionV5",Ga="OnesLike",Xr="OneHot",ka="Pack",_a="PadV2",os="Pool",Za="Pow",La="Prelu",wr="Prod",sa="RaggedTensorToTensor",Ia="Range",ba="Real",ca="Reciprocal",Ja="Relu",Fe="Reshape",dt="ResizeNearestNeighbor",Et="ResizeNearestNeighborGrad",Vt="ResizeBilinear",an="ResizeBilinearGrad",Zt="Relu6",_n="Reverse",Gn="Round",ar="Rsqrt",Rr="ScatterNd",Ir="SearchSorted",xa="Select",Er="Selu",Yr="Slice",ja="Sin",Oa="Sinh",$a="Sign",Xs="Sigmoid",$s="Softplus",bs="Sqrt",di="Sum",Ha="SpaceToBatchND",qa="SplitV",Ea="Softmax",ta="SparseFillEmptyRows",Ys="SparseReshape",ia="SparseSegmentMean",Aa="SparseSegmentSum",es="SparseToDense",gs="SquaredDifference",hi="Square",xs="StridedSlice",us="StringNGrams",pi="StringSplit",pr="StringToHashBucketFast",Jr="Sub",za="Tan",Es="Tanh",Qs="Tile",ts="TopK",As="Transform",Ns="Transpose",vs="Unique",Yn="Unpack",In="UnsortedSegmentSum",Fr="UpperBound",Sn="ZerosLike",Sa="Step",na="FromPixels",pa="RotateWithOffset",Zs="_FusedMatMul",ys="FusedConv2D",cs="FusedDepthwiseConv2D"},function(I,n,e){e.d(n,"a",function(){return b}),e.d(n,"i",function(){return A}),e.d(n,"j",function(){return D}),e.d(n,"k",function(){return y}),e.d(n,"l",function(){return E}),e.d(n,"m",function(){return S}),e.d(n,"n",function(){return l}),e.d(n,"h",function(){return B}),e.d(n,"d",function(){return O}),e.d(n,"s",function(){return V}),e.d(n,"u",function(){return L}),e.d(n,"v",function(){return g}),e.d(n,"e",function(){return W}),e.d(n,"p",function(){return de}),e.d(n,"r",function(){return ke}),e.d(n,"t",function(){return Ie}),e.d(n,"q",function(){return he}),e.d(n,"o",function(){return Q}),e.d(n,"b",function(){return Se}),e.d(n,"g",function(){return Z}),e.d(n,"c",function(){return G}),e.d(n,"f",function(){return He});var t=e(0),m=e(39),h=e(11);function b(me,et){if(!me)throw new Error(et)}function A(me){return typeof me=="boolean"}function D(me){return typeof me=="number"&&Number.isInteger(me)}function y(me){return me instanceof Array&&me.every(et=>D(et))}function E(me){return me instanceof Array&&me.every(et=>D(et)&&et>0||et===null)}function S(me){return me instanceof Float32Array||me instanceof Int32Array||me instanceof Uint32Array||me instanceof Int16Array||me instanceof Uint16Array||me instanceof Int8Array||me instanceof Uint8Array}function l(me){return me[0]===0&&me[1]===1||me[0]===1&&me[1]===2||me[0]===2&&me[1]===3}function B(me){if(me==="float32")return Float32Array;if(me==="int32")return Int32Array;if(me==="uint32")return Uint32Array;if(me==="float16")return Uint16Array;if(me==="int8")return Int8Array;if(me==="uint8")return Uint8Array;throw new Error("Type is not supported.")}function O(me){let et;return me.dtype==="float32"?et=h.d.float32:me.dtype==="int32"&&(et=h.d.int32),{type:et,dimensions:me.shape}}function V(me){b(me.type in h.d,"The operand type is invalid."),me.dimensions&&b(y(me.dimensions),"The dimensions is invalid.")}function L(me,et,rt){b(S(me),"The value is not a typed array."),b(me instanceof B(et),"The type of value is invalid."),b(me.length===de(rt),`the value length ${me.length} is invalid, size of [${rt}] ${de(rt)} is expected.`)}function g(me,et){et===h.d.int32?b(Number.isInteger(me),"the value is not an int32."):et===h.d.uint32?b(Number.isInteger(me)&&me>=0,"the value is not an uint32."):et===h.d.int8?b(Number.isInteger(me)&&me>=-128&&me<=127,"the value is not an int8."):et===h.d.uint8&&b(Number.isInteger(me)&&me>=0&&me<=255,"the value is not an uint8.")}function W(me,et){const rt=function(It){if(It==="float32")return"float32";if(It==="int32")return"int32";throw new Error("The operand type is not supported by TF.js.")}(me.type);if(me.dimensions!==void 0){b(S(et),"Only ArrayBufferView value is supported.");const It=et;L(It,me.type,me.dimensions);const X=function($t){let Ct;if($t instanceof Float32Array)Ct=new Float32Array($t.length);else if($t instanceof Int32Array)Ct=new Int32Array($t.length);else if($t instanceof Uint32Array)Ct=new Uint32Array($t.length);else if($t instanceof Uint16Array)Ct=new Uint16Array($t.length);else if($t instanceof Int8Array)Ct=new Int8Array($t.length);else{if(!($t instanceof Uint8Array))throw new Error("Type is not supported.");Ct=new Uint8Array($t.length)}return Ct.set($t),Ct}(It);return t.tensor(X,me.dimensions,rt)}return typeof et=="number"?(g(et,me.type),t.scalar(et,rt)):(L(et,me.type,me.dimensions),t.scalar(et[0],rt))}function de(me){return me===void 0||y(me)&&me.length===0?1:me.reduce((et,rt)=>rt>0?et*rt:et,1)}function ke(me,et=""){b(me instanceof h.c,`The parameter ${et} is not an operand.`)}function Ie(me,et=""){b(me===void 0||me instanceof h.c,`The parameter ${et} is not an optional operand.`)}function he(me,et){if(typeof me!="undefined"&&me.length>0){for(let rt=0;rt<me.length;++rt)if(me[rt]>=et||me[rt]<-et)return!1}return!0}function Q(me){return me.reduce((et,rt)=>et*rt)}function Se(me,et){b(me.length===et.length,`The actual length ${me.length} is not equal to expected length ${et.length}.`);for(let rt=0;rt<me.length;++rt)b(me[rt]===et[rt],`${me[rt]} is not equal to ${et[rt]} of index ${rt}.`)}function Z(me,et,rt,It,X,$t,Ct){let Gt;if($t===m.a.explicit)Gt=[[0,0],[rt[0],rt[1]],[rt[2],rt[3]],[0,0]];else{Gt=[[0,0],[0,0],[0,0],[0,0]];const Wt=[0,0];if(Ct===void 0)for(let lt=0;lt<2;++lt)Wt[lt]=It[lt]*(Math.ceil(me.shape[1+lt]/It[lt])-1)+((et.shape[lt]-1)*X[lt]+1)-me.shape[1+lt];else for(let lt=0;lt<2;++lt)Wt[lt]=(me.shape[1+lt]-1)*It[lt]+et.shape[lt]+(et.shape[lt]-1)*(X[lt]-1)+Ct[lt]-me.shape[1+lt]*It[lt];if($t===m.a["same-upper"])for(let lt=0;lt<2;++lt)Gt[lt+1][0]=Wt[lt]-Math.ceil(Wt[lt]/2),Gt[lt+1][1]=Math.ceil(Wt[lt]/2);else for(let lt=0;lt<2;++lt)Gt[lt+1][0]=Wt[lt]-Math.floor(Wt[lt]/2),Gt[lt+1][1]=Math.floor(Wt[lt]/2)}return Gt}function G(me,et,rt,It,X,$t,Ct){const Gt=((rt+X-1)/X-1)*X+(It+(It-1)*(et-1)),Wt=Gt>rt?Gt-rt:0;switch(me){case m.a["same-upper"]:$t=Math.floor(Wt/2),Ct=Math.floor((Wt+1)/2);break;case m.a["same-lower"]:$t=Math.floor((Wt+1)/2),Ct=Math.floor(Wt/2)}return[$t,Ct]}function He(me,et){const rt=[],It=me.length,X=et.length,$t=Math.max(It,X);for(let Ct=0;Ct<$t;++Ct){let Gt=me[It-Ct-1];Gt===void 0&&(Gt=1);let Wt=et[X-Ct-1];if(Wt===void 0&&(Wt=1),Gt===1)rt.unshift(Wt);else if(Wt===1)rt.unshift(Gt);else{if(Gt!==Wt)throw new Error(`Shapes [${me}] and [${et}] are incompatible.`);rt.unshift(Gt)}}return rt}},function(I,n,e){e.r(n),e.d(n,"shuffle",function(){return m.M}),e.d(n,"shuffleCombo",function(){return m.N}),e.d(n,"clamp",function(){return m.i}),e.d(n,"nearestLargerEven",function(){return m.H}),e.d(n,"swap",function(){return m.S}),e.d(n,"sum",function(){return m.R}),e.d(n,"randUniform",function(){return m.J}),e.d(n,"distSquared",function(){return m.l}),e.d(n,"assert",function(){return m.b}),e.d(n,"assertShapesMatch",function(){return m.e}),e.d(n,"assertNonNull",function(){return m.d}),e.d(n,"flatten",function(){return m.m}),e.d(n,"sizeFromShape",function(){return m.O}),e.d(n,"isScalarShape",function(){return m.y}),e.d(n,"arraysEqual",function(){return m.a}),e.d(n,"isInt",function(){return m.v}),e.d(n,"tanh",function(){return m.T}),e.d(n,"sizeToSquarishShape",function(){return m.P}),e.d(n,"createShuffledIndices",function(){return m.k}),e.d(n,"rightPad",function(){return m.L}),e.d(n,"repeatedTry",function(){return m.K}),e.d(n,"inferFromImplicitShape",function(){return m.s}),e.d(n,"parseAxisParam",function(){return m.I}),e.d(n,"squeezeShape",function(){return m.Q}),e.d(n,"getTypedArrayFromDType",function(){return m.o}),e.d(n,"getArrayFromDType",function(){return m.n}),e.d(n,"checkConversionForErrors",function(){return m.h}),e.d(n,"isValidDtype",function(){return m.B}),e.d(n,"hasEncodingLoss",function(){return m.p}),e.d(n,"isTypedArray",function(){return m.A}),e.d(n,"bytesPerElement",function(){return m.g}),e.d(n,"bytesFromStringArray",function(){return m.f}),e.d(n,"isString",function(){return m.z}),e.d(n,"isBoolean",function(){return m.t}),e.d(n,"isNumber",function(){return m.w}),e.d(n,"inferDtype",function(){return m.r}),e.d(n,"isFunction",function(){return m.u}),e.d(n,"nearestDivisor",function(){return m.G}),e.d(n,"computeStrides",function(){return m.j}),e.d(n,"toNestedArray",function(){return m.U}),e.d(n,"makeOnesTypedArray",function(){return m.D}),e.d(n,"makeZerosTypedArray",function(){return m.F}),e.d(n,"makeZerosNestedTypedArray",function(){return m.E}),e.d(n,"assertNonNegativeIntegerDimensions",function(){return m.c}),e.d(n,"locToIndex",function(){return m.C}),e.d(n,"indexToLoc",function(){return m.q}),e.d(n,"isPromise",function(){return m.x}),e.d(n,"hexToLong",function(){return A}),e.d(n,"fingerPrint64",function(){return W}),e.d(n,"createScalarValue",function(){return de}),e.d(n,"toTypedArray",function(){return ke}),e.d(n,"now",function(){return Ie}),e.d(n,"fetch",function(){return he}),e.d(n,"encodeString",function(){return Q}),e.d(n,"decodeString",function(){return Se});var t=e(9),m=e(15),h=e(92);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=e.n(h).a||h;function A(Z){return b.fromString(Z,!0,16)}const D=A("c3a5c85c97cb3127"),y=A("b492b66fbe98f273"),E=A("9ae16a3b2f90404f");function S(Z){return Z.xor(Z.shru(47))}function l(Z,G,He){const me=Z.slice(G,G+He);return b.fromBytes(Array.from(me),!0,!0)}function B(Z,G){return l(Z,G,8)}function O(Z,G){return l(Z,G,4)}function V(Z,G){return G===0?Z:Z.shru(G).or(Z.shl(64-G))}function L(Z,G,He=A("9ddfea08eb382d69")){let me=Z.xor(G).mul(He);me=me.xor(me.shru(47));let et=G.xor(me).mul(He);return et=et.xor(et.shru(47)),et=et.mul(He),et}function g(Z,G,He,me){return function(et,rt,It,X,$t,Ct){$t=$t.add(et),Ct=V(Ct.add($t).add(X),21);const Gt=$t;return $t=($t=$t.add(rt)).add(It),Ct=Ct.add(V($t,44)),[$t.add(X),Ct.add(Gt)]}(B(Z,G),B(Z,G+8),B(Z,G+16),B(Z,G+24),He,me)}function W(Z,G=Z.length){const He=b.fromNumber(81,!0);if(G<=32)return G<=16?function(lt,Qt=lt.length){if(Qt>=8){const Ft=E.add(2*Qt),yn=B(lt,0).add(E),Nn=B(lt,Qt-8);return L(V(Nn,37).mul(Ft).add(yn),V(yn,25).add(Nn).mul(Ft),Ft)}if(Qt>=4){const Ft=E.add(2*Qt);return L(O(lt,0).shl(3).add(Qt),O(lt,Qt-4),Ft)}if(Qt>0){const Ft=lt[0]+(lt[Qt>>1]<<8),yn=Qt+(lt[Qt-1]<<2);return S(E.mul(Ft).xor(D.mul(yn))).mul(E)}return E}(Z,G):function(lt,Qt=lt.length){const Ft=E.add(2*Qt),yn=B(lt,0).mul(y),Nn=B(lt,8),Kn=B(lt,Qt-8).mul(Ft),zn=B(lt,Qt-16).mul(E);return L(V(yn.add(Nn),43).add(V(Kn,30)).add(zn),yn.add(V(Nn.add(E),18)).add(Kn),Ft)}(Z,G);if(G<=64)return function(lt,Qt=lt.length){const Ft=E.add(2*Qt),yn=B(lt,0).mul(E),Nn=B(lt,8),Kn=B(lt,Qt-8).mul(Ft),zn=B(lt,Qt-16).mul(E),sr=V(yn.add(Nn),43).add(V(Kn,30)).add(zn),K=L(sr,yn.add(V(Nn.add(E),18)).add(Kn),Ft),J=B(lt,16).mul(Ft),we=B(lt,24),vt=sr.add(B(lt,Qt-32)).mul(Ft),wt=K.add(B(lt,Qt-24)).mul(Ft);return L(V(J.add(we),43).add(V(vt,30)).add(wt),J.add(V(we.add(yn),18)).add(vt),Ft)}(Z,G);let me=He,et=He.mul(y).add(113),rt=S(et.mul(E).add(113)).mul(E),It=[b.UZERO,b.UZERO],X=[b.UZERO,b.UZERO];me=me.mul(E).add(B(Z,0));let $t=0;const Ct=64*(G-1>>6),Gt=Ct+(G-1&63)-63;do me=V(me.add(et).add(It[0]).add(B(Z,$t+8)),37).mul(y),et=V(et.add(It[1]).add(B(Z,$t+48)),42).mul(y),me=me.xor(X[1]),et=et.add(It[0]).add(B(Z,$t+40)),rt=V(rt.add(X[0]),33).mul(y),It=g(Z,$t,It[1].mul(y),me.add(X[0])),X=g(Z,$t+32,rt.add(X[1]),et.add(B(Z,$t+16))),[rt,me]=[me,rt],$t+=64;while($t!==Ct);const Wt=y.add(rt.and(255).shl(1));return $t=Gt,X[0]=X[0].add(G-1&63),It[0]=It[0].add(X[0]),X[0]=X[0].add(It[0]),me=V(me.add(et).add(It[0]).add(B(Z,$t+8)),37).mul(Wt),et=V(et.add(It[1]).add(B(Z,$t+48)),42).mul(Wt),me=me.xor(X[1].mul(9)),et=et.add(It[0].mul(9).add(B(Z,$t+40))),rt=V(rt.add(X[0]),33).mul(Wt),It=g(Z,$t,It[1].mul(Wt),me.add(X[0])),X=g(Z,$t+32,rt.add(X[1]),et.add(B(Z,$t+16))),[rt,me]=[me,rt],L(L(It[0],X[0],Wt).add(S(et).mul(D)).add(rt),L(It[1],X[1],Wt).add(me),Wt)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(Z,G){return G==="string"?Q(Z):ke([Z],G)}function ke(Z,G){if(G==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(Z)&&(Z=m.m(Z)),Object(t.c)().getBool("DEBUG")&&m.h(Z,G),function(He,me){return He instanceof Float32Array&&me==="float32"||He instanceof Int32Array&&me==="int32"||He instanceof Uint8Array&&me==="bool"}(Z,G))return Z;if(G==null||G==="float32"||G==="complex64")return new Float32Array(Z);if(G==="int32")return new Int32Array(Z);if(G==="bool"){const He=new Uint8Array(Z.length);for(let me=0;me<He.length;++me)Math.round(Z[me])!==0&&(He[me]=1);return He}throw new Error(`Unknown data type ${G}`)}function Ie(){return Object(t.c)().platform.now()}function he(Z,G){return Object(t.c)().platform.fetch(Z,G)}function Q(Z,G="utf-8"){return G=G||"utf-8",Object(t.c)().platform.encode(Z,G)}function Se(Z,G="utf-8"){return G=G||"utf-8",Object(t.c)().platform.decode(Z,G)}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b){Array.isArray(h)||(h=[h]),h.forEach(A=>{A!=null&&t.util.assert(A.dtype!=="complex64",()=>`${b} does not support complex64 tensors in the CPU backend.`)})}},function(I,n,e){e.d(n,"a",function(){return h}),e.d(n,"b",function(){return b});var t=e(0),m=e(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(A,D,y){return({inputs:E,attrs:S,backend:l})=>{const{x:B}=E;if(Object(m.a)(B,A),B.dtype==="string"||y==="string")throw new Error("unaryKernelFunc does not support string input/output");const O=l,V=O.data.get(B.dataId).values,L=t.util.sizeFromShape(B.shape),g=y||B.dtype,W=t.util.getArrayFromDType(g,L);for(let de=0;de<L;++de)W[de]=D(V[de],S);return O.makeTensorInfo(B.shape,g,W)}}function b(A,D,y){return({inputs:E,attrs:S,backend:l})=>{const{x:B}=E;if(Object(m.a)(B,A),B.dtype==="string"||y==="string")throw new Error("unaryKernelFunc does not support string input/output");const O=l,V=O.data.get(B.dataId).values,L=y||B.dtype,g=D(V,L,S);return O.makeTensorInfo(B.shape,L,g)}}},function(I,n,e){e.d(n,"b",function(){return h}),e.d(n,"c",function(){return A}),e.d(n,"a",function(){return D}),e.d(n,"d",function(){return y});var t=e(15);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m="tfjsflags";class h{constructor(S){this.global=S,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=b,this.populateURLFlags()}setPlatform(S,l){this.platform!=null&&(A().getBool("IS_TEST")||A().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${S}.`)),this.platformName=S,this.platform=l}registerFlag(S,l,B){if(this.flagRegistry[S]={evaluationFn:l,setHook:B},this.urlFlags[S]!=null){const O=this.urlFlags[S];A().getBool("IS_TEST")||A().getBool("PROD")||console.warn(`Setting feature override from URL ${S}: ${O}.`),this.set(S,O)}}async getAsync(S){return S in this.flags||(this.flags[S]=await this.evaluateFlag(S)),this.flags[S]}get(S){if(S in this.flags)return this.flags[S];const l=this.evaluateFlag(S);if(Object(t.x)(l))throw new Error(`Flag ${S} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[S]=l,this.flags[S]}getNumber(S){return this.get(S)}getBool(S){return this.get(S)}getFlags(){return this.flags}get features(){return this.flags}set(S,l){if(this.flagRegistry[S]==null)throw new Error(`Cannot set flag ${S} as it has not been registered.`);this.flags[S]=l,this.flagRegistry[S].setHook!=null&&this.flagRegistry[S].setHook(l)}evaluateFlag(S){if(this.flagRegistry[S]==null)throw new Error(`Cannot evaluate flag '${S}': no evaluation function found.`);return this.flagRegistry[S].evaluationFn()}setFlags(S){this.flags=Object.assign({},S)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const S=this.getQueryParams(this.global.location.search);m in S&&S.tfjsflags.split(",").forEach(l=>{const[B,O]=l.split(":");this.urlFlags[B]=function(V,L){if((L=L.toLowerCase())==="true"||L==="false")return L==="true";if(""+ +L===L)return+L;throw new Error(`Could not parse value flag value ${L} for flag ${V}.`)}(B,O)})}}function b(E){const S={};return E.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(l,...B)=>(function(O,V,L){O[decodeURIComponent(V)]=decodeURIComponent(L||"")}(S,B[0],B[1]),B.join("="))),S}function A(){return D}let D=null;function y(E){D=E}},function(I,n,e){e.r(n),e.d(n,"makeTypesMatch",function(){return b}),e.d(n,"assertTypesMatch",function(){return A}),e.d(n,"isTensorInList",function(){return D}),e.d(n,"getTensorsInContainer",function(){return y});var t=e(14),m=e(34),h=e(15);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(S,l){if(S.dtype===l.dtype)return[S,l];const B=Object(m.c)(S.dtype,l.dtype);return[S.cast(B),l.cast(B)]}function A(S,l){Object(h.b)(S.dtype===l.dtype,()=>`The dtypes of the first(${S.dtype}) and second(${l.dtype}) input must match`)}function D(S,l){return l.some(B=>B.id===S.id)}function y(S){const l=[];return E(S,l,new Set),l}function E(S,l,B){if(S==null)return;if(S instanceof t.a)return void l.push(S);if(O=S,!Array.isArray(O)&&typeof O!="object")return;var O;const V=S;for(const L in V){const g=V[L];B.has(g)||(B.add(g),E(g,l,B))}}},function(I,n,e){e.d(n,"d",function(){return t}),e.d(n,"c",function(){return h}),e.d(n,"b",function(){return b}),e.d(n,"a",function(){return A}),e.d(n,"e",function(){return D});var t,m=e(5);(function(y){y.float32="float32",y.float16="float16",y.int32="int32",y.uint32="uint32",y.int8="int8",y.uint8="uint8"})(t||(t={}));class h{get builder(){return this.builder_}constructor(E){this.builder_=E}}class b extends h{constructor(E,S,l){super(l),m.a(typeof E=="string","The name parameter is invalid"),this.name=E,m.s(S),this.desc=S}}class A extends h{static createScalar(E,S=t.float32,l){return m.a(S in t,"The operand type is invalid."),m.v(E,S),new A({type:S},E,l)}static createTensor(E,S,l){m.a(m.m(S),"Only ArrayBufferView value type is supported.");const B=S;return m.s(E),m.u(B,E.type,E.dimensions),new A(E,B.slice(),l)}constructor(E,S,l){super(l),this.desc=E,this.value=S}}class D extends h{constructor(E){super(E.builder),this.operation=E}}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h){return(b,A,D,y,E)=>{const S=t.backend_util.assertAndGetBroadcastShape(b,A),l=S.length,B=t.util.computeStrides(S),O=t.util.sizeFromShape(S),V=t.util.getTypedArrayFromDType(E,O),L=b.length,g=A.length,W=t.util.computeStrides(b),de=t.util.computeStrides(A),ke=t.backend_util.getBroadcastDims(b,S),Ie=t.backend_util.getBroadcastDims(A,S);if(ke.length+Ie.length===0)for(let he=0;he<V.length;++he)V[he]=h(D[he%D.length],y[he%y.length]);else for(let he=0;he<V.length;++he){const Q=t.util.indexToLoc(he,l,B),Se=Q.slice(-L);ke.forEach(me=>Se[me]=0);const Z=t.util.locToIndex(Se,L,W),G=Q.slice(-g);Ie.forEach(me=>G[me]=0);const He=t.util.locToIndex(G,g,de);V[he]=h(D[Z],y[He])}return[V,S]}}},function(I,n,e){e.d(n,"a",function(){return A}),e.d(n,"b",function(){return D});var t=e(0),m=e(7),h=e(25),b=e(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A(y,E,S,l){return S==null?({inputs:B,backend:O})=>{const{a:V,b:L}=B,g=O;Object(m.a)([V,L],y);const W=g.data.get(V.dataId).values,de=g.data.get(L.dataId).values,ke=V.dtype==="string"?t.backend_util.fromUint8ToStringArray(W):W,Ie=V.dtype==="string"?t.backend_util.fromUint8ToStringArray(de):de,he=l||V.dtype,[Q,Se]=E(V.shape,L.shape,ke,Ie,he);return g.makeTensorInfo(Se,he,Q)}:({inputs:B,backend:O})=>{const{a:V,b:L}=B,g=O;if(V.dtype==="complex64"||L.dtype==="complex64"){const W=Object(h.a)({inputs:{x:V},backend:g,attrs:{dtype:"complex64"}}),de=g.data.get(W.dataId),ke=de.complexTensorInfos.real,Ie=de.complexTensorInfos.imag,he=g.data.get(ke.dataId).values,Q=g.data.get(Ie.dataId).values,Se=Object(h.a)({inputs:{x:L},backend:g,attrs:{dtype:"complex64"}}),Z=g.data.get(Se.dataId),G=Z.complexTensorInfos.real,He=Z.complexTensorInfos.imag,me=g.data.get(G.dataId).values,et=g.data.get(He.dataId).values,[rt,It,X]=S(V.shape,L.shape,he,Q,me,et),$t=g.makeTensorInfo(X,"float32",rt),Ct=g.makeTensorInfo(X,"float32",It),Gt=Object(b.a)({inputs:{real:$t,imag:Ct},backend:g});return g.disposeIntermediateTensorInfo(W),g.disposeIntermediateTensorInfo(Se),g.disposeIntermediateTensorInfo($t),g.disposeIntermediateTensorInfo(Ct),Gt}{const W=g.data.get(V.dataId).values,de=g.data.get(L.dataId).values,ke=l||V.dtype,[Ie,he]=E(V.shape,L.shape,W,de,ke);return g.makeTensorInfo(he,ke,Ie)}}}function D(y){return(E,S,l,B,O,V)=>{const L=t.backend_util.assertAndGetBroadcastShape(E,S),g=t.util.sizeFromShape(L),W=L.length,de=t.util.computeStrides(L),ke=t.util.getTypedArrayFromDType("float32",g),Ie=t.util.getTypedArrayFromDType("float32",g),he=t.backend_util.getBroadcastDims(E,L),Q=t.backend_util.getBroadcastDims(S,L),Se=t.backend_util.mergeRealAndImagArrays(l,B),Z=t.backend_util.mergeRealAndImagArrays(O,V),G=E.length,He=t.util.computeStrides(E),me=S.length,et=t.util.computeStrides(S);if(he.length+Q.length===0)for(let rt=0;rt<ke.length;rt++){const It=rt%Se.length,X=rt%Z.length,$t=y(Se[2*It],Se[2*It+1],Z[2*X],Z[2*X+1]);ke[rt]=$t.real,Ie[rt]=$t.imag}else for(let rt=0;rt<ke.length;rt++){const It=t.util.indexToLoc(rt,W,de),X=It.slice(-G);he.forEach(lt=>X[lt]=0);const $t=t.util.locToIndex(X,G,He),Ct=It.slice(-me);Q.forEach(lt=>Ct[lt]=0);const Gt=t.util.locToIndex(Ct,me,et),Wt=y(Se[2*$t],Se[2*$t+1],Z[2*Gt],Z[2*Gt+1]);ke[rt]=Wt.real,Ie[rt]=Wt.imag}return[ke,Ie,L]}}},function(I,n,e){e.d(n,"b",function(){return S}),e.d(n,"f",function(){return O}),e.d(n,"e",function(){return V}),e.d(n,"d",function(){return L}),e.d(n,"a",function(){return g}),e.d(n,"c",function(){return W});var t=e(38),m=e(15);function h(de,ke,Ie,he){const Q=Object(m.j)(ke),Se=function(me,et,rt,It){const X=Object(m.O)(et),$t=It[It.length-1],Ct=new Array($t).fill(0),Gt=et.length,Wt=rt==="complex64"?y(me):me;if(Gt>1)for(let lt=0;lt<X/$t;lt++){const Qt=lt*$t;for(let Ft=0;Ft<$t;Ft++)Ct[Ft]=Math.max(Ct[Ft],b(Wt[Qt+Ft],0,rt).length)}return Ct}(de,ke,Ie,Q),Z=ke.length,G=D(de,ke,Ie,Q,Se),He=["Tensor"];return he&&(He.push(`  dtype: ${Ie}`),He.push(`  rank: ${Z}`),He.push(`  shape: [${ke}]`),He.push("  values:")),He.push(G.map(me=>"    "+me).join(`
`)),He.join(`
`)}function b(de,ke,Ie){let he;return he=Array.isArray(de)?`${parseFloat(de[0].toFixed(7))} + ${parseFloat(de[1].toFixed(7))}j`:Object(m.z)(de)?`'${de}'`:Ie==="bool"?A(de):parseFloat(de.toFixed(7)).toString(),Object(m.L)(he,ke)}function A(de){return de===0?"false":"true"}function D(de,ke,Ie,he,Q,Se=!0){const Z=Ie==="complex64"?2:1,G=ke[0],He=ke.length;if(He===0)return Ie==="complex64"?[b(y(de)[0],0,Ie)]:Ie==="bool"?[A(de[0])]:[de[0].toString()];if(He===1){if(G>20){const Ct=3*Z;let Gt=Array.from(de.slice(0,Ct)),Wt=Array.from(de.slice((G-3)*Z,G*Z));return Ie==="complex64"&&(Gt=y(Gt),Wt=y(Wt)),["["+Gt.map((lt,Qt)=>b(lt,Q[Qt],Ie)).join(", ")+", ..., "+Wt.map((lt,Qt)=>b(lt,Q[G-3+Qt],Ie)).join(", ")+"]"]}return["["+(Ie==="complex64"?y(de):Array.from(de)).map((Ct,Gt)=>b(Ct,Q[Gt],Ie)).join(", ")+"]"]}const me=ke.slice(1),et=he.slice(1),rt=he[0]*Z,It=[];if(G>20){for(let Ct=0;Ct<3;Ct++){const Gt=Ct*rt,Wt=Gt+rt;It.push(...D(de.slice(Gt,Wt),me,Ie,et,Q,!1))}It.push("...");for(let Ct=G-3;Ct<G;Ct++){const Gt=Ct*rt,Wt=Gt+rt;It.push(...D(de.slice(Gt,Wt),me,Ie,et,Q,Ct===G-1))}}else for(let Ct=0;Ct<G;Ct++){const Gt=Ct*rt,Wt=Gt+rt;It.push(...D(de.slice(Gt,Wt),me,Ie,et,Q,Ct===G-1))}const X=He===2?",":"";It[0]="["+It[0]+X;for(let Ct=1;Ct<It.length-1;Ct++)It[Ct]=" "+It[Ct]+X;let $t=`,
`;for(let Ct=2;Ct<He;Ct++)$t+=`
`;return It[It.length-1]=" "+It[It.length-1]+"]"+(Se?"":$t),It}function y(de){const ke=[];for(let Ie=0;Ie<de.length;Ie+=2)ke.push([de[Ie],de[Ie+1]]);return ke}var E=e(6);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S{constructor(ke,Ie,he){if(this.dtype=Ie,this.shape=ke.slice(),this.size=m.O(ke),he!=null){const Q=he.length;m.b(Q===this.size,()=>`Length of values '${Q}' does not match the size inferred by the shape '${this.size}'.`)}if(Ie==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=he||m.n(Ie,this.size),this.strides=Object(m.j)(ke)}set(ke,...Ie){Ie.length===0&&(Ie=[0]),m.b(Ie.length===this.rank,()=>`The number of provided coordinates (${Ie.length}) must match the rank (${this.rank})`);const he=this.locToIndex(Ie);this.values[he]=ke}get(...ke){ke.length===0&&(ke=[0]);let Ie=0;for(const Q of ke){if(Q<0||Q>=this.shape[Ie]){const Se=`Requested out of range element at ${ke}.   Buffer shape=${this.shape}`;throw new Error(Se)}Ie++}let he=ke[ke.length-1];for(let Q=0;Q<ke.length-1;++Q)he+=this.strides[Q]*ke[Q];return this.values[he]}locToIndex(ke){if(this.rank===0)return 0;if(this.rank===1)return ke[0];let Ie=ke[ke.length-1];for(let he=0;he<ke.length-1;++he)Ie+=this.strides[he]*ke[he];return Ie}indexToLoc(ke){if(this.rank===0)return[];if(this.rank===1)return[ke];const Ie=new Array(this.shape.length);for(let he=0;he<Ie.length-1;++he)Ie[he]=Math.floor(ke/this.strides[he]),ke-=Ie[he]*this.strides[he];return Ie[Ie.length-1]=ke,Ie}get rank(){return this.shape.length}toTensor(){return l().makeTensor(this.values,this.shape,this.dtype)}}let l=null,B=null;function O(de){l=de}function V(de){B=de}function L(de){}class g{constructor(ke,Ie,he,Q){this.kept=!1,this.isDisposedInternal=!1,this.shape=ke.slice(),this.dtype=Ie||"float32",this.size=m.O(ke),this.strides=Object(m.j)(ke),this.dataId=he,this.id=Q,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const ke=await this.data();return B.buffer(this.shape,this.dtype,ke)}bufferSync(){return B.buffer(this.shape,this.dtype,this.dataSync())}async array(){const ke=await this.data();return Object(m.U)(this.shape,ke,this.dtype==="complex64")}arraySync(){return Object(m.U)(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const ke=l().read(this.dataId);if(this.dtype==="string"){const Ie=await ke;try{return Ie.map(he=>E.decodeString(he))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return ke}dataToGPU(ke){return this.throwIfDisposed(),l().readToGPU(this.dataId,ke)}dataSync(){this.throwIfDisposed();const ke=l().readSync(this.dataId);if(this.dtype==="string")try{return ke.map(Ie=>E.decodeString(Ie))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ke}async bytes(){this.throwIfDisposed();const ke=await l().read(this.dataId);return this.dtype==="string"?ke:new Uint8Array(ke.buffer)}dispose(){this.isDisposed||(l().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ke=!1){return B.print(this,ke)}clone(){return this.throwIfDisposed(),B.clone(this)}toString(ke=!1){return h(this.dataSync(),this.shape,this.dtype,ke)}cast(ke){return this.throwIfDisposed(),B.cast(this,ke)}variable(ke=!0,Ie,he){return this.throwIfDisposed(),l().makeVariable(this,ke,Ie,he)}}Object.defineProperty(g,Symbol.hasInstance,{value:de=>!!de&&de.data!=null&&de.dataSync!=null&&de.throwIfDisposed!=null}),Object(t.a)("Tensor",()=>g);class W extends g{constructor(ke,Ie,he,Q){super(ke.shape,ke.dtype,ke.dataId,Q),this.trainable=Ie,this.name=he}assign(ke){if(ke.dtype!==this.dtype)throw new Error(`dtype of the new value (${ke.dtype}) and previous value (${this.dtype}) must match`);if(!m.a(ke.shape,this.shape))throw new Error(`shape of the new value (${ke.shape}) and previous value (${this.shape}) must match`);l().disposeTensor(this),this.dataId=ke.dataId,l().incRef(this,null)}dispose(){l().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(W,Symbol.hasInstance,{value:de=>de instanceof g&&de.assign!=null&&de.assign instanceof Function})},function(I,n,e){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t(Ae){let mt=Ae.length,Mt=0;for(;mt>0;)Mt=Math.random()*mt|0,mt--,A(Ae,mt,Mt)}function m(Ae,mt){if(Ae.length!==mt.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Ae.length}Second array length was ${mt.length}`);let Mt=Ae.length,Nt=0;for(;Mt>0;)Nt=Math.random()*Mt|0,Mt--,A(Ae,Mt,Nt),A(mt,Mt,Nt)}function h(Ae,mt,Mt){return Math.max(Ae,Math.min(mt,Mt))}function b(Ae){return Ae%2==0?Ae:Ae+1}function A(Ae,mt,Mt){const Nt=Ae[mt];Ae[mt]=Ae[Mt],Ae[Mt]=Nt}function D(Ae){let mt=0;for(let Mt=0;Mt<Ae.length;Mt++)mt+=Ae[Mt];return mt}function y(Ae,mt){const Mt=Math.random();return mt*Mt+(1-Mt)*Ae}function E(Ae,mt){let Mt=0;for(let Nt=0;Nt<Ae.length;Nt++){const un=Number(Ae[Nt])-Number(mt[Nt]);Mt+=un*un}return Mt}function S(Ae,mt){if(!Ae)throw new Error(typeof mt=="string"?mt:mt())}function l(Ae,mt,Mt=""){S(g(Ae,mt),()=>Mt+` Shapes ${Ae} and ${mt} must match`)}function B(Ae){S(Ae!=null,()=>"The input to the tensor constructor must be a non-null value.")}function O(Ae,mt=[],Mt=!1){if(mt==null&&(mt=[]),Array.isArray(Ae)||X(Ae)&&!Mt)for(let Nt=0;Nt<Ae.length;++Nt)O(Ae[Nt],mt,Mt);else mt.push(Ae);return mt}function V(Ae){if(Ae.length===0)return 1;let mt=Ae[0];for(let Mt=1;Mt<Ae.length;Mt++)mt*=Ae[Mt];return mt}function L(Ae){return Ae.length===0}function g(Ae,mt){if(Ae===mt)return!0;if(Ae==null||mt==null||Ae.length!==mt.length)return!1;for(let Mt=0;Mt<Ae.length;Mt++)if(Ae[Mt]!==mt[Mt])return!1;return!0}function W(Ae){return Ae%1==0}function de(Ae){if(Math.tanh!=null)return Math.tanh(Ae);if(Ae===1/0)return 1;if(Ae===-1/0)return-1;{const mt=Math.exp(2*Ae);return(mt-1)/(mt+1)}}function ke(Ae){const mt=Math.ceil(Math.sqrt(Ae));return[mt,Math.ceil(Ae/mt)]}function Ie(Ae){const mt=new Uint32Array(Ae);for(let Mt=0;Mt<Ae;++Mt)mt[Mt]=Mt;return t(mt),mt}function he(Ae,mt){return mt<=Ae.length?Ae:Ae+" ".repeat(mt-Ae.length)}function Q(Ae,mt=Nt=>0,Mt){return new Promise((Nt,un)=>{let Rn=0;const oe=()=>{if(Ae())return void Nt();Rn++;const le=mt(Rn);Mt!=null&&Rn>=Mt?un():setTimeout(oe,le)};oe()})}function Se(Ae,mt){let Mt=1,Nt=-1;for(let Rn=0;Rn<Ae.length;++Rn)if(Ae[Rn]>=0)Mt*=Ae[Rn];else if(Ae[Rn]===-1){if(Nt!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Nt} and dim ${Rn}`);Nt=Rn}else if(Ae[Rn]<0)throw Error(`Shapes can not be < 0. Found ${Ae[Rn]} at dim ${Rn}`);if(Nt===-1){if(mt>0&&mt!==Mt)throw Error(`Size(${mt}) must match the product of shape ${Ae}`);return Ae}if(Mt===0)throw Error(`Cannot infer the missing size in [${Ae}] when there are 0 elements`);if(mt%Mt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${mt} / ${Mt}`);const un=Ae.slice();return un[Nt]=mt/Mt,un}function Z(Ae,mt){const Mt=mt.length;return S((Ae=Ae==null?mt.map((Nt,un)=>un):[].concat(Ae)).every(Nt=>Nt>=-Mt&&Nt<Mt),()=>`All values in axis param must be in range [-${Mt}, ${Mt}) but got axis ${Ae}`),S(Ae.every(Nt=>W(Nt)),()=>`All values in axis param must be integers but got axis ${Ae}`),Ae.map(Nt=>Nt<0?Mt+Nt:Nt)}function G(Ae,mt){const Mt=[],Nt=[],un=mt!=null&&Array.isArray(mt)&&mt.length===0,Rn=mt==null||un?null:Z(mt,Ae).sort();let oe=0;for(let le=0;le<Ae.length;++le){if(Rn!=null){if(Rn[oe]===le&&Ae[le]!==1)throw new Error(`Can't squeeze axis ${le} since its dim '${Ae[le]}' is not 1`);(Rn[oe]==null||Rn[oe]>le)&&Ae[le]===1&&(Mt.push(Ae[le]),Nt.push(le)),Rn[oe]<=le&&oe++}Ae[le]!==1&&(Mt.push(Ae[le]),Nt.push(le))}return{newShape:Mt,keptDims:Nt}}function He(Ae,mt){let Mt=null;if(Ae==null||Ae==="float32")Mt=new Float32Array(mt);else if(Ae==="int32")Mt=new Int32Array(mt);else{if(Ae!=="bool")throw new Error(`Unknown data type ${Ae}`);Mt=new Uint8Array(mt)}return Mt}function me(Ae,mt){let Mt=null;if(Ae==null||Ae==="float32")Mt=new Float32Array(mt);else if(Ae==="int32")Mt=new Int32Array(mt);else if(Ae==="bool")Mt=new Uint8Array(mt);else{if(Ae!=="string")throw new Error(`Unknown data type ${Ae}`);Mt=new Array(mt)}return Mt}function et(Ae,mt){for(let Mt=0;Mt<Ae.length;Mt++){const Nt=Ae[Mt];if(isNaN(Nt)||!isFinite(Nt))throw Error(`A tensor of type ${mt} being uploaded contains ${Nt}.`)}}function rt(Ae){return Ae==="bool"||Ae==="complex64"||Ae==="float32"||Ae==="int32"||Ae==="string"}function It(Ae,mt){return mt!=="complex64"&&(mt!=="float32"||Ae==="complex64")&&(mt!=="int32"||Ae==="float32"||Ae==="complex64")&&(mt!=="bool"||Ae!=="bool")}function X(Ae){return Ae instanceof Float32Array||Ae instanceof Int32Array||Ae instanceof Uint8Array||Ae instanceof Uint8ClampedArray}function $t(Ae){if(Ae==="float32"||Ae==="int32")return 4;if(Ae==="complex64")return 8;if(Ae==="bool")return 1;throw new Error(`Unknown dtype ${Ae}`)}function Ct(Ae){if(Ae==null)return 0;let mt=0;return Ae.forEach(Mt=>mt+=Mt.length),mt}function Gt(Ae){return typeof Ae=="string"||Ae instanceof String}function Wt(Ae){return typeof Ae=="boolean"}function lt(Ae){return typeof Ae=="number"}function Qt(Ae){return Array.isArray(Ae)?Qt(Ae[0]):Ae instanceof Float32Array?"float32":Ae instanceof Int32Array||Ae instanceof Uint8Array||Ae instanceof Uint8ClampedArray?"int32":lt(Ae)?"float32":Gt(Ae)?"string":Wt(Ae)?"bool":"float32"}function Ft(Ae){return!!(Ae&&Ae.constructor&&Ae.call&&Ae.apply)}function yn(Ae,mt){for(let Mt=mt;Mt<Ae;++Mt)if(Ae%Mt==0)return Mt;return Ae}function Nn(Ae){const mt=Ae.length;if(mt<2)return[];const Mt=new Array(mt-1);Mt[mt-2]=Ae[mt-1];for(let Nt=mt-3;Nt>=0;--Nt)Mt[Nt]=Mt[Nt+1]*Ae[Nt+1];return Mt}function Kn(Ae,mt,Mt,Nt=!1){const un=new Array;if(mt.length===1){const Rn=mt[0]*(Nt?2:1);for(let oe=0;oe<Rn;oe++)un[oe]=Mt[Ae+oe]}else{const Rn=mt[0],oe=mt.slice(1),le=oe.reduce((qe,Mn)=>qe*Mn)*(Nt?2:1);for(let qe=0;qe<Rn;qe++)un[qe]=Kn(Ae+qe*le,oe,Mt,Nt)}return un}function zn(Ae,mt,Mt=!1){if(Ae.length===0)return mt[0];const Nt=Ae.reduce((un,Rn)=>un*Rn)*(Mt?2:1);if(Nt===0)return[];if(Nt!==mt.length)throw new Error(`[${Ae}] does not match the input size ${mt.length}${Mt?" for a complex tensor":""}.`);return Kn(0,Ae,mt,Mt)}function sr(Ae,mt){const Mt=K(Ae,mt);for(let Nt=0;Nt<Mt.length;Nt++)Mt[Nt]=1;return Mt}function K(Ae,mt){if(mt==null||mt==="float32"||mt==="complex64")return new Float32Array(Ae);if(mt==="int32")return new Int32Array(Ae);if(mt==="bool")return new Uint8Array(Ae);throw new Error(`Unknown data type ${mt}`)}function J(Ae,mt){const Mt=Ae.reduce((Nt,un)=>Nt*un,1);if(mt==null||mt==="float32")return zn(Ae,new Float32Array(Mt));if(mt==="int32")return zn(Ae,new Int32Array(Mt));if(mt==="bool")return zn(Ae,new Uint8Array(Mt));throw new Error(`Unknown data type ${mt}`)}function we(Ae){Ae.forEach(mt=>{S(Number.isInteger(mt)&&mt>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Ae}].`)})}function vt(Ae,mt,Mt){if(mt===0)return 0;if(mt===1)return Ae[0];let Nt=Ae[Ae.length-1];for(let un=0;un<Ae.length-1;++un)Nt+=Mt[un]*Ae[un];return Nt}function wt(Ae,mt,Mt){if(mt===0)return[];if(mt===1)return[Ae];const Nt=new Array(mt);for(let un=0;un<Nt.length-1;++un)Nt[un]=Math.floor(Ae/Mt[un]),Ae-=Nt[un]*Mt[un];return Nt[Nt.length-1]=Ae,Nt}function Ot(Ae){return Ae&&Ae.then&&typeof Ae.then=="function"}e.d(n,"M",function(){return t}),e.d(n,"N",function(){return m}),e.d(n,"i",function(){return h}),e.d(n,"H",function(){return b}),e.d(n,"S",function(){return A}),e.d(n,"R",function(){return D}),e.d(n,"J",function(){return y}),e.d(n,"l",function(){return E}),e.d(n,"b",function(){return S}),e.d(n,"e",function(){return l}),e.d(n,"d",function(){return B}),e.d(n,"m",function(){return O}),e.d(n,"O",function(){return V}),e.d(n,"y",function(){return L}),e.d(n,"a",function(){return g}),e.d(n,"v",function(){return W}),e.d(n,"T",function(){return de}),e.d(n,"P",function(){return ke}),e.d(n,"k",function(){return Ie}),e.d(n,"L",function(){return he}),e.d(n,"K",function(){return Q}),e.d(n,"s",function(){return Se}),e.d(n,"I",function(){return Z}),e.d(n,"Q",function(){return G}),e.d(n,"o",function(){return He}),e.d(n,"n",function(){return me}),e.d(n,"h",function(){return et}),e.d(n,"B",function(){return rt}),e.d(n,"p",function(){return It}),e.d(n,"A",function(){return X}),e.d(n,"g",function(){return $t}),e.d(n,"f",function(){return Ct}),e.d(n,"z",function(){return Gt}),e.d(n,"t",function(){return Wt}),e.d(n,"w",function(){return lt}),e.d(n,"r",function(){return Qt}),e.d(n,"u",function(){return Ft}),e.d(n,"G",function(){return yn}),e.d(n,"j",function(){return Nn}),e.d(n,"U",function(){return zn}),e.d(n,"D",function(){return sr}),e.d(n,"F",function(){return K}),e.d(n,"E",function(){return J}),e.d(n,"c",function(){return we}),e.d(n,"C",function(){return vt}),e.d(n,"q",function(){return wt}),e.d(n,"x",function(){return Ot})},function(I,n,e){e.d(n,"a",function(){return b}),e.d(n,"b",function(){return A});var t=e(0),m=e(7),h=e(46);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(D){const{inputs:y,attrs:E,backend:S}=D,{x:l}=y,{perm:B}=E;Object(m.a)(l,"transpose");const O=l.shape.length,V=new Array(O);for(let W=0;W<V.length;W++)V[W]=l.shape[B[W]];const L=S.data.get(l.dataId).values,g=Object(h.a)(L,l.shape,l.dtype,B,V);return{dataId:S.write(g,V,l.dtype),shape:V,dtype:l.dtype}}const A={kernelName:t.Transpose,backendName:"cpu",kernelFunc:b}},function(I,n,e){(function(t){e.d(n,"f",function(){return D}),e.d(n,"e",function(){return y}),e.d(n,"a",function(){return B}),e.d(n,"b",function(){return O}),e.d(n,"d",function(){return V}),e.d(n,"c",function(){return L}),e.d(n,"i",function(){return g}),e.d(n,"g",function(){return W}),e.d(n,"h",function(){return de});var m=e(22),h=e(32),b=e(15),A=e(52);async function D(Ie,he){const Q=[],Se=[],Z=Array.isArray(Ie)?Ie.map(G=>G.name):Object.keys(Ie);for(let G=0;G<Z.length;++G){const He=Z[G],me=Array.isArray(Ie)?Ie[G].tensor:Ie[He];if(me.dtype!=="float32"&&me.dtype!=="int32"&&me.dtype!=="bool"&&me.dtype!=="string"&&me.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${He}': ${me.dtype}`);const et={name:He,shape:me.shape,dtype:me.dtype};if(me.dtype==="string"){const rt=new Promise(async It=>{const X=await me.bytes(),$t=X.reduce((Wt,lt)=>Wt+lt.length,0)+4*X.length,Ct=new Uint8Array($t);let Gt=0;for(let Wt=0;Wt<X.length;Wt++){const lt=X[Wt],Qt=new Uint8Array(new Uint32Array([lt.length]).buffer);Ct.set(Qt,Gt),Gt+=4,Ct.set(lt,Gt),Gt+=lt.length}It(Ct)});Se.push(rt)}else Se.push(me.data());he!=null&&(et.group=he),Q.push(et)}return{data:E(await Promise.all(Se)),specs:Q}}function y(Ie,he){const Q={};let Se,Z=0;for(const G of he){const He=G.name,me=G.dtype,et=G.shape,rt=Object(b.O)(et);let It;if("quantization"in G){const X=G.quantization;if(X.dtype==="uint8"||X.dtype==="uint16"){if(!("min"in X)||!("scale"in X))throw new Error(`Weight ${G.name} with quantization ${X.dtype} doesn't have corresponding metadata min and scale.`)}else{if(X.dtype!=="float16")throw new Error(`Weight ${G.name} has unknown quantization dtype ${X.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if(me!=="float32")throw new Error(`Weight ${G.name} is quantized with ${X.dtype} which only supports weights of type float32 not ${me}.`)}const $t=A.a[X.dtype],Ct=Ie.slice(Z,Z+rt*$t),Gt=X.dtype==="uint8"?new Uint8Array(Ct):new Uint16Array(Ct);if(me==="float32")if(X.dtype==="uint8"||X.dtype==="uint16"){It=new Float32Array(Gt.length);for(let Wt=0;Wt<Gt.length;Wt++){const lt=Gt[Wt];It[Wt]=lt*X.scale+X.min}}else{if(X.dtype!=="float16")throw new Error(`Unsupported quantization type ${X.dtype} for weight type float32.`);Se===void 0&&(Se=ke()),It=Se(Gt)}else{if(me!=="int32")throw new Error(`Unsupported dtype in weight '${He}': ${me}`);if(X.dtype!=="uint8"&&X.dtype!=="uint16")throw new Error(`Unsupported quantization type ${X.dtype} for weight type int32.`);It=new Int32Array(Gt.length);for(let Wt=0;Wt<Gt.length;Wt++){const lt=Gt[Wt];It[Wt]=Math.round(lt*X.scale+X.min)}}Z+=rt*$t}else if(me==="string"){const X=Object(b.O)(G.shape);It=[];for(let $t=0;$t<X;$t++){const Ct=new Uint32Array(Ie.slice(Z,Z+4))[0];Z+=4;const Gt=new Uint8Array(Ie.slice(Z,Z+Ct));It.push(Gt),Z+=Ct}}else{const X=A.a[me],$t=Ie.slice(Z,Z+rt*X);if(me==="float32")It=new Float32Array($t);else if(me==="int32")It=new Int32Array($t);else if(me==="bool")It=new Uint8Array($t);else{if(me!=="complex64")throw new Error(`Unsupported dtype in weight '${He}': ${me}`);{It=new Float32Array($t);const Ct=new Float32Array(It.length/2),Gt=new Float32Array(It.length/2);for(let Qt=0;Qt<Ct.length;Qt++)Ct[Qt]=It[2*Qt],Gt[Qt]=It[2*Qt+1];const Wt=Object(h.a)(Ct,et,"float32"),lt=Object(h.a)(Gt,et,"float32");Q[He]=Object(m.a)(Wt,lt),Wt.dispose(),lt.dispose()}}Z+=rt*X}me!=="complex64"&&(Q[He]=Object(h.a)(It,et,me))}return Q}function E(Ie){if(Ie===null)throw new Error(`Invalid input value: ${JSON.stringify(Ie)}`);let he=0;const Q=[];Ie.forEach(G=>{if(he+=G.byteLength,Q.push(G.byteLength===G.buffer.byteLength?G:new G.constructor(G)),!(G instanceof Float32Array||G instanceof Int32Array||G instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${G.constructor.name}`)});const Se=new Uint8Array(he);let Z=0;return Q.forEach(G=>{Se.set(new Uint8Array(G.buffer),Z),Z+=G.byteLength}),Se.buffer}const S=typeof t!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function l(Ie){return S?t.byteLength(Ie):new Blob([Ie]).size}function B(Ie){if(S)return t.from(Ie).toString("base64");const he=new Uint8Array(Ie);let Q="";for(let Se=0,Z=he.length;Se<Z;Se++)Q+=String.fromCharCode(he[Se]);return btoa(Q)}function O(Ie){if(S){const Se=t.from(Ie,"base64");return Se.buffer.slice(Se.byteOffset,Se.byteOffset+Se.byteLength)}const he=atob(Ie),Q=new Uint8Array(he.length);for(let Se=0;Se<he.length;++Se)Q.set([he.charCodeAt(Se)],Se);return Q.buffer}function V(Ie){if(Ie.length===1)return Ie[0];let he=0;Ie.forEach(Z=>{he+=Z.byteLength});const Q=new Uint8Array(he);let Se=0;return Ie.forEach(Z=>{Q.set(new Uint8Array(Z),Se),Se+=Z.byteLength}),Q.buffer}function L(Ie){for(Ie=Ie.trim();Ie.endsWith("/");)Ie=Ie.slice(0,Ie.length-1);const he=Ie.split("/");return he[he.length-1]}function g(Ie,he){const Q={modelTopology:Ie.modelTopology,format:Ie.format,generatedBy:Ie.generatedBy,convertedBy:Ie.convertedBy,weightsManifest:he};return Ie.signature!=null&&(Q.signature=Ie.signature),Ie.userDefinedMetadata!=null&&(Q.userDefinedMetadata=Ie.userDefinedMetadata),Ie.modelInitializer!=null&&(Q.modelInitializer=Ie.modelInitializer),Ie.trainingConfig!=null&&(Q.trainingConfig=Ie.trainingConfig),Q}async function W(Ie,he){const Q={modelTopology:Ie.modelTopology,format:Ie.format,generatedBy:Ie.generatedBy,convertedBy:Ie.convertedBy};if(Ie.trainingConfig!=null&&(Q.trainingConfig=Ie.trainingConfig),Ie.weightsManifest!=null){const[Se,Z]=await he(Ie.weightsManifest);Q.weightSpecs=Se,Q.weightData=Z}return Ie.signature!=null&&(Q.signature=Ie.signature),Ie.userDefinedMetadata!=null&&(Q.userDefinedMetadata=Ie.userDefinedMetadata),Ie.modelInitializer!=null&&(Q.modelInitializer=Ie.modelInitializer),Q}function de(Ie){if(Ie.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:Ie.modelTopology==null?0:l(JSON.stringify(Ie.modelTopology)),weightSpecsBytes:Ie.weightSpecs==null?0:l(JSON.stringify(Ie.weightSpecs)),weightDataBytes:Ie.weightData==null?0:Ie.weightData.byteLength}}function ke(){const Ie=function(){const Se=G=>{let He=G<<13,me=0;for(;(8388608&He)==0;)me-=8388608,He<<=1;return He&=-8388609,me+=947912704,He|me},Z=new Uint32Array(2048);Z[0]=0;for(let G=1;G<1024;G++)Z[G]=Se(G);for(let G=1024;G<2048;G++)Z[G]=939524096+(G-1024<<13);return Z}(),he=function(){const Se=new Uint32Array(64);Se[0]=0,Se[31]=1199570944,Se[32]=2147483648,Se[63]=3347054592;for(let Z=1;Z<31;Z++)Se[Z]=Z<<23;for(let Z=33;Z<63;Z++)Se[Z]=2147483648+(Z-32<<23);return Se}(),Q=function(){const Se=new Uint32Array(64);for(let Z=0;Z<64;Z++)Se[Z]=1024;return Se[0]=Se[32]=0,Se}();return Se=>{const Z=new ArrayBuffer(4*Se.length),G=new Uint32Array(Z);for(let He=0;He<Se.length;He++){const me=Se[He],et=Ie[Q[me>>10]+(1023&me)]+he[me>>10];G[He]=et}return new Float32Array(Z)}}}).call(this,e(105).Buffer)},function(I,n,e){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t(h){const{inputs:b,backend:A}=h,{real:D,imag:y}=b,E=A.data.get(D.dataId).values,S=A.data.get(y.dataId).values,l=A.makeTensorInfo(D.shape,"complex64");return A.data.get(l.dataId).complexTensorInfos={real:A.makeTensorInfo(D.shape,"float32",E),imag:A.makeTensorInfo(y.shape,"float32",S)},l}e.d(n,"a",function(){return t}),e.d(n,"b",function(){return m});const m={kernelName:e(0).Complex,backendName:"cpu",kernelFunc:t}},function(I,n,e){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t(h){const{inputs:b,backend:A}=h,{x:D}=b;return A.incRef(D.dataId),{dataId:D.dataId,shape:D.shape,dtype:D.dtype}}e.d(n,"a",function(){return t}),e.d(n,"b",function(){return m});const m={kernelName:e(0).Identity,backendName:"cpu",kernelFunc:t}},function(I,n,e){e.d(n,"a",function(){return b});var t=e(3),m=e(15),h=e(6);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(A,D,y,E){if(E==null&&(E=Object(m.r)(A)),E==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(m.A)(A)&&!Array.isArray(A)&&typeof A!="number"&&typeof A!="boolean"&&typeof A!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(D!=null){Object(m.c)(D);const S=Object(m.O)(D),l=Object(m.O)(y);Object(m.b)(S===l,()=>`Based on the provided shape, [${D}], the tensor should have ${S} values but has ${l}`);for(let B=0;B<y.length;++B){const O=y[B],V=B!==y.length-1||O!==Object(m.O)(D.slice(B));Object(m.b)(y[B]===D[B]||!V,()=>`Error creating a new Tensor. Inferred shape (${y}) does not match the provided shape (${D}). `)}}return Object(m.A)(A)||Array.isArray(A)||(A=[A]),D=D||y,A=E!=="string"?Object(h.toTypedArray)(A,E):Object(m.m)(A,[],!0),t.a.makeTensor(A,D,E)}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h){return(b,A,D)=>{const y=t.util.getTypedArrayFromDType(A,b.length);for(let E=0;E<b.length;++E)y[E]=h(b[E],D);return y}}},function(I,n,e){e.d(n,"a",function(){return D});var t=e(3),m=e(4),h=e(1),b=e(15),A=e(2);const D=Object(A.b)({complex_:function(y,E){const S=Object(h.a)(y,"real","complex"),l=Object(h.a)(E,"imag","complex");b.e(S.shape,l.shape,`real and imag shapes, ${S.shape} and ${l.shape}, must match in call to tf.complex().`);const B={real:S,imag:l};return t.a.runKernel(m.A,B)}})},function(I,n,e){e.d(n,"c",function(){return h}),e.d(n,"a",function(){return b}),e.d(n,"b",function(){return A});var t=e(0),m=e(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(D,y,E,S,l){const B=t.slice_util.isSliceContinous(S,y,E),O=t.util.sizeFromShape(E),V=t.util.computeStrides(S);if(B){const de=t.slice_util.computeFlatOffset(y,V);return l==="string"?D.slice(de,de+O):D.subarray(de,de+O)}const L=l==="string"?t.backend_util.fromUint8ToStringArray(D):D,g=Object(t.buffer)(S,l,L),W=Object(t.buffer)(E,l);for(let de=0;de<W.size;++de){const ke=W.indexToLoc(de),Ie=ke.map((he,Q)=>he+y[Q]);W.set(g.get(...Ie),...ke)}return l==="string"?t.backend_util.fromStringArrayToUint8(W.values):W.values}function b(D){const{inputs:y,backend:E,attrs:S}=D,{x:l}=y,{begin:B,size:O}=S;Object(m.a)(l,"slice");const[V,L]=t.slice_util.parseSliceParams(l,B,O);t.slice_util.assertParamsValid(l,V,L);const g=h(E.data.get(l.dataId).values,V,L,l.shape,l.dtype);return E.makeTensorInfo(L,l.dtype,g)}const A={kernelName:t.Slice,backendName:"cpu",kernelFunc:b}},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return D}),e.d(n,"b",function(){return y});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((E,S)=>E+S),A=Object(h.b)((E,S,l,B)=>({real:E+l,imag:S+B})),D=Object(h.a)(t.Add,b,A),y={kernelName:t.Add,backendName:"cpu",kernelFunc:D}},function(I,n,e){e.d(n,"c",function(){return y}),e.d(n,"a",function(){return E}),e.d(n,"b",function(){return S});var t=e(0),m=e(12),h=e(89),b=e(18),A=e(19),D=e(26);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y(l,B,O,V){if(V==="int32")return[B,"int32",Int32Array.from(l)];if(V==="bool"){const L=t.util.toTypedArray([0],O),[g,W]=Object(m.a)((de,ke)=>de!==ke?1:0)(B,[],l,L,"bool");return[W,"bool",g]}throw new Error(`Error in Cast: failed to cast ${O} to ${V}`)}function E(l){const{inputs:B,backend:O,attrs:V}=l,{x:L}=B,{dtype:g}=V;if(g==="complex64"){if(L.dtype==="complex64")return Object(A.a)({inputs:{x:L},backend:O});const he=Object(h.a)(O,L.shape,L.dtype),Q=E({inputs:{x:L},backend:O,attrs:{dtype:"float32"}}),Se=Object(b.a)({inputs:{real:Q,imag:he},backend:O});return O.disposeIntermediateTensorInfo(he),O.disposeIntermediateTensorInfo(Q),Se}if(L.dtype==="complex64"){const he=Object(D.a)({inputs:{input:L},backend:O}),Q=E({inputs:{x:he},backend:O,attrs:{dtype:g}});return O.disposeIntermediateTensorInfo(he),Q}if(!t.util.hasEncodingLoss(L.dtype,g)){const he=Object(A.a)({inputs:{x:L},backend:O});return{dataId:he.dataId,shape:he.shape,dtype:g}}const W=O.data.get(L.dataId).values,[de,ke,Ie]=y(W,L.shape,L.dtype,g);return O.makeTensorInfo(de,ke,Ie)}const S={kernelName:t.Cast,backendName:"cpu",kernelFunc:E}},function(I,n,e){/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/function t(h){const{inputs:b,backend:A}=h,{input:D}=b,y=A.data.get(D.dataId).complexTensorInfos.real,E=A.data.get(y.dataId).values;return A.makeTensorInfo(y.shape,y.dtype,E)}e.d(n,"a",function(){return t}),e.d(n,"b",function(){return m});const m={kernelName:e(0).Real,backendName:"cpu",kernelFunc:t}},function(I,n){I.exports=function(){throw new Error("define cannot be used indirect")}},function(I,n,e){e.r(n);var t=e(56);e.d(n,"simpleAbsImpl",function(){return t.b});var m=e(24);e.d(n,"addImpl",function(){return m.c});var h=e(35);e.d(n,"bincountImpl",function(){return h.a}),e.d(n,"bincountReduceImpl",function(){return h.b});var b=e(25);e.d(n,"castImpl",function(){return b.c});var A=e(57);e.d(n,"ceilImpl",function(){return A.b});var D=e(58);e.d(n,"concatImpl",function(){return D.a});var y=e(44);e.d(n,"equalImpl",function(){return y.c});var E=e(45);e.d(n,"expImpl",function(){return E.c});var S=e(59);e.d(n,"expm1Impl",function(){return S.b});var l=e(60);e.d(n,"floorImpl",function(){return l.b});var B=e(61);e.d(n,"gatherNdImpl",function(){return B.a});var O=e(62);e.d(n,"gatherV2Impl",function(){return O.a});var V=e(63);e.d(n,"greaterImpl",function(){return V.b});var L=e(64);e.d(n,"greaterEqualImpl",function(){return L.b});var g=e(65);e.d(n,"lessImpl",function(){return g.b});var W=e(66);e.d(n,"lessEqualImpl",function(){return W.b});var de=e(67);e.d(n,"linSpaceImpl",function(){return de.a});var ke=e(68);e.d(n,"logImpl",function(){return ke.b});var Ie=e(69);e.d(n,"maxImpl",function(){return Ie.a});var he=e(70);e.d(n,"maximumImpl",function(){return he.b});var Q=e(71);e.d(n,"minimumImpl",function(){return Q.b});var Se=e(29);e.d(n,"multiplyImpl",function(){return Se.c});var Z=e(72);e.d(n,"negImpl",function(){return Z.b});var G=e(73);e.d(n,"notEqualImpl",function(){return G.b});var He=e(74);e.d(n,"prodImpl",function(){return He.b});var me=e(75);e.d(n,"raggedTensorToTensorImpl",function(){return me.a});var et=e(76);e.d(n,"rangeImpl",function(){return et.a});var rt=e(77);e.d(n,"rsqrtImpl",function(){return rt.b});var It=e(33);e.d(n,"scatterImpl",function(){return It.a});var X=e(47);e.d(n,"sigmoidImpl",function(){return X.c});var $t=e(23);e.d(n,"sliceImpl",function(){return $t.c});var Ct=e(78);e.d(n,"sparseFillEmptyRowsImpl",function(){return Ct.a});var Gt=e(79);e.d(n,"sparseReshapeImpl",function(){return Gt.a});var Wt=e(48);e.d(n,"sparseSegmentReductionImpl",function(){return Wt.a});var lt=e(80);e.d(n,"sqrtImpl",function(){return lt.b});var Qt=e(81);e.d(n,"squaredDifferenceImpl",function(){return Qt.b});var Ft=e(82);e.d(n,"stridedSliceImpl",function(){return Ft.a});var yn=e(83);e.d(n,"stringNGramsImpl",function(){return yn.a});var Nn=e(84);e.d(n,"stringSplitImpl",function(){return Nn.a});var Kn=e(85);e.d(n,"stringToHashBucketFastImpl",function(){return Kn.a});var zn=e(36);e.d(n,"subImpl",function(){return zn.c});var sr=e(86);e.d(n,"tileImpl",function(){return sr.a});var K=e(87);e.d(n,"topKImpl",function(){return K.a});var J=e(46);e.d(n,"transposeImpl",function(){return J.a});var we=e(88);e.d(n,"uniqueImpl",function(){return we.a})},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return D}),e.d(n,"b",function(){return y});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((E,S)=>E*S),A=Object(h.b)((E,S,l,B)=>({real:E*l-S*B,imag:E*B+S*l})),D=Object(h.a)(t.Multiply,b,A),y={kernelName:t.Multiply,backendName:"cpu",kernelFunc:D}},function(I,n,e){e.d(n,"b",function(){return m}),e.d(n,"a",function(){return h});var t=e(9);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(...b){Object(t.c)().getBool("IS_TEST")||Object(t.c)().getBool("PROD")||console.warn(...b)}function h(...b){Object(t.c)().getBool("IS_TEST")||Object(t.c)().getBool("PROD")||console.log(...b)}},function(I,n,e){e.d(n,"c",function(){return D}),e.d(n,"b",function(){return y}),e.d(n,"d",function(){return E}),e.d(n,"f",function(){return S}),e.d(n,"e",function(){return l}),e.d(n,"h",function(){return B}),e.d(n,"g",function(){return O}),e.d(n,"a",function(){return V});var t=e(9),m=e(38),h=e(30);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)("kernelRegistry",()=>new Map),A=Object(m.a)("gradRegistry",()=>new Map);function D(g,W){const de=L(g,W);return b.get(de)}function y(g){return A.get(g)}function E(g){const W=b.entries(),de=[];for(;;){const{done:ke,value:Ie}=W.next();if(ke)break;const[he,Q]=Ie,[Se]=he.split("_");Se===g&&de.push(Q)}return de}function S(g){const{kernelName:W,backendName:de}=g,ke=L(W,de);b.has(ke)&&h.b(`The kernel '${W}' for backend '${de}' is already registered`),b.set(ke,g)}function l(g){const{kernelName:W}=g;A.has(W)&&Object(t.c)().getBool("DEBUG")&&h.b(`Overriding the gradient for '${W}'`),A.set(W,g)}function B(g,W){const de=L(g,W);if(!b.has(de))throw new Error(`The kernel '${g}' for backend '${W}' is not registered`);b.delete(de)}function O(g){if(!A.has(g))throw new Error(`The gradient '${g}' for backend is not registered`);A.delete(g)}function V(g,W){E(g).forEach(de=>{S(Object.assign({},de,{backendName:W}))})}function L(g,W){return`${W}_${g}`}},function(I,n,e){e.d(n,"a",function(){return h});var t=e(1),m=e(20);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(b,A,D){const y=Object(t.c)(b,D);return Object(m.a)(b,A,y,D)}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y,E,S,l,B,O){const V=[D/y,y],L=h.values,g=b.values;if(D===0)return Object(t.buffer)(A,b.dtype);const W=Object(t.buffer)(V,b.dtype);typeof B=="string"||typeof B=="number"?W.values.fill(B):typeof B=="boolean"&&W.values.fill(+B);for(let de=0;de<E;de++){const ke=[];let Ie=0;for(let he=0;he<S;he++){const Q=L[de*S+he];ke.push(Q),Ie+=Q*l[he]}if(Ie<0||Ie>=D/y)throw new Error(`Invalid indices: ${ke} does not index into ${A}`);for(let he=0;he<y;he++)O?W.values[Ie*y+he]+=g[de*y+he]:W.values[Ie*y+he]=b.rank===0?g[0]:g[de*y+he]}return W}},function(I,n,e){/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/var t,m,h,b,A;e.d(n,"a",function(){return t}),e.d(n,"c",function(){return y}),e.d(n,"b",function(){return E}),function(S){S.R0="R0",S.R1="R1",S.R2="R2",S.R3="R3",S.R4="R4",S.R5="R5",S.R6="R6"}(t||(t={})),function(S){S.float32="float32",S.int32="int32",S.bool="int32",S.complex64="complex64"}(m||(m={})),function(S){S.float32="float32",S.int32="int32",S.bool="bool",S.complex64="complex64"}(h||(h={})),function(S){S.float32="float32",S.int32="float32",S.bool="float32",S.complex64="complex64"}(b||(b={})),function(S){S.float32="complex64",S.int32="complex64",S.bool="complex64",S.complex64="complex64"}(A||(A={}));const D={float32:b,int32:m,bool:h,complex64:A};function y(S,l){if(S==="string"||l==="string"){if(S==="string"&&l==="string")return"string";throw new Error(`Can not upcast ${S} with ${l}`)}return D[S][l]}function E(S){return y(S,"int32")}},function(I,n,e){e.d(n,"a",function(){return m}),e.d(n,"b",function(){return h});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(b,A,D,y,E){const S=t.util.sizeFromShape(y),l=t.util.makeZerosTypedArray(E,D);for(let B=0;B<b.length;B++){const O=b[B];if(O<0)throw new Error("Input x must be non-negative!");O>=E||(l[O]+=S>0?A[B]:1)}return l}function h(b,A,D,y=!1){const E=b.shape[0],S=b.shape[1],l=Object(t.buffer)([E,D],A.dtype);for(let B=0;B<E;B++)for(let O=0;O<S;O++){const V=b.get(B,O);if(V<0)throw new Error("Input x must be non-negative!");V>=D||(y?l.set(1,B,V):A.size>0?l.set(l.get(B,V)+A.get(B,O),B,V):l.set(l.get(B,V)+1,B,V))}return l}},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return D}),e.d(n,"b",function(){return y});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((E,S)=>E-S),A=Object(h.b)((E,S,l,B)=>({real:E-l,imag:S-B})),D=Object(h.a)(t.Sub,b,A),y={kernelName:t.Sub,backendName:"cpu",kernelFunc:D}},function(I,n,e){e.d(n,"a",function(){return y}),e(97),e(98),e(99);var t,m,h,b=e(90),A=e(0),D=e(5);(function(E){E.default="default",E.webgpu="webgpu"})(t||(t={})),function(E){E.cpu="cpu",E.gpu="gpu"}(m||(m={})),function(E){E.default="default",E["high-performance"]="high-performance",E["low-power"]="low-power"}(h||(h={}));class y{constructor(S={}){D.a(S instanceof Object,"Invalid options."),S.deviceType!==void 0&&D.a(S.deviceType in m,"Invalid device type."),S.powerPreference!==void 0&&D.a(S.powerPreference in h,"Invalid power preference."),this.options_=S,this.type_=t.default}get options(){return this.options_}get type(){return this.type_}async compute(S,l,B){return await S.compute(l,B)}computeSync(S,l,B){D.a(typeof window=="undefined"&&typeof importScripts=="function","computeSync() should only be allowed in dedicated worker."),S.computeSync(l,B)}get tf(){return b.a(`https://unpkg.com/@tensorflow/tfjs-backend-wasm@${A.version_core}/dist/`),A}}},function(I,n,e){(function(t,m){/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let h;function b(){if(h==null){let D;if(typeof window!="undefined")D=window;else if(typeof t!="undefined")D=t;else if(typeof m!="undefined")D=m;else{if(typeof self=="undefined")throw new Error("Could not find a global object");D=self}h=D}return h}function A(D,y){const E=function(){const S=b();return S._tfGlobals==null&&(S._tfGlobals=new Map),S._tfGlobals}();if(E.has(D))return E.get(D);{const S=y();return E.set(D,S),E.get(D)}}e.d(n,"b",function(){return b}),e.d(n,"a",function(){return A})}).call(this,e(40),e(41))},function(I,n,e){e.d(n,"e",function(){return y}),e.d(n,"b",function(){return E}),e.d(n,"a",function(){return S}),e.d(n,"c",function(){return l}),e.d(n,"i",function(){return B}),e.d(n,"h",function(){return O}),e.d(n,"g",function(){return V}),e.d(n,"j",function(){return L}),e.d(n,"f",function(){return g}),e.d(n,"d",function(){return gr});var t=e(37),m=e(53),h=e(11),b=e(0);class A{get builder(){return this.builder_}get outputs(){return this.outputs_}constructor(q){this.outputs_=[],this.builder_=q}compute(q){const ae=new Map;for(const ht of this.inputs())ae.set(ht,q.getTensor(ht));const Qe=b.tidy(()=>this.computeImpl(ae));for(let ht=0;ht<this.outputs_.length;++ht)q.setOutputTensor(this.outputs_[ht],Qe[ht]);for(const ht of this.inputs())q.releaseTensor(ht)}dispose(){}}class D extends A{constructor(q){super(q),q&&this.createOutput()}createOutput(){this.outputs_.push(new h.e(this))}get output(){return this.outputs_[0]}computeImpl(q){return[this.run(q)]}}var y,E,S,l,B,O,V,L,g,W=e(5);class de extends D{constructor(q,ae,Qe,ht={}){if(super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.mean_=ae,W.r(Qe),this.variance_=Qe,W.t(ht.scale),this.scale_=ht.scale,W.t(ht.bias),this.bias_=ht.bias,ht.axis!==void 0){const Bt=ht.axis;W.a(W.j(Bt),"The axis parameter is invalid."),this.axis_=Bt}else this.axis_=1;if(ht.epsilon!==void 0){const Bt=ht.epsilon;W.a(typeof Bt=="number","The epsilon parameter is invalid"),this.epsilon_=Bt}else this.epsilon_=1e-5;this.activation_=ht.activation}inputs(){const q=[this.input_,this.mean_,this.variance_];return this.scale_&&q.push(this.scale_),this.bias_&&q.push(this.bias_),q}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}run(q){const ae=q.get(this.input_);W.a(this.axis_<ae.rank&&this.axis_>=-ae.rank,"The axis parameter is invalid.");const Qe=this.axis_>=0?this.axis_:ae.rank+this.axis_,ht=q.get(this.mean_);W.a(ht.rank===1,"The mean operand is not 1-D.");const Bt=q.get(this.variance_);let Kt,Ut;W.a(Bt.rank===1,"The mean operand is not 1-D."),this.scale_&&(Kt=q.get(this.scale_),W.a(Kt.rank===1,"The scale operand is not 1-D.")),this.bias_&&(Ut=q.get(this.bias_),W.a(Ut.rank===1,"The bias operand is not 1-D."));const tn=Array.from(Array(ae.rank).keys());tn[Qe]=ae.rank-1,tn[ae.rank-1]=Qe;const bn=b.transpose(b.batchNorm(b.transpose(ae,tn),ht,Bt,Ut,Kt,this.epsilon_),tn);return this.needCheckOutputShape_&&(W.b(bn.shape,ae.shape),this.needCheckOutputShape_=!1),bn}}class ke extends D{constructor(q,ae){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.a_=q,W.r(ae),this.b_=ae}inputs(){return[this.a_,this.b_]}run(q){const ae=q.get(this.a_),Qe=q.get(this.b_),ht=this.runOp(ae,Qe);if(this.needCheckOutputShape_){let Bt;if(this instanceof me){const Kt=ae.rank,Ut=Qe.rank;Kt===1&&Ut===1?Bt=[]:Kt>=2&&Ut===1?(Bt=ae.shape.slice(),Bt[Kt-1]=1):Kt===1&&Ut>=2?(Bt=Qe.shape.slice(),Bt[Ut-2]=1):Kt>=2&&Ut>=2&&(Bt=W.f(ae.shape.slice(0,-2),Qe.shape.slice(0,-2)),Bt.push(ae.shape[Kt-2]),Bt.push(Qe.shape[Ut-1]))}else Bt=W.f(ae.shape,Qe.shape);W.b(ht.shape,Bt),this.needCheckOutputShape_=!1}return ht}}class Ie extends ke{runOp(q,ae){return b.add(q,ae)}}class he extends ke{runOp(q,ae){return b.sub(q,ae)}}class Q extends ke{runOp(q,ae){return b.mul(q,ae)}}class Se extends ke{runOp(q,ae){return b.div(q,ae)}}class Z extends ke{runOp(q,ae){return b.maximum(q,ae)}}class G extends ke{runOp(q,ae){return b.minimum(q,ae)}}class He extends ke{runOp(q,ae){return b.pow(q,ae)}}class me extends ke{runOp(q,ae){if(q.rank===1)return ae.rank===1?b.dot(q,ae):b.matMul(b.reshape(q,[1,-1]),ae);if(ae.rank===1)return b.matMul(q,b.reshape(ae,[-1,1]));{const Qe=q.rank>ae.rank?q.rank:ae.rank;let ht=b.matMul(q,ae);return ht.rank!==Qe&&(ht=b.reshape(ht,[1].concat(ht.shape))),ht}}}class et extends D{constructor(q){q!==void 0?(super(q.builder),W.r(q),this.x_=q):(super(void 0),this.x_=void 0),this.needCheckOutputShape_=!0}inputs(){return[this.x_]}run(q){const ae=q.get(this.x_),Qe=this.runOp(ae);return this.needCheckOutputShape_&&(W.b(Qe.shape,ae.shape),this.needCheckOutputShape_=!1),Qe}}class rt extends et{runOp(q){return b.abs(q)}}class It extends et{runOp(q){return b.ceil(q)}}class X extends et{runOp(q){return b.cos(q)}}class $t extends et{runOp(q){return b.exp(q)}}class Ct extends et{runOp(q){return b.floor(q)}}class Gt extends et{runOp(q){return b.log(q)}}class Wt extends et{runOp(q){return b.neg(q)}}class lt extends et{runOp(q){return b.sin(q)}}class Qt extends et{runOp(q){return b.tan(q)}}class Ft extends et{apply(q){return this.builder_=q.builder,W.r(q),this.x_=q,this.createOutput(),this.output}}class yn extends Ft{runOp(q){return b.sigmoid(q)}}class Nn extends Ft{runOp(q){return b.tanh(q)}}class Kn extends Ft{runOp(q){return b.relu(q)}}class zn extends Ft{runOp(q){return b.div(b.mul(q,b.maximum(0,b.minimum(6,b.add(q,3)))),6)}}class sr extends Ft{get minValue(){return this.minValue_!==void 0?this.minValue_:-1/0}get maxValue(){return this.maxValue_!==void 0?this.maxValue_:1/0}constructor(q,ae={}){if(q!==void 0?(super(q),W.r(q),this.x_=q):(super(void 0),this.x_=void 0),ae.minValue!==void 0){const Qe=ae.minValue;W.a(typeof Qe=="number","The minValue parameter is invalid"),this.minValue_=Qe}if(ae.maxValue!==void 0){const Qe=ae.maxValue;W.a(typeof Qe=="number","The maxValue parameter is invalid"),this.maxValue_=Qe}}runOp(q){return this.minValue_!==void 0&&this.maxValue_!==void 0?b.clipByValue(q,this.minValue_,this.maxValue_):this.minValue_!==void 0&&this.maxValue_===void 0?b.maximum(q,this.minValue_):this.minValue_===void 0&&this.maxValue_!==void 0?b.minimum(q,this.maxValue_):b.clone(q)}}class K extends D{constructor(q,ae){super(q[0].builder),this.needCheckOutputShape_=!0,W.a(q.every(Qe=>Qe instanceof h.c),"The parameter is not an operand."),this.inputs_=q,W.a(W.j(ae),"The axis parameter is invalid."),this.axis_=ae}inputs(){return this.inputs_}run(q){const ae=[];for(const ht of this.inputs())ae.push(q.get(ht));const Qe=b.concat(ae,this.axis_);if(this.needCheckOutputShape_){const ht=ae[0].shape.slice();for(let Bt=1;Bt<ae.length;++Bt)ht[this.axis_]+=ae[Bt].shape[this.axis_];W.b(Qe.shape,ht),this.needCheckOutputShape_=!1}return Qe}}class J extends Ft{get alpha(){return this.alpha_}constructor(q,ae=.01){super(q),W.a(typeof ae=="number","The alpha parameter is invalid."),this.alpha_=ae}runOp(q){return b.leakyRelu(q,this.alpha_)}}class we extends D{constructor(q,ae,Qe={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.filter_=ae,this.initOptions(Qe.padding,Qe.strides,Qe.dilations,Qe.groups,Qe.inputLayout,Qe.filterLayout,Qe.autoPad,Qe.bias,Qe.activation)}initOptions(q=[0,0,0,0],ae=[1,1],Qe=[1,1],ht=1,Bt=y.nchw,Kt=E.oihw,Ut=S.explicit,tn,bn){W.a(W.k(q)&&q.length===4,"The padding parameter is invalid."),this.padding_=q,W.a(W.k(ae)&&ae.length===2,"The strides parameter is invalid."),this.strides_=ae,W.a(W.k(Qe)&&Qe.length===2,"The dilations parameter is invalid."),this.dilations_=Qe,W.a(W.j(ht),"The gourps parameter is invalid."),this.groups_=ht,W.a(Bt in y,"The input layout parameter is invalid."),this.inputLayout_=Bt,W.a(Kt in E,"The filter layout parameter is invalid."),this.filterLayout_=Kt,W.a(Ut in S,"The autoPad parameter is invalid."),this.autoPad_=Ut,this.bias_=tn,this.bias_&&W.r(this.bias_),bn instanceof Kn?(this.fusedActivation_="relu",this.activation_=void 0):this.isRelu6(bn)?(this.fusedActivation_="relu6",this.activation_=void 0):bn instanceof J?(this.fusedActivation_="leakyrelu",this.leakyreluAlpha_=bn.alpha,this.activation_=void 0):bn instanceof yn?(this.fusedActivation_="sigmoid",this.activation_=void 0):(this.fusedActivation_=void 0,this.activation_=bn)}isRelu6(q){if(q instanceof sr){const ae=q;if(Math.abs(ae.minValue-0)<1e-5&&Math.abs(ae.maxValue-6)<1e-5)return!0}return!1}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}inputs(){const q=[this.input_,this.filter_];return this.bias_&&q.push(this.bias_),q}run(q){let ae,Qe,ht=q.get(this.input_),Bt=!1;this.bias_&&(Qe=q.get(this.bias_)),this.inputLayout_===y.nchw&&(ht=b.transpose(ht,[0,2,3,1]));const Kt=ht.shape[3];this.filterTensor_===void 0?(ae=q.get(this.filter_),this.filterLayout_===E.oihw?ae=b.transpose(ae,[2,3,1,0]):this.filterLayout_===E.ohwi?ae=b.transpose(ae,[1,2,3,0]):this.filterLayout_===E.ihwo&&(ae=b.transpose(ae,[1,2,0,3])),this.groups_!==1&&(ae=b.transpose(ae,[0,1,3,2])),this.filter_ instanceof h.a&&(this.filterTensor_=ae,b.keep(this.filterTensor_))):ae=this.filterTensor_;const Ut=W.g(ht,ae,this.padding_,this.strides_,this.dilations_,this.autoPad_);let tn;if(this.groups_===1)tn=b.fused.conv2d({x:ht,filter:ae,strides:this.strides_,pad:Ut,dataFormat:"NHWC",dilations:this.dilations_,bias:Qe,activation:this.fusedActivation_,leakyreluAlpha:this.leakyreluAlpha_}),Bt=!0;else{if(this.groups_!==Kt||this.groups_!==ae.shape[2])throw new Error(`The tf.js convolution doesn't support groups parameter ${this.groups_}`);if(Ut instanceof Array&&Ut[1][0]===Ut[1][1]&&Ut[1][0]===Ut[2][0]&&Ut[1][0]===Ut[2][1]){const bn=Ut[1][0];tn=b.fused.depthwiseConv2d({x:ht,filter:ae,strides:this.strides_,pad:bn,dataFormat:"NHWC",dilations:this.dilations_,bias:Qe,activation:this.fusedActivation_,leakyreluAlpha:this.leakyreluAlpha_}),Bt=!0}else tn=b.depthwiseConv2d(ht,ae,this.strides_,Ut,"NHWC",this.dilations_)}if(Bt||(Qe&&(tn=b.add(tn,Qe)),this.fusedActivation_==="relu"?tn=b.relu(tn):this.fusedActivation_==="relu6"?tn=b.clipByValue(tn,0,6):this.fusedActivation_==="leakyrelu"?tn=b.leakyRelu(tn,this.leakyreluAlpha_):this.fusedActivation_==="sigmoid"?tn=b.sigmoid(tn):this.fusedActivation_!==void 0&&W.a(!1,`The ${this.fusedActivation_} is un supported.`)),this.inputLayout_===y.nchw&&(tn=b.transpose(tn,[0,3,1,2])),this.needCheckOutputShape_){const bn=ae.shape[0]+(ae.shape[0]-1)*(this.dilations_[0]-1),xn=ae.shape[1]+(ae.shape[1]-1)*(this.dilations_[1]-1),rn=1+Math.floor((ht.shape[1]-bn+Ut[1][0]+Ut[1][1])/this.strides_[0]),Xn=1+Math.floor((ht.shape[2]-xn+Ut[2][0]+Ut[2][1])/this.strides_[1]),xr=this.groups_!==1?ae.shape[2]:ae.shape[3],Lr=new Array(4);Lr[0]=ht.shape[0],Lr[1]=rn,Lr[2]=Xn,Lr[3]=xr,this.inputLayout_===y.nchw&&(Lr[1]=xr,Lr[2]=rn,Lr[3]=Xn),W.b(tn.shape,Lr),this.needCheckOutputShape_=!1}return tn}dispose(){this.filterTensor_&&b.dispose(this.filterTensor_)}}class vt extends D{constructor(q,ae,Qe={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.filter_=ae,this.initOptions(Qe.padding,Qe.strides,Qe.dilations,Qe.groups,Qe.inputLayout,Qe.filterLayout,Qe.autoPad,Qe.outputPadding,Qe.outputSizes,Qe.bias,Qe.activation)}initOptions(q=[0,0,0,0],ae=[1,1],Qe=[1,1],ht=1,Bt=y.nchw,Kt=l.iohw,Ut=S.explicit,tn=[0,0],bn,xn,rn){W.a(W.k(q)&&q.length===4,"The padding parameter is invalid."),this.padding_=q,W.a(W.k(ae)&&ae.length===2,"The strides parameter is invalid."),this.strides_=ae,W.a(W.k(Qe)&&Qe.length===2,"The dilations parameter is invalid."),this.dilations_=Qe,W.a(this.dilations_.every(Xn=>Xn===1),"The tf.conv2dTranspose does not support dilations parameter."),W.a(W.j(ht),"The gourps parameter is invalid."),this.groups_=ht,W.a(this.groups_===1,"The tf.conv2dTranspose does not support groups parameter."),W.a(Bt in y,"The input layout parameter is invalid."),this.inputLayout_=Bt,W.a(Kt in l,"The filter layout parameter is invalid."),this.filterLayout_=Kt,W.a(Ut in S,"The autoPad parameter is invalid."),this.autoPad_=Ut,W.a(bn===void 0||W.k(bn)&&bn.length===2,"The outputSizes parameter is invalid."),this.outputSizes_=bn,bn===void 0?(W.a(W.k(tn)&&tn.length===2,"The outputPadding parameter is invalid."),this.outputPadding_=tn):this.outputPadding_=[0,0],this.bias_=xn,this.bias_&&W.r(this.bias_),rn instanceof Kn?(this.fusedActivation_="relu",this.activation_=void 0):this.isRelu6(rn)?(this.fusedActivation_="relu6",this.activation_=void 0):rn instanceof J?(this.fusedActivation_="leakyrelu",this.leakyreluAlpha_=rn.alpha,this.activation_=void 0):rn instanceof yn?(this.fusedActivation_="sigmoid",this.activation_=void 0):(this.fusedActivation_=void 0,this.activation_=rn)}isRelu6(q){if(q instanceof sr){const ae=q;if(Math.abs(ae.minValue-0)<1e-5&&Math.abs(ae.maxValue-6)<1e-5)return!0}return!1}getFusedOutputs(){return this.activation_?[this.activation_.apply(this.output)]:[this.output]}inputs(){const q=[this.input_,this.filter_];return this.bias_&&q.push(this.bias_),q}run(q){let ae,Qe,ht=q.get(this.input_);if(this.bias_&&(Qe=q.get(this.bias_)),this.inputLayout_===y.nchw&&(ht=b.transpose(ht,[0,2,3,1])),this.filterTensor_===void 0){if(ae=q.get(this.filter_),this.filterLayout_===l.iohw?ae=b.transpose(ae,[2,3,1,0]):this.filterLayout_===l.ohwi&&(ae=b.transpose(ae,[1,2,0,3])),this.groups_!==1)throw new Error("Unsupported the groups parameter by tfjs.convTranspose2d");this.filter_ instanceof h.a&&(this.filterTensor_=ae,b.keep(this.filterTensor_))}else ae=this.filterTensor_;const Bt=W.g(ht,ae,this.padding_,this.strides_,this.dilations_,this.autoPad_,this.outputPadding_);let Kt;const Ut=[ht.shape[0],0,0,ae.shape[2]];if(this.outputSizes_!==void 0)Ut[1]=this.outputSizes_[0],Ut[2]=this.outputSizes_[1];else for(let bn=0;bn<2;++bn)Ut[bn+1]=(ht.shape[bn+1]-1)*this.strides_[bn]+ae.shape[bn]+(ae.shape[bn]-1)*(this.dilations_[bn]-1)-Bt[bn+1][0]-Bt[bn+1][1]+this.outputPadding_[bn];Kt=b.conv2dTranspose(ht,ae,Ut,this.strides_,Bt),Qe&&(Kt=b.add(Kt,Qe)),this.fusedActivation_==="relu"?Kt=b.relu(Kt):this.fusedActivation_==="relu6"?Kt=b.clipByValue(Kt,0,6):this.fusedActivation_==="leakyrelu"?Kt=b.leakyRelu(Kt,this.leakyreluAlpha_):this.fusedActivation_==="sigmoid"?Kt=b.sigmoid(Kt):this.fusedActivation_!==void 0&&W.a(!1,`The ${this.fusedActivation_} is un supported.`);let tn=Ut.slice();return this.inputLayout_===y.nchw&&(Kt=b.transpose(Kt,[0,3,1,2]),tn=[Ut[0],Ut[3],Ut[1],Ut[2]]),this.needCheckOutputShape_&&(W.b(Kt.shape,tn),this.needCheckOutputShape_=!1),Kt}dispose(){this.filterTensor_&&b.dispose(this.filterTensor_)}}class wt{static build(q,ae,Qe,ht={}){W.r(ae),W.r(Qe),W.a(ht.c===void 0||typeof ht.c=="number"||ht.c instanceof h.c,"The options.c is invalid."),W.a(ht.aTranspose===void 0||W.i(ht.aTranspose),"The options.aTranspose is invalid."),W.a(ht.bTranspose===void 0||W.i(ht.bTranspose),"The options.bTranspose is invalid."),W.a(ht.alpha===void 0||typeof ht.alpha=="number","The options.alpha is invalid."),W.a(ht.beta===void 0||typeof ht.beta=="number","The options.beta is invalid."),ht.aTranspose&&(ae=q.transpose(ae)),ht.bTranspose&&(Qe=q.transpose(Qe));const Bt=q.constant(ht.alpha===void 0?1:ht.alpha),Kt=q.constant(ht.beta===void 0?1:ht.beta),Ut=q.matmul(q.mul(Bt,ae),Qe);return ht.c?q.add(Ut,q.mul(Kt,ht.c)):Ut}}class Ot extends A{constructor(q,ae,Qe,ht,Bt,Kt={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.weight_=ae,W.r(Qe),this.recurrentWeight_=Qe,W.a(W.j(ht)&&ht>0,"The steps parameter is invalid."),this.steps_=ht,W.a(W.j(Bt)&&Bt>0,"The hiddenSize parameter is invalid."),this.hiddenSize_=Bt,this.initOptions(Kt.bias,Kt.recurrentBias,Kt.initialHiddenState,Kt.resetAfter,Kt.returnSequence,Kt.direction,Kt.layout,Kt.activations),this.outputs.push(new h.e(this)),this.returnSequence_&&this.outputs_.push(new h.e(this))}initOptions(q,ae,Qe,ht=!0,Bt=!1,Kt=O.forward,Ut=B.zrn,tn=[this.builder.sigmoid(),this.builder.tanh()]){W.t(q),this.bias_=q,W.t(ae),this.recurrentBias_=ae,W.t(Qe),this.initialHiddenState_=Qe,W.a(W.i(ht),"The resetAfter parameter is not a boolean."),this.resetAfter_=ht,W.a(W.i(Bt),"The resetAfter parameter is not a boolean."),this.returnSequence_=Bt,W.a(Kt in O,"The direction parameter is invalid."),this.direction_=Kt,W.a(Ut in B,"The layout parameter is invalid."),this.layout_=Ut,W.a(tn instanceof Array&&tn.length===2&&tn.every(bn=>bn instanceof Ft),"The activations parameter is invalid."),this.activations_=tn}inputs(){const q=[this.input_,this.weight_,this.recurrentWeight_];return this.bias_&&q.push(this.bias_),this.recurrentBias_&&q.push(this.recurrentBias_),this.initialHiddenState_&&q.push(this.initialHiddenState_),q}computeImpl(q){const ae=q.get(this.input_),Qe=q.get(this.weight_),ht=q.get(this.recurrentWeight_),Bt=this.bias_?q.get(this.bias_):void 0,Kt=this.recurrentWeight_?q.get(this.recurrentBias_):void 0,Ut=this.initialHiddenState_?q.get(this.initialHiddenState_):void 0,tn=this.steps_,bn=this.hiddenSize_,xn=this.resetAfter_,rn=this.returnSequence_,Xn=this.layout_,xr=this.activations_,Lr=this.direction_,Wr=Lr===O.both?2:1;let vr,ua=Ut;ua===void 0&&(ua=b.zeros([Wr,1,bn]));const ma=[],Cr=[],Da=[],kr=[];for(let qr=0;qr<Wr;++qr)ma.push(b.squeeze(b.slice(Qe,[qr,0,0],[1,-1,-1]),[0])),Cr.push(b.squeeze(b.slice(ht,[qr,0,0],[1,-1,-1]),[0])),Da.push(Bt?b.squeeze(b.slice(Bt,[qr,0],[1,-1]),[0]):void 0),kr.push(Kt?b.squeeze(b.slice(Kt,[qr,0],[1,-1]),[0]):void 0);for(let qr=0;qr<tn;++qr){const ha=[];let Zr;for(let Vr=0;Vr<Wr;++Vr)ha.push(b.squeeze(b.slice(ua,[Vr,0,0],[1,-1,-1]),[0]));for(let Vr=0;Vr<Wr;++Vr){const Ca=Vr===1||Lr===O.backward?tn-qr-1:qr,Ta=b.squeeze(b.slice(ae,[Ca,0,0],[1,-1,-1]),[0]),Pa=b.reshape(Ae.compute(Ta,ma[Vr],Cr[Vr],ha[Vr],bn,xr,Da[Vr],kr[Vr],xn,Xn),[1,-1,bn]);Zr=Zr?b.concat([Zr,Pa],0):Pa}ua=Zr,rn&&(Zr=b.reshape(Zr,[1,Wr,-1,bn]),vr=vr?b.concat([vr,Zr],0):Zr)}const Pr=[ua];if(rn&&Pr.push(vr),this.needCheckOutputShape_){const qr=[[Wr,ae.shape[1],bn]];rn&&qr.push([tn,Wr,ae.shape[1],bn]);for(let ha=0;ha<Pr.length;++ha)W.b(Pr[ha].shape,qr[ha]);this.needCheckOutputShape_=!1}return Pr}}class Ae extends D{constructor(q,ae,Qe,ht,Bt,Kt={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.weight_=ae,W.r(Qe),this.recurrentWeight_=Qe,W.r(ht),this.hiddenState_=ht,W.a(W.j(Bt)&&Bt>0,"The hiddenSize parameter is invalid."),this.hiddenSize_=Bt,this.initOptions(Kt.bias,Kt.recurrentBias,Kt.resetAfter,Kt.layout,Kt.activations)}initOptions(q,ae,Qe=!0,ht=B.zrn,Bt=[this.builder.sigmoid(),this.builder.tanh()]){W.t(q),this.bias_=q,W.t(ae),this.recurrentBias_=ae,W.a(W.i(Qe),"The resetAfter parameter is not a boolean."),this.resetAfter_=Qe,W.a(ht in B,"The layout parameter is invalid."),this.layout_=ht,W.a(Bt instanceof Array&&Bt.length===2&&Bt.every(Kt=>Kt instanceof Ft),"The activations parameter is invalid."),this.activations_=Bt}inputs(){const q=[this.input_,this.weight_,this.recurrentWeight_,this.hiddenState_];return this.bias_&&q.push(this.bias_),this.recurrentBias_&&q.push(this.recurrentBias_),q}static compute(q,ae,Qe,ht,Bt,Kt,Ut,tn,bn=!0,xn=B.zrn){const rn=b.scalar(1),Xn=b.scalar(0),xr=xn===B.zrn?{z:0,r:Bt,n:2*Bt}:{r:0,z:Bt,n:2*Bt},Lr=Kt[0],Wr=Kt[1],vr=Lr.runOp(b.add(b.add(Ut?b.slice(Ut,[xr.z],[Bt]):Xn,tn?b.slice(tn,[xr.z],[Bt]):Xn),b.add(b.matMul(q,b.transpose(b.slice(ae,[xr.z,0],[Bt,-1]))),b.matMul(ht,b.transpose(b.slice(Qe,[xr.z,0],[Bt,-1])))))),ua=Lr.runOp(b.add(b.add(Ut?b.slice(Ut,[xr.r],[Bt]):Xn,tn?b.slice(tn,[xr.r],[Bt]):Xn),b.add(b.matMul(q,b.transpose(b.slice(ae,[xr.r,0],[Bt,-1]))),b.matMul(ht,b.transpose(b.slice(Qe,[xr.r,0],[Bt,-1]))))));let ma;return ma=bn?Wr.runOp(b.add(Ut?b.slice(Ut,[xr.n],[Bt]):Xn,b.add(b.matMul(q,b.transpose(b.slice(ae,[xr.n,0],[Bt,-1]))),b.mul(ua,b.add(tn?b.slice(tn,[xr.n],[Bt]):Xn,b.matMul(ht,b.transpose(b.slice(Qe,[xr.n,0],[Bt,-1])))))))):Wr.runOp(b.add(b.add(Ut?b.slice(Ut,[xr.n],[Bt]):Xn,tn?b.slice(tn,[xr.n],[Bt]):Xn),b.add(b.matMul(q,b.transpose(b.slice(ae,[xr.n,0],[Bt,-1]))),b.matMul(b.mul(ua,ht),b.transpose(b.slice(Qe,[xr.n,0],[Bt,-1])))))),b.add(b.mul(vr,ht),b.mul(ma,b.sub(rn,vr)))}run(q){const ae=q.get(this.input_),Qe=Ae.compute(ae,q.get(this.weight_),q.get(this.recurrentWeight_),q.get(this.hiddenState_),this.hiddenSize_,this.activations_,this.bias_?q.get(this.bias_):void 0,this.recurrentBias_?q.get(this.recurrentBias_):void 0,this.resetAfter_,this.layout_);if(this.needCheckOutputShape_){const ht=[ae.shape[0],this.hiddenSize_];W.b(Qe.shape,ht),this.needCheckOutputShape_=!1}return Qe}}class mt extends D{constructor(q,ae={}){if(super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.t(ae.scale),this.scale_=ae.scale,W.t(ae.bias),this.bias_=ae.bias,ae.epsilon!==void 0){const Qe=ae.epsilon;W.a(typeof Qe=="number","The epsilon parameter is invalid"),this.epsilon_=Qe}else this.epsilon_=1e-5;ae.layout!==void 0?(W.a(ae.layout in y,"The layout parameter is invalid."),this.layout_=ae.layout):this.layout_=y.nchw}inputs(){const q=[this.input_];return this.scale_&&q.push(this.scale_),this.bias_&&q.push(this.bias_),q}run(q){const ae=q.get(this.input_);W.a(ae.rank===4,"The input operand is not 4-D.");let Qe,ht,Bt=[2,3],Kt=[1,-1,1,1],Ut=ae.shape[1];this.layout_===y.nhwc&&(Bt=[1,2],Kt=[1,1,1,-1],Ut=ae.shape[3]),this.scale_&&(Qe=q.get(this.scale_),W.a(Qe.rank===1,"The scale operand is not 1-D."),W.a(Qe.shape[0]===Ut,"The length of scale is not equal to the size of the feature dimension of the input.")),this.bias_&&(ht=q.get(this.bias_),W.a(ht.rank===1,"The bias operand is not 1-D."),W.a(ht.shape[0]===Ut,"The length of bias is not equal to the size of the feature dimension of the input."));const tn=b.mean(ae,Bt,!0),bn=b.mean(b.pow(b.sub(ae,tn),2),Bt,!0),xn=b.div(b.sub(ae,tn),b.sqrt(b.add(bn,this.epsilon_))),rn=Qe?b.mul(b.reshape(Qe,Kt),xn):xn,Xn=ht?b.add(b.reshape(ht,Kt),rn):rn;return this.needCheckOutputShape_&&(W.b(Xn.shape,ae.shape),this.needCheckOutputShape_=!1),Xn}}class Mt extends D{constructor(q,ae,Qe={}){super(q.builder),this.mode_=V.constant,this.value_=0,this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.r(ae),this.padding_=ae,Qe.mode!==void 0&&(W.a(Qe.mode in V,"The mode parameter is invalid."),this.mode_=Qe.mode),Qe.value!==void 0&&(this.value_=Qe.value)}inputs(){return[this.input_,this.padding_]}run(q){const ae=q.get(this.input_),Qe=q.get(this.padding_);W.a(Qe.rank===2&&Qe.dtype==="int32"&&Qe.shape[0]===ae.rank,"The padding operand is invalid.");const ht=Qe.arraySync(),Bt=ae.shape.map((Ut,tn)=>Ut+ht[tn][0]+ht[tn][1]);let Kt;if(this.mode_===V.constant)Kt=b.pad(ae,ht,this.value_);else if(this.mode_===V.edge){const Ut=new Array(ht.length);let tn=ae;for(;;){for(let bn=0;bn<ht.length;++bn){Ut[bn]=[0,0];for(let xn=0;xn<2;++xn)ht[bn][xn]>0?(Ut[bn][xn]=1,ht[bn][xn]-=1):Ut[bn][xn]=0}if(Ut.every(bn=>bn[0]===0&&bn[1]===0))break;tn=b.mirrorPad(tn,Ut,"symmetric")}Kt=tn}else{let Ut;this.mode_===V.reflection?Ut="reflect":this.mode_===V.symmetric&&(Ut="symmetric"),Kt=b.mirrorPad(ae,ht,Ut)}return this.needCheckOutputShape_&&(W.b(Kt.shape,Bt),this.needCheckOutputShape_=!1),Kt}}class Nt extends D{constructor(q,ae={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,this.initOptions(ae.windowDimensions,ae.padding,ae.strides,ae.dilations,ae.layout,ae.autoPad,ae.roundingType,ae.outputSizes)}initOptions(q=[-1,-1],ae=[0,0,0,0],Qe=[1,1],ht=[1,1],Bt=y.nchw,Kt=S.explicit,Ut=L.floor,tn){W.a(W.k(q)&&q.length===2,"The padding parameter is invalid."),this.windowDimensions_=q,W.a(W.k(ae)&&ae.length===4,"The padding parameter is invalid."),this.padding_=ae,W.a(W.k(Qe)&&Qe.length===2,"The strides parameter is invalid."),this.strides_=Qe,W.a(W.k(ht)&&ht.length===2,"The dilations parameter is invalid."),this.dilations_=ht,W.a(Bt in y,"The layout parameter is invalid."),this.layout_=Bt,W.a(Kt in S,"The autoPad parameter is invalid."),this.autoPad_=Kt,W.a(Ut in L,"The roundingType parameter is invalid."),this.roundingType_=Ut,tn&&W.a(W.k(tn)&&tn.length===2,"The outputSizes parameter is invalid."),this.outputSizes_=tn}inputs(){return[this.input_]}calculateOutputSizes(q,ae){const Qe=q[1],ht=q[2],Bt=this.windowDimensions_[0],Kt=this.windowDimensions_[1];let Ut,tn=this.padding_[0],bn=this.padding_[1],xn=this.padding_[2],rn=this.padding_[3];if(this.autoPad_!==S.explicit&&([tn,bn]=W.c(this.autoPad_,this.dilations_[0],Qe,Bt,this.strides_[0],tn,bn),[xn,rn]=W.c(this.autoPad_,this.dilations_[1],ht,Kt,this.strides_[1],xn,rn)),ae===void 0)Ut=Math.trunc;else switch(ae){case"ceil":Ut=Math.ceil;break;case"floor":Ut=Math.floor;break;case"round":Ut=Math.round}const Xn=Bt+(Bt-1)*(this.dilations_[0]-1),xr=Kt+(Kt-1)*(this.dilations_[1]-1);return[1+Ut((Qe-Xn+tn+bn)/this.strides_[0]),1+Ut((ht-xr+xn+rn)/this.strides_[1])]}run(q){let ae=q.get(this.input_);this.layout_===y.nchw&&(ae=b.transpose(ae,[0,2,3,1]));const Qe=this.windowDimensions_;let ht;if(Qe[0]===-1&&Qe[1]===-1&&(Qe[0]=ae.shape[1],Qe[1]=ae.shape[2]),this.outputSizes_!==void 0){let tn=!1;for(const bn of[void 0,"ceil","floor","round"]){const[xn,rn]=this.calculateOutputSizes(ae.shape,bn);if(this.outputSizes_[0]===xn&&this.outputSizes_[1]===rn){ht=bn,tn=!0;break}}W.a(tn,`The outputSizes [${this.outputSizes_}] is invalid.`)}else ht=this.roundingType_===L.floor?"floor":"ceil";const Bt=this.getPoolingType();let Kt,Ut;if(this.autoPad_===S.explicit)this.padding_.every(tn=>tn===0)?(Kt="valid",ht=void 0):Kt=[[0,0],[this.padding_[0],this.padding_[1]],[this.padding_[2],this.padding_[3]],[0,0]];else if(this.autoPad_===S["same-upper"])Kt="same",ht=void 0;else{Kt=[[0,0],[0,0],[0,0],[0,0]];const tn=[0,0];for(let xn=0;xn<2;++xn)tn[xn]=Math.ceil(ae.shape[1+xn]/this.strides_[xn]);const bn=[0,0];for(let xn=0;xn<2;++xn)bn[xn]=this.strides_[xn]*(tn[xn]-1)+((Qe[xn]-1)*this.dilations_[xn]+1)-ae.shape[1+xn];for(let xn=0;xn<2;++xn)Kt[xn+1][0]=bn[xn]-Math.floor(bn[xn]/2),Kt[xn+1][1]=Math.floor(bn[xn]/2)}if(Bt==="l2"?(ae=b.pow(ae,2),Ut=b.sqrt(b.pool(ae,this.windowDimensions_,"avg",Kt,this.dilations_,this.strides_,ht))):Ut=b.pool(ae,this.windowDimensions_,Bt,Kt,this.dilations_,this.strides_,ht),this.layout_===y.nchw&&(Ut=b.transpose(Ut,[0,3,1,2])),this.needCheckOutputShape_){let tn,bn,xn;this.outputSizes_!==void 0?(tn=this.outputSizes_[0],bn=this.outputSizes_[1]):(ht=this.roundingType_===L.floor?"floor":"ceil",[tn,bn]=this.calculateOutputSizes(ae.shape,ht)),xn=this.layout_===y.nchw?[ae.shape[0],ae.shape[3],tn,bn]:[ae.shape[0],tn,bn,ae.shape[3]],W.b(Ut.shape,xn),this.needCheckOutputShape_=!1}return Ut}}class un extends Nt{getPoolingType(){return"avg"}}class Rn extends Nt{getPoolingType(){return"max"}}class oe extends Nt{getPoolingType(){return"l2"}}class le extends D{constructor(q,ae={}){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,ae.axes!==void 0?(W.a(W.k(ae.axes),"The axes parameter is invalid."),this.axes_=ae.axes):this.axes_=void 0,ae.keepDimensions!==void 0?(W.a(W.i(ae.keepDimensions),"The keepDimensions parameter is not a boolean."),this.keepDimensions_=ae.keepDimensions):this.keepDimensions_=!1}inputs(){return[this.input_]}run(q){var ae;const Qe=q.get(this.input_);W.a(W.q(this.axes_,Qe.rank),`The axes must be in range [-${Qe.rank}, ${Qe.rank})`);const ht=this.runOp(Qe,this.axes_,this.keepDimensions_);if(this.needCheckOutputShape_){const Bt=(ae=this.axes_)!==null&&ae!==void 0?ae:[...Array(Qe.rank).keys()];let Kt=Qe.shape.slice();for(let Ut=0;Ut<Bt.length;++Ut)Bt[Ut]<0&&(Bt[Ut]=Qe.rank+Bt[Ut]),Kt[Bt[Ut]]=1;this.keepDimensions_||(Kt=Kt.filter((Ut,tn)=>!(Ut===1&&Bt.indexOf(tn)!==-1))),W.b(ht.shape,Kt),this.needCheckOutputShape_=!1}return ht}}class qe extends le{runOp(q,ae,Qe){return b.logSumExp(q,ae,Qe)}}class Mn extends le{runOp(q,ae,Qe){return b.max(q,ae,Qe)}}class zr extends le{runOp(q,ae,Qe){return b.mean(q,ae,Qe)}}class Ur extends le{runOp(q,ae,Qe){return b.min(q,ae,Qe)}}class _r extends le{runOp(q,ae,Qe){return b.prod(q,ae,Qe)}}class ir extends le{runOp(q,ae,Qe){return b.sum(q,ae,Qe)}}class Zn extends le{runOp(q,ae,Qe){return b.sum(b.abs(q),ae,Qe)}}class $r extends le{runOp(q,ae,Qe){return b.sqrt(b.sum(b.pow(q,2),ae,Qe))}}class en extends D{constructor(q,ae={}){if(super(q.builder),this.mode_=g["nearest-neighbor"],this.scales_=[1,1],this.axes_=[2,3],this.needCheckOutputShape_=!0,W.r(q),this.input_=q,ae.scales!==void 0){const Qe=ae.scales;W.a(Qe instanceof Array&&Qe.every(ht=>typeof ht=="number")&&Qe.length===2,"The scales parameter is invalid."),this.scales_=ae.scales}ae.sizes!==void 0&&(W.a(W.k(ae.sizes)&&ae.sizes.length===2,"The sizes parameter is invalid."),this.sizes_=ae.sizes),ae.axes!==void 0&&(W.a(W.k(ae.axes)&&ae.axes.length===2&&W.n(ae.axes),"The axes parameter is invalid."),this.axes_=ae.axes),W.a(this.scales_!==void 0||this.sizes_!==void 0,"The scales or sizes parameter is not provied."),ae.mode!==void 0&&(W.a(ae.mode in g,"The mode parameter is invalid."),this.mode_=ae.mode)}inputs(){return[this.input_]}run(q){let ae=q.get(this.input_);W.a(ae.rank===4,"The input tensor is not 4-D.");const Qe=ae.shape.slice(),ht=[0,0];let Bt;return this.sizes_!==void 0?(ht[0]=this.sizes_[0],ht[1]=this.sizes_[1]):this.scales_!==void 0&&(ht[0]=Math.floor(ae.shape[this.axes_[0]]*this.scales_[0]),ht[1]=Math.floor(ae.shape[this.axes_[1]]*this.scales_[1])),this.axes_[0]===0?ae=b.transpose(ae,[2,0,1,3]):this.axes_[0]===2&&(ae=b.transpose(ae,[0,2,3,1])),this.mode_===g["nearest-neighbor"]?Bt=b.image.resizeNearestNeighbor(ae,ht,!1,!0):this.mode_===g.linear&&(Bt=b.image.resizeBilinear(ae,ht,!1,!0)),this.axes_[0]===0?Bt=b.transpose(Bt,[1,2,0,3]):this.axes_[0]===2&&(Bt=b.transpose(Bt,[0,3,1,2])),this.needCheckOutputShape_&&(this.axes_.map((Kt,Ut)=>Qe[Kt]=ht[Ut]),W.b(Bt.shape,Qe),this.needCheckOutputShape_=!1),Bt}}class mn extends D{constructor(q,ae){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.a(W.l(ae)&&ae.length!==0,"The newShape parameter is invalid."),this.newShape_=ae}inputs(){return[this.input_]}run(q){const ae=q.get(this.input_),Qe=this.newShape_.slice(),ht=Qe.indexOf(null);ht!==-1&&(Qe[ht]=-1,Qe[ht]=W.o(ae.shape)/W.o(Qe)*-1);const Bt=b.reshape(ae,Qe);return this.needCheckOutputShape_&&(W.b(Bt.shape,Qe),this.needCheckOutputShape_=!1),Bt}}class Ln extends D{constructor(q,ae,Qe,ht){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.a(W.k(ae),"The starts parameter is invalid."),this.starts_=ae,W.a(W.k(Qe)&&Qe.every(Bt=>Bt>0||Bt===-1),"The sizes parameter is invalid."),this.sizes_=Qe,W.a(Qe.length==Qe.length,"The length of sizes is not equal to the length of sizes.))"),W.a(ht===void 0||W.k(ht),"The axes parameter is invalid."),ht!==void 0&&W.a(Qe.length===ht.length,"The length of axes is invalid.))"),this.axes_=ht}inputs(){return[this.input_]}run(q){const ae=q.get(this.input_),Qe=ae.shape.length;if(this.axes_===void 0){this.axes_=[];for(let Ut=0;Ut<Qe;++Ut)this.axes_.push(Ut)}W.a(this.axes_.every(Ut=>Ut<Qe&&Ut>=-Qe),"The value of axes is invalid."),W.a(this.starts_.length===this.axes_.length,"The length of starts is invalid."),W.a(this.sizes_.length===this.axes_.length,"The length of sizes is invalid.");const ht=new Array(this.axes_.length).fill(0),Bt=new Array(this.axes_.length).fill(-1);for(let Ut=0;Ut<this.axes_.length;++Ut){let tn=this.axes_[Ut];tn<0&&(tn=Qe+tn),ht[tn]=this.starts_[Ut]>=0?this.starts_[Ut]:this.starts_[Ut]+ae.shape[tn],Bt[tn]=this.sizes_[Ut]}const Kt=b.slice(ae,ht,Bt);if(this.needCheckOutputShape_){const Ut=ae.shape.slice();for(let tn=0;tn<this.axes_.length;++tn){const bn=this.axes_[tn]>=0?this.axes_[tn]:this.axes_[tn]+Qe,xn=ae.shape[bn],rn=this.starts_[tn],Xn=this.sizes_[tn];Ut[bn]=Xn>=0?Xn:rn>=0?xn-rn:-rn}W.b(Kt.shape,Ut)}return Kt}}class or extends D{constructor(q){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.x_=q}inputs(){return[this.x_]}run(q){const ae=q.get(this.x_);if(ae.rank!==2)throw new Error("The rank of x parameter should be 2.");const Qe=b.softmax(ae);return this.needCheckOutputShape_&&(W.b(Qe.shape,ae.shape),this.needCheckOutputShape_=!1),Qe}}class lr extends A{constructor(q,ae,Qe={}){var ht;super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,W.a(W.j(ae)||W.k(ae),"The splits parameter is invalid."),this.splits_=ae,W.a(Qe.axis===void 0||W.j(Qe.axis),"The options.axis is invalid."),this.axis_=(ht=Qe.axis)!==null&&ht!==void 0?ht:0;const Bt=W.j(ae)?ae:ae.length;for(let Kt=0;Kt<Bt;++Kt)this.outputs.push(new h.e(this))}inputs(){return[this.input_]}computeImpl(q){const ae=q.get(this.input_),Qe=b.split(ae,this.splits_,this.axis_);if(this.needCheckOutputShape_){const ht=this.axis_>=0?this.axis_:this.axis_+ae.rank;let Bt=[];Bt=typeof this.splits_=="number"?new Array(this.splits_).fill(ae.shape[ht]/this.splits_):this.splits_.slice();const Kt=[];for(const Ut of Bt){const tn=ae.shape.slice();tn[ht]=Ut,Kt.push(tn)}for(let Ut=0;Ut<Qe.length;++Ut)W.b(Qe[Ut].shape,Kt[Ut]);this.needCheckOutputShape_=!1}return Qe}}class Qn extends D{constructor(q,ae){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,ae!==void 0&&W.a(W.k(ae)&&ae.length!==0,"The axes parameter is invalid."),this.axes_=ae}inputs(){return[this.input_]}run(q){var ae;const Qe=q.get(this.input_),ht=b.squeeze(Qe,this.axes_);if(this.needCheckOutputShape_){const Bt=(ae=this.axes_)!==null&&ae!==void 0?ae:[...Array(Qe.rank).keys()],Kt=Qe.shape.filter((Ut,tn)=>!(Ut===1&&Bt.indexOf(tn)!==-1));W.b(ht.shape,Kt),this.needCheckOutputShape_=!1}return ht}}class br extends D{constructor(q,ae){super(q.builder),this.needCheckOutputShape_=!0,W.r(q),this.input_=q,ae!==void 0&&W.a(W.k(ae)&&ae.length!==0,"The permutation parameter is invalid."),this.permutation_=ae}inputs(){return[this.input_]}run(q){var ae;const Qe=q.get(this.input_),ht=b.transpose(Qe,this.permutation_);if(this.needCheckOutputShape_){const Bt=(ae=this.permutation_)!==null&&ae!==void 0?ae:new Array(Qe.rank).fill(0).map((Ut,tn,bn)=>bn.length-tn-1),Kt=new Array(Qe.rank).fill(0).map((Ut,tn)=>Qe.shape[Bt[tn]]);W.b(ht.shape,Kt),this.needCheckOutputShape_=!1}return ht}}(function(At){At.nchw="nchw",At.nhwc="nhwc"})(y||(y={})),function(At){At.oihw="oihw",At.hwio="hwio",At.ohwi="ohwi",At.ihwo="ihwo"}(E||(E={})),function(At){At.explicit="explicit",At["same-upper"]="same-upper",At["same-lower"]="same-lower"}(S||(S={})),function(At){At.iohw="iohw",At.hwoi="hwoi",At.ohwi="ohwi"}(l||(l={})),function(At){At.zrn="zrn",At.rzn="rzn"}(B||(B={})),function(At){At.forward="forward",At.backward="backward",At.both="both"}(O||(O={})),function(At){At.constant="constant",At.edge="edge",At.reflection="reflection",At.symmetric="symmetric"}(V||(V={})),function(At){At.floor="floor",At.ceil="ceil"}(L||(L={})),function(At){At["nearest-neighbor"]="nearest-neighbor",At.linear="linear"}(g||(g={}));class gr{constructor(q){W.a(q instanceof t.a,"The context paramter is invalid."),this.context_=q}get context(){return this.context_}async build(q){return await m.a.buildAndCompile(q)}buildSync(q){return W.a(typeof window=="undefined"&&typeof importScripts=="function","buildSync() should only be allowed in dedicated worker."),m.a.buildAndCompileSync(q)}input(q,ae){return new h.b(q,ae,this)}constant(q,ae){return typeof q=="number"?(ae===void 0&&(ae=h.d.float32),h.a.createScalar(q,ae,this)):h.a.createTensor(q,ae,this)}batchNormalization(q,ae,Qe,ht={}){return this.validateOperandBuilder([q,ae,Qe,ht.scale,ht.bias]),new de(q,ae,Qe,ht).getFusedOutputs()[0]}clamp(q={},ae={}){if(q instanceof h.c){const Qe=q;return this.validateOperandBuilder([Qe]),new sr(Qe,ae).output}return new sr(void 0,q)}concat(q,ae){return this.validateOperandBuilder(q),new K(q,ae).output}conv2d(q,ae,Qe={}){const ht=[q,ae];return Qe.bias&&ht.push(Qe.bias),this.validateOperandBuilder(ht),new we(q,ae,Qe).getFusedOutputs()[0]}convTranspose2d(q,ae,Qe={}){const ht=[q,ae];return Qe.bias&&ht.push(Qe.bias),this.validateOperandBuilder(ht),new vt(q,ae,Qe).getFusedOutputs()[0]}add(q,ae){return this.validateOperandBuilder([q,ae]),new Ie(q,ae).output}sub(q,ae){return this.validateOperandBuilder([q,ae]),new he(q,ae).output}mul(q,ae){return this.validateOperandBuilder([q,ae]),new Q(q,ae).output}div(q,ae){return this.validateOperandBuilder([q,ae]),new Se(q,ae).output}max(q,ae){return this.validateOperandBuilder([q,ae]),new Z(q,ae).output}min(q,ae){return this.validateOperandBuilder([q,ae]),new G(q,ae).output}pow(q,ae){return this.validateOperandBuilder([q,ae]),new He(q,ae).output}abs(q){return this.validateOperandBuilder([q]),new rt(q).output}ceil(q){return this.validateOperandBuilder([q]),new It(q).output}cos(q){return this.validateOperandBuilder([q]),new X(q).output}exp(q){return this.validateOperandBuilder([q]),new $t(q).output}floor(q){return this.validateOperandBuilder([q]),new Ct(q).output}log(q){return this.validateOperandBuilder([q]),new Gt(q).output}neg(q){return this.validateOperandBuilder([q]),new Wt(q).output}sin(q){return this.validateOperandBuilder([q]),new lt(q).output}tan(q){return this.validateOperandBuilder([q]),new Qt(q).output}hardSwish(q){return q===void 0?new zn(void 0):(this.validateOperandBuilder([q]),new zn(q).output)}relu(q){return q===void 0?new Kn(void 0):(this.validateOperandBuilder([q]),new Kn(q).output)}sigmoid(q){return q===void 0?new yn(void 0):(this.validateOperandBuilder([q]),new yn(q).output)}tanh(q){return q===void 0?new Nn(void 0):(this.validateOperandBuilder([q]),new Nn(q).output)}gemm(q,ae,Qe={}){return this.validateOperandBuilder([q,ae,Qe.c]),wt.build(this,q,ae,Qe)}gru(q,ae,Qe,ht,Bt,Kt={}){return this.validateOperandBuilder([q,ae,Qe,Kt.bias,Kt.recurrentBias,Kt.initialHiddenState]),new Ot(q,ae,Qe,ht,Bt,Kt).outputs}gruCell(q,ae,Qe,ht,Bt,Kt={}){return this.validateOperandBuilder([q,ae,Qe,ht,Kt.bias,Kt.recurrentBias]),new Ae(q,ae,Qe,ht,Bt,Kt).output}instanceNormalization(q,ae={}){return this.validateOperandBuilder([q,ae.bias,ae.scale]),new mt(q,ae).output}leakyRelu(q={},ae={}){if(q instanceof h.c){const Qe=q;return this.validateOperandBuilder([Qe]),new J(Qe,ae.alpha).output}return new J(void 0,q.alpha)}matmul(q,ae){return this.validateOperandBuilder([q,ae]),new me(q,ae).output}pad(q,ae,Qe={}){return this.validateOperandBuilder([q,ae]),new Mt(q,ae,Qe).output}averagePool2d(q,ae={}){return this.validateOperandBuilder([q]),new un(q,ae).output}l2Pool2d(q,ae={}){return this.validateOperandBuilder([q]),new oe(q,ae).output}maxPool2d(q,ae={}){return this.validateOperandBuilder([q]),new Rn(q,ae).output}reduceL1(q,ae={}){return this.validateOperandBuilder([q]),new Zn(q,ae).output}reduceL2(q,ae={}){return this.validateOperandBuilder([q]),new $r(q,ae).output}reduceLogSumExp(q,ae={}){return this.validateOperandBuilder([q]),new qe(q,ae).output}reduceMax(q,ae={}){return this.validateOperandBuilder([q]),new Mn(q,ae).output}reduceMean(q,ae={}){return this.validateOperandBuilder([q]),new zr(q,ae).output}reduceMin(q,ae={}){return this.validateOperandBuilder([q]),new Ur(q,ae).output}reduceProduct(q,ae={}){return this.validateOperandBuilder([q]),new _r(q,ae).output}reduceSum(q,ae={}){return this.validateOperandBuilder([q]),new ir(q,ae).output}resample2d(q,ae={}){return this.validateOperandBuilder([q]),new en(q,ae).output}reshape(q,ae){return this.validateOperandBuilder([q]),new mn(q,ae).output}slice(q,ae,Qe,ht={}){return this.validateOperandBuilder([q]),new Ln(q,ae,Qe,ht.axes).output}softmax(q){return this.validateOperandBuilder([q]),new or(q).output}split(q,ae,Qe={}){return this.validateOperandBuilder([q]),new lr(q,ae,Qe).outputs}squeeze(q,ae={}){return this.validateOperandBuilder([q]),new Qn(q,ae.axes).output}transpose(q,ae={}){return this.validateOperandBuilder([q]),new br(q,ae.permutation).output}validateOperandBuilder(q){W.a(q.every(ae=>!ae||ae instanceof h.c&&ae.builder===this),"The operand is not built by this builder.")}}},function(I,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch{typeof window=="object"&&(e=window)}I.exports=e},function(I,n){var e,t,m=I.exports={};function h(){throw new Error("setTimeout has not been defined")}function b(){throw new Error("clearTimeout has not been defined")}function A(L){if(e===setTimeout)return setTimeout(L,0);if((e===h||!e)&&setTimeout)return e=setTimeout,setTimeout(L,0);try{return e(L,0)}catch{try{return e.call(null,L,0)}catch{return e.call(this,L,0)}}}(function(){try{e=typeof setTimeout=="function"?setTimeout:h}catch{e=h}try{t=typeof clearTimeout=="function"?clearTimeout:b}catch{t=b}})();var D,y=[],E=!1,S=-1;function l(){E&&D&&(E=!1,D.length?y=D.concat(y):S=-1,y.length&&B())}function B(){if(!E){var L=A(l);E=!0;for(var g=y.length;g;){for(D=y,y=[];++S<g;)D&&D[S].run();S=-1,g=y.length}D=null,E=!1,function(W){if(t===clearTimeout)return clearTimeout(W);if((t===b||!t)&&clearTimeout)return t=clearTimeout,clearTimeout(W);try{t(W)}catch{try{return t.call(null,W)}catch{return t.call(this,W)}}}(L)}}function O(L,g){this.fun=L,this.array=g}function V(){}m.nextTick=function(L){var g=new Array(arguments.length-1);if(arguments.length>1)for(var W=1;W<arguments.length;W++)g[W-1]=arguments[W];y.push(new O(L,g)),y.length!==1||E||A(B)},O.prototype.run=function(){this.fun.apply(null,this.array)},m.title="browser",m.browser=!0,m.env={},m.argv=[],m.version="",m.versions={},m.on=V,m.addListener=V,m.once=V,m.off=V,m.removeListener=V,m.removeAllListeners=V,m.emit=V,m.prependListener=V,m.prependOnceListener=V,m.listeners=function(L){return[]},m.binding=function(L){throw new Error("process.binding is not supported")},m.cwd=function(){return"/"},m.chdir=function(L){throw new Error("process.chdir is not supported")},m.umask=function(){return 0}},function(I,n){I.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(I,n){(function(e){I.exports=e}).call(this,{})},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return A}),e.d(n,"b",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y===E?1:0),A=Object(h.a)(t.Equal,b,null,"bool"),D={kernelName:t.Equal,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return A}),e.d(n,"b",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.exp(y)),A=Object(h.b)(t.Exp,b,"float32"),D={kernelName:t.Exp,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y){const E=b.length,S=t.util.sizeFromShape(b),l=t.util.computeStrides(b),B=t.util.computeStrides(y),O=t.util.getTypedArrayFromDType(A,t.util.sizeFromShape(y));for(let V=0;V<S;++V){const L=t.util.indexToLoc(V,E,l),g=new Array(L.length);for(let W=0;W<g.length;W++)g[W]=L[D[W]];O[t.util.locToIndex(g,E,B)]=h[V]}return O}},function(I,n,e){e.d(n,"c",function(){return b}),e.d(n,"a",function(){return A}),e.d(n,"b",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>1/(1+Math.exp(-y))),A=Object(h.a)(t.Sigmoid,y=>1/(1+Math.exp(-y))),D={kernelName:t.Sigmoid,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y,E=!1,S=0){const l=D.length,B=[b[0],h.length/b[0]],O=B[1],V=l>0?y[l-1]+1:0;if(V<0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const L=b.slice();L[0]=V;const g=L.reduce((Q,Se)=>Q*Se,1),W=t.util.getArrayFromDType(A,g);if(l===0)return V>0&&W.fill(S),[W,L];if(V<=0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let de=0,ke=1,Ie=0,he=y[de];for(;;){let Q=0;if(ke<l){if(Q=y[ke],he===Q){++ke;continue}if(he>=Q)throw new Error(t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(he<0||he>=V)throw new Error(t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(he,V));he>Ie&&W.fill(S,Ie*O,he*O);for(let Se=de;Se<ke;++Se){const Z=D[Se];if(Z<0||Z>=B[0])throw new Error(t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(Se,D[Se],B[0]));for(let G=0;G<O;G++)W[he*O+G]+=h[Z*O+G]}if(E)for(let Se=0;Se<O;Se++)W[he*O+Se]/=ke-de;if(de=ke,++ke,Ie=he+1,he=Q,ke>l)break}return Ie<V&&W.fill(S,Ie*O,V*O),[W,L]}},function(I,n,e){var t=e(112),m=e(113),h=e(114),b=e(115),A=e(116),D=e(117),y=e(118);y.alea=t,y.xor128=m,y.xorwow=h,y.xorshift7=b,y.xor4096=A,y.tychei=D,I.exports=y},function(I,n,e){(function(t){e(3);var m=e(55),h=e(9);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(h.c)();b.registerFlag("DEBUG",()=>!1,A=>{A&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),b.registerFlag("IS_BROWSER",()=>m.isBrowser()),b.registerFlag("IS_NODE",()=>typeof t!="undefined"&&typeof t.versions!="undefined"&&typeof t.versions.node!="undefined"),b.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),b.registerFlag("PROD",()=>!1),b.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>b.getBool("DEBUG")),b.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),b.registerFlag("IS_TEST",()=>!1),b.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),b.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),b.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),b.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1)}).call(this,e(41))},function(I,n,e){e.d(n,"a",function(){return t}),e.d(n,"b",function(){return m});class t{constructor(A,D){this.backend=A,this.dataMover=D,this.data=new WeakMap,this.dataIdsCount=0}get(A){return this.data.has(A)||this.dataMover.moveData(this.backend,A),this.data.get(A)}set(A,D){this.dataIdsCount++,this.data.set(A,D)}has(A){return this.data.has(A)}delete(A){return this.dataIdsCount--,this.data.delete(A)}numDataIds(){return this.dataIdsCount}}class m{refCount(A){return h("refCount")}incRef(A){return h("incRef")}timerAvailable(){return!0}time(A){return h("time")}read(A){return h("read")}readSync(A){return h("readSync")}readToGPU(A,D){return h("readToGPU")}numDataIds(){return h("numDataIds")}disposeData(A,D){return h("disposeData")}write(A,D,y){return h("write")}move(A,D,y,E,S){return h("move")}memory(){return h("memory")}floatPrecision(){return h("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return h("dispose")}}function h(b){throw new Error(`'${b}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},function(I,n,e){e.d(n,"a",function(){return t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},function(I,n,e){e.d(n,"a",function(){return A}),e(97),e(98),e(99),e(90);var t=e(0),m=e(11),h=e(5);class b{constructor(y,E,S,l){this.constantTenosrs_=y,this.operandRefs_=l,this.allocateInputTensors(E,S),this.outputTensors_=new Map,this.outputOperands_=new Set}allocateInputTensors(y,E){this.inputTensors_=new Map;for(const S in E){const l=E[S],B=y.get(S),O=B.desc,V=l;this.inputTensors_.set(B,{ref:this.operandRefs_.get(B),tensor:h.e(O,V)})}}compute(y){for(const S of y.values())this.outputOperands_.add(S);const E={};for(const S of y.keys())E[S]=this.getTensor(y.get(S));return E}setOutputTensor(y,E){h.a(!this.outputTensors_.has(y),"MLOutput already has tensor."),this.outputTensors_.set(y,{ref:this.operandRefs_.get(y),tensor:E})}releaseTensor(y){let E;if(y instanceof m.b)E=this.inputTensors_;else{if(!(y instanceof m.e)||this.outputOperands_.has(y))return;E=this.outputTensors_}const S=E.get(y);h.a(S!==void 0,"No tensor found for operand."),S.ref--,S.ref===0&&(t.dispose(S.tensor),E.delete(y))}getTensor(y){if(y instanceof m.a)return this.constantTenosrs_.get(y);if(y instanceof m.b)return this.inputTensors_.get(y).tensor;if(y instanceof m.e)return this.outputTensors_.has(y)||(y.operation.compute(this),h.a(this.outputTensors_.has(y),"No output is set.")),this.outputTensors_.get(y).tensor;throw new Error("The operand is invalid.")}}class A{validateInputs(y){for(const E in y){h.a(typeof E=="string"&&this.inputs_.has(E),"The name of the input is invalid.");const S=this.inputs_.get(E),l=y[E],B=S.desc.dimensions;h.a(h.m(l),"Only resource of ArrayBufferView type is supported."),h.u(l,S.desc.type,B)}}validateAndSetOutputOperands(y){h.a(Object.keys(y).length!==0,"The outputs is invalid.");const E=new Map;for(const S in y)h.a(typeof S=="string"&&this.outputs_.has(S),"The name of the output is invalid."),h.a(h.m(y[S]),"Only output of ArrayBufferView type is supported."),E.set(S,this.outputs_.get(S));return E}computeOutputTensors(y,E){if(y)this.validateInputs(y);else{y={};for(const l of this.inputs_.keys()){const B=this.inputs_.get(l),O=new(h.h(B.desc.type))(h.p(B.desc.dimensions));y[l]=O}}let S=this.outputs_;return E&&(S=this.validateAndSetOutputOperands(E)),t.tidy(()=>new b(this.constantTensors_,this.inputs_,y,this.operandRefs_).compute(S))}async compute(y,E){const S=this.computeOutputTensors(y,E);for(const l of Object.keys(S)){const B=S[l],O=h.d(B),V=E[l];h.u(V,O.type,O.dimensions),V.set(await B.data()),t.dispose(B)}return{inputs:y,outputs:E}}computeSync(y,E){const S=this.computeOutputTensors(y,E);for(const l of Object.keys(S)){const B=S[l],O=h.d(B),V=E[l];h.u(V,O.type,O.dimensions),V.set(B.dataSync()),t.dispose(B)}}constructor(y){this.inputs_=new Map,this.outputs_=new Map,this.constants_=new Set,this.operandRefs_=new Map,this.constantTensors_=new Map,h.a(y!==void 0,"Invalid argument");for(const E in y)h.a(typeof E=="string"&&y[E]instanceof m.e,"The outputs parameter is invalid."),this.outputs_.set(E,y[E]);h.a(this.outputs_.size!==0,"The outputs is empty")}static async buildAndCompile(y){const E=new A(y);return E.build(),await E.compile(),E}static buildAndCompileSync(y){const E=new A(y);return E.build(),E.compileSync(),E}build(){const y=new Set;for(const E of this.outputs_.values())this.buildOperation(E.operation,y)}buildOperation(y,E){if(!E.has(y)){E.add(y);for(const S of y.inputs()){if(this.operandRefs_.has(S)){let l=this.operandRefs_.get(S);l++,this.operandRefs_.set(S,l)}else this.operandRefs_.set(S,1);if(S instanceof m.b){if(this.inputs_.has(S.name)){if(this.inputs_.get(S.name)!==S)throw new Error("The name of this input is existed.");continue}this.inputs_.set(S.name,S)}else S instanceof m.a?this.constants_.has(S)||this.constants_.add(S):S instanceof m.e&&this.buildOperation(S.operation,E)}}}async compile(){this.allocateConstants(),await this.computeOnce()}compileSync(){this.allocateConstants(),this.computeOnceSync()}allocateConstants(){for(const y of this.constants_)this.constantTensors_.set(y,h.e(y.desc,y.value))}async computeOnce(){const y=this.computeOutputTensors();for(const E of Object.keys(y)){const S=y[E];await S.data(),t.dispose(S)}}computeOnceSync(){const y=this.computeOutputTensors();for(const E of Object.keys(y)){const S=y[E];S.dataSync(),t.dispose(S)}}dispose(){for(const E of this.constantTensors_.values())t.dispose(E);const y=new Set;for(const E of this.outputs_.values())this.disposeOperation(E.operation,y)}disposeOperation(y,E){if(!E.has(y)){y.dispose(),E.add(y);for(const S of y.inputs())S instanceof m.e&&this.disposeOperation(S.operation,E)}}}},function(I,n){},function(I,n,e){let t;function m(A){t=A}function h(A){if(t!==void 0)return t;if(A||typeof navigator!="undefined"&&navigator!=null){if(A||(A=navigator),A.product==="ReactNative")return!0;const D=A.userAgent||A.vendor||(typeof window!="undefined"?window.opera:"");if(!D){const y=A;return y.userAgentData&&y.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(D)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(D.substr(0,4))}return!1}function b(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}e.r(n),e.d(n,"mockIsMobile",function(){return m}),e.d(n,"isMobile",function(){return h}),e.d(n,"isBrowser",function(){return b})},function(I,n,e){e.d(n,"b",function(){return h}),e.d(n,"a",function(){return b});var t=e(0),m=e(7);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(A){const D=new Float32Array(A.length);for(let y=0;y<A.length;++y)D[y]=Math.abs(A[y]);return D}const b={kernelName:t.Abs,backendName:"cpu",kernelFunc:A=>{const{x:D}=A.inputs,y=A.backend;Object(m.a)(D,"abs");let E=new Float32Array(t.util.sizeFromShape(D.shape));return E=h(y.data.get(D.dataId).values),y.makeOutput(E,D.shape,D.dtype)}}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.ceil(y)),A=Object(h.b)(t.Ceil,b),D={kernelName:t.Ceil,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D){const y=t.util.getArrayFromDType(A,t.util.sizeFromShape(b));if(D&&A!=="string"){let E=0;h.forEach(S=>{const l=t.util.sizeFromShape(S.shape);y.set(S.vals,E),E+=l})}else{let E=0;h.forEach(S=>{const l=A==="string"?t.backend_util.fromUint8ToStringArray(S.vals):S.vals;let B=0;for(let O=0;O<S.shape[0];++O){const V=O*b[1]+E;for(let L=0;L<S.shape[1];++L)y[V+L]=l[B++]}E+=S.shape[1]})}return y}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.expm1(y)),A=Object(h.b)(t.Expm1,b),D={kernelName:t.Expm1,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.floor(y)),A=Object(h.b)(t.Floor,b),D={kernelName:t.Floor,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y,E,S,l,B){const O=Object(t.buffer)([D,E],A);for(let V=0;V<D;V++){const L=[];let g=0;for(let W=0;W<y;W++){const de=h[V*y+W];g+=de*S[W],L.push(de)}if(g<0||g>=B/E)throw new Error(`Invalid indices: ${L} does not index into ${l}`);for(let W=0;W<E;W++)O.values[V*E+W]=b.get(...b.indexToLoc(g*E+W))}return O}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A){const D=Object(t.buffer)(A,h.dtype);for(let y=0;y<D.size;++y){const E=D.indexToLoc(y).slice(),S=E[0],l=E[2],B=b.locToIndex([S,l]);E[2]=b.values[B];const O=h.locToIndex(E);0<=O&&O<h.values.length&&(D.values[y]=h.values[O])}return D}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y>E?1:0),A=Object(h.a)(t.Greater,b,null,"bool"),D={kernelName:t.Greater,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y>=E?1:0),A=Object(h.a)(t.GreaterEqual,b,null,"bool"),D={kernelName:t.GreaterEqual,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y<E?1:0),A=Object(h.a)(t.Less,b,null,"bool"),D={kernelName:t.Less,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y<=E?1:0),A=Object(h.a)(t.LessEqual,b,null,"bool"),D={kernelName:t.LessEqual,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A){const D=(b-h)/(A-1),y=t.util.makeZerosTypedArray(A,"float32");y[0]=h;for(let E=1;E<y.length;E++)y[E]=y[E-1]+D;return y}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.log(y)),A=Object(h.b)(t.Log,b),D={kernelName:t.Log,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D){const y=t.util.getTypedArrayFromDType(D,t.util.sizeFromShape(A));for(let E=0;E<y.length;++E){const S=E*b;let l=h[S];for(let B=0;B<b;++B){const O=h[S+B];(Number.isNaN(O)||O>l)&&(l=O)}y[E]=l}return y}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>Math.max(y,E)),A=Object(h.a)(t.Maximum,b),D={kernelName:t.Maximum,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>Math.min(y,E)),A=Object(h.a)(t.Minimum,b),D={kernelName:t.Minimum,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return A});var t=e(0),m=e(7),h=e(29);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(D,y,E){const S=t.util.createScalarValue(-1,E);return Object(h.c)([],y,S,D,E)}const A={kernelName:t.Neg,backendName:"cpu",kernelFunc:function(D){const{inputs:y,backend:E}=D,{x:S}=y;Object(m.a)(S,"neg");const l=E.data.get(S.dataId).values,[B,O]=b(l,S.shape,S.dtype);return E.makeTensorInfo(O,S.dtype,B)}}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>y!==E?1:0),A=Object(h.a)(t.NotEqual,b,null,"bool"),D={kernelName:t.NotEqual,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return A});var t=e(0),m=e(7),h=e(16);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(D,y,E,S){const[l,B]=t.backend_util.computeOutAndReduceShapes(D,S),O=Object(t.upcastType)(y,"int32"),V=t.util.makeZerosTypedArray(t.util.sizeFromShape(l),O),L=t.util.sizeFromShape(B);for(let g=0;g<V.length;++g){const W=g*L;let de=1;for(let ke=0;ke<L;++ke)de*=E[W+ke];V[g]=de}return{outVals:V,outShape:l,outDtype:O}}const A={kernelName:t.Prod,backendName:"cpu",kernelFunc:function(D){const{inputs:y,backend:E,attrs:S}=D,{x:l}=y,{axis:B,keepDims:O}=S;Object(m.a)(l,"prod");const V=l.shape.length,L=t.util.parseAxisParam(B,l.shape),g=t.backend_util.getAxesPermutation(L,V);let W=L,de=l;const ke=[];g!=null&&(de=Object(h.a)({inputs:{x:l},backend:E,attrs:{perm:g}}),ke.push(de),W=t.backend_util.getInnerMostAxes(W.length,V));const Ie=E.data.get(de.dataId).values,{outVals:he,outShape:Q,outDtype:Se}=b(de.shape,de.dtype,Ie,W);let Z=Q;return O&&(Z=t.backend_util.expandShapeToKeepDim(Q,L)),ke.forEach(G=>E.disposeIntermediateTensorInfo(G)),E.makeTensorInfo(Z,Se,he)}}},function(I,n,e){e.d(n,"a",function(){return D});var t=e(0),m=t.backend_util.RowPartitionType;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h{constructor(E,S,l,B,O,V,L,g,W,de){this.shape=E,this.shapeShape=S,this.values=l,this.valuesShape=B,this.valuesDType=O,this.defaultValue=V,this.defaultValueShape=L,this.rowPartitionValues=g,this.rowPartitionValuesShapes=W,this.rowPartitionTypes=t.backend_util.getRowPartitionTypesHelper(de),this.raggedRank=t.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(E){return this.rowPartitionTypes[0]===m.FIRST_DIM_SIZE?this.rowPartitionTypes[E+1]:this.rowPartitionTypes[E]}getRowPartitionTensor(E){return this.rowPartitionTypes[0]===m.FIRST_DIM_SIZE?this.rowPartitionValues[E+1]:this.rowPartitionValues[E]}getMaxWidth(E){const S=this.getRowPartitionTensor(E-1);switch(this.getRowPartitionTypeByDimension(E-1)){case m.VALUE_ROWIDS:return h.getMaxWidthValueRowID(S);case m.ROW_SPLITS:return h.getMaxWidthRowSplit(S);default:throw new Error(`Cannot handle partition type ${m[this.getRowPartitionTypeByDimension(E-1)]}`)}}static getMaxWidthRowSplit(E){const S=E.length;if(S===0||S===1)return 0;let l=0;for(let B=0;B<S-1;++B){const O=E[B+1]-E[B];O>l&&(l=O)}return l}static getMaxWidthValueRowID(E){const S=E.length;if(S===0)return 0;let l=0,B=E[0],O=0;for(let V=1;V<S;++V){const L=E[V];L!==B&&(B=L,O=Math.max(V-l,O),l=V)}return Math.max(S-l,O)}tensorShapeFromTensor(E,S,l=!0){if(S.length===0){if(E[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return A(E,l)}calculateOutputSize(E){const S=this.valuesShape,l=this.defaultValueShape;t.backend_util.validateDefaultValueShape(l,S);const B=this.tensorShapeFromTensor(this.shape,this.shapeShape),O=t.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,B,S);O[0]<0&&(O[0]=E);for(let V=1;V<=this.raggedRank;++V)O[V]<0&&(O[V]=this.getMaxWidth(V));return O}calculateFirstParentOutputIndex(E,S,l){const B=Math.min(E,l),O=[];let V=0;for(let L=0;L<B;++L,V+=S)O.push(V);for(let L=B;L<E;++L)O.push(-1);return t.util.assert(O.length===E,()=>"Final length of result must be equal to firstDimension."),O}calculateOutputIndexRowSplit(E,S,l,B){const O=E.length,V=[];for(let L=0;L<O-1;++L){const g=E[L+1]-E[L];let W=Math.min(B,g),de=S[L];de===-1&&(W=0);for(let ke=0;ke<W;++ke)V.push(de),de+=l;for(let ke=0;ke<g-W;++ke)V.push(-1)}if(O>0&&V.length!==E[O-1])throw new Error("Invalid row split size.");return V}calculateOutputIndexValueRowID(E,S,l,B){const O=E.length,V=[];if(O===0)return[];let L=0,g=E[0];if(g>=S.length)throw new Error(`Got currentValueRowId=${g}, which is not less than ${S.length}`);let W=S[g];V.push(W);for(let de=1;de<O;++de){const ke=E[de];if(ke===g)W>=0&&(++L,L<B?W+=l:W=-1);else{if(L=0,g=ke,ke>=S.length)throw new Error(`Got nextValueRowId=${ke} which is not less than ${S.length}`);W=S[ke]}V.push(W)}if(V.length!==E.length)throw new Error("Invalid row ids.");return V}calculateOutputIndex(E,S,l,B){const O=this.getRowPartitionTensor(E),V=this.getRowPartitionTypeByDimension(E);switch(V){case m.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(O,S,l,B);case m.ROW_SPLITS:if(O.length-1>S.length)throw new Error(`Row partition size is greater than output size: ${O.length-1} > ${S.length}`);return this.calculateOutputIndexRowSplit(O,S,l,B);default:throw new Error(`Unsupported partition type: ${m[V]}`)}}getFirstDimensionSize(){const E=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const S=this.rowPartitionTypes[0];switch(S){case m.FIRST_DIM_SIZE:return E[0];case m.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case m.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${m[S]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const E=this.getFirstDimensionSize(),S=this.calculateOutputSize(E),l=new Array(this.raggedRank+1);l[l.length-1]=1;for(let V=l.length-2;V>=0;--V)l[V]=l[V+1]*S[V+1];const B=A(S,!1),O=t.util.getArrayFromDType(this.valuesDType,t.util.sizeFromShape(B));if(l[0]*S[0]>0){let V=this.calculateFirstParentOutputIndex(E,l[0],S[0]);for(let L=1;L<=this.raggedRank;++L)V=this.calculateOutputIndex(L-1,V,l[L],S[L]);this.setOutput(this.raggedRank,V,O,B)}return[B,O]}setOutput(E,S,l,B){if(l.length===0)return;const O=this.values,V=l;let L=B.slice();L=L.slice(E+1);const g=t.util.sizeFromShape(L),W=S.length;let de=this.defaultValue;if(de.length!==g&&de.length!==1){const Q=this.defaultValueShape;Object(t.tidy)(()=>{const Se=Object(t.reshape)(de,Q);de=Object(t.broadcastTo)(Se,L).dataSync()})}let ke=0,Ie=0,he=0;for(let Q=0;Q<=W;++Q){let Se=Q<W?S[Q]:-1;if(Se!==he){if(Ie<he){const Z=O.subarray(ke*g);b(V.subarray(Ie*g),Z,(he-Ie)*g)}if(Q>=W){const Z=l.length;Se=Math.floor(Z/g)}if(Se>he)if(this.defaultValue.length===1)V.subarray(he*g,Se*g).fill(this.defaultValue[0]),he=Se;else for(;Se>he;)b(V.slice(he*g),de,g),++he;Se<0?(ke=Q+1,Ie=he):(ke=Q,Ie=he,he=Ie+1)}else++he}}}function b(y,E,S){for(let l=0;l<S;l++)y[l]=E[l]}function A(y,E){const S=[];for(let l of y){if(l<0){if(!E)throw new Error(`Dimension ${l} must be >= 0`);if(l<-1)throw new Error(`Dimension ${l} must be >= -1`);l=-1}S.push(l)}return S}function D(y,E,S,l,B,O,V,L,g,W){return new h(y,E,S,l,B,O,V,L,g,W).compute()}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D){if(h===b||h<b&&A<0||b<h&&A>1)return t.util.makeZerosTypedArray(0,D);const y=Math.abs(Math.ceil((b-h)/A)),E=t.util.makeZerosTypedArray(y,D);b<h&&A===1&&(A=-1),E[0]=h;for(let S=1;S<E.length;S++)E[S]=E[S-1]+A;return E}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>1/Math.sqrt(y)),A=Object(h.b)(t.Rsqrt,b),D={kernelName:t.Rsqrt,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y,E,S){const l=b[0],B=E[0],O=new Array(B),V=new Array(l),L=b[1];if(B===0){if(l!==0)throw new Error(t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[t.util.getArrayFromDType(A,0),[0,L],t.util.getArrayFromDType(y,0),O,V]}let g=!0,W=0;const de=new Array(B).fill(0);for(let Ie=0;Ie<l;++Ie){const he=h[Ie*L];if(he<0)throw new Error(t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(Ie,he));if(he>=B)throw new Error(t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(Ie,he,B));++de[he],g=g&&he>=W,W=he}let ke=!0;for(let Ie=0;Ie<B;++Ie){const he=de[Ie]===0;O[Ie]=he,ke=ke&&!he,de[Ie]=Math.max(de[Ie],1),Ie>0&&(de[Ie]+=de[Ie-1])}if(ke&&g){const Ie=h,he=D;for(let Q=0;Q<l;++Q)V[Q]=Q;return[Ie,[l,L],he,O,V]}{const Ie=de[B-1],he=t.util.getArrayFromDType(A,Ie*L),Q=t.util.getArrayFromDType(y,Ie),Se=new Array(B).fill(0);for(let Z=0;Z<l;++Z){const G=h[Z*L],He=Se[G],me=(G===0?0:de[G-1])+He;Se[G]++;for(let et=0;et<L;++et)he[me*L+et]=h[Z*L+et];Q[me]=D[Z],V[Z]=me}for(let Z=0;Z<B;++Z)if(Se[Z]===0){const G=Z===0?0:de[Z-1];he[G*L+0]=Z;for(let He=1;He<L;++He)he[G*L+He]=0;Q[G]=S}return[he,[Ie,L],Q,O,V]}}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D,y){const E=t.util.sizeFromShape(D),S=b[0],l=y.length,B=[];let O=1,V=-1;for(let ke=0;ke<l;++ke){const Ie=y[ke];if(Ie===-1){if(V!==-1)throw new Error(t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(V,ke));V=ke,B.push(1)}else{if(Ie<0)throw new Error(t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(ke,Ie));O*=Ie,B.push(Ie)}}if(V!==-1){if(O<=0)throw new Error(t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const ke=Math.trunc(E/O);if(O*ke!==E)throw new Error(t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(D,B));B[V]=ke}if(t.util.sizeFromShape(B)!==E)throw new Error(t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(D,B));const L=D.length,g=[];if(L>0){g[L-1]=1;for(let ke=L-2;ke>=0;--ke)g[ke]=g[ke+1]*D[ke+1]}const W=[];if(l>0){W[l-1]=1;for(let ke=l-2;ke>=0;--ke)W[ke]=W[ke+1]*B[ke+1]}const de=t.util.getArrayFromDType(A,S*l);for(let ke=0;ke<S;++ke){let Ie=0;for(let he=0;he<L;++he)Ie+=h[ke*L+he]*g[he];for(let he=0;he<l;++he)de[ke*l+he]=Math.trunc(Ie/W[he]),Ie%=W[he]}return[de,[S,l],B]}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(21),h=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)(y=>Math.sqrt(y)),A=Object(h.a)(t.Sqrt,y=>Math.sqrt(y)),D={kernelName:t.Sqrt,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"b",function(){return b}),e.d(n,"a",function(){return D});var t=e(0),m=e(12),h=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b=Object(m.a)((y,E)=>{const S=y-E;return S*S}),A=Object(h.a)(t.SquaredDifference,b),D={kernelName:t.SquaredDifference,backendName:"cpu",kernelFunc:A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D){const y=Object(t.buffer)(h,b.dtype);for(let E=0;E<y.size;E++){const S=y.indexToLoc(E),l=new Array(S.length);for(let B=0;B<l.length;B++)l[B]=S[B]*A[B]+D[B];y.set(b.get(...l),...S)}return y}},function(I,n,e){e.d(n,"a",function(){return h});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m{constructor(A,D,y,E,S,l){this.separator=t.util.encodeString(A),this.nGramWidths=D,this.leftPad=t.util.encodeString(y),this.rightPad=t.util.encodeString(E),this.padWidth=S,this.preserveShort=l}getPadWidth(A){return Math.min(this.padWidth<0?A-1:this.padWidth,A-1)}getNumNGrams(A,D){const y=this.getPadWidth(D);return Math.max(0,A+2*y-D+1)}createNGrams(A,D,y,E,S,l){for(let B=0;B<S;++B){const O=this.getPadWidth(l),V=Math.max(0,O-B),L=Math.max(0,O-(S-(B+1))),g=l-(V+L),W=D+(V>0?0:B-O);let de=0;de+=V*this.leftPad.length;for(let Q=0;Q<g;++Q)de+=A[W+Q].length;de+=L*this.rightPad.length,de+=(V+L+g-1)*this.separator.length,y[E+B]=new Uint8Array(de);const ke=y[E+B];let Ie=0;const he=Q=>Q.forEach(Se=>ke[Ie++]=Se);for(let Q=0;Q<V;++Q)he(this.leftPad),he(this.separator);for(let Q=0;Q<g-1;++Q)he(A[W+Q]),he(this.separator);if(g>0){he(A[W+g-1]);for(let Q=0;Q<L;++Q)he(this.separator),he(this.rightPad)}else{for(let Q=0;Q<L-1;++Q)he(this.rightPad),he(this.separator);he(this.rightPad)}}}compute(A,D){const y=A.length,E=D.length;if(E>0){let O=D[0];if(O!==0)throw new Error(`First split value must be 0, got ${O}`);for(let V=1;V<E;++V){let L=D[V]>=O;if(L=L&&D[V]<=y,!L)throw new Error(`Invalid split value ${D[V]}, must be in [${O}, ${y}]`);O=D[V]}if(O!==y)throw new Error(`Last split value must be data size. Expected ${y}, got ${O}`)}const S=E-1,l=t.util.getArrayFromDType("int32",E);if(y===0||E===0){const O=new Array(y);for(let V=0;V<=S;++V)l[V]=0;return[O,l]}l[0]=0;for(let O=1;O<=S;++O){const V=D[O]-D[O-1];let L=0;this.nGramWidths.forEach(g=>{L+=this.getNumNGrams(V,g)}),this.preserveShort&&V>0&&L===0&&(L=1),l[O]=l[O-1]+L}const B=new Array(l[S]);for(let O=0;O<S;++O){const V=D[O];let L=l[O];if(this.nGramWidths.forEach(g=>{const W=D[O+1]-D[O],de=this.getNumNGrams(W,g);this.createNGrams(A,V,B,L,de,g),L+=de}),this.preserveShort&&L===l[O]){const g=D[O+1]-D[O];if(g===0)continue;const W=g+2*this.padWidth,de=1;this.createNGrams(A,V,B,L,de,W)}}return[B,l]}}function h(b,A,D,y,E,S,l,B){return new m(D,y,E,S,l,B).compute(b,A)}},function(I,n,e){e.d(n,"a",function(){return h});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(b,A,D,y){if(!b.length)return;if(A.length===0){for(let S=0;S<b.length;++S)y.push(b.subarray(S,S+1));return}if(A.length===1){const S=A[0];let l=b.indexOf(S);for(;l!==-1;){const B=b.subarray(0,l);D&&B.length===0||y.push(B),l=(b=b.subarray(l+1)).indexOf(S)}return void(D&&b.length===0||y.push(b))}let E=0;for(let S=0;S<b.length+1;S++)if(S===b.length||A.indexOf(b[S])!==-1){const l=b.subarray(E,S);D&&l.length===0||y.push(l),E=S+1}}function h(b,A,D){const y=b.length,E=[];let S=0,l=0;const B=new Array(y);for(let W=0;W<y;++W){const de=E.length;m(b[W],A,D,E);const ke=E.length-de;B[W]=ke,S+=ke,l=Math.max(l,ke)}const O=t.util.getArrayFromDType("int32",2*S),V=new Array(S),L=[y,l];let g=0;for(let W=0;W<y;++W)for(let de=0;de<B[W];++de)O[2*g]=W,O[2*g+1]=de,V[g]=E[g],++g;return[O,V,L]}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b){const A=t.util.getArrayFromDType("int32",h.length);for(let D=0;D<h.length;++D)A[D]=t.util.fingerPrint64(h[D]).modulo(b).getLowBitsUnsigned();return A}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b){const A=new Array(h.rank);for(let y=0;y<A.length;y++)A[y]=h.shape[y]*b[y];const D=Object(t.buffer)(A,h.dtype);for(let y=0;y<D.values.length;++y){const E=D.indexToLoc(y),S=new Array(h.rank);for(let B=0;B<S.length;B++)S[B]=E[B]%h.shape[B];const l=h.locToIndex(S);D.values[y]=h.values[l]}return D}},function(I,n,e){e.d(n,"a",function(){return b});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m=(A,D)=>{const y=D.value-A.value;return y===0?A.index-D.index:y};function h(A,D,y=0,E=A.length-1){for(;E>y;){if(E-y>600){const O=E-y+1,V=D-y+1,L=Math.log(O),g=.5*Math.exp(2*L/3),W=.5*Math.sqrt(L*g*(O-g)/O)*Math.sign(V-O/2);h(A,D,Math.max(y,Math.floor(D-V*g/O+W)),Math.min(E,Math.floor(D+(O-V)*g/O+W)))}const S=A[D];let l=y,B=E;for(t.util.swap(A,y,D),m(A[E],S)>0&&t.util.swap(A,y,E);l<B;){for(t.util.swap(A,l,B),l++,B--;m(A[l],S)<0;)l+=1;for(;m(A[B],S)>0;)B-=1}m(A[y],S)===0?t.util.swap(A,y,B):(B+=1,t.util.swap(A,B,E)),B<=D&&(y=B+1),D<=B&&(E=B-1)}}function b(A,D,y,E,S){const l=D[D.length-1],[B,O]=[A.length/l,l],V=t.util.getTypedArrayFromDType(y,B*E),L=t.util.getTypedArrayFromDType("int32",B*E);for(let W=0;W<B;W++){const de=W*O,ke=A.subarray(de,de+O);let Ie=new Array(ke.length);ke.forEach((Z,G)=>Ie[G]={value:Z,index:G}),E<Ie.length&&(h(Ie,E),Ie=Ie.slice(0,E)),S&&Ie.sort(m);const he=W*E,Q=V.subarray(he,he+E),Se=L.subarray(he,he+E);for(let Z=0;Z<E;Z++)Q[Z]=Ie[Z].value,Se[Z]=Ie[Z].index}const g=D.slice();return g[g.length-1]=E,[Object(t.buffer)(g,y,V),Object(t.buffer)(g,"int32",L)]}},function(I,n,e){e.d(n,"a",function(){return m});var t=e(0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m(h,b,A,D){const y=t.util.parseAxisParam(b,A)[0],E=[1,A[0],1];for(let de=0;de<y;de++)E[0]*=A[de];E[1]=A[y];for(let de=y+1;de<A.length;de++)E[2]*=A[de];const S={},l=new Int32Array(A[y]),B=new t.TensorBuffer(E,D,h),O=[],V=E[0]===1&&E[2]===1;for(let de=0;de<A[y];de++){let ke;if(V)ke=h[de].toString();else{const Ie=[];for(let he=0;he<E[0];he++)for(let Q=0;Q<E[2];Q++)Ie.push(B.get(he,de,Q));ke=Ie.join(",")}if(S[ke]!==void 0)l[de]=S[ke];else{const Ie=Object.keys(S).length;S[ke]=Ie,l[de]=Ie,O.push(de)}}const L=E.slice();L[1]=Object.keys(S).length;const g=new t.TensorBuffer(L,D);O.forEach((de,ke)=>{for(let Ie=0;Ie<E[0];Ie++)for(let he=0;he<E[2];he++)g.set(B.get(Ie,de,he),Ie,ke,he)});const W=A.slice();return W[y]=L[1],{outputValues:g.values,outputShape:W,indices:l}}},function(I,n,e){e.d(n,"a",function(){return h});var t=e(0),m=e(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h(b,A,D="float32"){if(D==="complex64"){const E=h(b,A,"float32"),S=h(b,A,"float32");return Object(m.a)({inputs:{real:E,imag:S},backend:b})}const y=t.util.makeZerosTypedArray(t.util.sizeFromShape(A),D);return b.makeTensorInfo(A,D,y)}},function(I,n,e){e.d(n,"a",function(){return Ri});var t,m,h=e(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b;(function(Ne){Ne[Ne.float32=0]="float32",Ne[Ne.int32=1]="int32",Ne[Ne.bool=2]="bool",Ne[Ne.string=3]="string",Ne[Ne.complex64=4]="complex64"})(t||(t={})),function(Ne){Ne[Ne.linear=0]="linear",Ne[Ne.relu=1]="relu",Ne[Ne.relu6=2]="relu6",Ne[Ne.prelu=3]="prelu",Ne[Ne.leakyrelu=4]="leakyrelu",Ne[Ne.sigmoid=5]="sigmoid",Ne[Ne.elu=6]="elu"}(m||(m={}));const A={kernelName:h._FusedMatMul,backendName:"wasm",setupFunc:function(Ne){b=Ne.wasm.cwrap(h._FusedMatMul,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{a:Te,b:Ye,bias:it,preluActivationWeights:xt}=ue;if(Te.dtype!=="float32"||Ye.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:ut,transposeB:ft,activation:pt,leakyreluAlpha:zt}=Xe,Dt=Be.dataIdMap.get(Te.dataId).id,We=Be.dataIdMap.get(Ye.dataId).id;let _t=0;if(it!=null){const cr=Be.dataIdMap.get(it.dataId);if(cr.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${cr.shape.length}.`);_t=cr.id}const jt=xt==null?0:Be.dataIdMap.get(xt.dataId).id,Xt=m[pt];if(Xt==null)throw new Error(`${pt} activation not yet supported for FusedConv2D in the wasm backend.`);const on=ut?Te.shape[2]:Te.shape[1],Pt=ft?Ye.shape[1]:Ye.shape[2],hn=h.broadcast_util.assertAndGetBroadcastShape(Te.shape.slice(0,-2),Ye.shape.slice(0,-2)),Fn=Be.makeOutput([...hn,on,Pt],Te.dtype),nr=Be.dataIdMap.get(Fn.dataId).id,dr=new Uint8Array(new Int32Array(Te.shape).buffer),hr=new Uint8Array(new Int32Array(Ye.shape).buffer);return b(Dt,dr,Te.shape.length,We,hr,Ye.shape.length,ut,ft,Xt,_t,jt,zt||0,nr),Fn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D(Ne,ue){let Be;return{kernelName:Ne,backendName:"wasm",setupFunc:function(Xe){Be=Xe.wasm.cwrap(Ne,null,["number","number","number"])},kernelFunc:function(Xe){const{backend:Te,inputs:{x:Ye}}=Xe,it=Te.dataIdMap.get(Ye.dataId).id,xt=Te.makeOutput(Ye.shape,ue||Ye.dtype),ut=Te.dataIdMap.get(xt.dataId).id;return h.util.sizeFromShape(xt.shape)===0||Be(it,t[Ye.dtype],ut),xt}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y=D(h.Abs);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E(Ne,ue,Be){let Xe;return{kernelName:Ne,backendName:"wasm",setupFunc:function(Te){Xe=Te.wasm.cwrap(Ne,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(Te){const{backend:Ye,inputs:it}=Te,{a:xt,b:ut}=it,ft=Ye.dataIdMap.get(xt.dataId).id,pt=Ye.dataIdMap.get(ut.dataId).id,zt=Be!=null?Be:xt.dtype,Dt=h.backend_util.assertAndGetBroadcastShape(xt.shape,ut.shape),We=Ye.makeOutput(Dt,zt);if(h.util.sizeFromShape(Dt)===0)return We;const _t=new Uint8Array(new Int32Array(xt.shape).buffer),jt=new Uint8Array(new Int32Array(ut.shape).buffer),Xt=Ye.dataIdMap.get(We.dataId).id;return Xe(ft,_t,xt.shape.length,pt,jt,ut.shape.length,t[xt.dtype],Xt),We}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S=E(h.Add);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l;const B={kernelName:h.AddN,backendName:"wasm",setupFunc:function(Ne){l=Ne.wasm.cwrap(h.AddN,null,["array","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be}=Ne,Xe=Be.makeOutput(ue[0].shape,ue[0].dtype);if(h.util.sizeFromShape(Xe.shape)===0)return Xe;const Te=ue.map(xt=>Be.dataIdMap.get(xt.dataId).id),Ye=new Uint8Array(new Int32Array(Te).buffer),it=Be.dataIdMap.get(Xe.dataId).id;return l(Ye,Te.length,t[Xe.dtype],it),Xe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O(Ne){const{inputs:{x:ue},backend:Be}=Ne,Xe=Be.makeOutput(ue.shape,ue.dtype),Te=Be.typedArrayFromHeap(ue);return Be.typedArrayFromHeap(Xe).set(Te),Xe}const V={kernelName:h.Identity,backendName:"wasm",kernelFunc:O};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let L;function g(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,[Te,Ye]=function(_t,jt){const Xt=[],on=[];for(let Pt=0;Pt<_t.length;++Pt)_t[Pt]!==1&&Xt.push(_t[Pt]),_t[jt[Pt]]!==1&&on.push(jt[Pt]);for(let Pt=0;Pt<on.length;++Pt){let hn=-1;for(let Fn=0;Fn<on.length;++Fn)on[Fn]>=Pt&&(hn===-1||on[hn]>on[Fn])&&(hn=Fn);on[hn]=Pt}return[Xt,on]}(ue.x.shape,Xe.perm);let it=!0;for(let _t=0;_t<Ye.length;_t++)Ye[_t]!==_t&&(it=!1);const xt=function(_t,jt){const Xt=new Array(_t.length);for(let on=0;on<Xt.length;on++)Xt[on]=_t[jt[on]];return Xt}(ue.x.shape,Xe.perm),ut={dataId:ue.x.dataId,shape:Te,dtype:ue.x.dtype};if(it){const _t=O({inputs:ue,backend:Be});return _t.shape=xt,_t}const ft=Be.makeOutput(xt,ut.dtype),pt=Be.dataIdMap.get(ut.dataId).id,zt=Be.dataIdMap.get(ft.dataId).id,Dt=new Uint8Array(new Int32Array(Ye).buffer),We=new Uint8Array(new Int32Array(ut.shape).buffer);return L(pt,We,ut.shape.length,t[ut.dtype],zt,Dt,Ye.length),ft}const W={kernelName:h.Transpose,backendName:"wasm",kernelFunc:g,setupFunc:function(Ne){L=Ne.wasm.cwrap(h.Transpose,null,["number","array","number","number","number","array","number"])}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(Ne,ue,Be){const Xe=Ne.shape,Te=Ne.shape.length,Ye=h.util.parseAxisParam(ue,Xe);let it=Ye;const xt=h.backend_util.getAxesPermutation(it,Te);let ut=null,ft=!1;if(xt!=null){const pt=new Array(Te);for(let Dt=0;Dt<pt.length;Dt++)pt[Dt]=Xe[xt[Dt]];it=h.backend_util.getInnerMostAxes(it.length,Te),ut=g({inputs:{x:Ne},attrs:{perm:xt},backend:Be});const zt=Be.dataIdMap.get(Ne.dataId).id;Be.dataIdMap.get(ut.dataId).id!==zt&&(ft=!0)}return{transposed:ut,originalAxes:Ye,axes:it,inputWasTransposed:ft}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ke;const Ie={kernelName:h.All,backendName:"wasm",setupFunc:function(Ne){ke=Ne.wasm.cwrap(h.All,null,["number, number, number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be;let xt=ue.dataIdMap.get(it.dataId).id,ut=it;const{transposed:ft,axes:pt,originalAxes:zt,inputWasTransposed:Dt}=de(it,Te,ue);Dt&&(ut=ft,xt=ue.dataIdMap.get(ft.dataId).id);const We=ut.shape.length;h.backend_util.assertAxesAreInnerMostDims("all",pt,We);const[_t,jt]=h.backend_util.computeOutAndReduceShapes(ut.shape,pt),Xt=h.util.sizeFromShape(jt),on=ue.makeOutput(_t,it.dtype);if(h.util.sizeFromShape(ut.shape)!==0){const Pt=ue.dataIdMap.get(on.dataId).id;ke(xt,Xt,Pt)}if(Dt&&ue.disposeData(ft.dataId),Ye){const Pt=h.backend_util.expandShapeToKeepDim(on.shape,zt);on.shape=Pt}return on}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let he;const Q={kernelName:h.Any,backendName:"wasm",setupFunc:function(Ne){he=Ne.wasm.cwrap(h.Any,null,["number, number, number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be;let xt=ue.dataIdMap.get(it.dataId).id,ut=it;const{transposed:ft,axes:pt,originalAxes:zt,inputWasTransposed:Dt}=de(it,Te,ue);Dt&&(ut=ft,xt=ue.dataIdMap.get(ft.dataId).id);const We=ut.shape.length;h.backend_util.assertAxesAreInnerMostDims("any",pt,We);const[_t,jt]=h.backend_util.computeOutAndReduceShapes(ut.shape,pt),Xt=h.util.sizeFromShape(jt),on=ue.makeOutput(_t,it.dtype);if(h.util.sizeFromShape(ut.shape)!==0){const Pt=ue.dataIdMap.get(on.dataId).id;he(xt,Xt,Pt)}if(Dt&&ue.disposeData(ft.dataId),Ye){const Pt=h.backend_util.expandShapeToKeepDim(on.shape,zt);on.shape=Pt}return on}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Se;const Z={kernelName:h.ArgMax,backendName:"wasm",kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te}=Xe,{x:Ye}=Be,it=ue.dataIdMap.get(Ye.dataId).id;let xt=it,ut=Ye;const{transposed:ft,axes:pt,inputWasTransposed:zt}=de(Ye,Te,ue);if(zt){const on=ue.dataIdMap.get(ft.dataId).id;on!==it&&(ut=ft,xt=on)}const Dt=ut.shape.slice(0,-1),We=ue.makeOutput(Dt,"int32"),_t=ue.dataIdMap.get(We.dataId).id,jt=h.util.sizeFromShape(We.shape),Xt=ut.shape[pt[0]];return Se(xt,t[ut.dtype],jt,Xt,_t),zt&&ue.disposeData(ft.dataId),We},setupFunc:function(Ne){Se=Ne.wasm.cwrap(h.ArgMax,null,["number","number","number","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let G;const He={kernelName:h.AvgPool,backendName:"wasm",setupFunc:function(Ne){G=Ne.wasm.cwrap(h.AvgPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,Te=ue.x,Ye=Xe.dataIdMap.get(Te.dataId).id,{filterSize:it,strides:xt,pad:ut,dimRoundingMode:ft}=Be,pt=h.backend_util.computePool2DInfo(Te.shape,it,xt,1,ut,ft),zt=pt.filterHeight,Dt=pt.filterWidth,We=pt.padInfo.top,_t=pt.padInfo.right,jt=pt.padInfo.bottom,Xt=pt.padInfo.left,on=pt.strideHeight,Pt=pt.strideWidth,hn=pt.inChannels;if(pt.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${pt.dataFormat}'. Please use 'channelsLast'.`);if(pt.dilationWidth!==1||pt.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${pt.dilationHeight}, ${pt.dilationWidth}].`);const Fn=Xe.makeOutput(pt.outShape,"float32"),nr=Xe.dataIdMap.get(Fn.dataId).id;return G(Ye,Te.shape[0],Te.shape[1],Te.shape[2],zt,Dt,We,_t,jt,Xt,on,Pt,hn,nr),Fn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function me(Ne){const{inputs:ue,attrs:Be}=Ne,{x:Xe}=ue,{shape:Te}=Be,Ye=h.util.sizeFromShape(Xe.shape),it=h.util.inferFromImplicitShape(Te,Ye);return h.util.assert(Ye===h.util.sizeFromShape(it),()=>`new shape: ${it}, old shape: ${Xe.shape}. New shape and old shape must have the same number of elements.`),Ne.backend.incRef(Xe.dataId),{dataId:Xe.dataId,shape:it,dtype:Xe.dtype}}const et={kernelName:h.Reshape,backendName:"wasm",kernelFunc:me};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rt;const It={kernelName:h.BatchMatMul,backendName:"wasm",setupFunc:function(Ne){rt=Ne.wasm.cwrap(h.BatchMatMul,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{a:Te,b:Ye}=ue,{transposeA:it,transposeB:xt}=Xe;if(Te.dtype!=="float32"||Ye.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const ut=Te.shape.length,ft=Ye.shape.length,pt=it?Te.shape[ut-2]:Te.shape[ut-1],zt=xt?Ye.shape[ft-1]:Ye.shape[ft-2],Dt=it?Te.shape[ut-1]:Te.shape[ut-2],We=xt?Ye.shape[ft-2]:Ye.shape[ft-1],_t=Te.shape.slice(0,-2),jt=Ye.shape.slice(0,-2),Xt=h.util.sizeFromShape(_t),on=h.util.sizeFromShape(jt),Pt=h.broadcast_util.assertAndGetBroadcastShape(Te.shape.slice(0,-2),Ye.shape.slice(0,-2)).concat([Dt,We]);h.util.assert(pt===zt,()=>`Error in matMul: inner shapes (${pt}) and (${zt}) of Tensors with shapes ${Te.shape} and ${Ye.shape} and transposeA=${it} and transposeB=${xt} must match.`);const hn=xt?[on,We,zt]:[on,zt,We],Fn=me({inputs:{x:Te},backend:Be,attrs:{shape:it?[Xt,pt,Dt]:[Xt,Dt,pt]}}),nr=me({inputs:{x:Ye},backend:Be,attrs:{shape:hn}}),dr=Be.dataIdMap.get(Fn.dataId).id,hr=Be.dataIdMap.get(nr.dataId).id,cr=it?Fn.shape[2]:Fn.shape[1],Mr=xt?nr.shape[1]:nr.shape[2],Sr=Math.max(Xt,on),Dr=Be.makeOutput([Sr,cr,Mr],Fn.dtype),Ar=Be.dataIdMap.get(Dr.dataId).id,aa=new Uint8Array(new Int32Array(Fn.shape).buffer),ya=new Uint8Array(new Int32Array(nr.shape).buffer);return rt(dr,aa,Fn.shape.length,hr,ya,nr.shape.length,it,xt,Ar),Be.disposeData(Fn.dataId),Be.disposeData(nr.dataId),Dr.shape=Pt,Dr}};var X=e(58),$t=e(23),Ct=e(76),Gt=e(83),Wt=e(84),lt=e(85);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(Ne){const{inputs:{x:ue},attrs:{begin:Be,size:Xe},backend:Te}=Ne,[Ye,it]=h.slice_util.parseSliceParams(ue,Be,Xe),xt=h.slice_util.isSliceContinous(ue.shape,Ye,it),ut=Te.readSync(ue.dataId),ft=Te.makeOutput(it,ue.dtype),pt=h.util.computeStrides(ue.shape),zt=Te.dataIdMap.get(ft.dataId);if(xt){const _t=h.slice_util.computeFlatOffset(Ye,pt);return ue.dtype==="string"?zt.stringBytes=ut.slice(_t,_t+h.util.sizeFromShape(it)):Te.typedArrayFromHeap(ft).set(ut.subarray(_t,_t+h.util.sizeFromShape(it))),ft}if(ue.dtype==="string"){const _t=Object($t.c)(ut,Ye,it,ue.shape,ue.dtype);return zt.stringBytes=_t,ft}const Dt=Te.typedArrayFromHeap(ft),We=ue.shape.length;if(We===2)(function(_t,jt,Xt,on,Pt){let hn=0;const Fn=on[0],nr=on[1],dr=Fn+Pt[0];for(let hr=Fn;hr<dr;hr++){const cr=hr*jt+nr;Xt.set(_t.subarray(cr,cr+Pt[1]),hn),hn+=Pt[1]}})(ut,pt[0],Dt,Ye,it);else if(We===3)(function(_t,jt,Xt,on,Pt,hn){let Fn=0;const nr=Pt[0],dr=Pt[1],hr=Pt[2],cr=nr+hn[0],Mr=dr+hn[1];for(let Sr=nr;Sr<cr;Sr++)for(let Dr=dr;Dr<Mr;Dr++){const Ar=Sr*jt+Dr*Xt+hr;on.set(_t.subarray(Ar,Ar+hn[2]),Fn),Fn+=hn[2]}})(ut,pt[0],pt[1],Dt,Ye,it);else if(We===4)(function(_t,jt,Xt,on,Pt,hn,Fn){let nr=0;const dr=hn[0],hr=hn[1],cr=hn[2],Mr=dr+Fn[0],Sr=hr+Fn[1],Dr=cr+Fn[2],Ar=hn[3];for(let aa=dr;aa<Mr;aa++)for(let ya=hr;ya<Sr;ya++)for(let Xa=cr;Xa<Dr;Xa++){const as=aa*jt+ya*Xt+Xa*on+Ar;Pt.set(_t.subarray(as,as+Fn[3]),nr),nr+=Fn[3]}})(ut,pt[0],pt[1],pt[2],Dt,Ye,it);else{const _t=Object($t.c)(ut,Ye,it,ue.shape,ue.dtype);Dt.set(_t)}return ft}const Ft={kernelName:h.Slice,backendName:"wasm",kernelFunc:Qt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yn={kernelName:h.BatchToSpaceND,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{blockShape:Ye,crops:it}=Xe,xt=Ye.reduce((Xt,on)=>Xt*on),ut=h.backend_util.getReshaped(Te.shape,Ye,xt),ft=h.backend_util.getPermuted(ut.length,Ye.length),pt=h.backend_util.getReshapedPermuted(Te.shape,Ye,xt),zt=h.backend_util.getSliceBeginCoords(it,Ye.length),Dt=h.backend_util.getSliceSize(pt,it,Ye.length),We=me({inputs:{x:Te},backend:Be,attrs:{shape:ut}}),_t=g({inputs:{x:We},backend:Be,attrs:{perm:ft}}),jt=Qt({inputs:{x:me({inputs:{x:_t},backend:Be,attrs:{shape:pt}})},backend:Be,attrs:{begin:zt,size:Dt}});return Be.disposeData(We.dataId),Be.disposeData(_t.dataId),Be.disposeData(We.dataId),jt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(Ne){const{inputs:{x:ue},attrs:{dtype:Be},backend:Xe}=Ne,Te=Xe.makeOutput(ue.shape,Be),Ye=Xe.typedArrayFromHeap(ue);return Xe.typedArrayFromHeap(Te).set(Ye),Te}const Kn={kernelName:h.Cast,backendName:"wasm",kernelFunc:Nn},zn=D(h.Ceil);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sr;const K={kernelName:h.ClipByValue,backendName:"wasm",setupFunc:function(Ne){sr=Ne.wasm.cwrap(h.ClipByValue,null,["number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{clipValueMin:Ye,clipValueMax:it}=Xe,xt=Be.dataIdMap.get(Te.dataId).id,ut=Be.makeOutput(Te.shape,Te.dtype),ft=Be.dataIdMap.get(ut.dataId).id;return sr(xt,Ye,it,ft),ut}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J(Ne){const{inputs:ue,backend:Be}=Ne,Xe=h.util.parseAxisParam(Ne.attrs.axis,ue[0].shape)[0];let Te=h.backend_util.computeOutShape(ue.map(We=>We.shape),Xe);const Ye=ue.filter(We=>h.util.sizeFromShape(We.shape)>0);if(Ye.length===1)return O({inputs:{x:Ye[0]},backend:Be});const it=Be.makeOutput(Te,ue[0].dtype);if(h.util.sizeFromShape(Te)===0)return it;const xt=Ye.map(We=>We.shape);if(h.backend_util.assertParamsConsistent(xt,Xe),Ye[0].dtype==="string"){const We=Ye.map(Pt=>{const hn=h.util.sizeFromShape(Pt.shape.slice(Xe));return me({inputs:{x:Pt},backend:Be,attrs:{shape:[-1,hn]}})}),_t=We.map(Pt=>({vals:Be.readSync(Pt.dataId),shape:Pt.shape}));Te=h.backend_util.computeOutShape(We.map(Pt=>Pt.shape),1);const jt=We[0].shape[0]===1,Xt=Object(X.a)(_t,Te,ue[0].dtype,jt),on=h.backend_util.computeOutShape(Ye.map(Pt=>Pt.shape),Xe);return it.shape=on,Be.dataIdMap.get(it.dataId).stringBytes=h.backend_util.fromStringArrayToUint8(Xt),We.forEach(Pt=>Be.disposeData(Pt.dataId)),it}const ut=h.util.sizeFromShape(Ye[0].shape.slice(0,Xe));let ft=0;const pt=Ye.map(We=>{const _t=h.util.sizeFromShape(We.shape.slice(Xe));return ft+=_t,_t}),zt=Ye.map(We=>Be.typedArrayFromHeap(We)),Dt=Be.typedArrayFromHeap(it);for(let We=0;We<ut;We++){let _t=We*ft;for(let jt=0;jt<zt.length;jt++){const Xt=pt[jt],on=We*Xt,Pt=zt[jt].subarray(on,on+Xt);Dt.set(Pt,_t),_t+=Xt}}return it}const we={kernelName:h.Concat,backendName:"wasm",kernelFunc:J};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vt;const wt={kernelName:h.Conv2D,backendName:"wasm",setupFunc:function(Ne){vt=Ne.wasm.cwrap(h.Conv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{x:Te,filter:Ye}=ue,it=Xe.dataIdMap.get(Te.dataId).id,xt=Xe.dataIdMap.get(Ye.dataId).id,{strides:ut,dilations:ft,pad:pt,dimRoundingMode:zt,dataFormat:Dt}=Be,We=h.backend_util.convertConv2DDataFormat(Dt),_t=h.backend_util.computeConv2DInfo(Te.shape,Ye.shape,ut,ft,pt,zt,!1,We),jt=_t.filterHeight,Xt=_t.filterWidth,on=_t.padInfo.top,Pt=_t.padInfo.right,hn=_t.padInfo.bottom,Fn=_t.padInfo.left,nr=_t.dilationHeight,dr=_t.dilationWidth,hr=_t.strideHeight,cr=_t.strideWidth,Mr=_t.inChannels,Sr=_t.outChannels,Dr=_t.padInfo.type==="SAME"?1:0;if(_t.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${_t.dataFormat}'. Please use 'channelsLast'.`);const Ar=Xe.makeOutput(_t.outShape,"float32"),aa=Xe.dataIdMap.get(Ar.dataId).id;return vt(it,Te.shape[0],Te.shape[1],Te.shape[2],xt,jt,Xt,on,Pt,hn,Fn,Dr,nr,dr,hr,cr,Mr,Sr,aa),Ar}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ot;const Ae={kernelName:h.Conv2DBackpropInput,backendName:"wasm",setupFunc:function(Ne){Ot=Ne.wasm.cwrap(h.Conv2DBackpropInput,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{dy:Te,filter:Ye}=Be,{strides:it,pad:xt,dataFormat:ut,dimRoundingMode:ft,inputShape:pt}=Xe,zt=h.backend_util.convertConv2DDataFormat(ut),Dt=h.backend_util.computeConv2DInfo(pt,Ye.shape,it,1,xt,ft,!1,zt),{batchSize:We,filterHeight:_t,filterWidth:jt,inChannels:Xt,inHeight:on,inWidth:Pt,outChannels:hn,outHeight:Fn,outWidth:nr,strideHeight:dr,strideWidth:hr}=Dt,cr=_t-1-Dt.padInfo.top,Mr=jt-1-Dt.padInfo.left,Sr=Dt.dataFormat==="channelsLast",Dr=h.util.computeStrides(Dt.inShape),Ar=h.util.computeStrides(Te.shape),[aa,ya,Xa]=h.util.computeStrides(Ye.shape),as=Dr[0],Us=Sr?Dr[1]:Dr[2],Is=Sr?Dr[2]:1,Ya=Sr?1:Dr[1],ds=Ar[0],hs=Sr?Ar[1]:Ar[2],Ws=Sr?Ar[2]:1,fa=Sr?1:Ar[1],Vs=ue.makeOutput(Dt.inShape,"float32"),wi=ue.dataIdMap.get(Vs.dataId).id,Gs=ue.dataIdMap.get(Te.dataId).id,ki=ue.dataIdMap.get(Ye.dataId).id;return Ot(Gs,ki,We,_t,jt,on,Pt,Xt,Fn,nr,hn,dr,hr,cr,Mr,aa,ya,Xa,as,Us,Is,Ya,ds,hs,Ws,fa,wi),Vs}},mt=D(h.Cos),Mt=D(h.Cosh);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Nt;let un;(function(Ne){Ne[Ne.bilinear=0]="bilinear",Ne[Ne.nearest=1]="nearest"})(Nt||(Nt={}));const Rn={kernelName:h.CropAndResize,backendName:"wasm",setupFunc:function(Ne){un=Ne.wasm.cwrap(h.CropAndResize,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{method:Te,extrapolationValue:Ye,cropSize:it}=Xe,{image:xt,boxes:ut,boxInd:ft}=Be,pt=ut.shape[0],[zt,Dt]=it,We=[pt,zt,Dt,xt.shape[3]];let _t,jt=ue.dataIdMap.get(xt.dataId);xt.dtype!=="float32"&&(_t=Nn({backend:ue,inputs:{x:xt},attrs:{dtype:"float32"}}),jt=ue.dataIdMap.get(_t.dataId));const Xt=jt.id,on=ue.dataIdMap.get(ut.dataId).id,Pt=ue.dataIdMap.get(ft.dataId).id,hn=ue.makeOutput(We,"float32"),Fn=ue.dataIdMap.get(hn.dataId).id,nr=new Uint8Array(new Int32Array(xt.shape).buffer);return un(Xt,on,Pt,pt,nr,zt,Dt,Nt[Te],Ye,Fn),_t!=null&&ue.disposeData(_t.dataId),hn}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oe;const le={kernelName:h.Cumprod,backendName:"wasm",setupFunc:function(Ne){oe=Ne.wasm.cwrap(h.Cumprod,null,["number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{axis:Ye,exclusive:it,reverse:xt}=Xe,ut=Te.shape.length;h.util.assert(Te.dtype==="float32"||Te.dtype==="int32",()=>`cumprod does not support ${Te.dtype} tensors in the WASM backend`);const ft=h.backend_util.getAxesPermutation([Ye],ut);let pt=Te;ft!==null&&(pt=g({inputs:{x:Te},attrs:{perm:ft},backend:Be}));const zt=h.backend_util.getInnerMostAxes(1,ut)[0];h.backend_util.assertAxesAreInnerMostDims("cumprod",[zt],ut);const Dt=Be.makeOutput(pt.shape,pt.dtype),We=pt.shape[zt],_t=Be.dataIdMap.get(pt.dataId).id,jt=Be.dataIdMap.get(Dt.dataId).id;oe(_t,it?1:0,xt?1:0,We,jt,t[Te.dtype]);let Xt=Dt;return ft!==null&&(Xt=g({inputs:{x:Dt},attrs:{perm:h.backend_util.getUndoAxesPermutation(ft)},backend:Be}),Be.disposeData(pt.dataId),Be.disposeData(Dt.dataId)),Xt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qe;const Mn={kernelName:h.Cumsum,backendName:"wasm",setupFunc:function(Ne){qe=Ne.wasm.cwrap(h.Cumsum,null,["number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{axis:Ye,exclusive:it,reverse:xt}=Xe,ut=Te.shape.length;h.util.assert(Te.dtype==="float32"||Te.dtype==="int32",()=>`cumsum does not support ${Te.dtype} tensors in the WASM backend`);const ft=h.backend_util.getAxesPermutation([Ye],ut);let pt=Te;ft!==null&&(pt=g({inputs:{x:Te},attrs:{perm:ft},backend:Be}));const zt=h.backend_util.getInnerMostAxes(1,ut)[0];h.backend_util.assertAxesAreInnerMostDims("cumsum",[zt],ut);const Dt=Be.makeOutput(pt.shape,pt.dtype),We=pt.shape[zt],_t=Be.dataIdMap.get(pt.dataId).id,jt=Be.dataIdMap.get(Dt.dataId).id;qe(_t,it?1:0,xt?1:0,We,jt,t[Te.dtype]);let Xt=Dt;return ft!==null&&(Xt=g({inputs:{x:Dt},attrs:{perm:h.backend_util.getUndoAxesPermutation(ft)},backend:Be}),Be.disposeData(pt.dataId),Be.disposeData(Dt.dataId)),Xt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zr;const Ur={kernelName:h.DepthToSpace,backendName:"wasm",setupFunc:function(Ne){zr=Ne.wasm.cwrap(h.DepthToSpace,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{x:Te}=Be,{blockSize:Ye,dataFormat:it}=Xe,xt=Te.shape[0],ut=(it==="NHWC"?Te.shape[1]:Te.shape[2])*Ye,ft=(it==="NHWC"?Te.shape[2]:Te.shape[3])*Ye,pt=(it==="NHWC"?Te.shape[3]:Te.shape[1])/(Ye*Ye),zt=it==="NHWC"?[xt,ut,ft,pt]:[xt,pt,ut,ft],Dt=ue.makeOutput(zt,"float32"),We=ue.dataIdMap.get(Te.dataId).id,_t=new Uint8Array(new Int32Array(h.util.computeStrides(Te.shape)).buffer),jt=new Uint8Array(new Int32Array(zt).buffer),Xt=new Uint8Array(new Int32Array(h.util.computeStrides(zt)).buffer),on=ue.dataIdMap.get(Dt.dataId).id;return zr(We,Ye,it==="NHWC"?1:0,_t,Te.shape.length-1,jt,Xt,zt.length,on),Dt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _r;const ir={kernelName:h.DepthwiseConv2dNative,backendName:"wasm",setupFunc:function(Ne){_r=Ne.wasm.cwrap(h.DepthwiseConv2dNative,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{x:Te,filter:Ye}=ue,it=Xe.dataIdMap.get(Te.dataId).id,xt=Xe.dataIdMap.get(Ye.dataId).id,{strides:ut,dilations:ft,pad:pt,dimRoundingMode:zt}=Be,Dt=ft==null?[1,1]:ft,We=h.backend_util.computeConv2DInfo(Te.shape,Ye.shape,ut,Dt,pt,zt,!0),_t=We.filterHeight,jt=We.filterWidth,Xt=We.padInfo.top,on=We.padInfo.right,Pt=We.padInfo.bottom,hn=We.padInfo.left,Fn=We.dilationHeight,nr=We.dilationWidth,dr=We.strideHeight,hr=We.strideWidth,cr=We.inChannels,Mr=We.outChannels,Sr=We.padInfo.type==="SAME"?1:0;if(We.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${We.dataFormat}'. Please use 'channelsLast'.`);const Dr=Xe.makeOutput(We.outShape,"float32"),Ar=Xe.dataIdMap.get(Dr.dataId).id;return _r(it,Te.shape[0],Te.shape[1],Te.shape[2],xt,_t,jt,Xt,on,Pt,hn,Sr,Fn,nr,dr,hr,cr,Mr,Ar),Dr}},Zn=D(h.Elu),$r=E(h.Equal,0,"bool"),en=D(h.Exp,"float32");/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mn(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{input:Te}=ue,{dim:Ye}=Be,it=Te.shape.length,xt=Te.shape.slice();let ut=Ye;return Ye<0&&(h.util.assert(-(it+1)<=Ye,()=>`Axis must be in the interval [${-(it+1)}, ${it}]`),ut=it+Ye+1),xt.splice(ut,0,1),me({inputs:{x:Te},backend:Xe,attrs:{shape:xt}})}const Ln={kernelName:h.ExpandDims,backendName:"wasm",kernelFunc:mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function or(Ne){const{attrs:{shape:ue,value:Be,dtype:Xe},backend:Te}=Ne,Ye=Te.makeOutput(ue,Xe);return Te.typedArrayFromHeap(Ye).fill(Be),Ye}const lr={kernelName:h.Fill,backendName:"wasm",kernelFunc:or};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qn;const br={kernelName:h.FlipLeftRight,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be}=Ne,{image:Xe}=ue,Te=Be.makeOutput(Xe.shape,Xe.dtype),Ye=Be.dataIdMap.get(Xe.dataId).id,it=Be.dataIdMap.get(Te.dataId).id,[xt,ut,ft,pt]=Xe.shape;return Qn(Ye,xt,ut,ft,pt,it),Te},setupFunc:function(Ne){Qn=Ne.wasm.cwrap(h.FlipLeftRight,null,["number","number","number","number","number","number"])}},gr=D(h.Floor),At=E(h.FloorDiv);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let q;const ae={kernelName:h.FusedBatchNorm,backendName:"wasm",setupFunc:function(Ne){q=Ne.wasm.cwrap(h.FusedBatchNorm,null,["number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{varianceEpsilon:Te}=Xe,{x:Ye,mean:it,variance:xt,offset:ut,scale:ft}=Be,pt=ue.dataIdMap.get(Ye.dataId).id,zt=ue.dataIdMap.get(it.dataId).id,Dt=ue.dataIdMap.get(xt.dataId).id,We=ut!=null?ue.dataIdMap.get(ut.dataId).id:0,_t=ft!=null?ue.dataIdMap.get(ft.dataId).id:0,jt=ue.makeOutput(Ye.shape,Ye.dtype);if(h.util.sizeFromShape(Ye.shape)===0)return jt;const Xt=ue.dataIdMap.get(jt.dataId).id;return q(pt,zt,Dt,We,_t,Te,Xt),jt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qe;const ht={kernelName:h.FusedConv2D,backendName:"wasm",setupFunc:function(Ne){Qe=Ne.wasm.cwrap(h.FusedConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{x:Te,filter:Ye,bias:it,preluActivationWeights:xt}=ue,{strides:ut,pad:ft,dilations:pt,dataFormat:zt,dimRoundingMode:Dt,activation:We,leakyreluAlpha:_t}=Be,jt=h.backend_util.computeConv2DInfo(Te.shape,Ye.shape,ut,pt,ft,Dt),Xt=m[We];if(Xt==null)throw new Error(`${We} activation not yet supported for FusedConv2D in the wasm backend.`);const on=Xe.dataIdMap.get(Te.dataId).id,Pt=Xe.dataIdMap.get(Ye.dataId).id,hn=jt.outChannels;let Fn=0;if(it!=null){const fa=Xe.dataIdMap.get(it.dataId);if(fa.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${fa.shape.length}.`);if(fa.shape[0]!==hn)throw new Error(`FusedConv2D bias shape (${fa.shape}) does not match the number of output channels (${hn})`);Fn=fa.id}const nr=jt.filterHeight,dr=jt.filterWidth,hr=jt.padInfo.top,cr=jt.padInfo.right,Mr=jt.padInfo.bottom,Sr=jt.padInfo.left,Dr=jt.dilationHeight,Ar=jt.dilationWidth,aa=jt.strideHeight,ya=jt.strideWidth,Xa=jt.inChannels,as=jt.padInfo.type==="SAME"?1:0,Us=jt.batchSize,Is=jt.inHeight,Ya=jt.inWidth;if(zt!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${zt}'. Please use 'NHWC'.`);const ds=Xe.makeOutput(jt.outShape,"float32"),hs=Xe.dataIdMap.get(ds.dataId).id,Ws=xt==null?0:Xe.dataIdMap.get(xt.dataId).id;return Qe(on,Us,Is,Ya,Pt,nr,dr,Fn,hr,cr,Mr,Sr,as,Dr,Ar,aa,ya,Xa,hn,Xt,Ws,_t||0,hs),ds}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bt;const Kt={kernelName:h.FusedDepthwiseConv2D,backendName:"wasm",setupFunc:function(Ne){Bt=Ne.wasm.cwrap(h.FusedDepthwiseConv2D,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{x:Te,filter:Ye,bias:it,preluActivationWeights:xt}=ue,{strides:ut,pad:ft,dilations:pt,dataFormat:zt,dimRoundingMode:Dt,activation:We,leakyreluAlpha:_t}=Be,jt=h.backend_util.computeConv2DInfo(Te.shape,Ye.shape,ut,pt,ft,Dt,!0),Xt=m[We];if(Xt==null)throw new Error(`${We} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const on=Xe.dataIdMap.get(Te.dataId).id,Pt=Xe.dataIdMap.get(Ye.dataId).id,hn=jt.outChannels;let Fn=0;if(it!=null){const fa=Xe.dataIdMap.get(it.dataId);if(fa.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${fa.shape.length}.`);if(fa.shape[0]!==hn)throw new Error(`FusedDepthwiseConv2D bias shape (${fa.shape}) does not match the number of output channels (${hn})`);Fn=fa.id}const nr=jt.filterHeight,dr=jt.filterWidth,hr=jt.padInfo.top,cr=jt.padInfo.right,Mr=jt.padInfo.bottom,Sr=jt.padInfo.left,Dr=jt.dilationHeight,Ar=jt.dilationWidth,aa=jt.strideHeight,ya=jt.strideWidth,Xa=jt.inChannels,as=jt.padInfo.type==="SAME"?1:0,Us=jt.batchSize,Is=jt.inHeight,Ya=jt.inWidth;if(zt!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${zt}'. Please use 'NHWC'.`);const ds=Xe.makeOutput(jt.outShape,"float32"),hs=Xe.dataIdMap.get(ds.dataId).id,Ws=xt==null?0:Xe.dataIdMap.get(xt.dataId).id;return Bt(on,Us,Is,Ya,Pt,nr,dr,Fn,hr,cr,Mr,Sr,as,Dr,Ar,aa,ya,Xa,hn,Xt,Ws,_t||0,hs),ds}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ut;const tn={kernelName:h.GatherNd,backendName:"wasm",setupFunc:function(Ne){Ut=Ne.wasm.cwrap(h.GatherNd,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be}=Ne,{params:Xe,indices:Te}=Be,[Ye,it,xt,ut]=h.gather_util.prepareAndValidate(Xe,Te),ft=ue.makeOutput(Ye,Xe.dtype);if(it===0)return ft;const pt=Te.shape,zt=pt[pt.length-1],Dt=ue.dataIdMap.get(Xe.dataId).id,We=ue.dataIdMap.get(Te.dataId).id,_t=new Uint8Array(new Int32Array(ut).buffer),jt=ue.dataIdMap.get(ft.dataId).id;return Ut(Dt,t[Xe.dtype],We,it,zt,xt,_t,jt),ft}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bn;const xn={kernelName:h.GatherV2,backendName:"wasm",setupFunc:function(Ne){bn=Ne.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{x:Te,indices:Ye}=Be,{axis:it,batchDims:xt}=Xe,ut=h.util.parseAxisParam(it,Te.shape)[0],ft=ue.readSync(Ye.dataId),pt=Te.shape[ut];for(let hr=0;hr<ft.length;++hr){const cr=ft[hr];h.util.assert(cr<=pt-1&&cr>=0,()=>`GatherV2: the index value ${cr} is not in [0, ${pt-1}]`)}const zt=h.backend_util.segment_util.collectGatherOpShapeInfo(Te,Ye,ut,xt),Dt=me({inputs:{x:Te},attrs:{shape:[zt.batchSize,zt.outerSize,zt.dimSize,zt.sliceSize]},backend:ue}),We=h.util.sizeFromShape(Ye.shape),_t=me({inputs:{x:Ye},attrs:{shape:[zt.batchSize,We/zt.batchSize]},backend:ue}),jt=[zt.batchSize,zt.outerSize,We/zt.batchSize,zt.sliceSize],Xt=ue.makeOutput(jt,Te.dtype);if(h.util.sizeFromShape(Te.shape)===0)return Xt;const on=Dt.shape.length-1,Pt=ue.dataIdMap.get(Dt.dataId).id,hn=ue.dataIdMap.get(_t.dataId).id,Fn=ue.dataIdMap.get(Xt.dataId).id,nr=new Uint8Array(new Int32Array(h.util.computeStrides(Dt.shape)).buffer),dr=new Uint8Array(new Int32Array(h.util.computeStrides(jt)).buffer);return bn(Pt,t[Te.dtype],nr,on,hn,zt.batchSize,dr,Fn),ue.disposeData(Dt.dataId),ue.disposeData(_t.dataId),Xt.shape=zt.outputShape,Xt}},rn=E(h.Greater,0,"bool"),Xn=E(h.GreaterEqual,0,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xr;const Lr={kernelName:h.LeakyRelu,backendName:"wasm",setupFunc:function(Ne){xr=Ne.wasm.cwrap(h.LeakyRelu,null,["number","number","number","number"])},kernelFunc:function(Ne){const{inputs:{x:ue},attrs:{alpha:Be},backend:Xe}=Ne,Te=Xe.dataIdMap.get(ue.dataId).id,Ye=Xe.makeOutput(ue.shape,"float32");if(h.util.sizeFromShape(ue.shape)!==0){const it=Xe.dataIdMap.get(Ye.dataId).id;xr(Te,t[ue.dtype],Be,it)}return Ye}},Wr=E(h.Less,0,"bool"),vr=E(h.LessEqual,0,"bool"),ua=D(h.Log),ma=E(h.LogicalAnd,0,"bool"),Cr=D(h.LogicalNot),Da=E(h.LogicalOr,0,"bool"),kr=E(h.LogicalXor,0,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pr;const qr={kernelName:h.Max,backendName:"wasm",setupFunc:function(Ne){Pr=Ne.wasm.cwrap(h.Max,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{reductionIndices:Te,keepDims:Ye}=Xe,{x:it}=Be;let xt=ue.dataIdMap.get(it.dataId).id,ut=it;const{transposed:ft,axes:pt,originalAxes:zt,inputWasTransposed:Dt}=de(it,Te,ue);Dt&&(ut=ft,xt=ue.dataIdMap.get(ft.dataId).id);const We=ut.shape.length;h.backend_util.assertAxesAreInnerMostDims("max",pt,We);const[_t,jt]=h.backend_util.computeOutAndReduceShapes(ut.shape,pt),Xt=h.util.sizeFromShape(jt),on=ue.makeOutput(_t,it.dtype);if(h.util.sizeFromShape(ut.shape)!==0){const Pt=ue.dataIdMap.get(on.dataId).id;Pr(xt,t[it.dtype],Xt,Pt)}if(Dt&&ue.disposeData(ft.dataId),Ye){const Pt=h.backend_util.expandShapeToKeepDim(on.shape,zt);on.shape=Pt}return on}},ha=E(h.Maximum);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zr;const Vr={kernelName:h.MaxPool,backendName:"wasm",setupFunc:function(Ne){Zr=Ne.wasm.cwrap(h.MaxPool,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,Te=ue.x,Ye=Xe.dataIdMap.get(Te.dataId).id;h.util.assert(Te.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${Te.dtype}.`);const{filterSize:it,strides:xt,pad:ut,dimRoundingMode:ft}=Be,pt=h.backend_util.computePool2DInfo(Te.shape,it,xt,1,ut,ft),zt=pt.filterHeight,Dt=pt.filterWidth,We=pt.padInfo.top,_t=pt.padInfo.right,jt=pt.padInfo.bottom,Xt=pt.padInfo.left,on=pt.dilationHeight,Pt=pt.dilationWidth,hn=pt.strideHeight,Fn=pt.strideWidth,nr=pt.inChannels,dr=pt.outChannels;if(pt.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${pt.dataFormat}'. Please use 'channelsLast'.`);const hr=Xe.makeOutput(pt.outShape,"float32"),cr=Xe.dataIdMap.get(hr.dataId).id;return Zr(Ye,Te.shape[0],Te.shape[1],Te.shape[2],zt,Dt,We,_t,jt,Xt,on,Pt,hn,Fn,nr,dr,cr),hr}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ca;const Ta={kernelName:h.Mean,backendName:"wasm",setupFunc:function(Ne){Ca=Ne.wasm.cwrap(h.Mean,null,["number, number, number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be,xt=ue.dataIdMap.get(it.dataId).id;let ut=xt,ft=it;const{transposed:pt,axes:zt,originalAxes:Dt,inputWasTransposed:We}=de(it,Te,ue);let _t=zt;if(We){const Fn=ue.dataIdMap.get(pt.dataId).id;Fn!==xt&&(ft=pt,ut=Fn,_t=h.backend_util.getInnerMostAxes(_t.length,ft.shape.length))}h.backend_util.assertAxesAreInnerMostDims("mean",_t,ft.shape.length);const[jt,Xt]=h.backend_util.computeOutAndReduceShapes(ft.shape,_t),on=h.util.sizeFromShape(Xt);let Pt=ft;ft.dtype!=="float32"&&(Pt=Nn({backend:ue,inputs:{x:ft},attrs:{dtype:"float32"}}),ut=ue.dataIdMap.get(Pt.dataId).id);const hn=ue.makeOutput(jt,"float32");if(h.util.sizeFromShape(ft.shape)!==0){const Fn=ue.dataIdMap.get(hn.dataId).id;Ca(ut,on,Fn)}if(We&&ue.disposeData(pt.dataId),Ye){const Fn=h.backend_util.expandShapeToKeepDim(hn.shape,Dt);hn.shape=Fn}return ft.dtype!=="float32"&&ue.disposeData(Pt.dataId),hn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pa;const is={kernelName:h.Min,backendName:"wasm",setupFunc:function(Ne){Pa=Ne.wasm.cwrap(h.Min,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be,xt=ue.dataIdMap.get(it.dataId).id;let ut=xt,ft=it;const{transposed:pt,axes:zt,originalAxes:Dt,inputWasTransposed:We}=de(it,Te,ue);if(We){const hn=ue.dataIdMap.get(pt.dataId).id;hn!==xt&&(ft=pt,ut=hn)}const _t=ft.shape.length;h.backend_util.assertAxesAreInnerMostDims("min",zt,_t);const[jt,Xt]=h.backend_util.computeOutAndReduceShapes(ft.shape,zt),on=h.util.sizeFromShape(Xt),Pt=ue.makeOutput(jt,ft.dtype);if(h.util.sizeFromShape(ft.shape)!==0){const hn=ue.dataIdMap.get(Pt.dataId).id;Pa(ut,t[it.dtype],on,hn)}if(We&&ue.disposeData(pt.dataId),Ye){const hn=h.backend_util.expandShapeToKeepDim(Pt.shape,Dt);Pt.shape=hn}return Pt}},ms=E(h.Minimum);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Va;let Ba;(function(Ne){Ne[Ne.reflect=0]="reflect",Ne[Ne.symmetric=1]="symmetric"})(Va||(Va={}));const wa={kernelName:h.MirrorPad,backendName:"wasm",kernelFunc:function(Ne){const{inputs:{x:ue},backend:Be,attrs:{paddings:Xe,mode:Te}}=Ne,Ye=Xe.map((_t,jt)=>_t[0]+ue.shape[jt]+_t[1]),it=Be.dataIdMap.get(ue.dataId).id,xt=Be.makeOutput(Ye,ue.dtype),ut=Be.dataIdMap.get(xt.dataId).id,ft=new Uint8Array(new Int32Array(ue.shape).buffer),pt=Xe.map(_t=>_t[0]),zt=Xe.map(_t=>_t[1]),Dt=new Uint8Array(new Int32Array(pt).buffer),We=new Uint8Array(new Int32Array(zt).buffer);return Ba(it,ft,ue.shape.length,t[ue.dtype],Dt,We,Va[Te],ut),xt},setupFunc:function(Ne){Ba=Ne.wasm.cwrap(h.MirrorPad,null,["number","array","number","number","array","array","number","number"])}},Ga=E(h.Multiply),Xr=D(h.Neg);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(Ne,ue){const Be=new Int32Array(Ne.wasm.HEAPU8.buffer,ue,4),Xe=Be[0],Te=Be[1],Ye=Be[2],it=Be[3];return Ne.wasm._free(ue),{pSelectedIndices:Xe,selectedSize:Te,pSelectedScores:Ye,pValidOutputs:it}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _a;const os={kernelName:h.NonMaxSuppressionV3,backendName:"wasm",setupFunc:function(Ne){_a=Ne.wasm.cwrap(h.NonMaxSuppressionV3,"number",["number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{iouThreshold:Te,maxOutputSize:Ye,scoreThreshold:it}=Xe,{boxes:xt,scores:ut}=Be,ft=ue.dataIdMap.get(xt.dataId).id,pt=ue.dataIdMap.get(ut.dataId).id,zt=_a(ft,pt,Ye,Te,it),{pSelectedIndices:Dt,selectedSize:We,pSelectedScores:_t,pValidOutputs:jt}=ka(ue,zt);return ue.wasm._free(_t),ue.wasm._free(jt),ue.makeOutput([We],"int32",Dt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Za;const La={kernelName:h.NonMaxSuppressionV4,backendName:"wasm",setupFunc:function(Ne){Za=Ne.wasm.cwrap(h.NonMaxSuppressionV4,"number",["number","number","number","number","number","bool"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{iouThreshold:Te,maxOutputSize:Ye,scoreThreshold:it,padToMaxOutputSize:xt}=Xe,{boxes:ut,scores:ft}=Be,pt=ue.dataIdMap.get(ut.dataId).id,zt=ue.dataIdMap.get(ft.dataId).id,Dt=Za(pt,zt,Ye,Te,it,xt),{pSelectedIndices:We,selectedSize:_t,pSelectedScores:jt,pValidOutputs:Xt}=ka(ue,Dt);return ue.wasm._free(jt),[ue.makeOutput([_t],"int32",We),ue.makeOutput([],"int32",Xt)]}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wr;const sa={kernelName:h.NonMaxSuppressionV5,backendName:"wasm",setupFunc:function(Ne){wr=Ne.wasm.cwrap(h.NonMaxSuppressionV5,"number",["number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{iouThreshold:Te,maxOutputSize:Ye,scoreThreshold:it,softNmsSigma:xt}=Xe,{boxes:ut,scores:ft}=Be,pt=ue.dataIdMap.get(ut.dataId).id,zt=ue.dataIdMap.get(ft.dataId).id,Dt=wr(pt,zt,Ye,Te,it,xt),{pSelectedIndices:We,selectedSize:_t,pSelectedScores:jt,pValidOutputs:Xt}=ka(ue,Dt);return ue.wasm._free(Xt),[ue.makeOutput([_t],"int32",We),ue.makeOutput([_t],"float32",jt)]}},Ia=E(h.NotEqual,0,"bool");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ba;const ca={kernelName:h.OneHot,backendName:"wasm",setupFunc:function(Ne){ba=Ne.wasm.cwrap(h.OneHot,null,["number","number","number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{indices:Te}=ue,{dtype:Ye,depth:it,onValue:xt,offValue:ut}=Xe,ft=Be.makeOutput([...Te.shape,it],Ye),pt=Be.dataIdMap.get(ft.dataId).id,zt=Be.dataIdMap.get(Te.dataId).id;return ba(zt,it,xt,ut,pt),ft}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ja={kernelName:h.OnesLike,backendName:"wasm",kernelFunc:function(Ne){const{inputs:{x:ue},backend:Be}=Ne,Xe=Be.makeOutput(ue.shape,ue.dtype);return Be.typedArrayFromHeap(Xe).fill(1),Xe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fe={kernelName:h.Pack,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{axis:Te}=Xe;if(ue.length===1)return mn({inputs:{input:ue[0]},backend:Be,attrs:{dim:Te}});const Ye=ue[0].shape,it=ue[0].dtype;ue.forEach(ft=>{h.util.assertShapesMatch(Ye,ft.shape,"All tensors passed to stack must have matching shapes"),h.util.assert(it===ft.dtype,()=>"All tensors passed to stack must have matching dtypes")});const xt=[],ut=J({inputs:ue.map(ft=>{const pt=mn({inputs:{input:ft},backend:Be,attrs:{dim:Te}});return xt.push(pt),pt}),backend:Be,attrs:{axis:Te}});return xt.forEach(ft=>Be.disposeData(ft.dataId)),ut}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dt;const Et={kernelName:h.PadV2,backendName:"wasm",kernelFunc:function(Ne){const{inputs:{x:ue},backend:Be,attrs:{paddings:Xe,constantValue:Te}}=Ne,Ye=Xe.map((_t,jt)=>_t[0]+ue.shape[jt]+_t[1]);if(h.util.sizeFromShape(ue.shape)===0)return or({backend:Be,attrs:{shape:Ye,value:Te,dtype:ue.dtype}});const it=Be.dataIdMap.get(ue.dataId).id,xt=Be.makeOutput(Ye,ue.dtype),ut=Be.dataIdMap.get(xt.dataId).id,ft=new Uint8Array(new Int32Array(ue.shape).buffer),pt=Xe.map(_t=>_t[0]),zt=Xe.map(_t=>_t[1]),Dt=new Uint8Array(new Int32Array(pt).buffer),We=new Uint8Array(new Int32Array(zt).buffer);return dt(it,ft,ue.shape.length,t[ue.dtype],Dt,We,Te,ut),xt},setupFunc:function(Ne){dt=Ne.wasm.cwrap(h.PadV2,null,["number","array","number","number","array","array","number","number"])}},Vt=E(h.Pow);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let an;const Zt={kernelName:h.Prelu,backendName:"wasm",setupFunc:function(Ne){an=Ne.wasm.cwrap(h.Prelu,null,["number","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be}=Ne,{x:Xe,alpha:Te}=ue,Ye=Be.dataIdMap.get(Xe.dataId).id,it=Be.dataIdMap.get(Te.dataId).id;let xt=Ye;const ut=Xe;let ft=ut;ut.dtype!=="float32"&&(ft=Nn({backend:Be,inputs:{x:Xe},attrs:{dtype:"float32"}}),xt=Be.dataIdMap.get(ft.dataId).id);const pt=Be.makeOutput(Xe.shape,"float32"),zt=Be.dataIdMap.get(pt.dataId).id;return an(xt,it,zt),ut.dtype!=="float32"&&Be.disposeData(ft.dataId),pt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _n;const Gn={kernelName:h.Prod,backendName:"wasm",setupFunc:function(Ne){_n=Ne.wasm.cwrap(h.Prod,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be,xt=ue.dataIdMap.get(it.dataId).id;let ut=xt,ft=it;const{transposed:pt,axes:zt,originalAxes:Dt,inputWasTransposed:We}=de(it,Te,ue);let _t=zt;if(We){const hn=ue.dataIdMap.get(pt.dataId).id;hn!==xt&&(ft=pt,ut=hn,_t=h.backend_util.getInnerMostAxes(_t.length,ft.shape.length))}h.backend_util.assertAxesAreInnerMostDims("prod",_t,ft.shape.length);const[jt,Xt]=h.backend_util.computeOutAndReduceShapes(ft.shape,_t),on=h.util.sizeFromShape(Xt),Pt=ue.makeOutput(jt,ft.dtype);if(h.util.sizeFromShape(ft.shape)!==0){const hn=ue.dataIdMap.get(Pt.dataId).id;_n(ut,on,t[Pt.dtype],hn)}if(We&&ue.disposeData(pt.dataId),Ye){const hn=h.backend_util.expandShapeToKeepDim(Pt.shape,Dt);Pt.shape=hn}return Pt}},ar={kernelName:h.Range,backendName:"wasm",kernelFunc:Ne=>{const{backend:ue,attrs:Be}=Ne,{start:Xe,stop:Te,step:Ye,dtype:it}=Be,xt=Object(Ct.a)(Xe,Te,Ye,it),ut=ue.makeOutput([xt.length],it);return ue.typedArrayFromHeap(ut).set(xt),ut}},Rr=E(h.RealDiv),Ir=D(h.Relu),xa=D(h.Relu6);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Er;const Yr={kernelName:h.ResizeBilinear,backendName:"wasm",setupFunc:function(Ne){Er=Ne.wasm.cwrap(h.ResizeBilinear,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{images:Te}=Be,{alignCorners:Ye,halfPixelCenters:it,size:xt}=Xe,[ut,ft]=xt,[pt,zt,Dt,We]=Te.shape,_t=[pt,ut,ft,We];let jt,Xt=ue.dataIdMap.get(Te.dataId);Xt.dtype!=="float32"&&(jt=Nn({backend:ue,inputs:{x:Te},attrs:{dtype:"float32"}}),Xt=ue.dataIdMap.get(jt.dataId));const on=Xt.id,Pt=ue.makeOutput(_t,"float32");if(h.util.sizeFromShape(Te.shape)===0)return Pt;const hn=ue.dataIdMap.get(Pt.dataId).id;return Er(on,pt,zt,Dt,We,ut,ft,Ye?1:0,it?1:0,hn),jt!=null&&ue.disposeData(jt.dataId),Pt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ja;const Oa={kernelName:h.ResizeNearestNeighbor,backendName:"wasm",setupFunc:function(Ne){ja=Ne.wasm.cwrap(h.ResizeNearestNeighbor,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{images:Te}=Be,{alignCorners:Ye,halfPixelCenters:it,size:xt}=Xe,[ut,ft]=xt,[pt,zt,Dt,We]=Te.shape,_t=[pt,ut,ft,We],jt=ue.makeOutput(_t,"float32");if(h.util.sizeFromShape(Te.shape)===0)return jt;let Xt,on=ue.dataIdMap.get(Te.dataId);on.dtype!=="float32"&&(Xt=Nn({backend:ue,inputs:{x:Te},attrs:{dtype:"float32"}}),on=ue.dataIdMap.get(Xt.dataId));const Pt=on.id,hn=ue.dataIdMap.get(jt.dataId).id;return ja(Pt,pt,zt,Dt,We,ut,ft,Ye?1:0,it?1:0,hn),Xt!=null&&ue.disposeData(Xt.dataId),jt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $a;const Xs={kernelName:h.Reverse,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{dims:Ye}=Xe,it=h.util.parseAxisParam(Ye,Te.shape);if(Te.shape.length===0)return O({inputs:{x:Te},backend:Be});const xt=Be.makeOutput(Te.shape,Te.dtype),ut=Be.dataIdMap.get(Te.dataId).id,ft=Be.dataIdMap.get(xt.dataId).id,pt=new Uint8Array(new Int32Array(it).buffer),zt=new Uint8Array(new Int32Array(Te.shape).buffer);$a(ut,pt,it.length,zt,Te.shape.length,ft);const Dt=me({inputs:{x:xt},attrs:{shape:Te.shape},backend:Be});return Be.disposeData(xt.dataId),Dt},setupFunc:function(Ne){$a=Ne.wasm.cwrap(h.Reverse,null,["number","array","number","array","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $s;const bs={kernelName:h.RotateWithOffset,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{image:Te}=ue,{radians:Ye,fillValue:it,center:xt}=Xe,ut=Be.makeOutput(Te.shape,Te.dtype),ft=Be.dataIdMap.get(Te.dataId).id,pt=Be.dataIdMap.get(ut.dataId).id,[zt,Dt,We,_t]=Te.shape,[jt,Xt]=h.backend_util.getImageCenter(xt,Dt,We),on=typeof it=="number"?[it,it,it,it===0?0:255]:[...it,255],Pt=new Uint8Array(new Int32Array(on).buffer);return $s(ft,zt,Dt,We,_t,Ye,jt,Xt,Pt,on.length,pt),ut},setupFunc:function(Ne){$s=Ne.wasm.cwrap(h.RotateWithOffset,null,["number","number","number","number","number","number","number","number","array","number","number"])}},di=D(h.Round),Ha=D(h.Rsqrt);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qa;const Ea={kernelName:h.ScatterNd,backendName:"wasm",setupFunc:function(Ne){qa=Ne.wasm.cwrap(h.ScatterNd,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{indices:Te,updates:Ye}=Be,{shape:it}=Xe,xt=ue.makeOutput(it,Ye.dtype);if(h.util.sizeFromShape(it)===0)return xt;const{sliceRank:ut,numUpdates:ft,sliceSize:pt,strides:zt,outputSize:Dt}=h.scatter_util.calculateShapes(Ye,Te,it),We=ue.dataIdMap.get(Te.dataId).id,_t=ue.dataIdMap.get(Ye.dataId).id,jt=new Uint8Array(new Int32Array(zt).buffer),Xt=ue.dataIdMap.get(xt.dataId).id;return qa(We,_t,t[Ye.dtype],ut,ft,pt,jt,Dt,Xt),xt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ta;const Ys={kernelName:h.Select,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be}=Ne,{condition:Xe,t:Te,e:Ye}=ue,it=Be.dataIdMap.get(Xe.dataId).id,xt=Be.dataIdMap.get(Te.dataId).id,ut=Be.dataIdMap.get(Ye.dataId).id,ft=Be.makeOutput(Te.shape,Te.dtype),pt=Be.dataIdMap.get(ft.dataId).id,zt=Xe.shape.length,Dt=Te.shape.length,We=zt===0||zt>1||Dt===1?1:h.util.sizeFromShape(Te.shape.slice(1));return ta(it,xt,ut,We,pt),ft},setupFunc:function(Ne){ta=Ne.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ia;const Aa={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(Ne){ia=Ne.wasm.cwrap(h.Sigmoid,null,["number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:{x:Be}}=Ne,Xe=ue.dataIdMap.get(Be.dataId).id,Te=ue.makeOutput(Be.shape,Be.dtype),Ye=ue.dataIdMap.get(Te.dataId).id;return h.util.sizeFromShape(Te.shape)===0||ia(Xe,Ye),Te}},es=D(h.Sin);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gs;const hi={kernelName:h.Softmax,backendName:"wasm",setupFunc:function(Ne){gs=Ne.wasm.cwrap(h.Softmax,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:{logits:Be},attrs:{dim:Xe}}=Ne,Te=ue.dataIdMap.get(Be.dataId).id,Ye=ue.makeOutput(Be.shape,Be.dtype),it=ue.dataIdMap.get(Ye.dataId).id,xt=Be.shape[Xe],ut=h.util.sizeFromShape(Be.shape)/xt;return h.util.sizeFromShape(Ye.shape)===0||gs(Te,it,xt,ut),Ye}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xs={kernelName:h.SpaceToBatchND,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,{blockShape:Ye,paddings:it}=Xe,xt=h.util.sizeFromShape(Ye),ut=[[0,0]];ut.push(...it);for(let Xt=1+Ye.length;Xt<Te.shape.length;++Xt)ut.push([0,0]);const ft=Et.kernelFunc({inputs:{x:Te},backend:Be,attrs:{paddings:ut,constantValue:0}}),pt=h.backend_util.getReshaped(ft.shape,Ye,xt,!1),zt=h.backend_util.getPermuted(pt.length,Ye.length,!1),Dt=h.backend_util.getReshapedPermuted(ft.shape,Ye,xt,!1),We=me({inputs:{x:ft},backend:Be,attrs:{shape:pt}}),_t=g({inputs:{x:We},backend:Be,attrs:{perm:zt}}),jt=me({inputs:{x:_t},backend:Be,attrs:{shape:Dt}});return Be.disposeData(ft.dataId),Be.disposeData(We.dataId),Be.disposeData(_t.dataId),jt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let us;const pi={kernelName:h.SparseFillEmptyRows,backendName:"wasm",setupFunc:function(Ne){us=Ne.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be}=Ne,{indices:Xe,values:Te,denseShape:Ye,defaultValue:it}=Be,xt=Xe.shape[0],ut=Xe.shape[1],ft=ue.readSync(Ye.dataId)[0],pt=[xt+ft,ut],zt=ue.dataIdMap.get(Xe.dataId).id,Dt=ue.dataIdMap.get(Te.dataId).id,We=ue.dataIdMap.get(it.dataId).id,_t=ue.makeOutput(pt,Xe.dtype),jt=ue.dataIdMap.get(_t.dataId).id,Xt=ue.makeOutput(pt.slice(0,1),Te.dtype),on=ue.dataIdMap.get(Xt.dataId).id,Pt=ue.makeOutput([ft],"bool"),hn=ue.dataIdMap.get(Pt.dataId).id,Fn=ue.makeOutput([xt],Xe.dtype),nr=ue.dataIdMap.get(Fn.dataId).id,dr=ue.makeOutput([4],"int32"),hr=ue.dataIdMap.get(dr.dataId).id,cr=us(zt,Dt,t[Te.dtype],xt,ft,ut,We,jt,on,hn,nr,hr),Mr=ue.readSync(dr.dataId);let Sr;switch(Mr[0]){case 1:Sr=h.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(Mr[1]);break;case 2:Sr=h.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(Mr[1],Mr[2]);break;case 3:Sr=h.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(Mr[1],Mr[2],Mr[3]);break;default:Sr=""}if(ue.disposeData(dr.dataId),Sr)throw ue.disposeData(_t.dataId),ue.disposeData(Xt.dataId),ue.disposeData(Pt.dataId),ue.disposeData(Fn.dataId),new Error(Sr);let Dr=_t,Ar=Xt;return cr!==pt[0]&&(Dr=Qt({inputs:{x:_t},attrs:{begin:0,size:[cr,ut]},backend:ue}),Ar=Qt({inputs:{x:Xt},attrs:{begin:0,size:cr},backend:ue}),ue.disposeData(_t.dataId),ue.disposeData(Xt.dataId)),[Dr,Ar,Pt,Fn]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pr;const Jr={kernelName:h.SparseReshape,backendName:"wasm",setupFunc:function(Ne){pr=Ne.wasm.cwrap(h.SparseReshape,null,["number","number","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be}=Ne,{inputIndices:Xe,inputShape:Te,newShape:Ye}=Be;if(Xe.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${Xe.shape}`);if(Te.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${Te.shape}`);if(Ye.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${Ye.shape}`);const it=ue.dataIdMap.get(Xe.dataId).id,xt=ue.dataIdMap.get(Te.dataId).id,ut=ue.dataIdMap.get(Ye.dataId).id,ft=Xe.shape[0],pt=h.util.sizeFromShape(Ye.shape),zt=ue.makeOutput([ft,pt],Xe.dtype),Dt=ue.dataIdMap.get(zt.dataId).id,We=ue.makeOutput([pt],Ye.dtype),_t=ue.dataIdMap.get(We.dataId).id,jt=ue.makeOutput([3],"int32"),Xt=ue.dataIdMap.get(jt.dataId).id;pr(it,xt,ut,ft,Dt,_t,Xt);const on=ue.readSync(jt.dataId);let Pt;switch(on[0]){case 0:Pt=h.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(on[1],on[2]);break;case 1:Pt=h.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(on[1],on[2]);break;case 2:Pt=h.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const hn=Array.from(ue.readSync(Te.dataId)),Fn=Array.from(ue.readSync(We.dataId));Pt=h.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(hn,Fn);break}case 4:{const hn=Array.from(ue.readSync(Te.dataId)),Fn=Array.from(ue.readSync(We.dataId));Pt=h.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(hn,Fn);break}default:Pt=""}if(ue.disposeData(jt.dataId),Pt)throw ue.disposeData(zt.dataId),ue.disposeData(We.dataId),new Error(Pt);return[zt,We]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let za;function Es(Ne){za=Ne.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Qs(Ne,ue){const{backend:Be,inputs:Xe}=Ne,{data:Te,indices:Ye,segmentIds:it}=Xe,xt=Ye.shape[0],ut=Be.readSync(it.dataId,xt-1,xt)[0],ft=xt>0?ut+1:0;if(ft<0)throw new Error(h.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const pt=Te.shape.slice();pt[0]=ft;const zt=Be.dataIdMap.get(Te.dataId).id,Dt=Be.dataIdMap.get(Ye.dataId).id,We=Be.dataIdMap.get(it.dataId).id,_t=Be.makeOutput(pt,Te.dtype),jt=Be.dataIdMap.get(_t.dataId).id,Xt=Be.makeOutput([4],"int32"),on=Be.dataIdMap.get(Xt.dataId).id;za(zt,t[Te.dtype],Te.shape[0],Dt,We,jt,on,ue,0);const Pt=Be.readSync(Xt.dataId);let hn;switch(Pt[0]){case 0:hn=h.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:hn=h.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:hn=h.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(Pt[1],Pt[2]);break;case 3:hn=h.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(Pt[1],Pt[2],Pt[3]);break;default:hn=""}if(Be.disposeData(Xt.dataId),hn)throw Be.disposeData(_t.dataId),new Error(hn);return _t}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ts={kernelName:h.SparseSegmentMean,backendName:"wasm",setupFunc:Es,kernelFunc:function(Ne){return Qs(Ne,!0)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const As={kernelName:h.SparseSegmentSum,backendName:"wasm",setupFunc:Es,kernelFunc:function(Ne){return Qs(Ne,!1)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns={kernelName:h.SplitV,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,attrs:Be,backend:Xe}=Ne,{x:Te}=ue,{numOrSizeSplits:Ye,axis:it}=Be,xt=h.util.parseAxisParam(it,Te.shape)[0],ut=h.backend_util.prepareSplitSize(Te,Ye,xt),ft=new Array(Te.shape.length).fill(0),pt=Te.shape.slice();return ut.map(zt=>{const Dt=[...pt];Dt[xt]=zt;const We=Qt({inputs:{x:Te},attrs:{begin:ft,size:Dt},backend:Xe});return ft[xt]+=zt,We})}},vs=D(h.Sqrt),Yn=D(h.Square),In=E(h.SquaredDifference);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fr;const Sn={kernelName:h.Step,backendName:"wasm",setupFunc:function(Ne){Fr=Ne.wasm.cwrap(h.Step,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{alpha:Te}=Xe,{x:Ye}=Be,it=ue.dataIdMap.get(Ye.dataId).id,xt=ue.makeOutput(Ye.shape,Ye.dtype),ut=ue.dataIdMap.get(xt.dataId).id;return Fr(it,Te,t[Ye.dtype],ut),xt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sa;const na={kernelName:h.StridedSlice,backendName:"wasm",setupFunc:function(Ne){Sa=Ne.wasm.cwrap(h.StridedSlice,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{x:Te}=Be,{begin:Ye,end:it,strides:xt,beginMask:ut,endMask:ft,ellipsisMask:pt,newAxisMask:zt,shrinkAxisMask:Dt}=Xe,{finalShapeSparse:We,finalShape:_t,isIdentity:jt,sliceDim0:Xt,isSimpleSlice:on,begin:Pt,end:hn,strides:Fn}=h.slice_util.sliceInfo(Te.shape,Ye,it,xt,ut,ft,pt,zt,Dt);let nr;if(jt)nr=me({inputs:{x:Te},backend:ue,attrs:{shape:_t}});else if(Xt||on){h.util.assert(Te.shape.length>=1,()=>`Input must have rank at least 1, got: ${Te.shape.length}`);const dr=h.slice_util.computeOutShape(Pt,hn,Fn),hr=Qt({inputs:{x:Te},backend:ue,attrs:{begin:Pt,size:dr}});nr=me({inputs:{x:hr},backend:ue,attrs:{shape:_t}}),ue.disposeData(hr.dataId)}else{const dr=ue.makeOutput(We,"float32"),hr=ue.dataIdMap.get(Te.dataId).id,cr=new Uint8Array(new Int32Array(h.util.computeStrides(Te.shape)).buffer),Mr=new Uint8Array(new Int32Array(Pt).buffer),Sr=new Uint8Array(new Int32Array(hn).buffer),Dr=new Uint8Array(new Int32Array(Fn).buffer),Ar=new Uint8Array(new Int32Array(We).buffer),aa=new Uint8Array(new Int32Array(h.util.computeStrides(We)).buffer),ya=ue.dataIdMap.get(dr.dataId).id;Sa(hr,cr,Te.shape.length,Mr,Sr,Dr,Ar,aa,We.length,ya),nr=me({inputs:{x:dr},backend:ue,attrs:{shape:_t}}),ue.disposeData(dr.dataId)}return nr}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pa={kernelName:h.StringNGrams,backendName:"wasm",kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{data:Te,dataSplits:Ye}=Be,{separator:it,nGramWidths:xt,leftPad:ut,rightPad:ft,padWidth:pt,preserveShortSequences:zt}=Xe,Dt=ue.readSync(Te.dataId),We=ue.readSync(Ye.dataId),[_t,jt]=Object(Gt.a)(Dt,We,it,xt,ut,ft,pt,zt),Xt=ue.makeOutput([_t.length],"string");ue.dataIdMap.get(Xt.dataId).stringBytes=_t;const on=ue.makeOutput(Ye.shape,"int32");return ue.typedArrayFromHeap(on).set(jt),[Xt,on]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zs={kernelName:h.StringSplit,backendName:"wasm",kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{input:Te,delimiter:Ye}=Be,{skipEmpty:it}=Xe,xt=ue.readSync(Te.dataId),ut=ue.readSync(Ye.dataId),[ft,pt,zt]=Object(Wt.a)(xt,ut[0],it),Dt=pt.length,We=ue.makeOutput([Dt,2],"int32");ue.typedArrayFromHeap(We).set(ft);const _t=ue.makeOutput([Dt],"string");ue.dataIdMap.get(_t.dataId).stringBytes=pt;const jt=ue.makeOutput([2],"int32");return ue.typedArrayFromHeap(jt).set(zt),[We,_t,jt]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ys={kernelName:h.StringToHashBucketFast,backendName:"wasm",kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{input:Te}=Be,{numBuckets:Ye}=Xe,it=ue.readSync(Te.dataId),xt=Object(lt.a)(it,Ye),ut=ue.makeOutput(Te.shape,"int32");return ue.typedArrayFromHeap(ut).set(xt),ut}},cs=E(h.Sub);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xi;const ra={kernelName:h.Sum,backendName:"wasm",setupFunc:function(Ne){xi=Ne.wasm.cwrap(h.Sum,null,["number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{axis:Te,keepDims:Ye}=Xe,{x:it}=Be,xt=ue.dataIdMap.get(it.dataId).id;let ut=xt,ft=it;const{transposed:pt,axes:zt,originalAxes:Dt,inputWasTransposed:We}=de(it,Te,ue);let _t=zt;if(We){const hn=ue.dataIdMap.get(pt.dataId).id;hn!==xt&&(ft=pt,ut=hn,_t=h.backend_util.getInnerMostAxes(_t.length,ft.shape.length))}h.backend_util.assertAxesAreInnerMostDims("sum",_t,ft.shape.length);const[jt,Xt]=h.backend_util.computeOutAndReduceShapes(ft.shape,_t),on=h.util.sizeFromShape(Xt),Pt=ue.makeOutput(jt,ft.dtype);if(h.util.sizeFromShape(ft.shape)!==0){const hn=ue.dataIdMap.get(Pt.dataId).id;xi(ut,on,t[Pt.dtype],hn)}if(We&&ue.disposeData(pt.dataId),Ye){const hn=h.backend_util.expandShapeToKeepDim(Pt.shape,Dt);Pt.shape=hn}return Pt}},Ua=D(h.Tan),ls=D(h.Tanh);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tr;const Ka={kernelName:h.Tile,backendName:"wasm",setupFunc:function(Ne){Tr=Ne.wasm.cwrap(h.Tile,null,["number","array","number","array","number","number"])},kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{x:Te}=ue,Ye=Be.dataIdMap.get(Te.dataId).id,{reps:it}=Xe,xt=new Array(Te.shape.length);for(let Dt=0;Dt<xt.length;Dt++)xt[Dt]=Te.shape[Dt]*it[Dt];const ut=new Uint8Array(new Int32Array(Te.shape).buffer),ft=new Uint8Array(new Int32Array(xt).buffer),pt=Be.makeOutput(xt,Te.dtype),zt=Be.dataIdMap.get(pt.dataId).id;return Tr(Ye,ut,Te.shape.length,ft,xt.length,t[pt.dtype],zt),pt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rs;const Js={kernelName:h.TopK,backendName:"wasm",setupFunc:function(Ne){Rs=Ne.wasm.cwrap(h.TopK,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:Ne,backend:ue,attrs:Be})=>{const{x:Xe}=Ne,{k:Te,sorted:Ye}=Be,it=ue.dataIdMap.get(Xe.dataId).id,xt=new Uint8Array(new Int32Array(Xe.shape).buffer),ut=Xe.shape.slice();ut[ut.length-1]=Te;const ft=ue.makeOutput(ut,Xe.dtype),pt=ue.dataIdMap.get(ft.dataId).id,zt=ue.makeOutput(ut,"int32"),Dt=ue.dataIdMap.get(zt.dataId).id;return Rs(it,xt,Xe.shape.length,t[Xe.dtype],Te,Ye,pt,Dt),[ft,zt]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ws;const ks={kernelName:h.Transform,backendName:"wasm",setupFunc:function(Ne){ws=Ne.wasm.cwrap(h.Transform,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(Ne){const{backend:ue,inputs:Be,attrs:Xe}=Ne,{image:Te,transforms:Ye}=Be,{interpolation:it,fillMode:xt,fillValue:ut,outputShape:ft}=Xe,[pt,zt,Dt,We]=Te.shape,[_t,jt]=ft!=null?ft:[zt,Dt],Xt=[pt,_t,jt,We],on=new Uint8Array(new Int32Array(h.util.computeStrides(Te.shape)).buffer),Pt=new Uint8Array(new Int32Array(h.util.computeStrides(Xt)).buffer),hn=ue.makeOutput(Xt,Te.dtype),Fn=ue.dataIdMap.get(hn.dataId).id,nr=ue.dataIdMap.get(Te.dataId).id,dr=ue.dataIdMap.get(Ye.dataId).id,hr=it==="nearest"?1:2;let cr;switch(xt){case"constant":default:cr=1;break;case"reflect":cr=2;break;case"wrap":cr=3;break;case"nearest":cr=4}return ws(nr,dr,Ye.shape[0]>1,pt,_t,jt,We,Dt,zt,on,Te.shape.length-1,Pt,Xt.length-1,hr,cr,ut,Fn),hn}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ur={kernelName:h.Unpack,backendName:"wasm",kernelFunc:function(Ne){const{inputs:ue,backend:Be,attrs:Xe}=Ne,{value:Te}=ue;let{axis:Ye}=Xe;Ye<0&&(Ye+=Te.shape.length);const it=Te.shape[Ye],xt=Te.shape.length,ut=new Array(xt-1);let ft=0;for(let We=0;We<xt;We++)We!==Ye&&(ut[ft++]=Te.shape[We]);const pt=new Array(it),zt=new Array(xt).fill(0),Dt=Te.shape.slice();Dt[Ye]=1;for(let We=0;We<pt.length;We++)zt[Ye]=We,pt[We]=Qt({inputs:{x:Te},attrs:{begin:zt,size:Dt},backend:Be});return pt.map(({dataId:We,dtype:_t})=>({dataId:We,dtype:_t,shape:ut}))}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fs={kernelName:h.ZerosLike,backendName:"wasm",kernelFunc:function(Ne){const{inputs:{x:ue},backend:Be}=Ne,Xe=Be.makeOutput(ue.shape,ue.dtype);return Be.typedArrayFromHeap(Xe).fill(0),Xe}},va=[A,y,S,B,Ie,Q,Z,He,It,yn,Kn,zn,K,we,wt,Ae,mt,Mt,Rn,le,Mn,Ur,ir,Zn,$r,en,Ln,lr,br,gr,At,ae,ht,Kt,tn,xn,rn,Xn,V,Lr,Wr,vr,ua,ma,Cr,Da,kr,qr,ha,Vr,Ta,is,ms,wa,Ga,Xr,os,La,sa,Ia,ca,Ja,Fe,Et,Vt,Zt,Gn,ar,Rr,Ir,xa,et,Yr,Oa,Xs,bs,di,Ha,Ea,Ys,Aa,es,Ft,hi,xs,pi,Jr,ts,As,Ns,vs,Yn,In,Sn,na,pa,Zs,ys,cs,ra,Ua,ls,Ka,Js,ks,W,ur,Fs];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const Ne of va)Object(h.registerKernel)(Ne);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ei=Object(h.env)();ei.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))),ei.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(ei.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var Ms=e(93),Ds=e.n(Ms),ti=e(100),Ps=e(94),ns=e.n(Ps);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bs=Ds.a||Ms,Ai=ns.a||Ps;class Ls extends h.KernelBackend{constructor(ue){super(),this.wasm=ue,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Fi),yi=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new h.DataStorage(this,Object(h.engine)())}write(ue,Be,Xe){const Te={id:this.dataIdNextNumber++};return this.move(Te,ue,Be,Xe,1),Te}numDataIds(){return this.dataIdMap.numDataIds()}async time(ue){const Be=h.util.now();return ue(),{kernelMs:h.util.now()-Be}}move(ue,Be,Xe,Te,Ye){const it=this.dataIdNextNumber++;if(Te==="string"){const pt=Be;return void this.dataIdMap.set(ue,{id:it,stringBytes:pt,shape:Xe,dtype:Te,memoryOffset:null,refCount:Ye})}const xt=h.util.sizeFromShape(Xe),ut=xt*h.util.bytesPerElement(Te),ft=this.wasm._malloc(ut);this.dataIdMap.set(ue,{id:it,memoryOffset:ft,shape:Xe,dtype:Te,refCount:Ye}),this.wasm.tfjs.registerTensor(it,xt,ft),Be!=null&&this.wasm.HEAPU8.set(new Uint8Array(Be.buffer,Be.byteOffset,ut),ft)}async read(ue){return this.readSync(ue)}readSync(ue,Be,Xe){const{memoryOffset:Te,dtype:Ye,shape:it,stringBytes:xt}=this.dataIdMap.get(ue);if(Ye==="string")return Be!=null&&Be!==0||!(Xe==null||Xe>=xt.length)?xt.slice(Be,Xe):xt;Be=Be||0,Xe=Xe||h.util.sizeFromShape(it);const ut=h.util.bytesPerElement(Ye);return function(ft,pt){switch(pt){case"float32":return new Float32Array(ft);case"int32":return new Int32Array(ft);case"bool":return new Uint8Array(ft);default:throw new Error(`Unknown dtype ${pt}`)}}(this.wasm.HEAPU8.slice(Te+Be*ut,Te+Xe*ut).buffer,Ye)}disposeData(ue,Be=!1){if(this.dataIdMap.has(ue)){const Xe=this.dataIdMap.get(ue);if(Xe.refCount--,!Be&&Xe.refCount>0)return!1;this.wasm._free(Xe.memoryOffset),this.wasm.tfjs.disposeData(Xe.id),this.dataIdMap.delete(ue)}return!0}refCount(ue){return this.dataIdMap.has(ue)?this.dataIdMap.get(ue).refCount:0}incRef(ue){const Be=this.dataIdMap.get(ue);Be!=null&&Be.refCount++}floatPrecision(){return 32}getMemoryOffset(ue){return this.dataIdMap.get(ue).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(ue,Be,Xe){let Te;if(Xe==null)Te=this.write(null,ue,Be);else{const Ye=this.dataIdNextNumber++;Te={id:Ye},this.dataIdMap.set(Te,{id:Ye,memoryOffset:Xe,shape:ue,dtype:Be,refCount:1});const it=h.util.sizeFromShape(ue);this.wasm.tfjs.registerTensor(Ye,it,Xe)}return{dataId:Te,shape:ue,dtype:Be}}typedArrayFromHeap({shape:ue,dtype:Be,dataId:Xe}){const Te=this.wasm.HEAPU8.buffer,{memoryOffset:Ye}=this.dataIdMap.get(Xe),it=h.util.sizeFromShape(ue);switch(Be){case"float32":return new Float32Array(Te,Ye,it);case"int32":return new Int32Array(Te,Ye,it);case"bool":return new Uint8Array(Te,Ye,it);default:throw new Error(`Unknown dtype ${Be}`)}}}function rs(Ne,ue,Be){let Xe="tfjs-backend-wasm.wasm";return Ne&&ue?Xe="tfjs-backend-wasm-threaded-simd.wasm":Ne&&(Xe="tfjs-backend-wasm-simd.wasm"),zs!=null&&zs[Xe]!=null?zs[Xe]:Be+Xe}async function ni(){const[Ne,ue]=await Promise.all([Object(h.env)().getAsync("WASM_HAS_SIMD_SUPPORT"),Object(h.env)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((Be,Xe)=>{const Te={};var Ye;Te.locateFile=(ut,ft)=>{if(ut.endsWith(".worker.js")){const pt=ti.wasmWorkerContents.replace(/\n/g,"\\n"),zt=new Blob([pt],{type:"application/javascript"});return URL.createObjectURL(zt)}return ut.endsWith(".wasm")?rs(Ne,ue,_s!=null?_s:ft):ft+ut},vi&&(Te.instantiateWasm=(Ye=rs(Ne,ue,_s!=null?_s:""),(ut,ft)=>(h.util.fetch(Ye,{credentials:"same-origin"}).then(pt=>{pt.ok||ut.env.a(`failed to load wasm binary file at '${Ye}'`),pt.arrayBuffer().then(zt=>{WebAssembly.instantiate(zt,ut).then(Dt=>{ft(Dt.instance,Dt.module)})})}),{})));let it,xt=!1;Te.onAbort=()=>{xt||ri||(ri=!0,Xe({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},ue&&Ne&&Ni==null?(Te.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Bs.toString()],{type:"text/javascript"}),it=Bs(Te)):it=Ai(Te),it.then(ut=>{xt=!0,ri=!1,ut.tfjs={init:ut.cwrap("init",null,[]),initWithThreadsCount:ut.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:ut.cwrap("get_threads_count","number",[]),registerTensor:ut.cwrap("register_tensor",null,["number","number","number"]),disposeData:ut.cwrap("dispose_data",null,["number"]),dispose:ut.cwrap("dispose",null,[])},Be({wasm:ut})}).catch(Xe)})}const js=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Ni=null,_s=null,zs={},ri=!1,vi=!1;function Ri(Ne,ue=!1){if(ri)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof Ne=="string")_s=Ne;else{zs=Ne;const Be=js.filter(Xe=>zs[Xe]==null);if(Be.length>0)throw new Error(`There were no entries found for the following binaries: ${Be.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}vi=ue}let Fi=-1,yi=-1;Object(h.registerBackend)("wasm",async()=>{const{wasm:Ne}=await ni();return new Ls(Ne)},2)},function(I,n,e){e.d(n,"a",function(){return h});var t=e(37),m=e(5);class h{constructor(){}async createContext(A={}){return new Promise((D,y)=>{let E;try{E=new t.a(A)}catch(S){y(S)}D(E)})}createContextSync(A={}){return m.a(typeof window=="undefined"&&typeof importScripts=="function","createContextSync() should only be allowed in dedicated worker."),new t.a(A)}}},function(I,n){I.exports=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(G,He,me){this.low=0|G,this.high=0|He,this.unsigned=!!me}function m(G){return(G&&G.__isLong__)===!0}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=m;var h={},b={};function A(G,He){var me,et,rt;return He?(rt=0<=(G>>>=0)&&G<256)&&(et=b[G])?et:(me=y(G,(0|G)<0?-1:0,!0),rt&&(b[G]=me),me):(rt=-128<=(G|=0)&&G<128)&&(et=h[G])?et:(me=y(G,G<0?-1:0,!1),rt&&(h[G]=me),me)}function D(G,He){if(isNaN(G))return He?W:g;if(He){if(G<0)return W;if(G>=O)return Q}else{if(G<=-V)return Se;if(G+1>=V)return he}return G<0?D(-G,He).neg():y(G%B|0,G/B|0,He)}function y(G,He,me){return new t(G,He,me)}t.fromInt=A,t.fromNumber=D,t.fromBits=y;var E=Math.pow;function S(G,He,me){if(G.length===0)throw Error("empty string");if(G==="NaN"||G==="Infinity"||G==="+Infinity"||G==="-Infinity")return g;if(typeof He=="number"?(me=He,He=!1):He=!!He,(me=me||10)<2||36<me)throw RangeError("radix");var et;if((et=G.indexOf("-"))>0)throw Error("interior hyphen");if(et===0)return S(G.substring(1),He,me).neg();for(var rt=D(E(me,8)),It=g,X=0;X<G.length;X+=8){var $t=Math.min(8,G.length-X),Ct=parseInt(G.substring(X,X+$t),me);if($t<8){var Gt=D(E(me,$t));It=It.mul(Gt).add(D(Ct))}else It=(It=It.mul(rt)).add(D(Ct))}return It.unsigned=He,It}function l(G,He){return typeof G=="number"?D(G,He):typeof G=="string"?S(G,He):y(G.low,G.high,typeof He=="boolean"?He:G.unsigned)}t.fromString=S,t.fromValue=l;var B=4294967296,O=B*B,V=O/2,L=A(1<<24),g=A(0);t.ZERO=g;var W=A(0,!0);t.UZERO=W;var de=A(1);t.ONE=de;var ke=A(1,!0);t.UONE=ke;var Ie=A(-1);t.NEG_ONE=Ie;var he=y(-1,2147483647,!1);t.MAX_VALUE=he;var Q=y(-1,-1,!0);t.MAX_UNSIGNED_VALUE=Q;var Se=y(0,-2147483648,!1);t.MIN_VALUE=Se;var Z=t.prototype;Z.toInt=function(){return this.unsigned?this.low>>>0:this.low},Z.toNumber=function(){return this.unsigned?(this.high>>>0)*B+(this.low>>>0):this.high*B+(this.low>>>0)},Z.toString=function(G){if((G=G||10)<2||36<G)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Se)){var He=D(G),me=this.div(He),et=me.mul(He).sub(this);return me.toString(G)+et.toInt().toString(G)}return"-"+this.neg().toString(G)}for(var rt=D(E(G,6),this.unsigned),It=this,X="";;){var $t=It.div(rt),Ct=(It.sub($t.mul(rt)).toInt()>>>0).toString(G);if((It=$t).isZero())return Ct+X;for(;Ct.length<6;)Ct="0"+Ct;X=""+Ct+X}},Z.getHighBits=function(){return this.high},Z.getHighBitsUnsigned=function(){return this.high>>>0},Z.getLowBits=function(){return this.low},Z.getLowBitsUnsigned=function(){return this.low>>>0},Z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Se)?64:this.neg().getNumBitsAbs();for(var G=this.high!=0?this.high:this.low,He=31;He>0&&(G&1<<He)==0;He--);return this.high!=0?He+33:He+1},Z.isZero=function(){return this.high===0&&this.low===0},Z.eqz=Z.isZero,Z.isNegative=function(){return!this.unsigned&&this.high<0},Z.isPositive=function(){return this.unsigned||this.high>=0},Z.isOdd=function(){return(1&this.low)==1},Z.isEven=function(){return(1&this.low)==0},Z.equals=function(G){return m(G)||(G=l(G)),(this.unsigned===G.unsigned||this.high>>>31!=1||G.high>>>31!=1)&&this.high===G.high&&this.low===G.low},Z.eq=Z.equals,Z.notEquals=function(G){return!this.eq(G)},Z.neq=Z.notEquals,Z.ne=Z.notEquals,Z.lessThan=function(G){return this.comp(G)<0},Z.lt=Z.lessThan,Z.lessThanOrEqual=function(G){return this.comp(G)<=0},Z.lte=Z.lessThanOrEqual,Z.le=Z.lessThanOrEqual,Z.greaterThan=function(G){return this.comp(G)>0},Z.gt=Z.greaterThan,Z.greaterThanOrEqual=function(G){return this.comp(G)>=0},Z.gte=Z.greaterThanOrEqual,Z.ge=Z.greaterThanOrEqual,Z.compare=function(G){if(m(G)||(G=l(G)),this.eq(G))return 0;var He=this.isNegative(),me=G.isNegative();return He&&!me?-1:!He&&me?1:this.unsigned?G.high>>>0>this.high>>>0||G.high===this.high&&G.low>>>0>this.low>>>0?-1:1:this.sub(G).isNegative()?-1:1},Z.comp=Z.compare,Z.negate=function(){return!this.unsigned&&this.eq(Se)?Se:this.not().add(de)},Z.neg=Z.negate,Z.add=function(G){m(G)||(G=l(G));var He=this.high>>>16,me=65535&this.high,et=this.low>>>16,rt=65535&this.low,It=G.high>>>16,X=65535&G.high,$t=G.low>>>16,Ct=0,Gt=0,Wt=0,lt=0;return Wt+=(lt+=rt+(65535&G.low))>>>16,Gt+=(Wt+=et+$t)>>>16,Ct+=(Gt+=me+X)>>>16,Ct+=He+It,y((Wt&=65535)<<16|(lt&=65535),(Ct&=65535)<<16|(Gt&=65535),this.unsigned)},Z.subtract=function(G){return m(G)||(G=l(G)),this.add(G.neg())},Z.sub=Z.subtract,Z.multiply=function(G){if(this.isZero())return g;if(m(G)||(G=l(G)),e)return y(e.mul(this.low,this.high,G.low,G.high),e.get_high(),this.unsigned);if(G.isZero())return g;if(this.eq(Se))return G.isOdd()?Se:g;if(G.eq(Se))return this.isOdd()?Se:g;if(this.isNegative())return G.isNegative()?this.neg().mul(G.neg()):this.neg().mul(G).neg();if(G.isNegative())return this.mul(G.neg()).neg();if(this.lt(L)&&G.lt(L))return D(this.toNumber()*G.toNumber(),this.unsigned);var He=this.high>>>16,me=65535&this.high,et=this.low>>>16,rt=65535&this.low,It=G.high>>>16,X=65535&G.high,$t=G.low>>>16,Ct=65535&G.low,Gt=0,Wt=0,lt=0,Qt=0;return lt+=(Qt+=rt*Ct)>>>16,Wt+=(lt+=et*Ct)>>>16,lt&=65535,Wt+=(lt+=rt*$t)>>>16,Gt+=(Wt+=me*Ct)>>>16,Wt&=65535,Gt+=(Wt+=et*$t)>>>16,Wt&=65535,Gt+=(Wt+=rt*X)>>>16,Gt+=He*Ct+me*$t+et*X+rt*It,y((lt&=65535)<<16|(Qt&=65535),(Gt&=65535)<<16|(Wt&=65535),this.unsigned)},Z.mul=Z.multiply,Z.divide=function(G){if(m(G)||(G=l(G)),G.isZero())throw Error("division by zero");var He,me,et;if(e)return this.unsigned||this.high!==-2147483648||G.low!==-1||G.high!==-1?y((this.unsigned?e.div_u:e.div_s)(this.low,this.high,G.low,G.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?W:g;if(this.unsigned){if(G.unsigned||(G=G.toUnsigned()),G.gt(this))return W;if(G.gt(this.shru(1)))return ke;et=W}else{if(this.eq(Se))return G.eq(de)||G.eq(Ie)?Se:G.eq(Se)?de:(He=this.shr(1).div(G).shl(1)).eq(g)?G.isNegative()?de:Ie:(me=this.sub(G.mul(He)),et=He.add(me.div(G)));if(G.eq(Se))return this.unsigned?W:g;if(this.isNegative())return G.isNegative()?this.neg().div(G.neg()):this.neg().div(G).neg();if(G.isNegative())return this.div(G.neg()).neg();et=g}for(me=this;me.gte(G);){He=Math.max(1,Math.floor(me.toNumber()/G.toNumber()));for(var rt=Math.ceil(Math.log(He)/Math.LN2),It=rt<=48?1:E(2,rt-48),X=D(He),$t=X.mul(G);$t.isNegative()||$t.gt(me);)$t=(X=D(He-=It,this.unsigned)).mul(G);X.isZero()&&(X=de),et=et.add(X),me=me.sub($t)}return et},Z.div=Z.divide,Z.modulo=function(G){return m(G)||(G=l(G)),e?y((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,G.low,G.high),e.get_high(),this.unsigned):this.sub(this.div(G).mul(G))},Z.mod=Z.modulo,Z.rem=Z.modulo,Z.not=function(){return y(~this.low,~this.high,this.unsigned)},Z.and=function(G){return m(G)||(G=l(G)),y(this.low&G.low,this.high&G.high,this.unsigned)},Z.or=function(G){return m(G)||(G=l(G)),y(this.low|G.low,this.high|G.high,this.unsigned)},Z.xor=function(G){return m(G)||(G=l(G)),y(this.low^G.low,this.high^G.high,this.unsigned)},Z.shiftLeft=function(G){return m(G)&&(G=G.toInt()),(G&=63)==0?this:G<32?y(this.low<<G,this.high<<G|this.low>>>32-G,this.unsigned):y(0,this.low<<G-32,this.unsigned)},Z.shl=Z.shiftLeft,Z.shiftRight=function(G){return m(G)&&(G=G.toInt()),(G&=63)==0?this:G<32?y(this.low>>>G|this.high<<32-G,this.high>>G,this.unsigned):y(this.high>>G-32,this.high>=0?0:-1,this.unsigned)},Z.shr=Z.shiftRight,Z.shiftRightUnsigned=function(G){if(m(G)&&(G=G.toInt()),(G&=63)===0)return this;var He=this.high;return G<32?y(this.low>>>G|He<<32-G,He>>>G,this.unsigned):y(G===32?He:He>>>G-32,0,this.unsigned)},Z.shru=Z.shiftRightUnsigned,Z.shr_u=Z.shiftRightUnsigned,Z.toSigned=function(){return this.unsigned?y(this.low,this.high,!1):this},Z.toUnsigned=function(){return this.unsigned?this:y(this.low,this.high,!0)},Z.toBytes=function(G){return G?this.toBytesLE():this.toBytesBE()},Z.toBytesLE=function(){var G=this.high,He=this.low;return[255&He,He>>>8&255,He>>>16&255,He>>>24,255&G,G>>>8&255,G>>>16&255,G>>>24]},Z.toBytesBE=function(){var G=this.high,He=this.low;return[G>>>24,G>>>16&255,G>>>8&255,255&G,He>>>24,He>>>16&255,He>>>8&255,255&He]},t.fromBytes=function(G,He,me){return me?t.fromBytesLE(G,He):t.fromBytesBE(G,He)},t.fromBytesLE=function(G,He){return new t(G[0]|G[1]<<8|G[2]<<16|G[3]<<24,G[4]|G[5]<<8|G[6]<<16|G[7]<<24,He)},t.fromBytesBE=function(G,He){return new t(G[4]<<24|G[5]<<16|G[6]<<8|G[7],G[0]<<24|G[1]<<16|G[2]<<8|G[3],He)}},function(I,n,e){(function(t,m,h,b){var A,D=(A=(A=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0)||t,function(y){function E(){return Qt.buffer!=J&&un(Qt.buffer),we}function S(){return Qt.buffer!=J&&un(Qt.buffer),vt}function l(){return Qt.buffer!=J&&un(Qt.buffer),wt}function B(){return Qt.buffer!=J&&un(Qt.buffer),Ot}var O,V,L,g=typeof(y=y||{})!="undefined"?y:{};g.ready=new Promise(function(Fe,dt){O=Fe,V=dt}),typeof m!="undefined"&&m.listeners&&(L={uncaughtException:m.listeners("uncaughtException"),unhandledRejection:m.listeners("unhandledRejection")});var W,de,ke,Ie,he,Q,Se=Object.assign({},g),Z=(Fe,dt)=>{throw dt},G=typeof window=="object",He=typeof importScripts=="function",me=typeof m=="object"&&typeof m.versions=="object"&&typeof m.versions.node=="string",et=g.ENVIRONMENT_IS_PTHREAD||!1,rt="";function It(Fe){return g.locateFile?g.locateFile(Fe,rt):rt+Fe}if(me){let Fe;rt=He?e(54).dirname(rt)+"/":h+"/",Q=()=>{he||(Ie=e(96),he=e(54))},W=function(dt,Et){return Q(),dt=he.normalize(dt),Ie.readFileSync(dt,Et?void 0:"utf8")},ke=dt=>{var Et=W(dt,!0);return Et.buffer||(Et=new Uint8Array(Et)),Et},de=(dt,Et,Vt)=>{Q(),dt=he.normalize(dt),Ie.readFile(dt,function(an,Zt){an?Vt(an):Et(Zt.buffer)})},m.argv.length>1&&m.argv[1].replace(/\\/g,"/"),m.argv.slice(2),m.on("uncaughtException",function(dt){if(!(dt instanceof ba))throw dt}),m.on("unhandledRejection",function(dt){throw dt}),Z=(dt,Et)=>{if(zr())throw m.exitCode=dt,Et;var Vt;(Vt=Et)instanceof ba||Wt("exiting due to exception: "+Vt),m.exit(dt)},g.inspect=function(){return"[Emscripten Module object]"};try{Fe=e(122)}catch(dt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),dt}b.Worker=Fe.Worker}else(G||He)&&(He?rt=self.location.href:typeof document!="undefined"&&document.currentScript&&(rt=document.currentScript.src),typeof A!="undefined"&&A&&(rt=A),rt=rt.indexOf("blob:")!==0?rt.substr(0,rt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",me||(W=Fe=>{var dt=new XMLHttpRequest;return dt.open("GET",Fe,!1),dt.send(null),dt.responseText},He&&(ke=Fe=>{var dt=new XMLHttpRequest;return dt.open("GET",Fe,!1),dt.responseType="arraybuffer",dt.send(null),new Uint8Array(dt.response)}),de=(Fe,dt,Et)=>{var Vt=new XMLHttpRequest;Vt.open("GET",Fe,!0),Vt.responseType="arraybuffer",Vt.onload=()=>{Vt.status==200||Vt.status==0&&Vt.response?dt(Vt.response):Et()},Vt.onerror=Et,Vt.send(null)}));me&&typeof performance=="undefined"&&(b.performance=e(123).performance);var X=console.log.bind(console),$t=console.warn.bind(console);me&&(Q(),X=Fe=>Ie.writeSync(1,Fe+`
`),$t=Fe=>Ie.writeSync(2,Fe+`
`));var Ct,Gt=g.print||X,Wt=g.printErr||$t;function lt(Fe){lt.shown||(lt.shown={}),lt.shown[Fe]||(lt.shown[Fe]=1,Wt(Fe))}Object.assign(g,Se),Se=null,g.arguments&&g.arguments,g.thisProgram&&g.thisProgram,g.quit&&(Z=g.quit),g.wasmBinary&&(Ct=g.wasmBinary);var Qt,Ft,yn=g.noExitRuntime||!0;typeof WebAssembly!="object"&&$r("no native wasm support detected");var Nn,Kn=!1;function zn(Fe){return g["_"+Fe]}function sr(Fe,dt,Et,Vt,an){var Zt={string:function(Er){var Yr=0;if(Er!=null&&Er!==0){var ja=1+(Er.length<<2);Nt(Er,Yr=sa(ja),ja)}return Yr},array:function(Er){var Yr=sa(Er.length);return function(ja,Oa){E().set(ja,Oa)}(Er,Yr),Yr}},_n=zn(Fe),Gn=[],ar=0;if(Vt)for(var Rr=0;Rr<Vt.length;Rr++){var Ir=Zt[Et[Rr]];Ir?(ar===0&&(ar=La()),Gn[Rr]=Ir(Vt[Rr])):Gn[Rr]=Vt[Rr]}var xa=_n.apply(null,Gn);return xa=function(Er){return ar!==0&&wr(ar),function(Yr){return dt==="string"?Mt(Yr):dt==="boolean"?Boolean(Yr):Yr}(Er)}(xa)}function K(Fe){var dt=new TextDecoder(Fe);this.decode=Et=>(Et.buffer instanceof SharedArrayBuffer&&(Et=new Uint8Array(Et)),dt.decode.call(dt,Et))}var J,we,vt,wt,Ot,Ae=typeof TextDecoder!="undefined"?new K("utf8"):void 0;function mt(Fe,dt,Et){for(var Vt=dt+Et,an=dt;Fe[an]&&!(an>=Vt);)++an;if(an-dt>16&&Fe.subarray&&Ae)return Ae.decode(Fe.subarray(dt,an));for(var Zt="";dt<an;){var _n=Fe[dt++];if(128&_n){var Gn=63&Fe[dt++];if((224&_n)!=192){var ar=63&Fe[dt++];if((_n=(240&_n)==224?(15&_n)<<12|Gn<<6|ar:(7&_n)<<18|Gn<<12|ar<<6|63&Fe[dt++])<65536)Zt+=String.fromCharCode(_n);else{var Rr=_n-65536;Zt+=String.fromCharCode(55296|Rr>>10,56320|1023&Rr)}}else Zt+=String.fromCharCode((31&_n)<<6|Gn)}else Zt+=String.fromCharCode(_n)}return Zt}function Mt(Fe,dt){return Fe?mt(S(),Fe,dt):""}function Nt(Fe,dt,Et){return function(Vt,an,Zt,_n){if(!(_n>0))return 0;for(var Gn=Zt,ar=Zt+_n-1,Rr=0;Rr<Vt.length;++Rr){var Ir=Vt.charCodeAt(Rr);if(Ir>=55296&&Ir<=57343&&(Ir=65536+((1023&Ir)<<10)|1023&Vt.charCodeAt(++Rr)),Ir<=127){if(Zt>=ar)break;an[Zt++]=Ir}else if(Ir<=2047){if(Zt+1>=ar)break;an[Zt++]=192|Ir>>6,an[Zt++]=128|63&Ir}else if(Ir<=65535){if(Zt+2>=ar)break;an[Zt++]=224|Ir>>12,an[Zt++]=128|Ir>>6&63,an[Zt++]=128|63&Ir}else{if(Zt+3>=ar)break;an[Zt++]=240|Ir>>18,an[Zt++]=128|Ir>>12&63,an[Zt++]=128|Ir>>6&63,an[Zt++]=128|63&Ir}}return an[Zt]=0,Zt-Gn}(Fe,S(),dt,Et)}function un(Fe){J=Fe,g.HEAP8=we=new Int8Array(Fe),g.HEAP16=new Int16Array(Fe),g.HEAP32=wt=new Int32Array(Fe),g.HEAPU8=vt=new Uint8Array(Fe),g.HEAPU16=new Uint16Array(Fe),g.HEAPU32=new Uint32Array(Fe),g.HEAPF32=new Float32Array(Fe),g.HEAPF64=Ot=new Float64Array(Fe)}typeof TextDecoder!="undefined"&&new K("utf-16le"),et&&(J=g.buffer);var Rn,oe=g.INITIAL_MEMORY||16777216;if(et)Qt=g.wasmMemory,J=g.buffer;else if(g.wasmMemory)Qt=g.wasmMemory;else if(!((Qt=new WebAssembly.Memory({initial:oe/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw Wt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),me&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Qt&&(J=Qt.buffer),oe=J.byteLength,un(J);var le=[],qe=[],Mn=[];function zr(){return yn||!1}function Ur(){et||lr(qe)}var _r,ir=0,Zn=null;function $r(Fe){et?postMessage({cmd:"onAbort",arg:Fe}):g.onAbort&&g.onAbort(Fe),Wt(Fe="Aborted("+Fe+")"),Kn=!0,Nn=1,Fe+=". Build with -s ASSERTIONS=1 for more info.";var dt=new WebAssembly.RuntimeError(Fe);throw V(dt),dt}function en(Fe){return Fe.startsWith("data:application/octet-stream;base64,")}function mn(Fe){return Fe.startsWith("file://")}function Ln(Fe){try{if(Fe==_r&&Ct)return new Uint8Array(Ct);if(ke)return ke(Fe);throw"both async and sync fetching of the wasm failed"}catch(dt){$r(dt)}}g.preloadedImages={},g.preloadedAudios={},en(_r="tfjs-backend-wasm-threaded-simd.wasm")||(_r=It(_r));var or={};function lr(Fe){for(;Fe.length>0;){var dt=Fe.shift();if(typeof dt!="function"){var Et=dt.func;typeof Et=="number"?dt.arg===void 0?ht(Et)():ht(Et)(dt.arg):Et(dt.arg===void 0?null:dt.arg)}else dt(g)}}function Qn(Fe){var dt=La(),Et=Fe();return wr(dt),Et}function br(Fe){var dt=At.pthreads[Fe];if(dt){l()[Fe>>2]=0;var Et=dt.worker;At.returnWorkerToPool(Et)}}function gr(Fe){(function(dt,Et){if(Nn=dt,!Et&&et)throw q(dt),"unwind";var Vt;zr()||et||At.terminateAllThreads(),Nn=Vt=dt,zr()||(At.terminateAllThreads(),g.onExit&&g.onExit(Vt),Kn=!0),Z(Vt,new ba(Vt))})(Fe)}var At={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){et?At.initWorker():At.initMainThread()},initMainThread:function(){for(var Fe=0;Fe<8;++Fe)At.allocateUnusedWorker()},initWorker:function(){yn=!1},pthreads:{},setExitStatus:function(Fe){Nn=Fe},terminateAllThreads:function(){for(var Fe in At.pthreads){var dt=At.pthreads[Fe];dt&&dt.worker&&At.returnWorkerToPool(dt.worker)}for(var Et=0;Et<At.unusedWorkers.length;++Et)At.unusedWorkers[Et].terminate();At.unusedWorkers=[]},returnWorkerToPool:function(Fe){At.runWithoutMainThreadQueuedCalls(function(){delete At.pthreads[Fe.pthread.threadInfoStruct],At.unusedWorkers.push(Fe),At.runningWorkers.splice(At.runningWorkers.indexOf(Fe),1),os(Fe.pthread.threadInfoStruct),Fe.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(Fe){l()[Ia>>2]=0;try{Fe()}finally{l()[Ia>>2]=1}},receiveObjectTransfer:function(Fe){},threadInit:function(){for(var Fe in At.tlsInitFunctions)At.tlsInitFunctions[Fe]()},loadWasmModuleToWorker:function(Fe,dt){Fe.onmessage=Et=>{var Vt,an=Et.data,Zt=an.cmd;if(Fe.pthread&&(At.currentProxiedOperationCallerThread=Fe.pthread.threadInfoStruct),an.targetThread&&an.targetThread!=Ba()){var _n=At.pthreads[an.targetThread];return _n?_n.worker.postMessage(an,an.transferList):Wt('Internal error! Worker sent a message "'+Zt+'" to target pthread '+an.targetThread+", but that thread no longer exists!"),void(At.currentProxiedOperationCallerThread=void 0)}Zt==="processQueuedMainThreadWork"?wa():Zt==="spawnThread"?Kt(an):Zt==="cleanupThread"?br(an.thread):Zt==="killThread"?function(Gn){l()[Gn>>2]=0;var ar=At.pthreads[Gn];delete At.pthreads[Gn],ar.worker.terminate(),os(Gn),At.runningWorkers.splice(At.runningWorkers.indexOf(ar.worker),1),ar.worker.pthread=void 0}(an.thread):Zt==="cancelThread"?(Vt=an.thread,At.pthreads[Vt].worker.postMessage({cmd:"cancel"})):Zt==="loaded"?(Fe.loaded=!0,dt&&dt(Fe),Fe.runPthread&&(Fe.runPthread(),delete Fe.runPthread)):Zt==="print"?Gt("Thread "+an.threadId+": "+an.text):Zt==="printErr"?Wt("Thread "+an.threadId+": "+an.text):Zt==="alert"?alert("Thread "+an.threadId+": "+an.text):an.target==="setimmediate"?Fe.postMessage(an):Zt==="onAbort"?g.onAbort&&g.onAbort(an.arg):Wt("worker sent an unknown command "+Zt),At.currentProxiedOperationCallerThread=void 0},Fe.onerror=Et=>{throw Wt("worker sent an error! "+Et.filename+":"+Et.lineno+": "+Et.message),Et},me&&(Fe.on("message",function(Et){Fe.onmessage({data:Et})}),Fe.on("error",function(Et){Fe.onerror(Et)}),Fe.on("detachedExit",function(){})),Fe.postMessage({cmd:"load",urlOrBlob:g.mainScriptUrlOrBlob||A,wasmMemory:Qt,wasmModule:Ft})},allocateUnusedWorker:function(){var Fe=It("tfjs-backend-wasm-threaded-simd.worker.js");At.unusedWorkers.push(new Worker(Fe))},getNewWorker:function(){return At.unusedWorkers.length==0&&(At.allocateUnusedWorker(),At.loadWasmModuleToWorker(At.unusedWorkers[0])),At.unusedWorkers.pop()}};function q(Fe){if(et)return tn(1,0,Fe);try{gr(Fe)}catch(dt){(function(Et){if(Et instanceof ba||Et=="unwind")return Nn;Z(1,Et)})(dt)}}g.establishStackSpace=function(){var Fe=Ba(),dt=l()[Fe+44>>2],Et=l()[Fe+48>>2];Za(dt,dt-Et),wr(dt)};var ae,Qe=[];function ht(Fe){var dt=Qe[Fe];return dt||(Fe>=Qe.length&&(Qe.length=Fe+1),Qe[Fe]=dt=Rn.get(Fe)),dt}function Bt(Fe,dt){var Et,Vt;if(Fe===0)Et=Date.now();else{if(Fe!==1&&Fe!==4)return Vt=28,l()[Va()>>2]=Vt,-1;Et=ae()}return l()[dt>>2]=Et/1e3|0,l()[dt+4>>2]=Et%1e3*1e3*1e3|0,0}function Kt(Fe){var dt=At.getNewWorker();if(!dt)return 6;At.runningWorkers.push(dt);var Et=At.pthreads[Fe.pthread_ptr]={worker:dt,threadInfoStruct:Fe.pthread_ptr};dt.pthread=Et;var Vt={cmd:"run",start_routine:Fe.startRoutine,arg:Fe.arg,threadInfoStruct:Fe.pthread_ptr};return dt.runPthread=()=>{Vt.time=performance.now(),dt.postMessage(Vt,Fe.transferList)},dt.loaded&&(dt.runPthread(),delete dt.runPthread),0}function Ut(){return 2147483648}function tn(Fe,dt){var Et=arguments.length-2,Vt=arguments;return Qn(function(){for(var an=Et,Zt=sa(8*an),_n=Zt>>3,Gn=0;Gn<Et;Gn++){var ar=Vt[2+Gn];B()[_n+Gn]=ar}return ka(Fe,an,Zt,dt)})}g.invokeEntryPoint=function(Fe,dt){return ht(Fe)(dt)},ae=me?()=>{var Fe=m.hrtime();return 1e3*Fe[0]+Fe[1]/1e6}:et?()=>performance.now()-g.__performance_now_clock_drift:()=>performance.now();var bn=[];function xn(Fe){try{return Qt.grow(Fe-J.byteLength+65535>>>16),un(Qt.buffer),1}catch{}}var rn={inEventHandler:0,removeAllEventListeners:function(){for(var Fe=rn.eventHandlers.length-1;Fe>=0;--Fe)rn._removeHandler(Fe);rn.eventHandlers=[],rn.deferredCalls=[]},registerRemoveEventListeners:function(){rn.removeEventListenersRegistered||(rn.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(Fe,dt,Et){function Vt(_n,Gn){if(_n.length!=Gn.length)return!1;for(var ar in _n)if(_n[ar]!=Gn[ar])return!1;return!0}for(var an in rn.deferredCalls){var Zt=rn.deferredCalls[an];if(Zt.targetFunction==Fe&&Vt(Zt.argsList,Et))return}rn.deferredCalls.push({targetFunction:Fe,precedence:dt,argsList:Et}),rn.deferredCalls.sort(function(_n,Gn){return _n.precedence<Gn.precedence})},removeDeferredCalls:function(Fe){for(var dt=0;dt<rn.deferredCalls.length;++dt)rn.deferredCalls[dt].targetFunction==Fe&&(rn.deferredCalls.splice(dt,1),--dt)},canPerformEventHandlerRequests:function(){return rn.inEventHandler&&rn.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(rn.canPerformEventHandlerRequests())for(var Fe=0;Fe<rn.deferredCalls.length;++Fe){var dt=rn.deferredCalls[Fe];rn.deferredCalls.splice(Fe,1),--Fe,dt.targetFunction.apply(null,dt.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(Fe,dt){for(var Et=0;Et<rn.eventHandlers.length;++Et)rn.eventHandlers[Et].target!=Fe||dt&&dt!=rn.eventHandlers[Et].eventTypeString||rn._removeHandler(Et--)},_removeHandler:function(Fe){var dt=rn.eventHandlers[Fe];dt.target.removeEventListener(dt.eventTypeString,dt.eventListenerFunc,dt.useCapture),rn.eventHandlers.splice(Fe,1)},registerOrRemoveHandler:function(Fe){var dt=function(Vt){++rn.inEventHandler,rn.currentEventHandler=Fe,rn.runDeferredCalls(),Fe.handlerFunc(Vt),rn.runDeferredCalls(),--rn.inEventHandler};if(Fe.callbackfunc)Fe.eventListenerFunc=dt,Fe.target.addEventListener(Fe.eventTypeString,dt,Fe.useCapture),rn.eventHandlers.push(Fe),rn.registerRemoveEventListeners();else for(var Et=0;Et<rn.eventHandlers.length;++Et)rn.eventHandlers[Et].target==Fe.target&&rn.eventHandlers[Et].eventTypeString==Fe.eventTypeString&&rn._removeHandler(Et--)},queueEventHandlerOnThread_iiii:function(Fe,dt,Et,Vt,an){Qn(function(){var Zt=sa(12);l()[Zt>>2]=Et,l()[Zt+4>>2]=Vt,l()[Zt+8>>2]=an,_a(Fe,637534208,dt,Vt,Zt)})},getTargetThreadForEventCallback:function(Fe){switch(Fe){case 1:return 0;case 2:return At.currentProxiedOperationCallerThread;default:return Fe}},getNodeNameForTarget:function(Fe){return Fe?Fe==window?"#window":Fe==screen?"#screen":Fe&&Fe.nodeName?Fe.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function Xn(Fe,dt,Et,Vt){Qn(function(){var an,Zt,_n,Gn=sa(12),ar=0;dt&&(Zt=function(Rr){for(var Ir=0,xa=0;xa<Rr.length;++xa){var Er=Rr.charCodeAt(xa);Er>=55296&&Er<=57343&&(Er=65536+((1023&Er)<<10)|1023&Rr.charCodeAt(++xa)),Er<=127?++Ir:Ir+=Er<=2047?2:Er<=65535?3:4}return Ir}(an=dt)+1,_n=is(Zt),Nt(an,_n,Zt),ar=_n),l()[Gn>>2]=ar,l()[Gn+4>>2]=Et,l()[Gn+8>>2]=Vt,_a(Fe,657457152,0,ar,Gn)})}var xr=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function Lr(Fe){var dt;return Fe=(dt=Fe)>2?Mt(dt):dt,xr[Fe]||(typeof document!="undefined"?document.querySelector(Fe):void 0)}function Wr(Fe){return Lr(Fe)}function vr(Fe,dt,Et){var Vt=Wr(Fe);if(!Vt)return-4;if(Vt.canvasSharedPtr&&(l()[Vt.canvasSharedPtr>>2]=dt,l()[Vt.canvasSharedPtr+4>>2]=Et),!Vt.offscreenCanvas&&Vt.controlTransferredOffscreen)return Vt.canvasSharedPtr?(function(_n,Gn,ar,Rr){Xn(_n,Gn=Gn?Mt(Gn):"",ar,Rr)}(l()[Vt.canvasSharedPtr+8>>2],Fe,dt,Et),1):-4;Vt.offscreenCanvas&&(Vt=Vt.offscreenCanvas);var an=!1;if(Vt.GLctxObject&&Vt.GLctxObject.GLctx){var Zt=Vt.GLctxObject.GLctx.getParameter(2978);an=Zt[0]===0&&Zt[1]===0&&Zt[2]===Vt.width&&Zt[3]===Vt.height}return Vt.width=dt,Vt.height=Et,an&&Vt.GLctxObject.GLctx.viewport(0,0,dt,Et),0}function ua(Fe,dt,Et){return et?tn(2,1,Fe,dt,Et):vr(Fe,dt,Et)}var ma,Cr={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(Fe){Cr.lastError||(Cr.lastError=Fe)},getNewId:function(Fe){for(var dt=Cr.counter++,Et=Fe.length;Et<dt;Et++)Fe[Et]=null;return dt},getSource:function(Fe,dt,Et,Vt){for(var an="",Zt=0;Zt<dt;++Zt){var _n=Vt?l()[Vt+4*Zt>>2]:-1;an+=Mt(l()[Et+4*Zt>>2],_n<0?void 0:_n)}return an},createContext:function(Fe,dt){Fe.getContextSafariWebGL2Fixed||(Fe.getContextSafariWebGL2Fixed=Fe.getContext,Fe.getContext=function(Vt,an){var Zt=Fe.getContextSafariWebGL2Fixed(Vt,an);return Vt=="webgl"==Zt instanceof WebGLRenderingContext?Zt:null});var Et=Fe.getContext("webgl",dt);return Et?Cr.registerContext(Et,dt):0},registerContext:function(Fe,dt){var Et=is(8);l()[Et+4>>2]=Ba();var Vt={handle:Et,attributes:dt,version:dt.majorVersion,GLctx:Fe};return Fe.canvas&&(Fe.canvas.GLctxObject=Vt),Cr.contexts[Et]=Vt,(typeof dt.enableExtensionsByDefault=="undefined"||dt.enableExtensionsByDefault)&&Cr.initExtensions(Vt),Et},makeContextCurrent:function(Fe){return Cr.currentContext=Cr.contexts[Fe],g.ctx=ma=Cr.currentContext&&Cr.currentContext.GLctx,!(Fe&&!ma)},getContext:function(Fe){return Cr.contexts[Fe]},deleteContext:function(Fe){Cr.currentContext===Cr.contexts[Fe]&&(Cr.currentContext=null),typeof rn=="object"&&rn.removeAllHandlersOnTarget(Cr.contexts[Fe].GLctx.canvas),Cr.contexts[Fe]&&Cr.contexts[Fe].GLctx.canvas&&(Cr.contexts[Fe].GLctx.canvas.GLctxObject=void 0),ms(Cr.contexts[Fe].handle),Cr.contexts[Fe]=null},initExtensions:function(Fe){if(Fe||(Fe=Cr.currentContext),!Fe.initExtensionsDone){Fe.initExtensionsDone=!0;var dt,Et=Fe.GLctx;(function(Vt){var an=Vt.getExtension("ANGLE_instanced_arrays");an&&(Vt.vertexAttribDivisor=function(Zt,_n){an.vertexAttribDivisorANGLE(Zt,_n)},Vt.drawArraysInstanced=function(Zt,_n,Gn,ar){an.drawArraysInstancedANGLE(Zt,_n,Gn,ar)},Vt.drawElementsInstanced=function(Zt,_n,Gn,ar,Rr){an.drawElementsInstancedANGLE(Zt,_n,Gn,ar,Rr)})})(Et),function(Vt){var an=Vt.getExtension("OES_vertex_array_object");an&&(Vt.createVertexArray=function(){return an.createVertexArrayOES()},Vt.deleteVertexArray=function(Zt){an.deleteVertexArrayOES(Zt)},Vt.bindVertexArray=function(Zt){an.bindVertexArrayOES(Zt)},Vt.isVertexArray=function(Zt){return an.isVertexArrayOES(Zt)})}(Et),function(Vt){var an=Vt.getExtension("WEBGL_draw_buffers");an&&(Vt.drawBuffers=function(Zt,_n){an.drawBuffersWEBGL(Zt,_n)})}(Et),Et.disjointTimerQueryExt=Et.getExtension("EXT_disjoint_timer_query"),(dt=Et).multiDrawWebgl=dt.getExtension("WEBGL_multi_draw"),(Et.getSupportedExtensions()||[]).forEach(function(Vt){Vt.includes("lose_context")||Vt.includes("debug")||Et.getExtension(Vt)})}}},Da=["default","low-power","high-performance"],kr={mappings:{},buffers:[null,[],[]],printChar:function(Fe,dt){var Et=kr.buffers[Fe];dt===0||dt===10?((Fe===1?Gt:Wt)(mt(Et,0)),Et.length=0):Et.push(dt)},varargs:void 0,get:function(){return kr.varargs+=4,l()[kr.varargs-4>>2]},getStr:function(Fe){return Mt(Fe)},get64:function(Fe,dt){return Fe}};function Pr(Fe){return et?tn(3,1,Fe):0}function qr(Fe,dt,Et,Vt,an){if(et)return tn(4,1,Fe,dt,Et,Vt,an)}function ha(Fe,dt,Et,Vt){if(et)return tn(5,1,Fe,dt,Et,Vt);for(var an=0,Zt=0;Zt<Et;Zt++){var _n=l()[dt>>2],Gn=l()[dt+4>>2];dt+=8;for(var ar=0;ar<Gn;ar++)kr.printChar(Fe,S()[_n+ar]);an+=Gn}return l()[Vt>>2]=an,0}At.init();var Zr,Vr,Ca,Ta=[null,q,ua,Pr,qr,ha],Pa={__clock_gettime:function(Fe,dt){return Bt(Fe,dt)},__emscripten_init_main_thread_js:function(Fe){Ga(Fe,!He,1,!G),At.threadInit()},__emscripten_thread_cleanup:function(Fe){et?postMessage({cmd:"cleanupThread",thread:Fe}):br(Fe)},__pthread_create_js:function(Fe,dt,Et,Vt){if(typeof SharedArrayBuffer=="undefined")return Wt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var an=[];if(et&&an.length===0)return Xr(687865856,Fe,dt,Et,Vt);var Zt={startRoutine:Et,pthread_ptr:Fe,arg:Vt,transferList:an};return et?(Zt.cmd="spawnThread",postMessage(Zt,an),0):Kt(Zt)},_emscripten_default_pthread_stack_size:function(){return 2097152},_emscripten_notify_thread_queue:function(Fe,dt){if(Fe==dt)postMessage({cmd:"processQueuedMainThreadWork"});else if(et)postMessage({targetThread:Fe,cmd:"processThreadQueue"});else{var Et=At.pthreads[Fe],Vt=Et&&Et.worker;if(!Vt)return;Vt.postMessage({cmd:"processThreadQueue"})}return 1},abort:function(){$r("")},emscripten_check_blocking_allowed:function(){me||He||lt("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_get_heap_max:Ut,emscripten_get_now:ae,emscripten_memcpy_big:function(Fe,dt,Et){S().copyWithin(Fe,dt,dt+Et)},emscripten_num_logical_cores:function(){return me?e(124).cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(Fe,dt,Et){bn.length=dt;for(var Vt=Et>>3,an=0;an<dt;an++)bn[an]=B()[Vt+an];return(Fe<0?or[-Fe-1]:Ta[Fe]).apply(null,bn)},emscripten_resize_heap:function(Fe){var dt=S().length;if((Fe>>>=0)<=dt)return!1;var Et,Vt,an=2147483648;if(Fe>an)return!1;for(var Zt=1;Zt<=4;Zt*=2){var _n=dt*(1+.2/Zt);if(_n=Math.min(_n,Fe+100663296),xn(Math.min(an,((Et=Math.max(Fe,_n))%(Vt=65536)>0&&(Et+=Vt-Et%Vt),Et))))return!0}return!1},emscripten_set_canvas_element_size:function(Fe,dt,Et){return Wr(Fe)?vr(Fe,dt,Et):ua(Fe,dt,Et)},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},emscripten_webgl_create_context:function(Fe,dt){return Et=Fe,Vt=dt>>2,an=l()[Vt+6],Zt={alpha:!!l()[Vt+0],depth:!!l()[Vt+1],stencil:!!l()[Vt+2],antialias:!!l()[Vt+3],premultipliedAlpha:!!l()[Vt+4],preserveDrawingBuffer:!!l()[Vt+5],powerPreference:Da[an],failIfMajorPerformanceCaveat:!!l()[Vt+7],majorVersion:l()[Vt+8],minorVersion:l()[Vt+9],enableExtensionsByDefault:l()[Vt+10],explicitSwapControl:l()[Vt+11],proxyContextToMainThread:l()[Vt+12],renderViaOffscreenBackBuffer:l()[Vt+13]},(_n=Wr(Et))?Zt.explicitSwapControl?0:Cr.createContext(_n,Zt):0;var Et,Vt,an,Zt,_n},exit:gr,fd_close:Pr,fd_seek:qr,fd_write:ha,memory:Qt||g.wasmMemory,setTempRet0:function(Fe){}},is=(function(){var Fe={env:Pa,wasi_snapshot_preview1:Pa};function dt(an,Zt){var _n,Gn,ar=an.exports;if(g.asm=ar,_n=g.asm.emscripten_tls_init,At.tlsInitFunctions.push(_n),Rn=g.asm.__indirect_function_table,Gn=g.asm.__wasm_call_ctors,qe.unshift(Gn),Ft=Zt,!et){var Rr=At.unusedWorkers.length;At.unusedWorkers.forEach(function(Ir){At.loadWasmModuleToWorker(Ir,function(){--Rr||function(xa){if(ir--,g.monitorRunDependencies&&g.monitorRunDependencies(ir),ir==0&&Zn){var Er=Zn;Zn=null,Er()}}()})})}}function Et(an){dt(an.instance,an.module)}function Vt(an){return function(){if(!Ct&&(G||He)){if(typeof fetch=="function"&&!mn(_r))return fetch(_r,{credentials:"same-origin"}).then(function(Zt){if(!Zt.ok)throw"failed to load wasm binary file at '"+_r+"'";return Zt.arrayBuffer()}).catch(function(){return Ln(_r)});if(de)return new Promise(function(Zt,_n){de(_r,function(Gn){Zt(new Uint8Array(Gn))},_n)})}return Promise.resolve().then(function(){return Ln(_r)})}().then(function(Zt){return WebAssembly.instantiate(Zt,Fe)}).then(function(Zt){return Zt}).then(an,function(Zt){Wt("failed to asynchronously prepare wasm: "+Zt),$r(Zt)})}if(et||(ir++,g.monitorRunDependencies&&g.monitorRunDependencies(ir)),g.instantiateWasm)try{return g.instantiateWasm(Fe,dt)}catch(an){return Wt("Module.instantiateWasm callback failed with error: "+an),!1}(Ct||typeof WebAssembly.instantiateStreaming!="function"||en(_r)||mn(_r)||typeof fetch!="function"?Vt(Et):fetch(_r,{credentials:"same-origin"}).then(function(an){return WebAssembly.instantiateStreaming(an,Fe).then(Et,function(Zt){return Wt("wasm streaming compile failed: "+Zt),Wt("falling back to ArrayBuffer instantiation"),Vt(Et)})})).catch(V)}(),g.___wasm_call_ctors=function(){return(g.___wasm_call_ctors=g.asm.__wasm_call_ctors).apply(null,arguments)},g._init=function(){return(g._init=g.asm.init).apply(null,arguments)},g._init_with_threads_count=function(){return(g._init_with_threads_count=g.asm.init_with_threads_count).apply(null,arguments)},g._get_threads_count=function(){return(g._get_threads_count=g.asm.get_threads_count).apply(null,arguments)},g._register_tensor=function(){return(g._register_tensor=g.asm.register_tensor).apply(null,arguments)},g._dispose_data=function(){return(g._dispose_data=g.asm.dispose_data).apply(null,arguments)},g._dispose=function(){return(g._dispose=g.asm.dispose).apply(null,arguments)},g._Abs=function(){return(g._Abs=g.asm.Abs).apply(null,arguments)},g._Add=function(){return(g._Add=g.asm.Add).apply(null,arguments)},g._AddN=function(){return(g._AddN=g.asm.AddN).apply(null,arguments)},g._All=function(){return(g._All=g.asm.All).apply(null,arguments)},g._Any=function(){return(g._Any=g.asm.Any).apply(null,arguments)},g._ArgMax=function(){return(g._ArgMax=g.asm.ArgMax).apply(null,arguments)},g._AvgPool=function(){return(g._AvgPool=g.asm.AvgPool).apply(null,arguments)},g._BatchMatMul=function(){return(g._BatchMatMul=g.asm.BatchMatMul).apply(null,arguments)},g._Ceil=function(){return(g._Ceil=g.asm.Ceil).apply(null,arguments)},g._ClipByValue=function(){return(g._ClipByValue=g.asm.ClipByValue).apply(null,arguments)},g._Conv2D=function(){return(g._Conv2D=g.asm.Conv2D).apply(null,arguments)},g._Conv2DBackpropInput=function(){return(g._Conv2DBackpropInput=g.asm.Conv2DBackpropInput).apply(null,arguments)},g._Cos=function(){return(g._Cos=g.asm.Cos).apply(null,arguments)},g._Cosh=function(){return(g._Cosh=g.asm.Cosh).apply(null,arguments)},g._CropAndResize=function(){return(g._CropAndResize=g.asm.CropAndResize).apply(null,arguments)},g._Cumprod=function(){return(g._Cumprod=g.asm.Cumprod).apply(null,arguments)},g._Cumsum=function(){return(g._Cumsum=g.asm.Cumsum).apply(null,arguments)},g._DepthToSpace=function(){return(g._DepthToSpace=g.asm.DepthToSpace).apply(null,arguments)},g._DepthwiseConv2dNative=function(){return(g._DepthwiseConv2dNative=g.asm.DepthwiseConv2dNative).apply(null,arguments)},g._Elu=function(){return(g._Elu=g.asm.Elu).apply(null,arguments)},g._Equal=function(){return(g._Equal=g.asm.Equal).apply(null,arguments)},g._Exp=function(){return(g._Exp=g.asm.Exp).apply(null,arguments)},g._FlipLeftRight=function(){return(g._FlipLeftRight=g.asm.FlipLeftRight).apply(null,arguments)},g._Floor=function(){return(g._Floor=g.asm.Floor).apply(null,arguments)},g._FloorDiv=function(){return(g._FloorDiv=g.asm.FloorDiv).apply(null,arguments)},g._FusedBatchNorm=function(){return(g._FusedBatchNorm=g.asm.FusedBatchNorm).apply(null,arguments)},g._FusedConv2D=function(){return(g._FusedConv2D=g.asm.FusedConv2D).apply(null,arguments)},g._FusedDepthwiseConv2D=function(){return(g._FusedDepthwiseConv2D=g.asm.FusedDepthwiseConv2D).apply(null,arguments)},g._Gather=function(){return(g._Gather=g.asm.Gather).apply(null,arguments)},g._GatherNd=function(){return(g._GatherNd=g.asm.GatherNd).apply(null,arguments)},g._Greater=function(){return(g._Greater=g.asm.Greater).apply(null,arguments)},g._GreaterEqual=function(){return(g._GreaterEqual=g.asm.GreaterEqual).apply(null,arguments)},g._LeakyRelu=function(){return(g._LeakyRelu=g.asm.LeakyRelu).apply(null,arguments)},g._Less=function(){return(g._Less=g.asm.Less).apply(null,arguments)},g._LessEqual=function(){return(g._LessEqual=g.asm.LessEqual).apply(null,arguments)},g._Log=function(){return(g._Log=g.asm.Log).apply(null,arguments)},g._LogicalAnd=function(){return(g._LogicalAnd=g.asm.LogicalAnd).apply(null,arguments)},g._LogicalNot=function(){return(g._LogicalNot=g.asm.LogicalNot).apply(null,arguments)},g._LogicalOr=function(){return(g._LogicalOr=g.asm.LogicalOr).apply(null,arguments)},g._LogicalXor=function(){return(g._LogicalXor=g.asm.LogicalXor).apply(null,arguments)},g._Max=function(){return(g._Max=g.asm.Max).apply(null,arguments)},g._MaxPool=function(){return(g._MaxPool=g.asm.MaxPool).apply(null,arguments)},g._Maximum=function(){return(g._Maximum=g.asm.Maximum).apply(null,arguments)},g._Mean=function(){return(g._Mean=g.asm.Mean).apply(null,arguments)},g._Min=function(){return(g._Min=g.asm.Min).apply(null,arguments)},g._Minimum=function(){return(g._Minimum=g.asm.Minimum).apply(null,arguments)},g._MirrorPad=function(){return(g._MirrorPad=g.asm.MirrorPad).apply(null,arguments)},g._Multiply=function(){return(g._Multiply=g.asm.Multiply).apply(null,arguments)},g._Neg=function(){return(g._Neg=g.asm.Neg).apply(null,arguments)},g._NonMaxSuppressionV3=function(){return(g._NonMaxSuppressionV3=g.asm.NonMaxSuppressionV3).apply(null,arguments)},g._NonMaxSuppressionV4=function(){return(g._NonMaxSuppressionV4=g.asm.NonMaxSuppressionV4).apply(null,arguments)},g._NonMaxSuppressionV5=function(){return(g._NonMaxSuppressionV5=g.asm.NonMaxSuppressionV5).apply(null,arguments)},g._NotEqual=function(){return(g._NotEqual=g.asm.NotEqual).apply(null,arguments)},g._OneHot=function(){return(g._OneHot=g.asm.OneHot).apply(null,arguments)},g._PadV2=function(){return(g._PadV2=g.asm.PadV2).apply(null,arguments)},g._Pow=function(){return(g._Pow=g.asm.Pow).apply(null,arguments)},g._Prelu=function(){return(g._Prelu=g.asm.Prelu).apply(null,arguments)},g._Prod=function(){return(g._Prod=g.asm.Prod).apply(null,arguments)},g._RealDiv=function(){return(g._RealDiv=g.asm.RealDiv).apply(null,arguments)},g._Relu=function(){return(g._Relu=g.asm.Relu).apply(null,arguments)},g._Relu6=function(){return(g._Relu6=g.asm.Relu6).apply(null,arguments)},g._ResizeBilinear=function(){return(g._ResizeBilinear=g.asm.ResizeBilinear).apply(null,arguments)},g._ResizeNearestNeighbor=function(){return(g._ResizeNearestNeighbor=g.asm.ResizeNearestNeighbor).apply(null,arguments)},g._Reverse=function(){return(g._Reverse=g.asm.Reverse).apply(null,arguments)},g._RotateWithOffset=function(){return(g._RotateWithOffset=g.asm.RotateWithOffset).apply(null,arguments)},g._Round=function(){return(g._Round=g.asm.Round).apply(null,arguments)},g._Rsqrt=function(){return(g._Rsqrt=g.asm.Rsqrt).apply(null,arguments)},g._ScatterNd=function(){return(g._ScatterNd=g.asm.ScatterNd).apply(null,arguments)},g._SelectV2=function(){return(g._SelectV2=g.asm.SelectV2).apply(null,arguments)},g._Sigmoid=function(){return(g._Sigmoid=g.asm.Sigmoid).apply(null,arguments)},g._Sin=function(){return(g._Sin=g.asm.Sin).apply(null,arguments)},g._Softmax=function(){return(g._Softmax=g.asm.Softmax).apply(null,arguments)},g._SparseFillEmptyRows=function(){return(g._SparseFillEmptyRows=g.asm.SparseFillEmptyRows).apply(null,arguments)},g._SparseReshape=function(){return(g._SparseReshape=g.asm.SparseReshape).apply(null,arguments)},g._SparseSegmentReduction=function(){return(g._SparseSegmentReduction=g.asm.SparseSegmentReduction).apply(null,arguments)},g._Sqrt=function(){return(g._Sqrt=g.asm.Sqrt).apply(null,arguments)},g._Square=function(){return(g._Square=g.asm.Square).apply(null,arguments)},g._SquaredDifference=function(){return(g._SquaredDifference=g.asm.SquaredDifference).apply(null,arguments)},g._Step=function(){return(g._Step=g.asm.Step).apply(null,arguments)},g._StridedSlice=function(){return(g._StridedSlice=g.asm.StridedSlice).apply(null,arguments)},g._Sub=function(){return(g._Sub=g.asm.Sub).apply(null,arguments)},g._Sum=function(){return(g._Sum=g.asm.Sum).apply(null,arguments)},g._Tan=function(){return(g._Tan=g.asm.Tan).apply(null,arguments)},g._Tanh=function(){return(g._Tanh=g.asm.Tanh).apply(null,arguments)},g._Tile=function(){return(g._Tile=g.asm.Tile).apply(null,arguments)},g._TopK=function(){return(g._TopK=g.asm.TopK).apply(null,arguments)},g._Transform=function(){return(g._Transform=g.asm.Transform).apply(null,arguments)},g._Transpose=function(){return(g._Transpose=g.asm.Transpose).apply(null,arguments)},g.__FusedMatMul=function(){return(g.__FusedMatMul=g.asm._FusedMatMul).apply(null,arguments)},g._malloc=function(){return(is=g._malloc=g.asm.malloc).apply(null,arguments)}),ms=g._free=function(){return(ms=g._free=g.asm.free).apply(null,arguments)},Va=(g._emscripten_tls_init=function(){return(g._emscripten_tls_init=g.asm.emscripten_tls_init).apply(null,arguments)},g.___errno_location=function(){return(Va=g.___errno_location=g.asm.__errno_location).apply(null,arguments)}),Ba=g._pthread_self=function(){return(Ba=g._pthread_self=g.asm.pthread_self).apply(null,arguments)},wa=g._emscripten_main_thread_process_queued_calls=function(){return(wa=g._emscripten_main_thread_process_queued_calls=g.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},Ga=(g.__emscripten_thread_crashed=function(){return(g.__emscripten_thread_crashed=g.asm._emscripten_thread_crashed).apply(null,arguments)},g.__emscripten_thread_init=function(){return(Ga=g.__emscripten_thread_init=g.asm._emscripten_thread_init).apply(null,arguments)}),Xr=(g._emscripten_current_thread_process_queued_calls=function(){return(g._emscripten_current_thread_process_queued_calls=g.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},g._emscripten_main_browser_thread_id=function(){return(g._emscripten_main_browser_thread_id=g.asm.emscripten_main_browser_thread_id).apply(null,arguments)},g._emscripten_sync_run_in_main_thread_2=function(){return(g._emscripten_sync_run_in_main_thread_2=g.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},g._emscripten_sync_run_in_main_thread_4=function(){return(Xr=g._emscripten_sync_run_in_main_thread_4=g.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)}),ka=g._emscripten_run_in_main_runtime_thread_js=function(){return(ka=g._emscripten_run_in_main_runtime_thread_js=g.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},_a=g._emscripten_dispatch_to_thread_=function(){return(_a=g._emscripten_dispatch_to_thread_=g.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},os=g.__emscripten_thread_free_data=function(){return(os=g.__emscripten_thread_free_data=g.asm._emscripten_thread_free_data).apply(null,arguments)},Za=(g.__emscripten_thread_exit=function(){return(g.__emscripten_thread_exit=g.asm._emscripten_thread_exit).apply(null,arguments)},g._memalign=function(){return(g._memalign=g.asm.memalign).apply(null,arguments)},g._emscripten_stack_set_limits=function(){return(Za=g._emscripten_stack_set_limits=g.asm.emscripten_stack_set_limits).apply(null,arguments)}),La=g.stackSave=function(){return(La=g.stackSave=g.asm.stackSave).apply(null,arguments)},wr=g.stackRestore=function(){return(wr=g.stackRestore=g.asm.stackRestore).apply(null,arguments)},sa=g.stackAlloc=function(){return(sa=g.stackAlloc=g.asm.stackAlloc).apply(null,arguments)},Ia=(g.dynCall_iijjiiii=function(){return(g.dynCall_iijjiiii=g.asm.dynCall_iijjiiii).apply(null,arguments)},g.dynCall_jiji=function(){return(g.dynCall_jiji=g.asm.dynCall_jiji).apply(null,arguments)},g.__emscripten_allow_main_runtime_queued_calls=21672);function ba(Fe){this.name="ExitStatus",this.message="Program terminated with exit("+Fe+")",this.status=Fe}function ca(Fe){if(!(ir>0)){if(et)return O(g),Ur(),void postMessage({cmd:"loaded"});(function(){if(g.preRun)for(typeof g.preRun=="function"&&(g.preRun=[g.preRun]);g.preRun.length;)Et=g.preRun.shift(),le.unshift(Et);var Et;lr(le)})(),ir>0||(g.setStatus?(g.setStatus("Running..."),setTimeout(function(){setTimeout(function(){g.setStatus("")},1),dt()},1)):dt())}function dt(){Zr||(Zr=!0,g.calledRun=!0,Kn||(Ur(),O(g),g.onRuntimeInitialized&&g.onRuntimeInitialized(),function(){if(!et){if(g.postRun)for(typeof g.postRun=="function"&&(g.postRun=[g.postRun]);g.postRun.length;)Et=g.postRun.shift(),Mn.unshift(Et);var Et;lr(Mn)}}()))}}if(g.cwrap=function(Fe,dt,Et,Vt){var an=(Et=Et||[]).every(function(Zt){return Zt==="number"});return dt!=="string"&&an&&!Vt?zn(Fe):function(){return sr(Fe,dt,Et,arguments)}},g.keepRuntimeAlive=zr,g.PThread=At,g.PThread=At,g.wasmMemory=Qt,g.ExitStatus=ba,Zn=function Fe(){Zr||ca(),Zr||(Zn=Fe)},g.run=ca,g.preInit)for(typeof g.preInit=="function"&&(g.preInit=[g.preInit]);g.preInit.length>0;)g.preInit.pop()();if(ca(),L&&(Vr={uncaughtException:m.listeners("uncaughtException").filter(function(Fe){return!L.uncaughtException.indexOf(Fe)>-1}),unhandledRejection:m.listeners("unhandledRejection").filter(function(Fe){return!L.unhandledRejection.indexOf(Fe)>-1})}),typeof WasmBackendModule!="undefined")Ca=WasmBackendModule;else{if(typeof y=="undefined")throw new Error("Could not find wasm module in post.js");Ca=y}if(Vr){var Ja=Ca._dispose;Ca._dispose=function(){Ja(),Vr.uncaughtException.forEach(function(Fe){m.removeListener("uncaughtException",Fe)}),Vr.unhandledRejection.forEach(function(Fe){m.removeListener("unhandledRejection",Fe)})}}return y.ready});I.exports=D}).call(this,"/index.js",e(41),"/",e(40))},function(I,n,e){(function(t,m,h){var b,A=(b=(b=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0)||t,function(D){var y,E,S,l=typeof(D=D||{})!="undefined"?D:{};l.ready=new Promise(function(en,mn){y=en,E=mn}),typeof m!="undefined"&&m.listeners&&(S={uncaughtException:m.listeners("uncaughtException"),unhandledRejection:m.listeners("unhandledRejection")});var B,O,V,L,g,W,de=Object.assign({},l),ke=typeof window=="object",Ie=typeof importScripts=="function",he=typeof m=="object"&&typeof m.versions=="object"&&typeof m.versions.node=="string",Q="";he?(Q=Ie?e(54).dirname(Q)+"/":h+"/",W=()=>{g||(L=e(96),g=e(54))},B=function(en,mn){return W(),en=g.normalize(en),L.readFileSync(en,mn?void 0:"utf8")},V=en=>{var mn=B(en,!0);return mn.buffer||(mn=new Uint8Array(mn)),mn},O=(en,mn,Ln)=>{W(),en=g.normalize(en),L.readFile(en,function(or,lr){or?Ln(or):mn(lr.buffer)})},m.argv.length>1&&m.argv[1].replace(/\\/g,"/"),m.argv.slice(2),m.on("uncaughtException",function(en){if(!(en instanceof ir))throw en}),m.on("unhandledRejection",function(en){throw en}),l.inspect=function(){return"[Emscripten Module object]"}):(ke||Ie)&&(Ie?Q=self.location.href:typeof document!="undefined"&&document.currentScript&&(Q=document.currentScript.src),b&&(Q=b),Q=Q.indexOf("blob:")!==0?Q.substr(0,Q.replace(/[?#].*/,"").lastIndexOf("/")+1):"",B=en=>{var mn=new XMLHttpRequest;return mn.open("GET",en,!1),mn.send(null),mn.responseText},Ie&&(V=en=>{var mn=new XMLHttpRequest;return mn.open("GET",en,!1),mn.responseType="arraybuffer",mn.send(null),new Uint8Array(mn.response)}),O=(en,mn,Ln)=>{var or=new XMLHttpRequest;or.open("GET",en,!0),or.responseType="arraybuffer",or.onload=()=>{or.status==200||or.status==0&&or.response?mn(or.response):Ln()},or.onerror=Ln,or.send(null)});var Se,Z=l.print||console.log.bind(console),G=l.printErr||console.warn.bind(console);Object.assign(l,de),de=null,l.arguments&&l.arguments,l.thisProgram&&l.thisProgram,l.quit&&l.quit,l.wasmBinary&&(Se=l.wasmBinary);var He;l.noExitRuntime,typeof WebAssembly!="object"&&we("no native wasm support detected");var me=!1;function et(en){return l["_"+en]}function rt(en,mn,Ln,or,lr){var Qn={string:function(ht){var Bt=0;if(ht!=null&&ht!==0){var Kt=1+(ht.length<<2);(function(Ut,tn,bn){(function(xn,rn,Xn,xr){if(!(xr>0))return 0;for(var Lr=Xn+xr-1,Wr=0;Wr<xn.length;++Wr){var vr=xn.charCodeAt(Wr);if(vr>=55296&&vr<=57343&&(vr=65536+((1023&vr)<<10)|1023&xn.charCodeAt(++Wr)),vr<=127){if(Xn>=Lr)break;rn[Xn++]=vr}else if(vr<=2047){if(Xn+1>=Lr)break;rn[Xn++]=192|vr>>6,rn[Xn++]=128|63&vr}else if(vr<=65535){if(Xn+2>=Lr)break;rn[Xn++]=224|vr>>12,rn[Xn++]=128|vr>>6&63,rn[Xn++]=128|63&vr}else{if(Xn+3>=Lr)break;rn[Xn++]=240|vr>>18,rn[Xn++]=128|vr>>12&63,rn[Xn++]=128|vr>>6&63,rn[Xn++]=128|63&vr}}rn[Xn]=0})(Ut,$t,tn,bn)})(ht,Bt=_r(Kt),Kt)}return Bt},array:function(ht){var Bt=_r(ht.length);return function(Kt,Ut){X.set(Kt,Ut)}(ht,Bt),Bt}},br=et(en),gr=[],At=0;if(or)for(var q=0;q<or.length;q++){var ae=Qn[Ln[q]];ae?(At===0&&(At=zr()),gr[q]=ae(or[q])):gr[q]=or[q]}var Qe=br.apply(null,gr);return Qe=function(ht){return At!==0&&Ur(At),function(Bt){return mn==="string"?lt(Bt):mn==="boolean"?Boolean(Bt):Bt}(ht)}(Qe)}var It,X,$t,Ct,Gt=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Wt(en,mn,Ln){for(var or=mn+Ln,lr=mn;en[lr]&&!(lr>=or);)++lr;if(lr-mn>16&&en.subarray&&Gt)return Gt.decode(en.subarray(mn,lr));for(var Qn="";mn<lr;){var br=en[mn++];if(128&br){var gr=63&en[mn++];if((224&br)!=192){var At=63&en[mn++];if((br=(240&br)==224?(15&br)<<12|gr<<6|At:(7&br)<<18|gr<<12|At<<6|63&en[mn++])<65536)Qn+=String.fromCharCode(br);else{var q=br-65536;Qn+=String.fromCharCode(55296|q>>10,56320|1023&q)}}else Qn+=String.fromCharCode((31&br)<<6|gr)}else Qn+=String.fromCharCode(br)}return Qn}function lt(en,mn){return en?Wt($t,en,mn):""}function Qt(en){It=en,l.HEAP8=X=new Int8Array(en),l.HEAP16=new Int16Array(en),l.HEAP32=Ct=new Int32Array(en),l.HEAPU8=$t=new Uint8Array(en),l.HEAPU16=new Uint16Array(en),l.HEAPU32=new Uint32Array(en),l.HEAPF32=new Float32Array(en),l.HEAPF64=new Float64Array(en)}typeof TextDecoder!="undefined"&&new TextDecoder("utf-16le"),l.INITIAL_MEMORY;var Ft,yn=[],Nn=[],Kn=[],zn,sr,K=0,J=null;function we(en){l.onAbort&&l.onAbort(en),G(en="Aborted("+en+")"),me=!0,en+=". Build with -s ASSERTIONS=1 for more info.";var mn=new WebAssembly.RuntimeError(en);throw E(mn),mn}function vt(en){return en.startsWith("data:application/octet-stream;base64,")}function wt(en){return en.startsWith("file://")}function Ot(en){try{if(en==zn&&Se)return new Uint8Array(Se);if(V)return V(en);throw"both async and sync fetching of the wasm failed"}catch(mn){we(mn)}}function Ae(en){for(;en.length>0;){var mn=en.shift();if(typeof mn!="function"){var Ln=mn.func;typeof Ln=="number"?mn.arg===void 0?Mt(Ln)():Mt(Ln)(mn.arg):Ln(mn.arg===void 0?null:mn.arg)}else mn(l)}}l.preloadedImages={},l.preloadedAudios={},vt(zn="tfjs-backend-wasm.wasm")||(sr=zn,zn=l.locateFile?l.locateFile(sr,Q):Q+sr);var mt=[];function Mt(en){var mn=mt[en];return mn||(en>=mt.length&&(mt.length=en+1),mt[en]=mn=Ft.get(en)),mn}function Nt(){return 2147483648}function un(en){try{return He.grow(en-It.byteLength+65535>>>16),Qt(He.buffer),1}catch{}}var Rn,oe,le,qe={mappings:{},buffers:[null,[],[]],printChar:function(en,mn){var Ln=qe.buffers[en];mn===0||mn===10?((en===1?Z:G)(Wt(Ln,0)),Ln.length=0):Ln.push(mn)},varargs:void 0,get:function(){return qe.varargs+=4,Ct[qe.varargs-4>>2]},getStr:function(en){return lt(en)},get64:function(en,mn){return en}},Mn={abort:function(){we("")},emscripten_get_heap_max:Nt,emscripten_memcpy_big:function(en,mn,Ln){$t.copyWithin(en,mn,mn+Ln)},emscripten_resize_heap:function(en){var mn,Ln,or=$t.length,lr=2147483648;if((en>>>=0)>lr)return!1;for(var Qn=1;Qn<=4;Qn*=2){var br=or*(1+.2/Qn);if(br=Math.min(br,en+100663296),un(Math.min(lr,((mn=Math.max(en,br))%(Ln=65536)>0&&(mn+=Ln-mn%Ln),mn))))return!0}return!1},fd_close:function(en){return 0},fd_seek:function(en,mn,Ln,or,lr){},fd_write:function(en,mn,Ln,or){for(var lr=0,Qn=0;Qn<Ln;Qn++){var br=Ct[mn>>2],gr=Ct[mn+4>>2];mn+=8;for(var At=0;At<gr;At++)qe.printChar(en,$t[br+At]);lr+=gr}return Ct[or>>2]=lr,0},setTempRet0:function(en){}},zr=(function(){var en={env:Mn,wasi_snapshot_preview1:Mn};function mn(lr,Qn){var br,gr=lr.exports;l.asm=gr,Qt((He=l.asm.memory).buffer),Ft=l.asm.__indirect_function_table,br=l.asm.__wasm_call_ctors,Nn.unshift(br),function(At){if(K--,l.monitorRunDependencies&&l.monitorRunDependencies(K),K==0&&J){var q=J;J=null,q()}}()}function Ln(lr){mn(lr.instance)}function or(lr){return function(){if(!Se&&(ke||Ie)){if(typeof fetch=="function"&&!wt(zn))return fetch(zn,{credentials:"same-origin"}).then(function(Qn){if(!Qn.ok)throw"failed to load wasm binary file at '"+zn+"'";return Qn.arrayBuffer()}).catch(function(){return Ot(zn)});if(O)return new Promise(function(Qn,br){O(zn,function(gr){Qn(new Uint8Array(gr))},br)})}return Promise.resolve().then(function(){return Ot(zn)})}().then(function(Qn){return WebAssembly.instantiate(Qn,en)}).then(function(Qn){return Qn}).then(lr,function(Qn){G("failed to asynchronously prepare wasm: "+Qn),we(Qn)})}if(K++,l.monitorRunDependencies&&l.monitorRunDependencies(K),l.instantiateWasm)try{return l.instantiateWasm(en,mn)}catch(lr){return G("Module.instantiateWasm callback failed with error: "+lr),!1}(Se||typeof WebAssembly.instantiateStreaming!="function"||vt(zn)||wt(zn)||typeof fetch!="function"?or(Ln):fetch(zn,{credentials:"same-origin"}).then(function(lr){return WebAssembly.instantiateStreaming(lr,en).then(Ln,function(Qn){return G("wasm streaming compile failed: "+Qn),G("falling back to ArrayBuffer instantiation"),or(Ln)})})).catch(E)}(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},l._init=function(){return(l._init=l.asm.init).apply(null,arguments)},l._init_with_threads_count=function(){return(l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},l._get_threads_count=function(){return(l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},l._register_tensor=function(){return(l._register_tensor=l.asm.register_tensor).apply(null,arguments)},l._dispose_data=function(){return(l._dispose_data=l.asm.dispose_data).apply(null,arguments)},l._dispose=function(){return(l._dispose=l.asm.dispose).apply(null,arguments)},l._Abs=function(){return(l._Abs=l.asm.Abs).apply(null,arguments)},l._Add=function(){return(l._Add=l.asm.Add).apply(null,arguments)},l._AddN=function(){return(l._AddN=l.asm.AddN).apply(null,arguments)},l._All=function(){return(l._All=l.asm.All).apply(null,arguments)},l._Any=function(){return(l._Any=l.asm.Any).apply(null,arguments)},l._ArgMax=function(){return(l._ArgMax=l.asm.ArgMax).apply(null,arguments)},l._AvgPool=function(){return(l._AvgPool=l.asm.AvgPool).apply(null,arguments)},l._BatchMatMul=function(){return(l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},l._Ceil=function(){return(l._Ceil=l.asm.Ceil).apply(null,arguments)},l._ClipByValue=function(){return(l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},l._Conv2D=function(){return(l._Conv2D=l.asm.Conv2D).apply(null,arguments)},l._Conv2DBackpropInput=function(){return(l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},l._Cos=function(){return(l._Cos=l.asm.Cos).apply(null,arguments)},l._Cosh=function(){return(l._Cosh=l.asm.Cosh).apply(null,arguments)},l._CropAndResize=function(){return(l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},l._Cumprod=function(){return(l._Cumprod=l.asm.Cumprod).apply(null,arguments)},l._Cumsum=function(){return(l._Cumsum=l.asm.Cumsum).apply(null,arguments)},l._DepthToSpace=function(){return(l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},l._DepthwiseConv2dNative=function(){return(l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},l._Elu=function(){return(l._Elu=l.asm.Elu).apply(null,arguments)},l._Equal=function(){return(l._Equal=l.asm.Equal).apply(null,arguments)},l._Exp=function(){return(l._Exp=l.asm.Exp).apply(null,arguments)},l._FlipLeftRight=function(){return(l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},l._Floor=function(){return(l._Floor=l.asm.Floor).apply(null,arguments)},l._FloorDiv=function(){return(l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},l._FusedBatchNorm=function(){return(l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},l._FusedConv2D=function(){return(l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},l._FusedDepthwiseConv2D=function(){return(l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},l._Gather=function(){return(l._Gather=l.asm.Gather).apply(null,arguments)},l._GatherNd=function(){return(l._GatherNd=l.asm.GatherNd).apply(null,arguments)},l._Greater=function(){return(l._Greater=l.asm.Greater).apply(null,arguments)},l._GreaterEqual=function(){return(l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},l._LeakyRelu=function(){return(l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},l._Less=function(){return(l._Less=l.asm.Less).apply(null,arguments)},l._LessEqual=function(){return(l._LessEqual=l.asm.LessEqual).apply(null,arguments)},l._Log=function(){return(l._Log=l.asm.Log).apply(null,arguments)},l._LogicalAnd=function(){return(l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},l._LogicalNot=function(){return(l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},l._LogicalOr=function(){return(l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},l._LogicalXor=function(){return(l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},l._Max=function(){return(l._Max=l.asm.Max).apply(null,arguments)},l._MaxPool=function(){return(l._MaxPool=l.asm.MaxPool).apply(null,arguments)},l._Maximum=function(){return(l._Maximum=l.asm.Maximum).apply(null,arguments)},l._Mean=function(){return(l._Mean=l.asm.Mean).apply(null,arguments)},l._Min=function(){return(l._Min=l.asm.Min).apply(null,arguments)},l._Minimum=function(){return(l._Minimum=l.asm.Minimum).apply(null,arguments)},l._MirrorPad=function(){return(l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},l._Multiply=function(){return(l._Multiply=l.asm.Multiply).apply(null,arguments)},l._Neg=function(){return(l._Neg=l.asm.Neg).apply(null,arguments)},l._NonMaxSuppressionV3=function(){return(l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},l._NonMaxSuppressionV4=function(){return(l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},l._NonMaxSuppressionV5=function(){return(l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},l._NotEqual=function(){return(l._NotEqual=l.asm.NotEqual).apply(null,arguments)},l._OneHot=function(){return(l._OneHot=l.asm.OneHot).apply(null,arguments)},l._PadV2=function(){return(l._PadV2=l.asm.PadV2).apply(null,arguments)},l._Pow=function(){return(l._Pow=l.asm.Pow).apply(null,arguments)},l._Prelu=function(){return(l._Prelu=l.asm.Prelu).apply(null,arguments)},l._Prod=function(){return(l._Prod=l.asm.Prod).apply(null,arguments)},l._RealDiv=function(){return(l._RealDiv=l.asm.RealDiv).apply(null,arguments)},l._Relu=function(){return(l._Relu=l.asm.Relu).apply(null,arguments)},l._Relu6=function(){return(l._Relu6=l.asm.Relu6).apply(null,arguments)},l._ResizeBilinear=function(){return(l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},l._ResizeNearestNeighbor=function(){return(l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},l._Reverse=function(){return(l._Reverse=l.asm.Reverse).apply(null,arguments)},l._RotateWithOffset=function(){return(l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},l._Round=function(){return(l._Round=l.asm.Round).apply(null,arguments)},l._Rsqrt=function(){return(l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},l._ScatterNd=function(){return(l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},l._SelectV2=function(){return(l._SelectV2=l.asm.SelectV2).apply(null,arguments)},l._Sigmoid=function(){return(l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},l._Sin=function(){return(l._Sin=l.asm.Sin).apply(null,arguments)},l._Softmax=function(){return(l._Softmax=l.asm.Softmax).apply(null,arguments)},l._SparseFillEmptyRows=function(){return(l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},l._SparseReshape=function(){return(l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},l._SparseSegmentReduction=function(){return(l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},l._Sqrt=function(){return(l._Sqrt=l.asm.Sqrt).apply(null,arguments)},l._Square=function(){return(l._Square=l.asm.Square).apply(null,arguments)},l._SquaredDifference=function(){return(l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},l._Step=function(){return(l._Step=l.asm.Step).apply(null,arguments)},l._StridedSlice=function(){return(l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},l._Sub=function(){return(l._Sub=l.asm.Sub).apply(null,arguments)},l._Sum=function(){return(l._Sum=l.asm.Sum).apply(null,arguments)},l._Tan=function(){return(l._Tan=l.asm.Tan).apply(null,arguments)},l._Tanh=function(){return(l._Tanh=l.asm.Tanh).apply(null,arguments)},l._Tile=function(){return(l._Tile=l.asm.Tile).apply(null,arguments)},l._TopK=function(){return(l._TopK=l.asm.TopK).apply(null,arguments)},l._Transform=function(){return(l._Transform=l.asm.Transform).apply(null,arguments)},l._Transpose=function(){return(l._Transpose=l.asm.Transpose).apply(null,arguments)},l.__FusedMatMul=function(){return(l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},l._malloc=function(){return(l._malloc=l.asm.malloc).apply(null,arguments)},l._free=function(){return(l._free=l.asm.free).apply(null,arguments)},l.___errno_location=function(){return(l.___errno_location=l.asm.__errno_location).apply(null,arguments)},l._emscripten_main_thread_process_queued_calls=function(){return(l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},l.stackSave=function(){return(zr=l.stackSave=l.asm.stackSave).apply(null,arguments)}),Ur=l.stackRestore=function(){return(Ur=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},_r=l.stackAlloc=function(){return(_r=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)};function ir(en){this.name="ExitStatus",this.message="Program terminated with exit("+en+")",this.status=en}function Zn(en){function mn(){Rn||(Rn=!0,l.calledRun=!0,me||(Ae(Nn),y(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),function(){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)Ln=l.postRun.shift(),Kn.unshift(Ln);var Ln;Ae(Kn)}()))}K>0||(function(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)Ln=l.preRun.shift(),yn.unshift(Ln);var Ln;Ae(yn)}(),K>0||(l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),mn()},1)):mn()))}if(l.dynCall_iijjiiii=function(){return(l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},l.dynCall_jiji=function(){return(l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},l.cwrap=function(en,mn,Ln,or){var lr=(Ln=Ln||[]).every(function(Qn){return Qn==="number"});return mn!=="string"&&lr&&!or?et(en):function(){return rt(en,mn,Ln,arguments)}},J=function en(){Rn||Zn(),Rn||(J=en)},l.run=Zn,l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();if(Zn(),S&&(oe={uncaughtException:m.listeners("uncaughtException").filter(function(en){return!S.uncaughtException.indexOf(en)>-1}),unhandledRejection:m.listeners("unhandledRejection").filter(function(en){return!S.unhandledRejection.indexOf(en)>-1})}),typeof D!="undefined")le=D;else{if(typeof WasmBackendModuleThreadedSimd=="undefined")throw new Error("Could not find wasm module in post.js");le=WasmBackendModuleThreadedSimd}if(oe){var $r=le._dispose;le._dispose=function(){$r(),oe.uncaughtException.forEach(function(en){m.removeListener("uncaughtException",en)}),oe.unhandledRejection.forEach(function(en){m.removeListener("unhandledRejection",en)})}}return D.ready});I.exports=A}).call(this,"/index.js",e(41),"/")},function(I,n,e){(function(t){e.d(n,"a",function(){return h});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m=typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof t!="undefined"?t:b=>b();function h(){return new Promise(b=>m(()=>b()))}}).call(this,e(120).setImmediate)},function(I,n){},function(I,n,e){var t=e(0);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m={},h={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function b(k,a){if(!(k in m)||a!=null){const d=function(c,f){if(c!==1&&c!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const w=f==null?function(C){if(typeof OffscreenCanvas!="undefined"&&C===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(c):f;return w.addEventListener("webglcontextlost",C=>{C.preventDefault(),delete m[c]},!1),Object(t.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(h.failIfMajorPerformanceCaveat=!1),c===1?w.getContext("webgl",h)||w.getContext("experimental-webgl",h):w.getContext("webgl2",h)}(k,a);if(d===null)return console.log("Could not get context for WebGL version",k),null;m[k]=d}const o=m[k];return o==null||o.isContextLost()?(delete m[k],b(k)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),m[k])}var A,D,y;function E(k,a){return[a,k]}function S(k){const a=t.util.sizeFromShape(k),o=Math.ceil(a/4);return t.util.sizeToSquarishShape(o)}function l(k,a){return[Math.max(1,Math.ceil(a/2)),Math.max(1,Math.ceil(k/2))]}function B(k,a){const o=k;let d,c,f,w,C,T,P,z,te,Y;return Object(t.env)().getNumber("WEBGL_VERSION")===2?(d=o.R32F,c=o.R16F,f=o.RGBA16F,w=o.RGBA32F,C=o.RED,P=4,z=1,te=o.HALF_FLOAT,Y=o.FLOAT,T=o.RGBA8):(d=k.RGBA,c=k.RGBA,f=k.RGBA,w=o.RGBA,C=k.RGBA,P=4,z=4,te=a!=null?a.HALF_FLOAT_OES:null,Y=k.FLOAT,T=k.RGBA),{internalFormatFloat:d,internalFormatHalfFloat:c,internalFormatPackedHalfFloat:f,internalFormatPackedFloat:w,textureFormatFloat:C,downloadTextureFormat:T,downloadUnpackNumChannels:P,defaultNumChannels:z,textureTypeHalfFloat:te,textureTypeFloat:Y}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O(k,a){const o=a();return Object(t.env)().getBool("DEBUG")&&function(d){const c=d.getError();if(c!==d.NO_ERROR)throw new Error("WebGL Error: "+function(f,w){switch(w){case f.NO_ERROR:return"NO_ERROR";case f.INVALID_ENUM:return"INVALID_ENUM";case f.INVALID_VALUE:return"INVALID_VALUE";case f.INVALID_OPERATION:return"INVALID_OPERATION";case f.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case f.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case f.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${w}`}}(d,c))}(k),o}(function(k){k[k.DENSE=0]="DENSE",k[k.SHARED_BATCH=1]="SHARED_BATCH"})(A||(A={})),function(k){k[k.RENDER=0]="RENDER",k[k.UPLOAD=1]="UPLOAD",k[k.PIXELS=2]="PIXELS",k[k.DOWNLOAD=3]="DOWNLOAD"}(D||(D={})),function(k){k[k.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",k[k.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",k[k.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",k[k.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",k[k.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(y||(y={}));function V(k){return!!(Object(t.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||k===0||596e-10<Math.abs(k)&&Math.abs(k)<65504)}function L(k,a){return Z(k,()=>k.getExtension(a),'Extension "'+a+'" not supported on this browser.')}const g=/ERROR: [0-9]+:([0-9]+):/g;function W(k,a){const o=g.exec(a);if(o==null)return console.log(`Couldn't parse line number in error: ${a}`),void console.log(k);const d=+o[1],c=k.split(`
`),f=c.length.toString().length+2,w=c.map((te,Y)=>t.util.rightPad((Y+1).toString(),f)+te);let C=0;for(let te=0;te<w.length;te++)C=Math.max(w[te].length,C);const T=w.slice(0,d-1),P=w.slice(d-1,d),z=w.slice(d);console.log(T.join(`
`)),console.log(a.split(`
`)[0]),console.log(`%c ${t.util.rightPad(P[0],C)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(z.join(`
`))}function de(k,a){if(O(k,()=>k.validateProgram(a)),k.getProgramParameter(a,k.VALIDATE_STATUS)===!1)throw console.log(k.getProgramInfoLog(a)),new Error("Shader program validation failed.")}function ke(k,a,o,d,c,f,w){const C=k.getAttribLocation(a,o);return C!==-1&&(O(k,()=>k.bindBuffer(k.ARRAY_BUFFER,d)),O(k,()=>k.vertexAttribPointer(C,c,k.FLOAT,!1,f,w)),O(k,()=>k.enableVertexAttribArray(C)),!0)}function Ie(k,a,o,d){O(k,()=>function(c,f,w){G(c,w),O(c,()=>c.activeTexture(c.TEXTURE0+w)),O(c,()=>c.bindTexture(c.TEXTURE_2D,f))}(k,a,d)),O(k,()=>k.uniform1i(o,d))}function he(k,a,o){O(k,()=>k.bindFramebuffer(k.FRAMEBUFFER,o)),O(k,()=>k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,k.TEXTURE_2D,a,0))}function Q(k,a){O(k,()=>k.bindFramebuffer(k.FRAMEBUFFER,a)),O(k,()=>k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,k.TEXTURE_2D,null,0))}function Se(k){const a=k.checkFramebufferStatus(k.FRAMEBUFFER);if(a!==k.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(o,d){switch(d){case o.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case o.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case o.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case o.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${d}`}}(k,a))}function Z(k,a,o){const d=O(k,()=>a());if(d==null)throw new Error(o);return d}function G(k,a){const o=k.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,d=a+k.TEXTURE0;if(d<k.TEXTURE0||d>o)throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${o}]`}.`)}function He(k,a=2){return t.util.sizeFromShape(k.slice(0,k.length-a))}function me(k){if(k.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[k.length>1?k[k.length-2]:1,k[k.length-1]]}function et(k){let a=[1,1,1];return k.length===0||k.length===1&&k[0]===1||(a=[He(k),...me(k)]),a}function rt(k){return k%2==0}function It(k,a){if(k=k.slice(-2),a=a.slice(-2),t.util.arraysEqual(k,a)||!k.length||!a.length||k[0]===0||k[1]===0||a[0]===0||a[1]===0)return!0;if(k.length!==a.length){const o=k.slice(-1)[0],d=a.slice(-1)[0];if(o===d||rt(o)&&rt(d)&&(k[0]===1||a[0]===1))return!0}return k[1]===a[1]&&rt(k[0])&&rt(a[0])}let X,$t;function Ct(k,a){return k.getExtension(a)!=null}function Gt(k){try{if(b(k)!=null)return!0}catch(a){return console.log("Error when getting WebGL context: ",a),!1}return!1}function Wt(k){if(k===0)return!1;const a=b(k);if(k!==1){if(Ct(a,"EXT_color_buffer_float"))return lt(a);const o="EXT_color_buffer_half_float";if(Ct(a,o)){const d=a.getExtension(o);return function(c,f){const w=B(c,f),C=c.createTexture();c.bindTexture(c.TEXTURE_2D,C);const T=1,P=1;c.texImage2D(c.TEXTURE_2D,0,w.internalFormatHalfFloat,T,P,0,w.textureFormatFloat,w.textureTypeHalfFloat,null);const z=c.createFramebuffer();c.bindFramebuffer(c.FRAMEBUFFER,z),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,C,0);const te=c.checkFramebufferStatus(c.FRAMEBUFFER)===c.FRAMEBUFFER_COMPLETE;return c.bindTexture(c.TEXTURE_2D,null),c.bindFramebuffer(c.FRAMEBUFFER,null),c.deleteTexture(C),c.deleteFramebuffer(z),te}(a,d)}return!1}return!Ct(a,"OES_texture_float")||!Ct(a,"WEBGL_color_buffer_float")?!1:lt(a)}function lt(k){const a=B(k),o=k.createTexture();k.bindTexture(k.TEXTURE_2D,o),k.texImage2D(k.TEXTURE_2D,0,a.internalFormatFloat,1,1,0,a.textureFormatFloat,a.textureTypeFloat,null);const d=k.createFramebuffer();k.bindFramebuffer(k.FRAMEBUFFER,d),k.framebufferTexture2D(k.FRAMEBUFFER,k.COLOR_ATTACHMENT0,k.TEXTURE_2D,o,0);const c=k.checkFramebufferStatus(k.FRAMEBUFFER)===k.FRAMEBUFFER_COMPLETE;return k.bindTexture(k.TEXTURE_2D,null),k.bindFramebuffer(k.FRAMEBUFFER,null),k.deleteTexture(o),k.deleteFramebuffer(d),c}function Qt(k,a){Array.isArray(k)||(k=[k]),k.forEach(o=>{o!=null&&t.util.assert(o.dtype!=="complex64",()=>`${a} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ft=Object(t.env)();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(){let k,a,o,d,c,f,w,C,T,P;return Object(t.env)().getNumber("WEBGL_VERSION")===2?(k="#version 300 es",a="in",o="out",d="in",c="texture",f="outputColor",w="out vec4 outputColor;",C=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,T="",P=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(k="",a="attribute",o="varying",d="varying",c="texture2D",f="gl_FragColor",w="",C=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,T=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,P=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:k,attribute:a,varyingVs:o,varyingFs:d,texture2D:c,output:f,defineOutput:w,defineSpecialNaN:C,defineSpecialInf:T,defineRound:P}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(k,a,o="index"){const d=t.util.computeStrides(a);return d.map((c,f)=>`${`int ${k[f]} = ${o} / ${c}`}; ${f===d.length-1?`int ${k[f+1]} = ${o} - ${k[f]} * ${c}`:`index -= ${k[f]} * ${c}`};`).join("")}function Kn(k,a,o="index"){const d=t.util.computeStrides(a);return d.map((c,f)=>`${`int ${k[f]} = ${o} / outShapeStrides[${f}]`}; ${f===d.length-1?`int ${k[f+1]} = ${o} - ${k[f]} * outShapeStrides[${f}]`:`index -= ${k[f]} * outShapeStrides[${f}]`};`).join("")}function zn(k,a,o="index"){const d=function(c,f){const w=c.length,C=c.map(P=>`${f}[${P}]`),T=new Array(w-1);T[w-2]=C[w-1];for(let P=w-3;P>=0;--P)T[P]=`(${T[P+1]} * ${C[P+1]})`;return T}(k.map((c,f)=>f),a);return d.map((c,f)=>`${`int ${k[f]} = ${o} / ${d[f]}`}; ${f===d.length-1?`int ${k[f+1]} = ${o} - ${k[f]} * ${d[f]}`:`index -= ${k[f]} * ${d[f]}`};`).join("")}function sr(k){const a=t.util.computeStrides(k).map(o=>o.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${a[0]} + coords.y * ${a[1]} + coords.z;
  }
`}Ft.registerFlag("HAS_WEBGL",()=>Ft.getNumber("WEBGL_VERSION")>0),Ft.registerFlag("WEBGL_VERSION",()=>Gt(2)?2:Gt(1)?1:0),Ft.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Ft.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ft.get("WEBGL_VERSION")===2),Ft.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Ft.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Ft.registerFlag("WEBGL_PACK",()=>Ft.getBool("HAS_WEBGL")),Ft.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_CLIP",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_PACK_REDUCE",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_CONV_IM2COL",()=>Ft.getBool("WEBGL_PACK")),Ft.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(k){if(X==null){const a=b(k);X=a.getParameter(a.MAX_TEXTURE_SIZE)}return X}(Ft.getNumber("WEBGL_VERSION"))),Ft.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(k){if($t==null){const a=b(k);$t=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$t)}(Ft.getNumber("WEBGL_VERSION"))),Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const k=Ft.getNumber("WEBGL_VERSION");return k===0?0:function(a){if(a===0)return 0;let o;const d=b(a);return o=Ct(d,"EXT_disjoint_timer_query_webgl2")&&a===2?2:Ct(d,"EXT_disjoint_timer_query")?1:0,o}(k)}),Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ft.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!t.device_util.isMobile()),Ft.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(k){if(k===0)return!1;const a=b(k);if(k===1){if(!Ct(a,"OES_texture_float"))return!1}else if(!Ct(a,"EXT_color_buffer_float"))return!1;return lt(a)}(Ft.getNumber("WEBGL_VERSION"))),Ft.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Ft.getBool("WEBGL_FORCE_F16_TEXTURES")&&Ft.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Ft.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Wt(Ft.getNumber("WEBGL_VERSION"))),Ft.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return(k=Ft.getNumber("WEBGL_VERSION"))===2&&b(k).fenceSync!=null;var k}),Ft.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ft.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Ft.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,k=>{if(k<0&&k!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${k}.`)}),Ft.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>t.device_util.isMobile()?1:-1,k=>{if(k<0&&k!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${k}.`)}),Ft.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Ft.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Ft.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Ft.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Ft.registerFlag("WEBGL_EXP_CONV",()=>!1),Ft.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ft.getBool("IS_TEST"));const K=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:J}=t.backend_util;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(k,a,o){const d=[];if(k.forEach(Y=>{const Ce=t.util.sizeFromShape(Y.shapeInfo.logicalShape);if(Y.shapeInfo.isUniform?d.push(`uniform float ${Y.name}${Ce>1?`[${Ce}]`:""};`):(d.push(`uniform sampler2D ${Y.name};`),d.push(`uniform int offset${Y.name};`)),o.enableShapeUniforms){const{uniformShape:fe}=le(o.packedInputs,Y.shapeInfo.logicalShape,Y.shapeInfo.texShape);switch(fe.length){case 1:d.push(`uniform int ${Y.name}Shape;`);break;case 2:d.push(`uniform ivec2 ${Y.name}Shape;`);break;case 3:d.push(`uniform ivec3 ${Y.name}Shape;`);break;case 4:d.push(`uniform ivec4 ${Y.name}Shape;`)}d.push(`uniform ivec2 ${Y.name}TexShape;`)}}),o.enableShapeUniforms){switch(a.logicalShape.length){case 1:d.push("uniform int outShape;");break;case 2:d.push("uniform ivec2 outShape;"),d.push("uniform int outShapeStrides;");break;case 3:d.push("uniform ivec3 outShape;"),d.push("uniform ivec2 outShapeStrides;");break;case 4:d.push("uniform ivec4 outShape;"),d.push("uniform ivec3 outShapeStrides;")}d.push("uniform ivec2 outTexShape;")}o.customUniforms&&o.customUniforms.forEach(Y=>{d.push(`uniform ${Y.type} ${Y.name}${Y.arrayIndex?`[${Y.arrayIndex}]`:""};`)});const c=d.join(`
`),f=k.map(Y=>function(Ce,fe,Pe=!1,Le){let _e="";_e+=Pe?wt(Ce,Le):vt(Ce,Le);const je=Ce.shapeInfo.logicalShape,qt=fe.logicalShape;return je.length<=qt.length&&(_e+=Pe?function(sn,vn){const En=sn.name,Cn=En.charAt(0).toUpperCase()+En.slice(1),An="get"+Cn+"AtOutCoords",kn=sn.shapeInfo.logicalShape.length,Jn=vn.logicalShape.length,qn=J(sn.shapeInfo.logicalShape,vn.logicalShape),s=oe(Jn),r=Jn-kn;let i;const u=["x","y","z","w","u","v"];i=kn===0?"":Jn<2&&qn.length>=1?"coords = 0;":qn.map(re=>`coords.${u[re+r]} = 0;`).join(`
`);let p="";p=Jn<2&&kn>0?"coords":sn.shapeInfo.logicalShape.map((re,pe)=>`coords.${u[pe+r]}`).join(", ");let _="return outputValue;";const $=t.util.sizeFromShape(sn.shapeInfo.logicalShape)===1,U=t.util.sizeFromShape(vn.logicalShape)===1;if(kn!==1||$||U){if($&&!U)_=Jn===1?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(qn.length){const re=kn-2,pe=kn-1;qn.indexOf(re)>-1&&qn.indexOf(pe)>-1?_="return vec4(outputValue.x);":qn.indexOf(re)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":qn.indexOf(pe)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}}else _=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${An}() {
      ${s} coords = getOutputCoords();
      ${i}
      vec4 outputValue = get${Cn}(${p});
      ${_}
    }
  `}(Ce,fe):function(sn,vn){const En=sn.name,Cn=En.charAt(0).toUpperCase()+En.slice(1),An="get"+Cn+"AtOutCoords",kn=vn.texShape,Jn=sn.shapeInfo.texShape,qn=sn.shapeInfo.logicalShape.length,s=vn.logicalShape.length;if(!sn.shapeInfo.isUniform&&qn===s&&sn.shapeInfo.flatOffset==null&&t.util.arraysEqual(Jn,kn))return`
      float ${An}() {
        return sampleTexture(${En}, resultUV);
      }
    `;const r=oe(s),i=J(sn.shapeInfo.logicalShape,vn.logicalShape),u=s-qn;let p;const _=["x","y","z","w","u","v"];p=qn===0?"":s<2&&i.length>=1?"coords = 0;":i.map(U=>`coords.${_[U+u]} = 0;`).join(`
`);let $="";return $=s<2&&qn>0?"coords":sn.shapeInfo.logicalShape.map((U,re)=>`coords.${_[re+u]}`).join(", "),`
    float ${An}() {
      ${r} coords = getOutputCoords();
      ${p}
      return get${Cn}(${$});
    }
  `}(Ce,fe)),_e}(Y,a,o.packedInputs,o.enableShapeUniforms)).join(`
`),w=a.texShape,C=yn(),T=function(Y){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${Y.texture2D}(textureSampler, uv).r;
    }
  `}(C);let P,z,te=function(Y){return`${Y.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${Y.varyingFs} vec2 resultUV;
    ${Y.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${Y.defineSpecialNaN}
    ${Y.defineSpecialInf}
    ${Y.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ot}
    ${Ae}
    ${mt}
  `}(C);return a.isPacked?(P=function(Y,Ce,fe){switch(Y.length){case 0:return Nt();case 1:return function(Pe,Le,_e){const je=[Math.ceil(Le[0]/2),Math.ceil(Le[1]/2)];return je[0]===1?_e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${je[1]}.0);
      }
    `:je[1]===1?_e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${je[0]}.0);
      }
    `:_e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${je[0]}, ${je[1]}));
      return 2 * (resTexRC.x * ${je[1]} + resTexRC.y);
    }
  `}(0,Ce,fe);case 2:return function(Pe,Le,_e){const je=[Math.ceil(Le[0]/2),Math.ceil(Le[1]/2)];if(t.util.arraysEqual(Pe,Le))return _e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${je[0]}, ${je[1]}));
      }
    `;const qt=Math.ceil(Pe[1]/2);return _e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${je[0]}, ${je[1]}));

      int index = resTexRC.x * ${je[1]} + resTexRC.y;
      int r = 2 * (index / ${qt});
      int c = imod(index, ${qt}) * 2;

      return ivec2(r, c);
    }
  `}(Y,Ce,fe);case 3:return function(Pe,Le,_e){if(_e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const je=[Math.ceil(Le[0]/2),Math.ceil(Le[1]/2)],qt=Math.ceil(Pe[2]/2),sn=qt*Math.ceil(Pe[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${je[0]}, ${je[1]}));
      int index = resTexRC.x * ${je[1]} + resTexRC.y;

      int b = index / ${sn};
      index -= b * ${sn};

      int r = 2 * (index / ${qt});
      int c = imod(index, ${qt}) * 2;

      return ivec3(b, r, c);
    }
  `}(Y,Ce,fe);default:return function(Pe,Le,_e){if(_e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const je=[Math.ceil(Le[0]/2),Math.ceil(Le[1]/2)],qt=Math.ceil(Pe[Pe.length-1]/2),sn=qt*Math.ceil(Pe[Pe.length-2]/2);let vn=sn,En="",Cn="b, r, c";for(let An=2;An<Pe.length-1;An++)vn*=Pe[Pe.length-An-1],En=`
      int b${An} = index / ${vn};
      index -= b${An} * ${vn};
    `+En,Cn=`b${An}, `+Cn;return`
    ivec${Pe.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${je[0]}, ${je[1]}));
      int index = resTexRC.x * ${je[1]} + resTexRC.y;

      ${En}

      int b = index / ${sn};
      index -= b * ${sn};

      int r = 2 * (index / ${qt});
      int c = imod(index, ${qt}) * 2;

      return ivec${Pe.length}(${Cn});
    }
  `}(Y,Ce,fe)}}(a.logicalShape,w,o.enableShapeUniforms),z=function(Y){return`
    void setOutput(vec4 val) {
      ${Y.output} = val;
    }
  `}(C)):(P=function(Y,Ce,fe){switch(Y.length){case 0:return Nt();case 1:return function(Pe,Le,_e){return Le[0]===1?_e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${Le[1]}.0);
      }
    `:Le[1]===1?_e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${Le[0]}.0);
      }
    `:_e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Le[0]}, ${Le[1]}));
      return resTexRC.x * ${Le[1]} + resTexRC.y;
    }
  `}(0,Ce,fe);case 2:return function(Pe,Le,_e){return t.util.arraysEqual(Pe,Le)?_e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${Le[0]}, ${Le[1]}));
      }
    `:Pe[1]===1?_e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${Le[0]}, ${Le[1]}));
        int index = resTexRC.x * ${Le[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:Pe[0]===1?_e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${Le[0]}, ${Le[1]}));
        int index = resTexRC.x * ${Le[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:_e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Le[0]}, ${Le[1]}));
      int index = resTexRC.x * ${Le[1]} + resTexRC.y;
      int r = index / ${Pe[1]};
      int c = index - r * ${Pe[1]};
      return ivec2(r, c);
    }
  `}(Y,Ce,fe);case 3:return function(Pe,Le,_e){if(_e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Kn(["r","c","d"],Pe)}
    return ivec3(r, c, d);
  }
`;const je=Nn(["r","c","d"],Pe);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${Le[0]}, ${Le[1]}));
      int index = resTexRC.x * ${Le[1]} + resTexRC.y;
      ${je}
      return ivec3(r, c, d);
    }
  `}(Y,Ce,fe);case 4:return function(Pe,Le,_e){if(_e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Kn(["r","c","d","d2"],Pe)}
      return ivec4(r, c, d, d2);
    }
  `;const je=Nn(["r","c","d","d2"],Pe);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${Le[0]}, ${Le[1]}));
      int index = resTexRC.x * ${Le[1]} + resTexRC.y;
      ${je}
      return ivec4(r, c, d, d2);
    }
  `}(Y,Ce,fe);case 5:return function(Pe,Le){const _e=Nn(["r","c","d","d2","d3"],Pe);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${Le[0]},
                             ${Le[1]}));

      int index = resTexRC.x * ${Le[1]} + resTexRC.y;

      ${_e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}(Y,Ce);case 6:return function(Pe,Le){const _e=Nn(["r","c","d","d2","d3","d4"],Pe);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${Le[0]}, ${Le[1]}));
      int index = resTexRC.x * ${Le[1]} + resTexRC.y;

      ${_e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}(Y,Ce);default:throw new Error(`${Y.length}-D output sampling is not yet supported`)}}(a.logicalShape,w,o.enableShapeUniforms),z=function(Y){return`
    void setOutput(float val) {
      ${Y.output} = vec4(val, 0, 0, 0);
    }
  `}(C)),o.packedInputs&&(te+=Mt),[te,T,z,c,P,f,o.userCode].join(`
`)}function vt(k,a=!1){const o=k.shapeInfo.logicalShape;switch(o.length){case 0:return function(d,c){const f=d.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1);if(d.shapeInfo.isUniform)return`float ${w}() {return ${f};}`;const[C,T]=d.shapeInfo.texShape;if(C===1&&T===1)return`
      float ${w}() {
        return sampleTexture(${f}, halfCR);
      }
    `;const P=un(f);if(c)return`
    float ${w}() {
      vec2 uv = uvFromFlat(${f}TexShape[0], ${f}TexShape[1], ${P});
      return sampleTexture(${f}, uv);
    }
  `;const[z,te]=d.shapeInfo.texShape;return`
    float ${w}() {
      vec2 uv = uvFromFlat(${z}, ${te}, ${P});
      return sampleTexture(${f}, uv);
    }
  `}(k,a);case 1:return function(d,c){const f=d.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1);if(d.shapeInfo.isUniform)return`
      float ${w}(int index) {
        ${Rn(d)}
      }
    `;const C=d.shapeInfo.texShape,T=C[0],P=C[1];if(P===1&&T===1)return`
      float ${w}(int index) {
        return sampleTexture(${f}, halfCR);
      }
    `;const z=un(f);return P===1?c?`
      float ${w}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${z}) + 0.5) / float(${f}TexShape[0]));
        return sampleTexture(${f}, uv);
      }
    `:`
      float ${w}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${z}) + 0.5) / ${T}.0);
        return sampleTexture(${f}, uv);
      }
    `:T===1?c?`
      float ${w}(int index) {
        vec2 uv = vec2((float(index + ${z}) + 0.5) / float(${f}TexShape[1]), 0.5);
        return sampleTexture(${f}, uv);
      }
    `:`
      float ${w}(int index) {
        vec2 uv = vec2((float(index + ${z}) + 0.5) / ${P}.0, 0.5);
        return sampleTexture(${f}, uv);
      }
    `:c?`
    float ${w}(int index) {
      vec2 uv = uvFromFlat(${f}TexShape[0], ${f}TexShape[1], index + ${z});
      return sampleTexture(${f}, uv);
    }
  `:`
    float ${w}(int index) {
      vec2 uv = uvFromFlat(${T}, ${P}, index + ${z});
      return sampleTexture(${f}, uv);
    }
  `}(k,a);case 2:return function(d,c){const f=d.shapeInfo.logicalShape,w=d.name,C="get"+w.charAt(0).toUpperCase()+w.slice(1),T=d.shapeInfo.texShape;if(T!=null&&t.util.arraysEqual(f,T)){if(c)return`
      float ${C}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${w}TexShape[1], ${w}TexShape[0]);
        return sampleTexture(${w}, uv);
      }
    `;const Pe=T[0];return`
    float ${C}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${T[1]}.0, ${Pe}.0);
      return sampleTexture(${w}, uv);
    }
  `}const{newShape:P,keptDims:z}=t.util.squeezeShape(f),te=P;if(te.length<f.length){const Pe=["row","col"];return`
      ${vt(qe(d,te),c)}
      float ${C}(int row, int col) {
        return ${C}(${Mn(Pe,z)});
      }
    `}if(d.shapeInfo.isUniform)return`
      float ${C}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${f[1]}, 1)));
        ${Rn(d)}
      }
    `;const Y=T[0],Ce=T[1],fe=un(w);return Ce===1?c?`
      float ${C}(int row, int col) {
        float index = dot(vec3(row, col, ${fe}), vec3(${w}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${w}TexShape[0]));
        return sampleTexture(${w}, uv);
      }
    `:`
    float ${C}(int row, int col) {
      float index = dot(vec3(row, col, ${fe}), vec3(${f[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${Y}.0);
      return sampleTexture(${w}, uv);
    }
  `:Y===1?c?`
      float ${C}(int row, int col) {
        float index = dot(vec3(row, col, ${fe}), vec3(${w}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${w}TexShape[1]), 0.5);
        return sampleTexture(${w}, uv);
      }
    `:`
    float ${C}(int row, int col) {
      float index = dot(vec3(row, col, ${fe}), vec3(${f[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${Ce}.0, 0.5);
      return sampleTexture(${w}, uv);
    }
  `:c?`
      float ${C}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${w}Shape[1] + col + ${fe};
        vec2 uv = uvFromFlat(${w}TexShape[0], ${w}TexShape[1], index);
        return sampleTexture(${w}, uv);
      }
    `:`
  float ${C}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${f[1]} + col + ${fe};
    vec2 uv = uvFromFlat(${Y}, ${Ce}, index);
    return sampleTexture(${w}, uv);
  }
`}(k,a);case 3:return function(d,c){const f=d.shapeInfo.logicalShape,w=d.name,C="get"+w.charAt(0).toUpperCase()+w.slice(1),T=f[1]*f[2],P=f[2],{newShape:z,keptDims:te}=t.util.squeezeShape(f),Y=z;if(Y.length<f.length){const je=["row","col","depth"];return`
        ${vt(qe(d,Y),c)}
        float ${C}(int row, int col, int depth) {
          return ${C}(${Mn(je,te)});
        }
      `}if(d.shapeInfo.isUniform)return`
      float ${C}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${T}, ${P}, 1)));
        ${Rn(d)}
      }
    `;const Ce=d.shapeInfo.texShape,fe=Ce[0],Pe=Ce[1],Le=d.shapeInfo.flatOffset;if(Pe===T&&Le==null)return c?`
      float ${C}(int row, int col, int depth) {
        int stride1 = ${w}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${w}TexShape[1], ${w}TexShape[0]);
        return sampleTexture(${w}, uv);
      }
    `:`
        float ${C}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${P}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${Pe}.0, ${fe}.0);
          return sampleTexture(${w}, uv);
        }
      `;if(Pe===P&&Le==null)return c?`
      float ${C}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${w}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${w}TexShape[1], ${w}TexShape[0]);
        return sampleTexture(${w}, uv);
      }
    `:`
    float ${C}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${f[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Pe}.0, ${fe}.0);
      return sampleTexture(${w}, uv);
    }
  `;const _e=un(w);return c?`
    float ${C}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${w}Shape[1] * ${w}Shape[2];
      int stride1 = ${w}Shape[2];
      int index = row * ${T} + col * ${P} + depth + ${_e};
      vec2 uv = uvFromFlat(${w}TexShape[0], ${w}TexShape[1], index);
      return sampleTexture(${w}, uv);
    }
    `:`
      float ${C}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${T} + col * ${P} + depth + ${_e};
        vec2 uv = uvFromFlat(${fe}, ${Pe}, index);
        return sampleTexture(${w}, uv);
      }
  `}(k,a);case 4:return function(d,c){const f=d.shapeInfo.logicalShape,w=d.name,C="get"+w.charAt(0).toUpperCase()+w.slice(1),T=f[3],P=f[2]*T,z=f[1]*P,{newShape:te,keptDims:Y}=t.util.squeezeShape(f);if(te.length<f.length){const vn=["row","col","depth","depth2"];return`
      ${vt(qe(d,te),c)}
      float ${C}(int row, int col, int depth, int depth2) {
        return ${C}(${Mn(vn,Y)});
      }
    `}if(d.shapeInfo.isUniform)return`
      float ${C}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${z}, ${P}, ${T}, 1)));
        ${Rn(d)}
      }
    `;const Ce=d.shapeInfo.flatOffset,fe=d.shapeInfo.texShape,Pe=fe[0],Le=fe[1],_e=`int stride2 = ${w}Shape[3];`,je=`int stride1 = ${w}Shape[2] * stride2;`,qt=`int stride0 = ${w}Shape[1] * stride1;`;if(Le===z&&Ce==null)return c?`
      float ${C}(int row, int col, int depth, int depth2) {
        ${_e}
        ${je}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${w}TexShape[1], ${w}TexShape[0]);
        return sampleTexture(${w}, uv);
      }
    `:`
      float ${C}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${P}, ${T}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Le}.0, ${Pe}.0);
        return sampleTexture(${w}, uv);
      }
    `;if(Le===T&&Ce==null)return c?`
      float ${C}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${w}Shape[1] * ${w}Shape[2], ${w}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${w}TexShape[1], ${w}TexShape[0]);
        return sampleTexture(${w}, uv);
      }
    `:`
      float ${C}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${f[1]*f[2]}, ${f[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Le}.0, ${Pe}.0);
        return sampleTexture(${w}, uv);
      }
    `;const sn=un(w);return c?`
    float ${C}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${_e}
      ${je}
      ${qt}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${w}TexShape[0], ${w}TexShape[1], index + ${sn});
      return sampleTexture(${w}, uv);
    }
  `:`
    float ${C}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${z} + col * ${P} +
          depth * ${T} + depth2;
      vec2 uv = uvFromFlat(${Pe}, ${Le}, index + ${sn});
      return sampleTexture(${w}, uv);
    }
  `}(k,a);case 5:return function(d){const c=d.shapeInfo.logicalShape,f=d.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1),C=c[4],T=c[3]*C,P=c[2]*T,z=c[1]*P,{newShape:te,keptDims:Y}=t.util.squeezeShape(c);if(te.length<c.length){const je=["row","col","depth","depth2","depth3"];return`
      ${vt(qe(d,te))}
      float ${w}(int row, int col, int depth, int depth2, int depth3) {
        return ${w}(${Mn(je,Y)});
      }
    `}if(d.shapeInfo.isUniform)return`
      float ${w}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${z}, ${P}, ${T}, ${C})) +
          depth3;
        ${Rn(d)}
      }
    `;const Ce=d.shapeInfo.flatOffset,fe=d.shapeInfo.texShape,Pe=fe[0],Le=fe[1];if(Le===z&&Ce==null)return`
      float ${w}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${P}, ${T}, ${C}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${Le}.0, ${Pe}.0);
        return sampleTexture(${f}, uv);
      }
    `;if(Le===C&&Ce==null)return`
      float ${w}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${c[1]*c[2]*c[3]},
               ${c[2]*c[3]}, ${c[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${Le}.0, ${Pe}.0);
        return sampleTexture(${f}, uv);
      }
    `;const _e=un(f);return`
    float ${w}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${z} + col * ${P} + depth * ${T} +
          depth2 * ${C} + depth3 + ${_e};
      vec2 uv = uvFromFlat(${Pe}, ${Le}, index);
      return sampleTexture(${f}, uv);
    }
  `}(k);case 6:return function(d){const c=d.shapeInfo.logicalShape,f=d.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1),{newShape:C,keptDims:T}=t.util.squeezeShape(c);if(C.length<c.length){const qt=["row","col","depth","depth2","depth3","depth4"];return`
      ${vt(qe(d,C))}
      float ${w}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${w}(${Mn(qt,T)});
      }
    `}const P=c[5],z=c[4]*P,te=c[3]*z,Y=c[2]*te,Ce=c[1]*Y;if(d.shapeInfo.isUniform)return`
      float ${w}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${Ce}, ${Y}, ${te}, ${z})) +
          dot(
            vec2(depth3, depth4),
            vec2(${P}, 1)));
        ${Rn(d)}
      }
    `;const fe=d.shapeInfo.flatOffset,Pe=d.shapeInfo.texShape,Le=Pe[0],_e=Pe[1];if(_e===Ce&&fe==null)return`
      float ${w}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${Y}, ${te}, ${z}, ${P})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${_e}.0, ${Le}.0);
        return sampleTexture(${f}, uv);
      }
    `;if(_e===P&&fe==null)return`
      float ${w}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${c[1]*c[2]*c[3]*c[4]},
               ${c[2]*c[3]*c[4]},
               ${c[3]*c[4]},
               ${c[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${_e}.0, ${Le}.0);
        return sampleTexture(${f}, uv);
      }
    `;const je=un(f);return`
    float ${w}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${Ce} + col * ${Y} + depth * ${te} +
          depth2 * ${z} + depth3 * ${P} + depth4 + ${je};
      vec2 uv = uvFromFlat(${Le}, ${_e}, index);
      return sampleTexture(${f}, uv);
    }
  `}(k);default:throw new Error(`${o.length}-D input sampling is not yet supported`)}}function wt(k,a){switch(k.shapeInfo.logicalShape.length){case 0:return function(o){const d=o.name,c="get"+d.charAt(0).toUpperCase()+d.slice(1),f=yn();return`
    vec4 ${c}() {
      return ${f.texture2D}(${d}, halfCR);
    }
  `}(k);case 1:return function(o,d){const c=o.name,f="get"+c.charAt(0).toUpperCase()+c.slice(1),w=o.shapeInfo.texShape,C=yn();if(d)return`
    vec4 ${f}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${c}TexShape[0]) / 2.0), ceil(float(${c}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${C.texture2D}(${c}, uv);
    }
  `;const T=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)];return`
    vec4 ${f}(int index) {
      vec2 uv = packedUVfrom1D(
        ${T[0]}, ${T[1]}, index);
      return ${C.texture2D}(${c}, uv);
    }
  `}(k,a);case 2:return function(o,d){const c=o.shapeInfo.logicalShape,f=o.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1),C=o.shapeInfo.texShape,T=C[0],P=C[1],z=yn();if(C!=null&&t.util.arraysEqual(c,C))return d?`
      vec4 ${w}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}TexShape[1], ${f}TexShape[0]);

        return ${z.texture2D}(${f}, uv);
      }
    `:`
      vec4 ${w}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${P}.0, ${T}.0);

        return ${z.texture2D}(${f}, uv);
      }
    `;if(d)return`
    vec4 ${w}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${f}TexShape[0]) / 2.0), ceil(float(${f}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${f}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${z.texture2D}(${f}, uv);
    }
  `;const te=[Math.ceil(C[0]/2),Math.ceil(C[1]/2)],Y=Math.ceil(c[1]/2);return`
    vec4 ${w}(int row, int col) {
      vec2 uv = packedUVfrom2D(${Y}, ${te[0]}, ${te[1]}, row, col);
      return ${z.texture2D}(${f}, uv);
    }
  `}(k,a);case 3:return function(o,d){const c=o.shapeInfo.logicalShape,f=o.name,w="get"+f.charAt(0).toUpperCase()+f.slice(1),C=o.shapeInfo.texShape,T=[Math.ceil(C[0]/2),Math.ceil(C[1]/2)];if(c[0]===1){const fe=[1,2],Pe=["b","row","col"];return`
        ${wt(qe(o,c.slice(1)),d)}
        vec4 ${w}(int b, int row, int col) {
          return ${w}(${Mn(Pe,fe)});
        }
      `}const P=yn();if(d)return`
    vec4 ${w}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${f}TexShape[0]) / 2.0), ceil(float(${f}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${f}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${f}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${P.texture2D}(${f}, uv);
    }
  `;const z=T[0],te=T[1],Y=Math.ceil(c[2]/2),Ce=Y*Math.ceil(c[1]/2);return`
    vec4 ${w}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${z}, ${te}, ${Ce}, ${Y}, b, row, col);
      return ${P.texture2D}(${f}, uv);
    }
  `}(k,a);default:return function(o,d){const c=o.name,f="get"+c.charAt(0).toUpperCase()+c.slice(1),w=yn();if(d)return`
    vec4 ${f}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${c}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${c}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${c}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${c}TexShape[0]) / 2.0), ceil(float(${c}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${w.texture2D}(${c}, uv);
    }
  `;const C=o.shapeInfo.logicalShape,T=C.length,P=o.shapeInfo.texShape,z=[Math.ceil(P[0]/2),Math.ceil(P[1]/2)],te=z[0],Y=z[1],Ce=Math.ceil(C[T-1]/2);let fe=Ce*Math.ceil(C[T-2]/2),Pe="int b, int row, int col",Le=`b * ${fe} + (row / 2) * ${Ce} + (col / 2)`;for(let _e=2;_e<T-1;_e++)Pe=`int b${_e}, `+Pe,fe*=C[T-_e-1],Le=`b${_e} * ${fe} + `+Le;return`
    vec4 ${f}(${Pe}) {
      int index = ${Le};
      int texR = index / ${Y};
      int texC = index - texR * ${Y};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Y}, ${te});
      return ${w.texture2D}(${c}, uv);
    }
  `}(k,a)}}const Ot=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Ae=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,mt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Mt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Nt(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function un(k){return`offset${k}`}function Rn(k){const a=k.name,o=t.util.sizeFromShape(k.shapeInfo.logicalShape);return o<2?`return ${a};`:`
    for (int i = 0; i < ${o}; i++) {
      if (i == index) {
        return ${a}[i];
      }
    }
  `}function oe(k){if(k<=1)return"int";if(k===2)return"ivec2";if(k===3)return"ivec3";if(k===4)return"ivec4";if(k===5)return"ivec5";if(k===6)return"ivec6";throw Error(`GPU for rank ${k} is not yet supported`)}function le(k,a,o){const{newShape:d,keptDims:c}=t.util.squeezeShape(a),f=a.length,w=k&&f===3&&a[0]===1,C=w?a.slice(1):d,T=!k&&f>1&&!t.util.arraysEqual(a,o)&&d.length<f||w;return{useSqueezeShape:T,uniformShape:T?C:a,keptDims:c}}function qe(k,a){const o=JSON.parse(JSON.stringify(k));return o.shapeInfo.logicalShape=a,o}function Mn(k,a){return a.map(o=>k[o]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zr(k,a,o,d){const c=o.map((z,te)=>{const Y={logicalShape:z.shape,texShape:z.isUniform?null:z.texData.texShape,isUniform:z.isUniform,isPacked:!z.isUniform&&z.texData.isPacked,flatOffset:null};return z.texData!=null&&z.texData.slice!=null&&z.texData.slice.flatOffset>0&&(Y.flatOffset=z.texData.slice.flatOffset),{name:a.variableNames[te],shapeInfo:Y}}),f=c.map(z=>z.shapeInfo),w={logicalShape:d.shape,texShape:d.texData.texShape,isUniform:!1,isPacked:d.texData.isPacked,flatOffset:null},C=we(c,w,a),T=function(z,te){const Y=Z(z,()=>z.createShader(z.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(O(z,()=>z.shaderSource(Y,te)),O(z,()=>z.compileShader(Y)),Object(t.env)().get("ENGINE_COMPILE_ONLY"))return Y;if(z.getShaderParameter(Y,z.COMPILE_STATUS)===!1)throw W(te,z.getShaderInfoLog(Y)),new Error("Failed to compile fragment shader.");return Y}(k.gl,C),P=k.createProgram(T);return Object(t.env)().get("ENGINE_COMPILE_ONLY")?{program:a,fragmentShader:T,source:C,webGLProgram:P,inShapeInfos:f,outShapeInfo:w,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:a,fragmentShader:T,source:C,webGLProgram:P,inShapeInfos:f,outShapeInfo:w},Ur(k,a,P))}function Ur(k,a,o){const d={},c={},f={},w=[];let C,T,P,z=null,te=null;te=k.getUniformLocation(o,"NAN",!1),Object(t.env)().getNumber("WEBGL_VERSION")===1&&(z=k.getUniformLocation(o,"INFINITY",!1));const Y=!1;for(let Ce=0;Ce<a.variableNames.length;Ce++){const fe=a.variableNames[Ce];d[fe]=k.getUniformLocation(o,fe,Y),d[`offset${fe}`]=k.getUniformLocation(o,`offset${fe}`,Y),a.enableShapeUniforms&&(c[`${fe}Shape`]=k.getUniformLocation(o,`${fe}Shape`,Y),f[`${fe}TexShape`]=k.getUniformLocation(o,`${fe}TexShape`,Y))}return a.enableShapeUniforms&&(C=k.getUniformLocation(o,"outShape",Y),P=k.getUniformLocation(o,"outShapeStrides",Y),T=k.getUniformLocation(o,"outTexShape",Y)),a.customUniforms&&a.customUniforms.forEach((Ce,fe)=>{w[fe]=k.getUniformLocation(o,Ce.name,Y)}),{uniformLocations:d,customUniformLocations:w,infLoc:z,nanLoc:te,inShapesLocations:c,inTexShapesLocations:f,outShapeLocation:C,outShapeStridesLocation:P,outTexShapeLocation:T}}function _r(k,a){if(k.length!==a.length)throw Error(`Binary was compiled with ${k.length} inputs, but was executed with ${a.length} inputs`);k.forEach((o,d)=>{const c=o.logicalShape,f=a[d],w=f.shape;if(!t.util.arraysEqual(c,w))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${c} and ${w} must match`);if(o.isUniform&&f.isUniform)return;const C=o.texShape,T=f.isUniform?null:f.texData.texShape;if(!t.util.arraysEqual(C,T))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${C} and ${T} must match`)})}function ir(k){return Object(t.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&k<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zn{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=A.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=yn();this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Kn(["r","c","d"],a):Nn(["r","c","d"],a)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $r{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=A.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=yn();this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Kn(["r","c","d"],a):Nn(["r","c","d"],a)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class en{constructor(a){this.variableNames=["A"],this.outTexUsage=D.DOWNLOAD;const o=yn();this.outputShape=a,this.userCode=`
      ${K}

      void main() {
        float x = getAAtOutCoords();
        ${o.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mn{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=D.DOWNLOAD;const o=yn();this.outputShape=a,this.userCode=`
      ${K}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${o.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ln{constructor(a,o=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const d=yn();this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length);let c="result";o&&(c="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:sr(a)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${d.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${d.output} = vec4(${c}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class or{constructor(a,o=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const d=yn();this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length);let c="",f="result";o&&(f="floor(result * 255. + 0.5)");for(let w=0;w<=1;w++)for(let C=0;C<=1;C++){const T=2*w+C;c+=`
          localCoords = coords;
          if(localCoords[2] + ${C} < ${this.enableShapeUniforms?"outShape[2]":`${a[2]}`}) {
          localCoords[2] += ${C};
          if (localCoords[1] + ${w} < ${this.enableShapeUniforms?"outShape[1]":`${a[1]}`}) {
            localCoords[1] += ${w};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${d.texture2D}(A, uv);

            if (offset == 0) {
              result[${T}] = values[0];
            } else if (offset == 1) {
              result[${T}] = values[1];
            } else if (offset == 2) {
              result[${T}] = values[2];
            } else {
              result[${T}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:sr(a)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${c}

          ${d.output} = ${f};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(k){const a=yn();return function(o,d){const c=Z(o,()=>o.createShader(o.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(O(o,()=>o.shaderSource(c,d)),O(o,()=>o.compileShader(c)),o.getShaderParameter(c,o.COMPILE_STATUS)===!1)throw console.log(o.getShaderInfoLog(c)),new Error("Failed to compile vertex shader.");return c}(k,`${a.version}
    precision highp float;
    ${a.attribute} vec3 clipSpacePos;
    ${a.attribute} vec2 uv;
    ${a.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function Qn(k){return function(a,o){const d=Z(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return O(a,()=>a.bindBuffer(a.ARRAY_BUFFER,d)),O(a,()=>a.bufferData(a.ARRAY_BUFFER,o,a.STATIC_DRAW)),d}(k,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function br(k){return function(a,o){const d=Z(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return O(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,d)),O(a,()=>a.bufferData(a.ELEMENT_ARRAY_BUFFER,o,a.STATIC_DRAW)),d}(k,new Uint16Array([0,1,2,2,1,3]))}function gr(k,a,o,d,c,f){(function(T,P){const z=Object(t.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(T<=0||P<=0)throw new Error(`Requested texture size [${T}x${P}] is invalid.`);if(T>z||P>z)throw new Error(`Requested texture size [${T}x${P}] greater than WebGL maximum on this browser / GPU [${z}x${z}].`)})(a,o);const w=function(T){return Z(T,()=>T.createTexture(),"Unable to create WebGLTexture.")}(k),C=k.TEXTURE_2D;return O(k,()=>k.bindTexture(C,w)),O(k,()=>k.texParameteri(C,k.TEXTURE_WRAP_S,k.CLAMP_TO_EDGE)),O(k,()=>k.texParameteri(C,k.TEXTURE_WRAP_T,k.CLAMP_TO_EDGE)),O(k,()=>k.texParameteri(C,k.TEXTURE_MIN_FILTER,k.NEAREST)),O(k,()=>k.texParameteri(C,k.TEXTURE_MAG_FILTER,k.NEAREST)),Object(t.env)().getNumber("WEBGL_VERSION")===1?O(k,()=>k.texImage2D(C,0,d,a,o,0,c,f,null)):O(k,()=>k.texStorage2D(C,1,d,a,o)),O(k,()=>k.bindTexture(k.TEXTURE_2D,null)),{texture:w,texShape:[o,a]}}function At(k){return k.internalFormatFloat}function q(k){return k.internalFormatHalfFloat}function ae(k){return k.downloadTextureFormat}function Qe(k){return k.internalFormatPackedFloat}function ht(k){return k.internalFormatPackedHalfFloat}function Bt(k,a,o,d,c,f,w,C){const T=k,P=new Float32Array(function(z,te){const[Y,Ce]=l(z,te);return Y*Ce*4}(f,w));return T.bindBuffer(T.PIXEL_PACK_BUFFER,a),T.getBufferSubData(T.PIXEL_PACK_BUFFER,0,P),T.bindBuffer(T.PIXEL_PACK_BUFFER,null),P}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kt{constructor(a){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const o=Object(t.env)().getNumber("WEBGL_VERSION");a!=null?(this.gl=a,function(f,w){m[f]=w}(o,a)):this.gl=b(o);let d="WEBGL_color_buffer_float";const c="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Object(t.env)().getNumber("WEBGL_VERSION")===1){const f="OES_texture_float",w="OES_texture_half_float";if(this.textureFloatExtension=L(this.gl,f),Ct(this.gl,w))this.textureHalfFloatExtension=L(this.gl,w);else if(Object(t.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(d),Ct(this.gl,c))this.colorBufferHalfFloatExtension=L(this.gl,c);else if(Object(t.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(d="EXT_color_buffer_float",Ct(this.gl,d))this.colorBufferFloatExtension=this.gl.getExtension(d);else{if(!Ct(this.gl,c))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(c)}this.vertexBuffer=Qn(this.gl),this.indexBuffer=br(this.gl),this.framebuffer=function(f){return Z(f,()=>f.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=B(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(t.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const a=this.gl;O(a,()=>a.finish()),O(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,null)),O(a,()=>a.deleteFramebuffer(this.framebuffer)),O(a,()=>a.bindBuffer(a.ARRAY_BUFFER,null)),O(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null)),O(a,()=>a.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(a,o){return this.throwIfDisposed(),function(d,c,f,w){const[C,T]=E(c,f);return gr(d,C,T,At(w),w.textureFormatFloat,d.FLOAT)}(this.gl,a,o,this.textureConfig)}createFloat16MatrixTexture(a,o){return this.throwIfDisposed(),function(d,c,f,w){const[C,T]=E(c,f);return gr(d,C,T,q(w),w.textureFormatFloat,w.textureTypeHalfFloat)}(this.gl,a,o,this.textureConfig)}createUnsignedBytesMatrixTexture(a,o){return this.throwIfDisposed(),function(d,c,f,w){const[C,T]=E(c,f);return gr(d,C,T,ae(w),d.RGBA,d.UNSIGNED_BYTE)}(this.gl,a,o,this.textureConfig)}uploadPixelDataToTexture(a,o){this.throwIfDisposed(),function(d,c,f){O(d,()=>d.bindTexture(d.TEXTURE_2D,c)),f.data instanceof Uint8Array?Object(t.env)().getNumber("WEBGL_VERSION")===2?O(d,()=>d.texSubImage2D(d.TEXTURE_2D,0,0,0,f.width,f.height,d.RGBA,d.UNSIGNED_BYTE,f.data)):O(d,()=>d.texImage2D(d.TEXTURE_2D,0,d.RGBA,f.width,f.height,0,d.RGBA,d.UNSIGNED_BYTE,f.data)):Object(t.env)().getNumber("WEBGL_VERSION")===2?O(d,()=>d.texSubImage2D(d.TEXTURE_2D,0,0,0,d.RGBA,d.UNSIGNED_BYTE,f)):O(d,()=>d.texImage2D(d.TEXTURE_2D,0,d.RGBA,d.RGBA,d.UNSIGNED_BYTE,f)),O(d,()=>d.bindTexture(d.TEXTURE_2D,null))}(this.gl,a,o)}uploadDenseMatrixToTexture(a,o,d,c){this.throwIfDisposed(),function(f,w,C,T,P,z){let te,Y,Ce;O(f,()=>f.bindTexture(f.TEXTURE_2D,w)),P instanceof Uint8Array?(te=new Uint8Array(C*T*4),Y=f.UNSIGNED_BYTE,Ce=f.RGBA):(te=new Float32Array(C*T*4),Y=f.FLOAT,Ce=z.internalFormatPackedFloat),te.set(P),Object(t.env)().getNumber("WEBGL_VERSION")===2?O(f,()=>f.texSubImage2D(f.TEXTURE_2D,0,0,0,C,T,f.RGBA,Y,te)):O(f,()=>f.texImage2D(f.TEXTURE_2D,0,Ce,C,T,0,f.RGBA,Y,te)),O(f,()=>f.bindTexture(f.TEXTURE_2D,null))}(this.gl,a,o,d,c,this.textureConfig)}createFloat16PackedMatrixTexture(a,o){return this.throwIfDisposed(),function(d,c,f,w){const[C,T]=l(c,f);return gr(d,C,T,ht(w),d.RGBA,w.textureTypeHalfFloat)}(this.gl,a,o,this.textureConfig)}createPackedMatrixTexture(a,o){return this.throwIfDisposed(),function(d,c,f,w){const[C,T]=l(c,f);return gr(d,C,T,Qe(w),d.RGBA,d.FLOAT)}(this.gl,a,o,this.textureConfig)}deleteMatrixTexture(a){this.throwIfDisposed(),this.outputTexture===a&&(Q(this.gl,this.framebuffer),this.outputTexture=null),O(this.gl,()=>this.gl.deleteTexture(a))}downloadByteEncodedFloatMatrixFromOutputTexture(a,o,d){return this.downloadMatrixDriver(a,()=>function(c,f,w,C){const[T,P]=E(f,w),z=new Uint8Array(f*w*4);return O(c,()=>c.readPixels(0,0,T,P,C.downloadTextureFormat,c.UNSIGNED_BYTE,z)),new Float32Array(z.buffer)}(this.gl,o,d,this.textureConfig))}downloadPackedMatrixFromBuffer(a,o,d,c,f,w){return Bt(this.gl,a,0,0,0,f,w,this.textureConfig)}downloadFloat32MatrixFromBuffer(a,o){return function(d,c,f){const w=d,C=new Float32Array(f);return w.bindBuffer(w.PIXEL_PACK_BUFFER,c),w.getBufferSubData(w.PIXEL_PACK_BUFFER,0,C),w.bindBuffer(w.PIXEL_PACK_BUFFER,null),C}(this.gl,a,o)}createBufferFromTexture(a,o,d){this.bindTextureToFrameBuffer(a);const c=function(f,w,C,T){const P=f.createBuffer();O(f,()=>f.bindBuffer(f.PIXEL_PACK_BUFFER,P));const z=16*w*C;return O(f,()=>f.bufferData(f.PIXEL_PACK_BUFFER,z,f.STREAM_READ)),O(f,()=>f.readPixels(0,0,C,w,f.RGBA,f.FLOAT,0)),O(f,()=>f.bindBuffer(f.PIXEL_PACK_BUFFER,null)),P}(this.gl,o,d,this.textureConfig);return this.unbindTextureToFrameBuffer(),c}createAndWaitForFence(){const a=this.createFence(this.gl);return this.pollFence(a)}createFence(a){let o,d;if(Object(t.env)().getBool("WEBGL_FENCE_API_ENABLED")){const c=a,f=c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE,0);a.flush(),d=()=>{const w=c.clientWaitSync(f,0,0);return w===c.ALREADY_SIGNALED||w===c.CONDITION_SATISFIED},o=f}else Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(o=this.beginQuery(),this.endQuery(),d=()=>this.isQueryAvailable(o,Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):d=()=>!0;return{query:o,isFencePassed:d}}downloadMatrixFromPackedTexture(a,o,d){return this.downloadMatrixDriver(a,()=>function(c,f,w){const C=new Float32Array(f*w*4);return O(c,()=>c.readPixels(0,0,w,f,c.RGBA,c.FLOAT,C)),C}(this.gl,o,d))}createProgram(a){this.throwIfDisposed();const o=this.gl;this.vertexShader==null&&(this.vertexShader=lr(o));const d=function(c){return Z(c,()=>c.createProgram(),"Unable to create WebGLProgram.")}(o);return O(o,()=>o.attachShader(d,this.vertexShader)),O(o,()=>o.attachShader(d,a)),function(c,f){if(O(c,()=>c.linkProgram(f)),!Object(t.env)().get("ENGINE_COMPILE_ONLY")&&c.getProgramParameter(f,c.LINK_STATUS)===!1)throw console.log(c.getProgramInfoLog(f)),new Error("Failed to link vertex and fragment shaders.")}(o,d),this.debug&&de(o,d),this.vertexAttrsAreBound||(this.setProgram(d),this.vertexAttrsAreBound=function(c,f,w){return O(c,()=>c.bindBuffer(c.ARRAY_BUFFER,w)),ke(c,f,"clipSpacePos",w,3,20,0)&&ke(c,f,"uv",w,2,20,12)}(o,this.program,this.vertexBuffer)),d}deleteProgram(a){this.throwIfDisposed(),a===this.program&&(this.program=null),a!=null&&O(this.gl,()=>this.gl.deleteProgram(a))}setProgram(a){this.throwIfDisposed(),this.program=a,this.program!=null&&this.debug&&de(this.gl,this.program),O(this.gl,()=>this.gl.useProgram(a))}getUniformLocation(a,o,d=!0){return this.throwIfDisposed(),d?function(c,f,w){return Z(c,()=>c.getUniformLocation(f,w),'uniform "'+w+'" not present in program.')}(this.gl,a,o):function(c,f,w){return c.getUniformLocation(f,w)}(this.gl,a,o)}getAttributeLocation(a,o){return this.throwIfDisposed(),O(this.gl,()=>this.gl.getAttribLocation(a,o))}getUniformLocationNoThrow(a,o){return this.throwIfDisposed(),this.gl.getUniformLocation(a,o)}setInputMatrixTexture(a,o,d){this.throwIfDisposed(),this.throwIfNoProgram(),Ie(this.gl,a,o,d)}setOutputMatrixTexture(a,o,d){this.setOutputMatrixTextureDriver(a,d,o)}setOutputPackedMatrixTexture(a,o,d){this.throwIfDisposed();const[c,f]=l(o,d);this.setOutputMatrixTextureDriver(a,c,f)}setOutputMatrixWriteRegion(a,o,d,c){this.setOutputMatrixWriteRegionDriver(d,a,c,o)}setOutputPackedMatrixWriteRegion(a,o,d,c){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&de(this.gl,this.program),Se(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const a=this.gl;this.debug&&this.debugValidate(),O(a,()=>a.drawElements(a.TRIANGLES,6,a.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),O(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=L(this.gl,Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const d=this.gl,c=this.getQueryTimerExtensionWebGL2(),f=d.createQuery();return d.beginQuery(c.TIME_ELAPSED_EXT,f),f}const a=this.getQueryTimerExtensionWebGL1(),o=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,o),o}endQuery(){if(Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const o=this.gl,d=this.getQueryTimerExtensionWebGL2();return void o.endQuery(d.TIME_ELAPSED_EXT)}const a=this.getQueryTimerExtensionWebGL1();a.endQueryEXT(a.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(a){return await t.util.repeatedTry(()=>this.disposed||this.isQueryAvailable(a,Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(a,Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(a,o){if(o===0)return null;if(o===2){const d=this.gl;return d.getQueryParameter(a,d.QUERY_RESULT)/1e6}{const d=this.getQueryTimerExtensionWebGL1();return d.getQueryObjectEXT(a,d.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(a,o){if(o===0)return!0;if(o===2){const d=this.gl,c=this.getQueryTimerExtensionWebGL2(),f=d.getQueryParameter(a,d.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(c.GPU_DISJOINT_EXT)),f&&!this.disjoint}{const d=this.getQueryTimerExtensionWebGL1(),c=d.getQueryObjectEXT(a,d.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(d.GPU_DISJOINT_EXT)),c&&!this.disjoint}}pollFence(a){return new Promise(o=>{this.addItemToPoll(()=>a.isFencePassed(),()=>o())})}pollItems(){const a=function(o){let d=0;for(;d<o.length&&o[d]();++d);return d-1}(this.itemsToPoll.map(o=>o.isDoneFn));for(let o=0;o<=a;++o){const{resolveFn:d}=this.itemsToPoll[o];d()}this.itemsToPoll=this.itemsToPoll.slice(a+1)}addItemToPoll(a,o){this.itemsToPoll.push({isDoneFn:a,resolveFn:o}),this.itemsToPoll.length>1||t.util.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(a){this.throwIfDisposed(),he(this.gl,a,this.framebuffer),this.debug&&Se(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(he(this.gl,this.outputTexture,this.framebuffer),this.debug&&Se(this.gl)):Q(this.gl,this.framebuffer)}downloadMatrixDriver(a,o){this.bindTextureToFrameBuffer(a);const d=o();return this.unbindTextureToFrameBuffer(),d}setOutputMatrixTextureDriver(a,o,d){this.throwIfDisposed();const c=this.gl;he(c,a,this.framebuffer),this.debug&&Se(c),this.outputTexture=a,O(c,()=>c.viewport(0,0,o,d)),O(c,()=>c.scissor(0,0,o,d))}setOutputMatrixWriteRegionDriver(a,o,d,c){this.throwIfDisposed(),O(this.gl,()=>this.gl.scissor(a,o,d,c))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}var Ut=e(28);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:tn,bincountImpl:bn,bincountReduceImpl:xn,castImpl:rn,ceilImpl:Xn,concatImpl:xr,equalImpl:Lr,expImpl:Wr,expm1Impl:vr,floorImpl:ua,gatherNdImpl:ma,gatherV2Impl:Cr,greaterImpl:Da,greaterEqualImpl:kr,lessImpl:Pr,lessEqualImpl:qr,linSpaceImpl:ha,logImpl:Zr,maxImpl:Vr,maximumImpl:Ca,minimumImpl:Ta,multiplyImpl:Pa,negImpl:is,notEqualImpl:ms,prodImpl:Va,raggedTensorToTensorImpl:Ba,rangeImpl:wa,rsqrtImpl:Ga,scatterImpl:Xr,sigmoidImpl:ka,simpleAbsImpl:_a,sliceImpl:os,sparseFillEmptyRowsImpl:Za,sparseReshapeImpl:La,sparseSegmentReductionImpl:wr,sqrtImpl:sa,stridedSliceImpl:Ia,stringNGramsImpl:ba,stringSplitImpl:ca,stringToHashBucketFastImpl:Ja,subImpl:Fe,tileImpl:dt,topKImpl:Et,transposeImpl:Vt,uniqueImpl:an}=Ut;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(k,a){return["x","y","z","w","u","v"].slice(0,a).map(o=>`${k}.${o}`)}function _n(k,a){return a===1?[k]:Zt(k,a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gn{constructor(a){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.enableShapeUniforms=ir(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const o=_n("rc",this.rank),d=oe(this.rank),c=this.getOutOfBoundsCondition(o),f=this.getSetup(o),w=this.getOutput(o);this.userCode=`
        void main() {
          ${d} rc = getOutputCoords();

          if(${c}) {
            setOutput(vec4(0));
          } else {
            ${f}

            setOutput(vec4(${w}));
          }
        }
      `}}getSourceCoordsArr(a){const o=[];for(let d=0;d<=1;d++)for(let c=0;c<=1;c++){let f=`${d===0?"r":"rp1"}, ${c===0?"c":"cp1"}`;for(let w=2;w<this.rank;w++)f=`${a[a.length-1-w]},`+f;o.push(f)}return o}getOutOfBoundsCondition(a){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let o="";for(let d=this.rank-2;d<this.rank;d++)o+=`${a[d]} >= ${this.enableShapeUniforms?`outShape[${d}]`:this.outputShape[d]}`,d<this.rank-1&&(o+="||");return o}getSetup(a){if(this.rank===1)return"";const o=a.slice(-2),d=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],c=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${o[0]};
      int c = ${o[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${d};
      bool rEdge = rp1 >= ${c};
    `}getOutput(a){const o=this.getSourceCoordsArr(a);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${o[0]}),
            cEdge ? 0. : getA(${o[1]}),
            rEdge ? 0. : getA(${o[2]}),
            rEdge || cEdge ? 0. : getA(${o[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ar{constructor(a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length);let d="";for(let w=0;w<4;w++){let C="thisRC = rc;";w%2==1&&(C+="thisRC.z += 1;"),w>1&&(C+="thisRC.y += 1;"),d+=`
        ${C}
        ${w>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${w}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${w>0?"}":""}
      `}var c,f;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */this.userCode=`
      ${c=o,f=this.enableShapeUniforms,`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${f?zn(["r","c","d"],"inputShape"):Nn(["r","c","d"],c)}
      return ivec3(r, c, d);
    }
  `}
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:sr(a)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":a[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":a[2]};

        ${d}

        setOutput(result);
      }
    `}}class Rr{constructor(a){this.gpgpu=a,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(a,o,d){const c=xa(o,d),f=Er(a,c,d);f in this.freeTextures||(this.freeTextures[f]=[]),f in this.usedTextures||(this.usedTextures[f]=[]);const w=Ir(a,c,this.gpgpu.gl,this.gpgpu.textureConfig,d);if(this.freeTextures[f].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=w,this.log();const T=this.freeTextures[f].shift();return this.usedTextures[f].push(T),T}let C;return c===y.PACKED_2X2_FLOAT32?C=this.gpgpu.createPackedMatrixTexture(a[0],a[1]):c===y.PACKED_2X2_FLOAT16?C=this.gpgpu.createFloat16PackedMatrixTexture(a[0],a[1]):c===y.UNPACKED_FLOAT32?C=this.gpgpu.createFloat32MatrixTexture(a[0],a[1]):c===y.UNPACKED_FLOAT16?C=this.gpgpu.createFloat16MatrixTexture(a[0],a[1]):c===y.PACKED_4X1_UNSIGNED_BYTE&&(C=this.gpgpu.createUnsignedBytesMatrixTexture(a[0],a[1])),this.usedTextures[f].push(C),this.numUsedTextures++,this._numBytesAllocated+=w,this.log(),C}releaseTexture(a,o,d,c){if(this.freeTextures==null)return;const f=xa(d,c),w=Er(o,f,c);w in this.freeTextures||(this.freeTextures[w]=[]);const C=Ir(o,f,this.gpgpu.gl,this.gpgpu.textureConfig,c),T=Object(t.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");T!==-1&&this._numBytesAllocated>T?(this.gpgpu.deleteMatrixTexture(a.texture),this._numBytesAllocated-=C):(this.freeTextures[w].push(a),this.numFreeTextures++,this._numBytesFree+=C),this.numUsedTextures--;const P=this.usedTextures[w],z=P.indexOf(a);if(z<0)throw new Error("Cannot release a texture that was never provided by this texture manager");P.splice(z,1),this.log()}log(){if(!this.logEnabled)return;const a=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${a})`);const o=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*o)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const a in this.freeTextures)this.freeTextures[a].forEach(o=>{this.gpgpu.deleteMatrixTexture(o.texture)});for(const a in this.usedTextures)this.usedTextures[a].forEach(o=>{this.gpgpu.deleteMatrixTexture(o.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Ir(k,a,o,d,c){const f=function(T,P){switch(T){case y.PACKED_2X2_FLOAT32:return Qe(P);case y.PACKED_2X2_FLOAT16:return ht(P);case y.UNPACKED_FLOAT32:return At(P);case y.UNPACKED_FLOAT16:return q(P);case y.PACKED_4X1_UNSIGNED_BYTE:return ae(P);default:throw new Error(`Unknown physical texture type ${T}`)}}(a,d);let w;if(c){const[T,P]=l(k[0],k[1]);w=T*P}else{const[T,P]=E(k[0],k[1]);w=T*P}const C=function(T,P){const z=T;if(P===z.R32F)return 4;if(P===z.R16F)return 2;if(P===z.RGBA32F||P===T.RGBA)return 16;if(P===z.RGBA16F)return 8;if(P===z.RGBA8)return 4;throw new Error(`Unknown internal format ${P}`)}(o,f);return w*C}function xa(k,a){if(k===D.UPLOAD)return y.PACKED_2X2_FLOAT32;if(k===D.RENDER||k==null)return function(o){return Object(t.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?o?y.PACKED_2X2_FLOAT32:y.UNPACKED_FLOAT32:o?y.PACKED_2X2_FLOAT16:y.UNPACKED_FLOAT16}(a);if(k===D.DOWNLOAD||k===D.PIXELS)return y.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${k}`)}function Er(k,a,o){return`${k[0]}_${k[1]}_${a}_${o}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yr{constructor(a,o){this.variableNames=["A"],this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${o}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ja="return abs(x);",Oa="return x;";class $a{constructor(a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${o}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xs{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length);const o=a.length,d=_n("rc",o),c=oe(o),f=function(T,P){if(T===1)return"rc";let z="";for(let te=0;te<T;te++)z+=P[te],te<T-1&&(z+=",");return z}(o,d),w=d.slice(-2),C=o<=1?"rc":`vec2(${w.join(",")})`;this.userCode=`
      void main() {
        ${c} rc = getOutputCoords();
        vec4 packedInput = getA(${f});

        setOutput(getChannel(packedInput, ${C}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $s=t.kernel_impls.whereImpl,bs={},di=Object(t.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Ha extends t.KernelBackend{constructor(a){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(t.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let o;if(a!=null){if(a instanceof Kt)o=a;else{const c=b(Object(t.env)().getNumber("WEBGL_VERSION"),a);o=new Kt(c)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const c=b(Object(t.env)().getNumber("WEBGL_VERSION"));o=new Kt(c),this.binaryCache=((d=Object(t.env)().getNumber("WEBGL_VERSION"))in bs||(bs[d]={}),bs[d]),this.gpgpuCreatedLocally=!0}var d;this.gpgpu=o,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Rr(this.gpgpu),this.numMBBeforeWarning=Object(t.env)().global.screen==null?1024:Object(t.env)().global.screen.height*Object(t.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new t.DataStorage(this,Object(t.engine)())}nextDataId(){return Ha.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(a,o,d){if((Object(t.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(t.env)().getBool("DEBUG"))&&this.checkNumericalProblems(a),d==="complex64"&&a!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const c={id:this.nextDataId()};return this.texData.set(c,{shape:o,dtype:d,values:a,usage:D.UPLOAD,refCount:1}),c}refCount(a){return this.texData.has(a)?this.texData.get(a).refCount:0}incRef(a){this.texData.get(a).refCount++}decRef(a){this.texData.has(a)&&this.texData.get(a).refCount--}move(a,o,d,c,f){if(Object(t.env)().getBool("DEBUG")&&this.checkNumericalProblems(o),c==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(a,{shape:d,dtype:c,values:o,usage:D.UPLOAD,refCount:f})}disposeIntermediateTensorInfo(a){this.disposeData(a.dataId)}readSync(a){const o=this.texData.get(a),{values:d,dtype:c,complexTensorInfos:f,slice:w,shape:C,isPacked:T}=o;if(w!=null){let Y;Y=T?new $a(C,Oa):new Yr(C,Oa);const Ce=this.runWebGLProgram(Y,[{dataId:a,shape:C,dtype:c}],c),fe=this.readSync(Ce.dataId);return this.disposeIntermediateTensorInfo(Ce),fe}if(d!=null)return this.convertAndCacheOnCPU(a);if(c==="string")return d;const P=this.activeTimers!=null;let z,te;if(P&&(z=t.util.now()),c==="complex64"){const Y=this.readSync(f.real.dataId),Ce=this.readSync(f.imag.dataId);te=t.backend_util.mergeRealAndImagArrays(Y,Ce)}else te=this.getValuesFromTexture(a);return P&&(this.downloadWaitMs+=t.util.now()-z),this.convertAndCacheOnCPU(a,te)}async read(a){if(this.pendingRead.has(a)){const fe=this.pendingRead.get(a);return new Promise(Pe=>fe.push(Pe))}const o=this.texData.get(a),{values:d,shape:c,slice:f,dtype:w,complexTensorInfos:C,isPacked:T}=o;if(f!=null){let fe;fe=T?new $a(c,Oa):new Yr(c,Oa);const Pe=this.runWebGLProgram(fe,[{dataId:a,shape:c,dtype:w}],w),Le=this.read(Pe.dataId);return this.disposeIntermediateTensorInfo(Pe),Le}if(d!=null)return this.convertAndCacheOnCPU(a);if(Object(t.env)().getBool("DEBUG")&&!Object(t.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Object(t.env)().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let P,z,te=null;if(w!=="complex64"&&Object(t.env)().get("WEBGL_BUFFER_SUPPORTED")){P=this.decode(a);const fe=this.texData.get(P.dataId);te=this.gpgpu.createBufferFromTexture(fe.texture.texture,...S(c))}if(this.pendingRead.set(a,[]),w!=="complex64"&&await this.gpgpu.createAndWaitForFence(),w==="complex64"){const fe=await Promise.all([this.read(C.real.dataId),this.read(C.imag.dataId)]),Pe=fe[0],Le=fe[1];z=t.backend_util.mergeRealAndImagArrays(Pe,Le)}else if(te==null)z=this.getValuesFromTexture(a);else{const fe=t.util.sizeFromShape(c);z=this.gpgpu.downloadFloat32MatrixFromBuffer(te,fe)}if(P!=null&&this.disposeIntermediateTensorInfo(P),te!=null){const fe=this.gpgpu.gl;O(fe,()=>fe.deleteBuffer(te))}const Y=this.convertAndCacheOnCPU(a,z),Ce=this.pendingRead.get(a);return this.pendingRead.delete(a),Ce.forEach(fe=>fe(Y)),this.pendingDisposal.has(a)&&(this.pendingDisposal.delete(a),this.disposeData(a)&&Object(t.engine)().removeDataId(a,this),this.pendingDeletes--),Y}readToGPU(a,o={}){const d=this.texData.get(a),{values:c,shape:f,slice:w,dtype:C,isPacked:T,texture:P}=d;if(C==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(w!=null){let Ce;Ce=T?new $a(f,Oa):new Yr(f,Oa);const fe=this.runWebGLProgram(Ce,[{dataId:a,shape:f,dtype:C}],C),Pe=this.readToGPU(fe,o);return this.disposeIntermediateTensorInfo(fe),Pe}if(P==null)throw c!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const z=this.decode(a,o.customTexShape),te=Object(t.engine)().makeTensorFromTensorInfo(z),Y=this.texData.get(z.dataId);return Object.assign({tensorRef:te},Y.texture)}bufferSync(a){const o=this.readSync(a.dataId);if(a.dtype==="string")try{const d=o.map(c=>t.util.decodeString(c));return Object(t.buffer)(a.shape,a.dtype,d)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(t.buffer)(a.shape,a.dtype,o)}checkNumericalProblems(a){if(a!=null)for(let o=0;o<a.length;o++){const d=a[o];if(!V(d))throw Object(t.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${d} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${d} cannot be represented on this device.`)}}getValuesFromTexture(a){const{shape:o,dtype:d,isPacked:c}=this.texData.get(a),f=t.util.sizeFromShape(o);if(Object(t.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const Y=this.decode(a),Ce=this.texData.get(Y.dataId),fe=this.gpgpu.downloadMatrixFromPackedTexture(Ce.texture.texture,...S(o)).subarray(0,f);return this.disposeIntermediateTensorInfo(Y),fe}const w=Object(t.env)().getBool("WEBGL_PACK")&&c===!0,C=w?et(o):o,T=w?new mn(C):new en(C),P=this.runWebGLProgram(T,[{shape:C,dtype:d,dataId:a}],"float32"),z=this.texData.get(P.dataId),te=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(z.texture.texture,z.texShape[0],z.texShape[1]).subarray(0,f);return this.disposeIntermediateTensorInfo(P),te}timerAvailable(){return Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(a){const o=this.activeTimers,d=[];let c=!1;this.programTimersStack==null?(this.programTimersStack=d,c=!0):this.activeTimers.push(d),this.activeTimers=d,a();const f=t.util.flatten(this.activeTimers.map(T=>T.query)).filter(T=>T!=null),w=t.util.flatten(this.activeTimers.map(T=>T.name)).filter(T=>T!=null);this.activeTimers=o,c&&(this.programTimersStack=null);const C={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const T=await Promise.all(f);C.kernelMs=t.util.sum(T),C.getExtraProfileInfo=()=>T.map((P,z)=>({name:w[z],ms:P})).map(P=>`${P.name}: ${P.ms}`).join(", ")}else C.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,C})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:t.util.now(),endMs:null}}endTimer(a){return Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),a):(a.endMs=t.util.now(),a)}async getQueryTime(a){if(Object(t.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(a);const o=a;return o.endMs-o.startMs}disposeData(a,o=!1){if(this.pendingDisposal.has(a))return!1;if(!this.texData.has(a))return!0;if(o?this.texData.get(a).refCount=0:this.texData.get(a).refCount--,!o&&this.texData.get(a).refCount>0)return!1;if(this.pendingRead.has(a))return this.pendingDisposal.add(a),this.pendingDeletes++,!1;this.releaseGPUData(a);const{complexTensorInfos:d}=this.texData.get(a);return d!=null&&(this.disposeData(d.real.dataId,o),this.disposeData(d.imag.dataId,o)),this.texData.delete(a),!0}releaseGPUData(a){const{texture:o,dtype:d,texShape:c,usage:f,isPacked:w,slice:C}=this.texData.get(a),T=C&&C.origDataId||a,P=this.dataRefCount.get(T);P>1?this.dataRefCount.set(T,P-1):(this.dataRefCount.delete(T),o!=null&&(this.numBytesInGPU-=this.computeBytes(c,d),this.textureManager.releaseTexture(o,c,f,w)));const z=this.texData.get(a);z.texture=null,z.texShape=null,z.isPacked=!1,z.slice=null}getTexture(a){return this.uploadToGPU(a),this.texData.get(a).texture.texture}getDataInfo(a){return this.texData.get(a)}shouldExecuteOnCPU(a,o=di){return Object(t.env)().getBool("WEBGL_CPU_FORWARD")&&a.every(d=>this.texData.get(d.dataId).texture==null&&t.util.sizeFromShape(d.shape)<o)}getGPGPUContext(){return this.gpgpu}where(a){t.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const o=a.dataSync();return $s(a.shape,o)}packedUnaryOp(a,o,d){const c=new $a(a.shape,o),f=this.compileAndRun(c,[a],d);return Object(t.engine)().makeTensorFromTensorInfo(f)}abs(a){if(this.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){const c=_a(this.texData.get(a.dataId).values);return this.makeOutput(a.shape,a.dtype,c)}if(Object(t.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(a,ja,a.dtype);const o=new Yr(a.shape,ja),d=this.compileAndRun(o,[a]);return Object(t.engine)().makeTensorFromTensorInfo(d)}makeTensorInfo(a,o,d){let c;if(o==="string"&&d!=null&&d.length>0&&t.util.isString(d[0])){const f=d.map(w=>t.util.encodeString(w));c=this.write(f,a,o)}else c=this.write(d,a,o);return this.texData.get(c).usage=null,{dataId:c,shape:a,dtype:o}}makeOutput(a,o,d){return Object(t.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(a,o,d),this)}unpackTensor(a){const o=new Xs(a.shape);return this.runWebGLProgram(o,[a],a.dtype)}packTensor(a){const o=new Gn(a.shape);return this.runWebGLProgram(o,[a],a.dtype,null,!0)}packedReshape(a,o){const d=[He(a.shape),...me(a.shape)],c={dtype:a.dtype,shape:d,dataId:a.dataId},f=[He(o),...me(o)],w=new ar(f,d),C=[d],T=this.runWebGLProgram(w,[c],a.dtype,C,!0);return{dataId:T.dataId,shape:o,dtype:T.dtype}}decode(a,o){const d=this.texData.get(a),{isPacked:c,shape:f,dtype:w}=d;if(o!=null){const z=t.util.sizeFromShape(f),te=o[0]*o[1]*4;t.util.assert(z<=te,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const C=et(f);let T;T=c?new $r(C):new Zn(C);const P=[o!=null?o:S(C)];return{dtype:w,shape:f,dataId:this.runWebGLProgram(T,[{shape:C,dtype:w,dataId:a}],w,P,!0,o).dataId}}runWebGLProgram(a,o,d,c,f=!1,w){const C=this.makeTensorInfo(a.outputShape,d),T=this.texData.get(C.dataId);if(a.packedOutput&&(T.isPacked=!0),a.outPackingScheme===A.DENSE){const _e=w!=null?w:S(a.outputShape);T.texShape=_e.map(je=>2*je)}if(a.outTexUsage!=null&&(T.usage=a.outTexUsage),t.util.sizeFromShape(C.shape)===0)return T.values=t.util.getTypedArrayFromDType(C.dtype,0),C;const P=[],z=o.map(_e=>{if(_e.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let je=this.texData.get(_e.dataId);if(je.texture==null){if(!a.packedInputs&&t.util.sizeFromShape(_e.shape)<=Object(t.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:_e.shape,texData:null,isUniform:!0,uniformValues:je.values};a.packedInputs&&(je.isPacked=!0,je.shape=_e.shape)}if(this.uploadToGPU(_e.dataId),!!je.isPacked!=!!a.packedInputs)_e=je.isPacked?this.unpackTensor(_e):this.packTensor(_e),P.push(_e),je=this.texData.get(_e.dataId);else if(je.isPacked&&!It(je.shape,_e.shape)){const qt=_e,sn=_e.shape;_e.shape=je.shape,_e=this.packedReshape(_e,sn),P.push(_e),je=this.texData.get(_e.dataId),qt.shape=sn}return{shape:_e.shape,texData:je,isUniform:!1}});this.uploadToGPU(C.dataId);const te={shape:C.shape,texData:T,isUniform:!1},Y=function(_e,je,qt){let sn="";je.concat(qt).forEach(Cn=>{const An=Cn.texData!=null&&Cn.texData.slice!=null&&Cn.texData.slice.flatOffset>0;if(_e.enableShapeUniforms&&!Cn.isUniform){const kn=Cn.texData.texShape,{useSqueezeShape:Jn,uniformShape:qn,keptDims:s}=le(_e.packedInputs,Cn.shape,kn);let r="",i="",u="";if(qn.length===1&&_e.packedInputs){const ze=[Math.ceil(kn[0]/2),Math.ceil(kn[1]/2)];r=`${ze[0]>1}_${ze[1]>1}`}else if(qn.length!==2||_e.packedInputs){if(qn.length>2&&!_e.packedInputs){const ze=t.util.computeStrides(qn);u=`${ze[0]===kn[1]}_${ze[ze.length-1]===kn[1]}`}}else i=`${qn[0]>1}_${qn[1]>1}`;const p=Cn.shape.length,_=qn.length===2&&t.util.arraysEqual(Cn.shape,kn),$=t.util.sizeFromShape(Cn.shape)===1,U=t.backend_util.getBroadcastDims(Cn.shape,qt.shape),re=!_e.packedInputs&&p===qt.shape.length&&t.util.arraysEqual(kn,qt.texData.texShape),pe=_e.packedInputs||qn.length>2?"":`${kn[0]>1}_${kn[1]>1}`;sn+=`${p}_${re}_${Jn?s:""}_${qn.length}_${$}_${U}_${_}_${r}_${i}_${u}_${pe}_${An}`}else{const kn=Cn.isUniform?"uniform":Cn.texData.texShape;sn+=`${Cn.shape}_${kn}_${An}`}});const vn=_e.userCode;let En=_e.constructor.name;return En+="_"+sn+"_"+vn+`${Object(t.env)().getNumber("WEBGL_VERSION")}`,En}(a,z,te),Ce=this.getAndSaveBinary(Y,()=>zr(this.gpgpu,a,z,te)),fe=this.activeTimers!=null;let Pe;fe&&(Pe=this.startTimer()),Object(t.env)().get("ENGINE_COMPILE_ONLY")||function(_e,je,qt,sn,vn){je.program.enableShapeUniforms||(_r(je.inShapeInfos,qt),_r([je.outShapeInfo],[sn]));const En=sn.texData.texture,Cn=sn.texData.texShape;sn.texData.isPacked?_e.setOutputPackedMatrixTexture(En.texture,Cn[0],Cn[1]):_e.setOutputMatrixTexture(En.texture,Cn[0],Cn[1]),_e.setProgram(je.webGLProgram),Object(t.env)().getNumber("WEBGL_VERSION")===1&&je.infLoc!==null&&_e.gl.uniform1f(je.infLoc,1/0),je.nanLoc!==null&&_e.gl.uniform1f(je.nanLoc,NaN),qt.forEach((kn,Jn)=>{const qn=je.program.variableNames[Jn],s=je.uniformLocations[qn],r=je.uniformLocations[`offset${qn}`],i=je.inShapesLocations[`${qn}Shape`],u=je.inTexShapesLocations[`${qn}TexShape`];if(i){const{uniformShape:p}=le(je.program.packedInputs,kn.shape,kn.texData.texShape);switch(p.length){case 1:_e.gl.uniform1iv(i,new Int32Array(p));break;case 2:_e.gl.uniform2iv(i,new Int32Array(p));break;case 3:_e.gl.uniform3iv(i,new Int32Array(p));break;case 4:_e.gl.uniform4iv(i,new Int32Array(p))}}if(u&&_e.gl.uniform2i(u,kn.texData.texShape[0],kn.texData.texShape[1]),s!=null)if(kn.isUniform)if(t.util.sizeFromShape(kn.shape)<2)_e.gl.uniform1f(s,kn.uniformValues[0]);else{let p=kn.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),_e.gl.uniform1fv(s,p)}else kn.texData.slice!=null&&r!=null&&_e.gl.uniform1i(r,kn.texData.slice.flatOffset),_e.setInputMatrixTexture(kn.texData.texture.texture,s,Jn)});const An=je.outShapeLocation;if(An)switch(sn.shape.length){case 1:_e.gl.uniform1iv(An,new Int32Array(sn.shape));break;case 2:_e.gl.uniform2iv(An,new Int32Array(sn.shape));break;case 3:_e.gl.uniform3iv(An,new Int32Array(sn.shape));break;case 4:_e.gl.uniform4iv(An,new Int32Array(sn.shape))}if(je.outShapeStridesLocation){const kn=t.util.computeStrides(sn.shape);switch(sn.shape.length){case 2:_e.gl.uniform1iv(je.outShapeStridesLocation,new Int32Array(kn));break;case 3:_e.gl.uniform2iv(je.outShapeStridesLocation,new Int32Array(kn));break;case 4:_e.gl.uniform3iv(je.outShapeStridesLocation,new Int32Array(kn))}}je.outTexShapeLocation&&_e.gl.uniform2i(je.outTexShapeLocation,sn.texData.texShape[0],sn.texData.texShape[1]),je.program.customUniforms&&vn&&je.program.customUniforms.forEach((kn,Jn)=>{const qn=je.customUniformLocations[Jn],s=vn[Jn];if(kn.type==="float")_e.gl.uniform1fv(qn,s);else if(kn.type==="vec2")_e.gl.uniform2fv(qn,s);else if(kn.type==="vec3")_e.gl.uniform3fv(qn,s);else if(kn.type==="vec4")_e.gl.uniform4fv(qn,s);else if(kn.type==="int")_e.gl.uniform1iv(qn,s);else if(kn.type==="ivec2")_e.gl.uniform2iv(qn,s);else if(kn.type==="ivec3")_e.gl.uniform3iv(qn,s);else{if(kn.type!=="ivec4")throw Error(`uniform type ${kn.type} is not supported yet.`);_e.gl.uniform4iv(qn,s)}}),_e.executeProgram()}(this.gpgpu,Ce,z,te,c),P.forEach(_e=>this.disposeIntermediateTensorInfo(_e)),fe&&(Pe=this.endTimer(Pe),this.activeTimers.push({name:a.constructor.name,query:this.getQueryTime(Pe)}));const Le=Object(t.env)().get("WEBGL_FLUSH_THRESHOLD");if(Le>0){const _e=t.util.now();_e-this.lastGlFlushTime>Le&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=_e)}if(!Object(t.env)().getBool("WEBGL_LAZILY_UNPACK")&&T.isPacked&&f===!1){const _e=this.unpackTensor(C);return this.disposeIntermediateTensorInfo(C),_e}return C}compileAndRun(a,o,d,c,f=!1){return d=d||o[0].dtype,this.runWebGLProgram(a,o,d,c,f)}getAndSaveBinary(a,o){return a in this.binaryCache||(this.binaryCache[a]=o()),this.binaryCache[a]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Object(t.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(a=>{this.gpgpu.deleteProgram(this.binaryCache[a].webGLProgram),delete this.binaryCache[a]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Object(t.tidy)(()=>{if(!Object(t.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const a=Object(t.env)().getBool("DEBUG");Object(t.env)().set("DEBUG",!1);const o=this.abs(Object(t.scalar)(1e-8)).dataSync()[0];if(Object(t.env)().set("DEBUG",a),o>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}uploadToGPU(a){const o=this.texData.get(a),{shape:d,dtype:c,values:f,texture:w,usage:C,isPacked:T}=o;if(w!=null)return;const P=this.activeTimers!=null;let z;P&&(z=t.util.now());let te=o.texShape;if(te==null&&(te=function(Y,Ce=!1){let fe=Object(t.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");Ce&&(fe*=2,(Y=Y.map((Le,_e)=>_e>=Y.length-2?t.util.nearestLargerEven(Y[_e]):Y[_e])).length===1&&(Y=[2,Y[0]])),Y.length!==2&&(Y=t.util.squeezeShape(Y).newShape);let Pe=t.util.sizeFromShape(Y);if(Y.length<=1&&Pe<=fe)return[1,Pe];if(Y.length===2&&Y[0]<=fe&&Y[1]<=fe)return Y;if(Y.length===3&&Y[0]*Y[1]<=fe&&Y[2]<=fe)return[Y[0]*Y[1],Y[2]];if(Y.length===3&&Y[0]<=fe&&Y[1]*Y[2]<=fe)return[Y[0],Y[1]*Y[2]];if(Y.length===4&&Y[0]*Y[1]*Y[2]<=fe&&Y[3]<=fe)return[Y[0]*Y[1]*Y[2],Y[3]];if(Y.length===4&&Y[0]<=fe&&Y[1]*Y[2]*Y[3]<=fe)return[Y[0],Y[1]*Y[2]*Y[3]];if(Ce){const Le=He(Y);let _e=2,je=2;return Y.length&&([_e,je]=me(Y)),Pe=Le*(_e/2)*(je/2),t.util.sizeToSquarishShape(Pe).map(qt=>2*qt)}return t.util.sizeToSquarishShape(Pe)}(d,T),o.texShape=te),f!=null){const Y=et(d);let Ce,fe=te[1],Pe=te[0];const Le=f instanceof Uint8Array||f instanceof Uint8ClampedArray;!T&&Le||([fe,Pe]=l(te[0],te[1])),Ce=T?new or(Y,Le):new Ln(Y,Le);const _e=Le?[Pe,fe]:te,je=this.makeTensorInfo(_e,c),qt=this.texData.get(je.dataId);qt.usage=Le?D.PIXELS:D.UPLOAD,qt.texShape=_e,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(je.dataId),fe,Pe,f);const sn=[[Pe,fe]],vn=!0,En=this.runWebGLProgram(Ce,[je],c,sn,vn),Cn=this.texData.get(En.dataId);o.texShape=Cn.texShape,o.isPacked=Cn.isPacked,o.usage=Cn.usage,Object(t.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(En.dataId):(o.texture=Cn.texture,o.values=null,this.texData.delete(En.dataId)),this.disposeIntermediateTensorInfo(je),P&&(this.uploadWaitMs+=t.util.now()-z)}else{const Y=this.acquireTexture(te,C,c,T);o.texture=Y}}convertAndCacheOnCPU(a,o){const d=this.texData.get(a),{dtype:c}=d;return this.releaseGPUData(a),o!=null&&(d.values=function(f,w){if(w==="float32"||w==="complex64")return f;if(w==="int32"||w==="bool"){const C=w==="int32"?new Int32Array(f.length):new Uint8Array(f.length);for(let T=0;T<C.length;++T)C[T]=Math.round(f[T]);return C}throw new Error(`Unknown dtype ${w}`)}(o,c)),d.values}acquireTexture(a,o,d,c){if(this.numBytesInGPU+=this.computeBytes(a,d),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const f=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${f} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(a,o,c)}computeBytes(a,o){return a[0]*a[1]*t.util.bytesPerElement(o)}checkCompileCompletion(){for(const[,a]of Object.entries(this.binaryCache))this.checkCompletion_(a)}async checkCompileCompletionAsync(){const a=[];if(this.gpgpu.parallelCompilationExtension){for(const[,o]of Object.entries(this.binaryCache))a.push(this.checkCompletionAsync_(o));return Promise.all(a)}for(const[,o]of Object.entries(this.binaryCache)){const d=new Promise(c=>{try{this.checkCompletion_(o),c(!0)}catch(f){throw f}});a.push(d)}return Promise.all(a)}async checkCompletionAsync_(a){return this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(a):(await Object(t.nextFrame)(),this.checkCompletionAsync_(a))}checkCompletion_(a){if(this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(a.webGLProgram)),this.gpgpu.gl.getShaderParameter(a.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(W(a.source,this.gpgpu.gl.getShaderInfoLog(a.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,a]of Object.entries(this.binaryCache)){const{uniformLocations:o,customUniformLocations:d,infLoc:c,nanLoc:f,inShapesLocations:w,inTexShapesLocations:C,outShapeLocation:T,outShapeStridesLocation:P,outTexShapeLocation:z}=Ur(this.gpgpu,a.program,a.webGLProgram);a.uniformLocations=o,a.customUniformLocations=d,a.infLoc=c,a.nanLoc=f,a.inShapesLocations=w,a.inTexShapesLocations=C,a.outShapeLocation=T,a.outShapeStridesLocation=P,a.outTexShapeLocation=z}}}Ha.nextDataId=0,t.device_util.isBrowser()&&Object(t.registerBackend)("webgl",()=>new Ha,2);class qa{constructor(a,o,d){this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(o,d),this.enableShapeUniforms=ir(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${a}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ea{constructor(a,o,d,c=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(o,d);const f=this.outputShape.length;this.enableShapeUniforms=ir(f);let w="";if(c)if(f===0||t.util.sizeFromShape(this.outputShape)===1)w=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(w=`
          ${oe(f)} coords = getOutputCoords();
        `,f===1)this.enableShapeUniforms?w+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:w+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const C=_n("coords",f);this.enableShapeUniforms?w+=`
            bool nextRowOutOfBounds =
              (${C[f-2]} + 1) >= outShape[${f} - 2];
            bool nextColOutOfBounds =
              (${C[f-1]} + 1) >= outShape[${f} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:w+=`
            bool nextRowOutOfBounds =
              (${C[f-2]} + 1) >= ${this.outputShape[f-2]};
            bool nextColOutOfBounds =
              (${C[f-1]} + 1) >= ${this.outputShape[f-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${a}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ta(k){const{inputs:a,backend:o}=k,{x:d}=a;return o.incRef(d.dataId),{dataId:d.dataId,shape:d.shape,dtype:d.dtype}}const Ys={kernelName:t.Identity,backendName:"webgl",kernelFunc:ta};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(k){const{inputs:a,backend:o}=k,{real:d,imag:c}=a,f=o.makeTensorInfo(d.shape,"complex64"),w=o.texData.get(f.dataId),C=ta({inputs:{x:d},backend:o}),T=ta({inputs:{x:c},backend:o});return w.complexTensorInfos={real:C,imag:T},f}const Aa={kernelName:t.Complex,backendName:"webgl",kernelFunc:ia},es="return (a < 0.) ? b * a : a;",gs=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hi={kernelName:t.LeakyRelu,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{alpha:f}=d,w=o.makeTensorInfo([],"float32",t.util.createScalarValue(f,"float32")),C=Object(t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ea(gs,c.shape,w.shape):new qa(es,c.shape,w.shape),T=o.runWebGLProgram(C,[c,w],"float32");return o.disposeIntermediateTensorInfo(w),T}},xs="return (a < 0.) ? b * a : a;",us=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pi={kernelName:t.Prelu,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{x:d,alpha:c}=a,f=Object(t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ea(us,d.shape,c.shape):new qa(xs,d.shape,c.shape);return o.runWebGLProgram(f,[d,c],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr({opSnippet:k,packedOpSnippet:a,cpuKernelImpl:o,dtype:d}){return({inputs:c,backend:f})=>{const{x:w}=c,C=f,T=d||w.dtype;if(C.shouldExecuteOnCPU([w])&&o!=null){const z=C.texData.get(w.dataId),te=o(z.values,T);return C.makeTensorInfo(w.shape,T,te)}let P;return P=Object(t.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&a!=null?new $a(w.shape,a):new Yr(w.shape,k),C.runWebGLProgram(P,[w],T)}}function Jr({opSnippet:k,packedOpSnippet:a,checkOutOfBounds:o=!1,supportsComplex:d=!1,cpuKernelImpl:c,dtype:f}){return({inputs:w,backend:C})=>{const{a:T,b:P}=w,z=C;if(d&&T.dtype==="complex64"){const Ce=z.texData.get(T.dataId),fe=z.texData.get(P.dataId),[Pe,Le]=[[Ce.complexTensorInfos.real,fe.complexTensorInfos.real],[Ce.complexTensorInfos.imag,fe.complexTensorInfos.imag]].map(je=>{const[qt,sn]=je,vn={dataId:qt.dataId,dtype:qt.dtype,shape:T.shape},En={dataId:sn.dataId,dtype:sn.dtype,shape:P.shape},Cn=new qa(k,T.shape,P.shape);return z.runWebGLProgram(Cn,[vn,En],Object(t.upcastType)(qt.dtype,sn.dtype))}),_e=ia({inputs:{real:Pe,imag:Le},backend:z});return z.disposeIntermediateTensorInfo(Pe),z.disposeIntermediateTensorInfo(Le),_e}const te=f||Object(t.upcastType)(T.dtype,P.dtype);if((T.dtype==="string"||P.dtype==="string"||z.shouldExecuteOnCPU([T,P]))&&c!=null){const Ce=z.texData.get(T.dataId).values,fe=z.texData.get(P.dataId).values,Pe=T.dtype==="string"?t.backend_util.fromUint8ToStringArray(Ce):Ce,Le=T.dtype==="string"?t.backend_util.fromUint8ToStringArray(fe):fe,[_e,je]=c(T.shape,P.shape,Pe,Le,te),qt=z.makeTensorInfo(je,te);return z.texData.get(qt.dataId).values=_e,qt}let Y;return Y=Object(t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&a!=null?new Ea(a,T.shape,P.shape,o):new qa(k,T.shape,P.shape),z.runWebGLProgram(Y,[T,P],te)}}function za(k,a=!1){if(k==="linear")return"return x;";if(k==="relu")return a?`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : x;
`;if(k==="elu")return a?`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if(k==="relu6")return a?`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;if(k==="prelu")return a?us:xs;if(k==="leakyrelu")return a?gs:es;if(k==="sigmoid")return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${k} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Es{constructor(a,o,d,c=!1,f=!1,w=!1,C=null,T=!1,P=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d,this.enableShapeUniforms=ir(this.outputShape.length);const z=c?a[1]:a[2],te=Math.ceil(z/2),Y=c?"i * 2, rc.y":"rc.y, i * 2",Ce=f?"rc.z, i * 2":"i * 2, rc.z",fe=c?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],Pe=f?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let Le="",_e="";C&&(Le=T?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${C}
        }`:P?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${C}
        }`:`vec4 activation(vec4 x) {
          ${C}
        }`,_e="result = activation(result);");const je=w?"result += getBiasAtOutCoords();":"";w&&this.variableNames.push("bias"),T&&this.variableNames.push("preluActivationWeights"),P&&this.variableNames.push("leakyreluAlpha");let qt="rc.x",sn="rc.x";a[0]<o[0]?qt=`int(min(float(rc.x), ${a[0]-1}.))`:o[0]<a[0]&&(sn=`int(min(float(rc.x), ${o[0]-1}.))`),this.userCode=`
      ${Le}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${te}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${te}; i++) {
          int batchA = ${qt};
          int batchB = ${sn};
          vec4 a = getMatrixA(batchA, ${Y});
          vec4 b = getMatrixB(batchB, ${Ce});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${fe[0]} * ${Pe[0]});
          result += (${fe[1]} * ${Pe[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${je}

        ${_e}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qs="return areal * breal - aimag * bimag;",ts="return areal * bimag + aimag * breal;";class As{constructor(a,o,d){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(o,d),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${a}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ns="return a * b;";function vs(k){const{inputs:a,backend:o}=k,{a:d,b:c}=a,f=t.backend_util.upcastType(d.dtype,c.dtype);if(d.dtype==="complex64"){const C=o.texData.get(d.dataId),T=o.texData.get(c.dataId),P=new As(Qs,d.shape,c.shape),z=new As(ts,d.shape,c.shape),te=[{dataId:C.complexTensorInfos.real.dataId,dtype:C.complexTensorInfos.real.dtype,shape:d.shape},{dataId:C.complexTensorInfos.imag.dataId,dtype:C.complexTensorInfos.imag.dtype,shape:d.shape},{dataId:T.complexTensorInfos.real.dataId,dtype:T.complexTensorInfos.real.dtype,shape:c.shape},{dataId:T.complexTensorInfos.imag.dataId,dtype:T.complexTensorInfos.imag.dtype,shape:c.shape}],Y=o.runWebGLProgram(P,te,"float32"),Ce=o.runWebGLProgram(z,te,"float32"),fe=ia({inputs:{real:Y,imag:Ce},backend:o});return o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Ce),fe}if(o.shouldExecuteOnCPU([d,c])){const C=o.texData.get(d.dataId),T=o.texData.get(c.dataId),[P,z]=Pa(d.shape,c.shape,C.values,T.values,f),te=o.makeTensorInfo(z,f);return o.texData.get(te.dataId).values=P,te}let w;return w=Object(t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ea(Ns,d.shape,c.shape):new qa(Ns,d.shape,c.shape),o.runWebGLProgram(w,[d,c],f)}const Yn={kernelName:t.Multiply,backendName:"webgl",kernelFunc:vs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function In(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{shape:f}=d,w=o,C=t.util.sizeFromShape(c.shape),T=t.util.inferFromImplicitShape(f,C),P=t.util.sizeFromShape(T);t.util.assert(C===P,()=>`The new shape (${T}) has ${P} elements and the old shape (${c.shape}) has ${C} elements. The new shape and old shape must have the same number of elements.`);const z=w.texData.get(c.dataId);return!z.isPacked||It(c.shape,T)||z.texture!==null&&It(z.shape,T)?(w.incRef(c.dataId),{dataId:c.dataId,shape:T,dtype:c.dtype}):function(te,Y,Ce){const fe=[He(te.shape),...me(te.shape)],Pe={dtype:te.dtype,shape:fe,dataId:te.dataId},Le=[He(Y),...me(Y)],_e=new ar(Le,fe),je=[fe],qt=Ce.runWebGLProgram(_e,[Pe],te.dtype,je,!0);return{dataId:qt.dataId,shape:Y,dtype:qt.dtype}}(c,T,w)}const Fr={kernelName:t.Reshape,backendName:"webgl",kernelFunc:In};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sn{constructor(a,o){this.variableNames=["x"];const{windowSize:d,batchSize:c,inSize:f,outSize:w}=a;this.outputShape=[c,w];const C=4*Math.floor(d/4),T=d%4;let P="sumValue += dot(values, ones);";if(o!=null){const te=1/o;P=`sumValue += dot(values * ${t.util.isInt(te)?te.toPrecision(2):te}, ones);`}let z="";f%d>0&&(z=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${z}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${d};

        float sumValue = 0.0;

        for (int i = 0; i < ${C}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${P}
        }

        int inIdx = inOffset + ${C};
        if (${T===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${P}
        } else if (${T===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${P}
        } else if (${T===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${P}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sa{constructor(a,o){this.variableNames=["x"];const{windowSize:d,batchSize:c,inSize:f,outSize:w}=a;this.outputShape=[c,w];let C="0.0",T="";o==="prod"?C="1.0":o==="min"?(C="1.0 / 1e-20",T="min"):o==="max"&&(C="-1.0 / 1e-20",T="max");let P=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="sum"?P="sumValue":o==="prod"?P="prodValue":o==="all"?P="allValue":o==="any"&&(P="anyValue");const z=4*Math.floor(d/4),te=d%4;let Y=`
      if (${o==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${o==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${T}(values, minMaxValue);
        if (${o==="min"} || ${o==="max"}) {
          minMaxValue = ${T}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,Ce="vec4";o==="all"?(C="1.0",Y=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,Ce="bvec4"):o==="any"&&(C="0.0",Y=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,Ce="bvec4");let fe="";f%d>0&&(fe=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${fe}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${d};

        vec4 minMaxValue = vec4(${C});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${z}; i += 4) {
          int inIdx = inOffset + i;
          ${Ce} values = ${Ce}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${Y}
        }

        int inIdx = inOffset + ${z};
        if (${te===1}) {
          ${Ce} values = ${Ce}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${Y}
        } else if (${te===2}) {
          ${Ce} values = ${Ce}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${Y}
        } else if (${te===3}) {
          ${Ce} values = ${Ce}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${Y}
        }
        setOutput(${P});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function na(k,a,o,d){const c=function(w){const C=[];for(;C.length===0||C[C.length-1].outSize!==1;){const T=C.length?C[C.length-1].outSize:w[1],P=t.backend_util.computeOptimalWindowSize(T);C.push({inSize:T,windowSize:P,outSize:Math.ceil(T/P)})}return C}(k.shape);let f=k;for(let w=0;w<c.length;w++){const{inSize:C,windowSize:T,outSize:P}=c[w];let z,te;z=o==="mean"?w===0?new Sn({windowSize:T,inSize:C,batchSize:k.shape[0],outSize:P},C):new Sn({windowSize:T,inSize:C,batchSize:k.shape[0],outSize:P}):new Sa({windowSize:T,inSize:C,batchSize:k.shape[0],outSize:P},o),te=f,f=d.runWebGLProgram(z,[f],a),te.dataId!==k.dataId&&d.disposeIntermediateTensorInfo(te)}return f}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pa{constructor(a,o){this.variableNames=["A"];const d=new Array(a.length);for(let w=0;w<d.length;w++)d[w]=a[o[w]];this.outputShape=d,this.rank=d.length;const c=oe(this.rank),f=function(w){const C=w.length;if(C>6)throw Error(`Transpose for rank ${C} is not yet supported`);const T=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],P=new Array(C);for(let z=0;z<w.length;z++)P[w[z]]=T[z];return P.join()}(o);this.userCode=`
    void main() {
      ${c} resRC = getOutputCoords();
      setOutput(getA(${f}));
    }
    `}}class Zs{constructor(a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const d=new Array(a.length);for(let z=0;z<d.length;z++)d[z]=a[o[z]];if(this.outputShape=d,this.rank=d.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const c=oe(this.rank),f=Zt("rc",this.rank),w=new Array(this.rank);for(let z=0;z<o.length;z++)w[o[z]]=f[z];const C=`vec2(${w.slice(-2).join()})`,T=`++${f[this.rank-1]} < ${d[this.rank-1]}`,P=`getChannel(getA(${w.join()}), ${C})`;this.userCode=`
    void main() {
      ${c} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${P};
      if(${T}) {
        result[1] = ${P};
      }
      --${f[this.rank-1]};
      if(++${f[this.rank-2]} < ${d[this.rank-2]}) {
        result[2] = ${P};
        if(${T}) {
          result[3] = ${P};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(k,a,o){const d=Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zs(k.shape,a):new pa(k.shape,a);return o.runWebGLProgram(d,[k],k.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cs(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,keepDims:w}=d;return function(C,T,P,z){const te=T,Y=C.shape.length,Ce=t.util.parseAxisParam(te,C.shape);let fe=Ce;const Pe=t.backend_util.getAxesPermutation(fe,Y),Le=Pe!=null;let _e=C;Le&&(_e=ys(C,Pe,z),fe=t.backend_util.getInnerMostAxes(fe.length,Y)),t.backend_util.assertAxesAreInnerMostDims("sum",fe,Y);const[je,qt]=t.backend_util.computeOutAndReduceShapes(_e.shape,fe);let sn=je;P&&(sn=t.backend_util.expandShapeToKeepDim(je,Ce));const vn=t.util.sizeFromShape(qt),En=In({inputs:{x:_e},attrs:{shape:[t.util.sizeFromShape(C.shape)/vn,vn]},backend:z}),Cn=na(En,Object(t.sumOutType)(C.dtype),"sum",z),An=In({inputs:{x:Cn},attrs:{shape:sn},backend:z});return z.disposeIntermediateTensorInfo(En),z.disposeIntermediateTensorInfo(Cn),Le&&z.disposeIntermediateTensorInfo(_e),An}(c,f,w,o)}const xi={kernelName:t.Sum,backendName:"webgl",kernelFunc:cs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{perm:f}=d,w=o,C=c.shape.length,T=new Array(C);for(let z=0;z<T.length;z++)T[z]=c.shape[f[z]];let P;if(w.shouldExecuteOnCPU([c])){const z=w.texData.get(c.dataId).values,te=Vt(z,c.shape,c.dtype,f,T);P=w.makeTensorInfo(T,c.dtype),w.texData.get(P.dataId).values=te}else P=ys(c,f,w);return P}const Ua={kernelName:t.Transpose,backendName:"webgl",kernelFunc:ra};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls({a:k,b:a,transposeA:o,transposeB:d,backend:c,bias:f=null,preluActivationWeights:w=null,leakyreluAlpha:C=0,activation:T=null}){const P=k.shape.length,z=a.shape.length,te=o?k.shape[P-2]:k.shape[P-1],Y=d?a.shape[z-1]:a.shape[z-2],Ce=o?k.shape[P-1]:k.shape[P-2],fe=d?a.shape[z-2]:a.shape[z-1],Pe=k.shape.slice(0,-2),Le=a.shape.slice(0,-2),_e=t.util.sizeFromShape(Pe),je=t.util.sizeFromShape(Le),qt=t.broadcast_util.assertAndGetBroadcastShape(k.shape.slice(0,-2),a.shape.slice(0,-2)).concat([Ce,fe]);t.util.assert(te===Y,()=>`Error in matMul: inner shapes (${te}) and (${Y}) of Tensors with shapes ${k.shape} and ${a.shape} and transposeA=${o} and transposeB=${d} must match.`);const sn=o?[_e,te,Ce]:[_e,Ce,te],vn=d?[je,fe,Y]:[je,Y,fe],En=In({inputs:{x:k},backend:c,attrs:{shape:sn}}),Cn=In({inputs:{x:a},backend:c,attrs:{shape:vn}}),An=[En,Cn],kn=Math.max(_e,je),Jn=o?En.shape[1]:En.shape[2],qn=f!=null,s=w!=null,r=T==="leakyrelu",i=T!=null?za(T,!0):null;let u;if((Ce===1||fe===1)&&Jn>1e3&&(qn||s||r||i!=null)===!1){let _=En,$=Cn;o&&(_=ra({inputs:{x:En},backend:c,attrs:{perm:[0,2,1]}}),An.push(_)),d&&($=ra({inputs:{x:Cn},backend:c,attrs:{perm:[0,2,1]}}),An.push($));const U=fe===1;let re=_;fe!==1&&(re=In({inputs:{x:_},backend:c,attrs:{shape:[kn,Jn,1]}}),An.push(re));const pe=fe===1?2:1;let ze=$;U&&(ze=In({inputs:{x:$},backend:c,attrs:{shape:[kn,1,Jn]}}),An.push(ze));const Me=vs({inputs:{a:re,b:ze},backend:c});u=cs({inputs:{x:Me},backend:c,attrs:{axis:pe,keepDims:!0}}),An.push(Me)}else{const _=Object(t.upcastType)(k.dtype,a.dtype),$=new Es(sn,vn,[kn,Ce,fe],o,d,qn,i,s,r),U=[En,Cn];if(f!=null&&U.push(f),s&&U.push(w),r){const re=c.makeTensorInfo([],"float32",t.util.createScalarValue(C,"float32"));U.push(re),An.push(re)}u=c.runWebGLProgram($,U,_)}const p=In({inputs:{x:u},backend:c,attrs:{shape:qt}});An.push(u);for(const _ of An)c.disposeIntermediateTensorInfo(_);return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tr={kernelName:t._FusedMatMul,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{a:c,b:f,bias:w,preluActivationWeights:C}=a,{transposeA:T,transposeB:P,activation:z,leakyreluAlpha:te}=d;return ls({a:c,b:f,transposeA:T,transposeB:P,backend:o,bias:w,preluActivationWeights:C,leakyreluAlpha:te,activation:z})}},Ka="return abs(x);";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rs={kernelName:t.Abs,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{x:d}=a;if(o.shouldExecuteOnCPU([d])&&d.dtype!=="complex64"){const f=o.texData.get(d.dataId),w=_a(f.values);return o.makeTensorInfo(d.shape,d.dtype,w)}let c;return c=Object(t.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $a(d.shape,Ka):new Yr(d.shape,Ka),o.runWebGLProgram(c,[d],d.dtype)}},Js=pr({opSnippet:`if (isnan(x)) return x;
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),ws={kernelName:t.Acos,backendName:"webgl",kernelFunc:Js},ks=pr({opSnippet:`if (isnan(x)) return x;
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),ur={kernelName:t.Acosh,backendName:"webgl",kernelFunc:ks},Fs="return a + b;",va=Jr({opSnippet:Fs,packedOpSnippet:Fs,supportsComplex:!0,cpuKernelImpl:tn}),ei={kernelName:t.Add,backendName:"webgl",kernelFunc:va};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ms{constructor(a,o){this.outputShape=[],this.outputShape=a,this.variableNames=o.map((f,w)=>`T${w}`);const d=[];this.variableNames.forEach(f=>{d.push(`float v${f} = get${f}AtOutCoords();`)});const c=this.variableNames.map(f=>`v${f}`).join(" + ");this.userCode=`
      void main() {
        ${d.join(`
        `)}

        float result = ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ds{constructor(a,o){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.variableNames=o.map((f,w)=>`T${w}`);const d=[];this.variableNames.forEach(f=>{d.push(`vec4 v${f} = get${f}AtOutCoords();`)});const c=this.variableNames.map(f=>`v${f}`).join(" + ");this.userCode=`
      void main() {
        ${d.join(`
        `)}

        vec4 result = ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti={kernelName:t.AddN,backendName:"webgl",kernelFunc:function k(a){const{inputs:o,backend:d}=a,c=o;if(c.length===1)return ta({inputs:{x:c[0]},backend:d});if(c.length>Object(t.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const T=Math.floor(c.length/2),P=k({inputs:c.slice(0,T),backend:d}),z=k({inputs:c.slice(T),backend:d});return k({inputs:[P,z],backend:d})}const f=c.map(T=>T.dtype).reduce((T,P)=>Object(t.upcastType)(T,P)),w=c.map(T=>T.shape),C=Object(t.env)().getBool("WEBGL_PACK")?new Ds(c[0].shape,w):new Ms(c[0].shape,w);return d.runWebGLProgram(C,c,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ps={kernelName:t.All,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,keepDims:w}=d,C=c.shape.length,T=t.util.parseAxisParam(f,c.shape);let P=T;const z=t.backend_util.getAxesPermutation(P,C);let te=c;z!=null&&(te=ra({inputs:{x:c},backend:o,attrs:{perm:z}}),P=t.backend_util.getInnerMostAxes(P.length,C)),t.backend_util.assertAxesAreInnerMostDims("all",P,C);const[Y,Ce]=t.backend_util.computeOutAndReduceShapes(te.shape,P),fe=In({inputs:{x:te},backend:o,attrs:{shape:[-1,t.util.sizeFromShape(Ce)]}}),Pe=na(fe,fe.dtype,"all",o);let Le;return w?Le=In({inputs:{x:Pe},backend:o,attrs:{shape:t.backend_util.expandShapeToKeepDim(Y,T)}}):Le=In({inputs:{x:Pe},backend:o,attrs:{shape:Y}}),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(Pe),z!=null&&o.disposeIntermediateTensorInfo(te),Le}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ns={kernelName:t.Any,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,keepDims:w}=d,C=c.shape.length,T=t.util.parseAxisParam(f,c.shape);let P=T;const z=t.backend_util.getAxesPermutation(P,C);let te=c;z!=null&&(te=ra({inputs:{x:c},backend:o,attrs:{perm:z}}),P=t.backend_util.getInnerMostAxes(P.length,C)),t.backend_util.assertAxesAreInnerMostDims("any",P,C);const[Y,Ce]=t.backend_util.computeOutAndReduceShapes(te.shape,P),fe=In({inputs:{x:te},backend:o,attrs:{shape:[-1,t.util.sizeFromShape(Ce)]}}),Pe=na(fe,fe.dtype,"any",o);let Le;return w?Le=In({inputs:{x:Pe},backend:o,attrs:{shape:t.backend_util.expandShapeToKeepDim(Y,T)}}):Le=In({inputs:{x:Pe},backend:o,attrs:{shape:Y}}),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(Pe),z!=null&&o.disposeIntermediateTensorInfo(te),Le}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bs{constructor(a,o,d){this.variableNames=["A"];const{windowSize:c,batchSize:f,outSize:w}=a;d||this.variableNames.push("bestIndicesA"),this.outputShape=[f,w];const C=o==="max"?">":"<",T=d?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${c};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${c}; i++) {
          int inIdx = ${T};
          float candidate = getA(batch, inIdx);
          if (candidate ${C} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai{constructor(a,o,d,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,t.util.assert(a.length>2,()=>`Packed arg${d.charAt(0).toUpperCase()+d.slice(1)} supports only inputs with rank above 2.`);const f=a[a.length-1],w=Math.ceil(f/o);this.outputShape=a.slice(0,-1),w>1&&this.outputShape.push(w),c||this.variableNames.push("bestIndicesA");const C=this.outputShape,T=C.length,P=oe(T),z=_n("coords",T);let te,Y;if(w===1){Y=T+1;const An=oe(Y);te=`
        ${An} sourceLocR = ${An}(${z.join()}, 0);
        ++${z[T-1]};
        ${An} sourceLocG = ${An}(${z.join()}, 0);
        ++${z[T-2]};
        ${An} sourceLocA = ${An}(${z.join()}, 0);
        --${z[T-1]};
        ${An} sourceLocB = ${An}(${z.join()}, 0);
        --${z[T-2]};`}else Y=T,te=`
        ${P} sourceLocR = coords;
        ++${z[T-1]};
        ${P} sourceLocG = coords;
        ++${z[T-2]};
        ${P} sourceLocA = coords;
        --${z[T-1]};
        ${P} sourceLocB = coords;
        --${z[T-2]};`;const Ce=["x","y","z","w","u","v"].slice(0,Y),fe="."+Ce[Y-1],Pe=Ce.map(An=>"int "+An),Le=_n("sourceLocR",Y-1).concat("inIdx.r"),_e=_n("sourceLocG",Y-1).concat("inIdx.g"),je=_n("sourceLocB",Y-1).concat("inIdx.b"),qt=_n("sourceLocA",Y-1).concat("inIdx.a"),sn=d==="max"?"greaterThan":"lessThan",vn=c?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${Le.join()}),
                             getBestIndicesAChannel(${_e.join()}),
                             getBestIndicesAChannel(${je.join()}),
                             getBestIndicesAChannel(${qt.join()})));`,En=`vec4(
            getAChannel(${Le.join()}),
            hasNextCol ? getAChannel(${_e.join()}) : 0.,
            hasNextRow ? getAChannel(${je.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${qt.join()}) : 0.)`,Cn=c?"":`
      float getBestIndicesAChannel(${Pe.join()}) {
        return getChannel(getBestIndicesA(${Ce.join()}),
                                          vec2(${Ce.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${Pe.join()}) {
        return getChannel(getA(${Ce.join()}),
                               vec2(${Ce.slice(-2).join()}));
      }
      ${Cn}
      void main() {
        ${P} coords = getOutputCoords();
        bool hasNextCol = ${z[T-1]} < ${C[T-1]-1};
        bool hasNextRow = ${z[T-2]} < ${C[T-2]-1};
        ${te}
        ivec4 srcIdx = ivec4(sourceLocR${fe}, sourceLocG${fe},
          sourceLocB${fe}, sourceLocA${fe}) * ${o};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${En};

        for (int i = 0; i < ${o}; i++) {
          inIdx = srcIdx;
          ${vn}
          vec4 candidate = ${En};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${sn}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ls(k,a,o,d=null){let c=a.shape[0],f=a.shape[1];d!=null&&(c=d.shape[0],f=d.shape[1]);const w=t.backend_util.computeOptimalWindowSize(f),C={windowSize:w,inSize:f,batchSize:c,outSize:Math.ceil(f/w)},T=new Bs(C,o,d==null),P=[a];d!=null&&P.push(d);const z=k.runWebGLProgram(T,P,"int32");if(z.shape[1]===1)return z;const te=Ls(k,a,o,z);return k.disposeIntermediateTensorInfo(z),te}function rs(k,a,o,d=null){const c=d!=null?d.shape:a.shape,f=c[c.length-1],w=t.backend_util.computeOptimalWindowSize(f),C=new Ai(c,w,o,d==null),T=d==null?[a]:[a,d],P=k.runWebGLProgram(C,T,"int32");if(P.shape.length===a.shape.length){const z=rs(k,a,o,P);return k.disposeIntermediateTensorInfo(P),z}return P}function ni(k,a,o,d){const c=[o];if(t.backend_util.assertAxesAreInnerMostDims("arg"+d.charAt(0).toUpperCase()+d.slice(1),c,a.shape.length),!Object(t.env)().getBool("WEBGL_PACK_REDUCE")||a.shape.length<=2){const f=[],w=k.texData.get(a.dataId);let C=a;w!==null&&w.isPacked&&(C=k.unpackTensor(a),f.push(C));const[T,P]=t.backend_util.computeOutAndReduceShapes(C.shape,c),z=t.util.sizeFromShape(P),te=In({inputs:{x:C},backend:k,attrs:{shape:[-1,z]}});f.push(te);const Y=Ls(k,te,d);f.push(Y);const Ce=In({inputs:{x:Y},backend:k,attrs:{shape:T}});return f.forEach(fe=>k.disposeIntermediateTensorInfo(fe)),Ce}return rs(k,a,d)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const js={kernelName:t.ArgMax,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f}=d;let w=t.util.parseAxisParam(f,c.shape);const C=t.backend_util.getAxesPermutation(w,c.shape.length);let T=c;const P=[];C!=null&&(T=ra({inputs:{x:c},backend:o,attrs:{perm:C}}),P.push(T),w=t.backend_util.getInnerMostAxes(w.length,T.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[w[0]],T.shape.length);const z=ni(o,T,w[0],"max");return P.forEach(te=>o.disposeIntermediateTensorInfo(te)),z}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ni={kernelName:t.ArgMin,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f}=d;let w=t.util.parseAxisParam(f,c.shape);const C=t.backend_util.getAxesPermutation(w,c.shape.length);let T=c;const P=[];C!=null&&(T=ra({inputs:{x:c},backend:o,attrs:{perm:C}}),P.push(T),w=t.backend_util.getInnerMostAxes(w.length,T.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[w[0]],T.shape.length);const z=ni(o,T,w[0],"min");return P.forEach(te=>o.disposeIntermediateTensorInfo(te)),z}},_s=pr({opSnippet:`if (isnan(x)) return x;
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),zs={kernelName:t.Asin,backendName:"webgl",kernelFunc:_s},ri=pr({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),vi={kernelName:t.Asinh,backendName:"webgl",kernelFunc:ri},Ri=pr({opSnippet:`if (isnan(x)) return x;
  return atan(x);
`}),Fi={kernelName:t.Atan,backendName:"webgl",kernelFunc:Ri},yi=Jr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),Ne={kernelName:t.Atan2,backendName:"webgl",kernelFunc:yi},ue=pr({opSnippet:`if (isnan(x)) return x;
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`}),Be={kernelName:t.Atanh,backendName:"webgl",kernelFunc:ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xe{constructor(a,o,d,c=!1,f=!1){if(this.variableNames=["x"],o==="avg"&&d)throw new Error("Cannot compute positions for average pool.");const w=a.filterWidth,C=a.strideHeight,T=a.strideWidth,P=a.dilationHeight,z=a.dilationWidth,te=a.effectiveFilterHeight,Y=a.effectiveFilterWidth,Ce=a.padInfo.top,fe=a.padInfo.left;this.outputShape=a.outShape;const Pe=o==="avg",Le=`((batch  * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + d`,_e=`(xR * ${a.inWidth} + xC) * ${a.inChannels} + d`;let je="0.0";if(Pe||(je="-1.0 / 1e-20"),d){const Cn=">=";return void(this.userCode=`
        const ivec2 strides = ivec2(${C}, ${T});
        const ivec2 pads = ivec2(${Ce}, ${fe});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${te};
              wR += ${P}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Y};
                wC += ${z}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${Cn} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${c?f?Le:_e:`wR * ${Y} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let qt=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="avg"&&(qt="avgValue / count");const sn=4*Math.floor(w/4),vn=w%4,En=`
      if (${Pe}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${C}, ${T});
      const ivec2 pads = ivec2(${Ce}, ${fe});
      const float initializationValue = ${je};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${a.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${je});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${te};
            wR += ${P}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${a.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${sn}; wC += 4) {
            int xC = xCCorner + wC * ${z};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${z}, d),
              getValue(batch, xR, xC + 2 * ${z}, d),
              getValue(batch, xR, xC + 3 * ${z}, d)
            );

            ${En}
          }

          int xC = xCCorner + ${sn};
          if (${vn===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${En}
          } else if (${vn===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${z}, d),
              initializationValue,
              initializationValue
            );

            ${En}
          } else if (${vn===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${z}, d),
              getValue(batch, xR, xC + 2 * ${z}, d),
              initializationValue
            );

            ${En}
          }
        }
        setOutput(${qt});
      }
    `}}class Te{constructor(a,o,d,c=!1,f=!1){if(this.variableNames=["x"],o==="avg"&&d)throw new Error("Cannot compute positions for average pool.");const w=a.filterWidth,C=a.strideDepth,T=a.strideHeight,P=a.strideWidth,z=a.dilationDepth,te=a.dilationHeight,Y=a.dilationWidth,Ce=a.effectiveFilterDepth,fe=a.effectiveFilterHeight,Pe=a.effectiveFilterWidth,Le=a.padInfo.front,_e=a.padInfo.top,je=a.padInfo.left;this.outputShape=a.outShape;const qt=o==="avg";let sn="0.0";if(qt||(sn="-1.0 / 1e-20"),d){const kn=">=";return void(this.userCode=`
        const ivec3 strides =
            ivec3(${C}, ${T}, ${P});
        const ivec3 pads = ivec3(${Le}, ${_e}, ${je});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${Ce};
              wD += ${z}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${a.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${fe};
                wR += ${te}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${a.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${Pe};
                  wC += ${Y}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${a.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${kn} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${c?f?`(((batch * ${a.inDepth} + xD) * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + ch`:`((xD * ${a.inHeight} + xR) * ${a.inWidth} + xC) * ${a.inChannels} + ch`:`wD * ${fe} * ${Pe} +
                      wR * ${Pe} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let vn=`${o}(${o}(${o}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;o==="avg"&&(vn="avgValue / count");const En=4*Math.floor(w/4),Cn=w%4,An=`
      if (${qt}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${C}, ${T}, ${P});
      const ivec3 pads = ivec3(${Le}, ${_e}, ${je});
      const float initializationValue = ${sn};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${a.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${sn});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${Ce};
            wD += ${z}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${a.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${fe};
            wR += ${te}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${En}; wC += 4) {
              int xC = xCCorner + wC * ${Y};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Y}, ch),
                getValue(batch, xD, xR, xC + 3 * ${Y}, ch)
              );

              ${An}
            }

            int xC = xCCorner + ${En};
            if (${Cn===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${An}
            } else if (${Cn===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                initializationValue,
                initializationValue
              );

              ${An}
            } else if (${Cn===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${Y}, ch),
                getValue(batch, xD, xR, xC + 2 * ${Y}, ch),
                initializationValue
              );

              ${An}
            }
          }
          setOutput(${vn});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ye={kernelName:t.AvgPool,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a;Qt(c,"avgPool");const{filterSize:f,strides:w,pad:C,dimRoundingMode:T}=d;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(w,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${w} and dilations '1'`);const P=t.backend_util.computePool2DInfo(c.shape,f,w,1,C,T);if(P.filterWidth===1&&P.filterHeight===1&&t.util.arraysEqual(P.inShape,P.outShape))return ta({inputs:{x:c},backend:o});const z=new Xe(P,"avg",!1);return o.runWebGLProgram(z,[c],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const it={kernelName:t.AvgPool3D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{filterSize:f,strides:w,pad:C,dimRoundingMode:T,dataFormat:P}=d,z=t.backend_util.computePool3DInfo(c.shape,f,w,[1,1,1],C,T,P),te=new Te(z,"avg",!1);return o.runWebGLProgram(te,[c],"float32")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xt{constructor(a){this.variableNames=["dy"],this.outputShape=a.inShape;const o=a.filterHeight,d=a.filterWidth,c=a.strideHeight,f=a.strideWidth,w=a.dilationHeight,C=a.dilationWidth,T=a.effectiveFilterHeight,P=a.effectiveFilterWidth,z=T-1-a.padInfo.top,te=P-1-a.padInfo.left,Y=1/(o*d);this.userCode=`
      const ivec2 pads = ivec2(${z}, ${te});
      const float avgMultiplier = float(${Y});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${T};
            wR += ${w}) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${P};
            wC+= ${C}) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class ut{constructor(a){this.variableNames=["dy"],this.outputShape=a.inShape;const o=a.filterDepth,d=a.filterHeight,c=a.filterWidth,f=a.strideDepth,w=a.strideHeight,C=a.strideWidth,T=a.dilationDepth,P=a.dilationHeight,z=a.dilationWidth,te=a.effectiveFilterDepth,Y=a.effectiveFilterHeight,Ce=a.effectiveFilterWidth,fe=te-1-a.padInfo.front,Pe=Y-1-a.padInfo.top,Le=Ce-1-a.padInfo.left,_e=1/(o*d*c);this.userCode=`
      const ivec3 pads = ivec3(${fe}, ${Pe}, ${Le});
      const float avgMultiplier = float(${_e});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${te};
            wD += ${T}) {
          float dyD = float(dyDCorner + wD) / ${f}.0;

          if (dyD < 0.0 || dyD >= ${a.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${Y};
              wR += ${P}) {
            float dyR = float(dyRCorner + wR) / ${w}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${Ce};
                wC += ${z}) {
              float dyC = float(dyCCorner + wC) / ${C}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ft={kernelName:t.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,input:f}=a,w=f,{filterSize:C,strides:T,pad:P,dimRoundingMode:z}=d,te=t.backend_util.computePool3DInfo(w.shape,C,T,[1,1,1],P,z),Y=new ut(te);return o.runWebGLProgram(Y,[c],w.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pt={kernelName:t.AvgPoolGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,input:f}=a,w=f;Qt([c,f],"avgPoolGrad");const{filterSize:C,strides:T,pad:P}=d,z=t.backend_util.computePool2DInfo(w.shape,C,T,1,P),te=new xt(z);return o.runWebGLProgram(te,[c],w.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zt={kernelName:t.BatchMatMul,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{a:c,b:f}=a,{transposeA:w,transposeB:C}=d;return ls({a:c,b:f,transposeA:w,transposeB:C,backend:o})}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dt{constructor(a,o,d,c,f,w){this.outputShape=[],this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(a,o),t.backend_util.assertAndGetBroadcastShape(a,d);let C="0.0";c!=null&&(t.backend_util.assertAndGetBroadcastShape(a,c),this.variableNames.push("offset"),C="getOffsetAtOutCoords()");let T="1.0";f!=null&&(t.backend_util.assertAndGetBroadcastShape(a,f),this.variableNames.push("scale"),T="getScaleAtOutCoords()"),this.outputShape=a,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${C};
        float scale = ${T};
        float inv = scale * inversesqrt(variance + float(${w}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class We{constructor(a,o,d,c,f,w){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(a,o),t.backend_util.assertAndGetBroadcastShape(a,d);let C="vec4(0.0)";c!=null&&(t.backend_util.assertAndGetBroadcastShape(a,c),this.variableNames.push("offset"),C="getOffsetAtOutCoords()");let T="vec4(1.0)";f!=null&&(t.backend_util.assertAndGetBroadcastShape(a,f),this.variableNames.push("scale"),T="getScaleAtOutCoords()"),this.outputShape=a,this.userCode=`
      void main() {
        vec4 offset = ${C};
        vec4 scale = ${T};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${w}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _t={kernelName:t.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:k,backend:a,attrs:o})=>{const{x:d,mean:c,variance:f,offset:w,scale:C}=k;t.util.assert(c.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),t.util.assert(w==null||c.shape.length===w.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),t.util.assert(C==null||c.shape.length===C.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:T}=o;T==null&&(T=.001);const P=[d,c,f];let z=null;w!=null&&(z=w.shape,P.push(w));let te=null;C!=null&&(te=C.shape,P.push(C));const Y=Object(t.env)().getBool("WEBGL_PACK_NORMALIZATION")?new We(d.shape,c.shape,f.shape,z,te,T):new Dt(d.shape,c.shape,f.shape,z,te,T);return a.runWebGLProgram(Y,P,P[0].dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jt{constructor(a){this.variableNames=["source"],this.outputShape=a,this.rank=a.length;const o=oe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const d=function(f){if(f===1)return"sourceLoc";if(f<=6)return Xt.slice(0,f).map(w=>"sourceLoc."+w).join(",");throw Error(`Slicing for rank ${f} is not yet supported`)}(this.rank);let c;c=`
        ${o} sourceLoc;
        ${o} coords = getOutputCoords();
        ${a.map((f,w)=>`sourceLoc.${Xt[w]} = start[${w}] + coords.${Xt[w]};`).join(`
`)}
      `,this.userCode=`
      void main() {
        ${c}
        setOutput(getSource(${d}));
      }
    `}}const Xt=["x","y","z","w","u","v"];class on{constructor(a){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const o=oe(this.rank),d=_n("coords",this.rank),c=_n("sourceLoc",this.rank),f=this.rank===1?"sourceLoc":`vec2(${c.slice(-2).join()})`,w=`getChannel(getSource(${c.join()}), ${f})`,C=`
      result.x = ${w};
      if (++${d[this.rank-1]} < ${a[this.rank-1]}) {
        ++${c[this.rank-1]};
        result.y = ${w};
        --${c[this.rank-1]};
      }
    `,T=this.rank===1?"":`
      --${d[this.rank-1]};
      if (++${d[this.rank-2]} < ${a[this.rank-2]}) {
        ++${c[this.rank-2]};
        result.z = ${w};
        if (++${d[this.rank-1]} < ${a[this.rank-1]}) {
          ++${c[this.rank-1]};
          result.w = ${w};
        }
      }
    `,P=this.rank<=4?`sourceLoc = coords +
            ${o}(${a.map((z,te)=>`start[${te}]`).join()});`:a.map((z,te)=>`${c[te]} = ${d[te]} + start[${te}];`).join(`
`);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        ${o} sourceLoc;
        ${P}
        vec4 result = vec4(0.);
        ${C}
        ${T}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pt(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{begin:f,size:w}=d,[C,T]=t.slice_util.parseSliceParams(c,f,w);if(t.slice_util.assertParamsValid(c,C,T),t.util.sizeFromShape(T)===0)return o.makeTensorInfo(T,c.dtype,[]);if(o.shouldExecuteOnCPU([c])||c.dtype==="string"){const te=o.texData.get(c.dataId),Y=os(te.values,C,T,c.shape,c.dtype);return o.makeTensorInfo(T,c.dtype,Y)}const{isPacked:P}=o.texData.get(c.dataId),z=t.slice_util.isSliceContinous(c.shape,C,T);if(P||!z){const te=Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new on(T):new jt(T),Y=[C];return o.runWebGLProgram(te,[c],c.dtype,Y)}return o.uploadToGPU(c.dataId),function(te,Y,Ce,fe){const Pe=fe.texData.get(te.dataId),Le=fe.makeTensorInfo(Ce,te.dtype),_e=fe.texData.get(Le.dataId);Object.assign(_e,Pe),_e.refCount=1,_e.shape=Ce,_e.dtype=te.dtype;let je=t.slice_util.computeFlatOffset(Y,t.util.computeStrides(te.shape));Pe.slice&&(je+=Pe.slice.flatOffset),_e.slice={flatOffset:je,origDataId:Pe.slice&&Pe.slice.origDataId||te.dataId};const qt=fe.dataRefCount.get(_e.slice.origDataId)||1;return fe.dataRefCount.set(_e.slice.origDataId,qt+1),Le}(c,C,T,o)}const hn={kernelName:t.Slice,backendName:"webgl",kernelFunc:Pt},Fn={kernelName:t.BatchToSpaceND,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{blockShape:f,crops:w}=d;t.util.assert(c.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const C=f.reduce((je,qt)=>je*qt),T=t.backend_util.getReshaped(c.shape,f,C),P=t.backend_util.getPermuted(T.length,f.length),z=t.backend_util.getReshapedPermuted(c.shape,f,C),te=t.backend_util.getSliceBeginCoords(w,f.length),Y=t.backend_util.getSliceSize(z,w,f.length),Ce=[],fe=In({inputs:{x:c},backend:o,attrs:{shape:T}}),Pe=ra({inputs:{x:fe},backend:o,attrs:{perm:P}}),Le=In({inputs:{x:Pe},backend:o,attrs:{shape:z}}),_e=Pt({inputs:{x:Le},backend:o,attrs:{begin:te,size:Y}});return Ce.push(fe),Ce.push(Pe),Ce.push(Le),Ce.forEach(je=>o.disposeIntermediateTensorInfo(je)),_e}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nr={kernelName:t.Bincount,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,weights:f}=a,{size:w}=d,C=o.readSync(c.dataId),T=o.readSync(f.dataId),P=bn(C,T,f.dtype,f.shape,w);return o.makeTensorInfo([w],f.dtype,P)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dr={kernelName:t.BroadcastArgs,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{s0:d,s1:c}=a,f=o.readSync(d.dataId),w=o.readSync(c.dataId),C=t.backend_util.assertAndGetBroadcastShape(Array.from(f),Array.from(w));return o.makeTensorInfo([C.length],"int32",Int32Array.from(C))}},hr=Jr({opSnippet:"return float(a != b);",cpuKernelImpl:ms,dtype:"bool"}),cr={kernelName:t.NotEqual,backendName:"webgl",kernelFunc:hr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(k){const{inputs:a,backend:o}=k,{input:d}=a;return ta({inputs:{x:o.texData.get(d.dataId).complexTensorInfos.real},backend:o})}const Sr={kernelName:t.Real,backendName:"webgl",kernelFunc:Mr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dr={kernelName:t.Cast,backendName:"webgl",kernelFunc:function k(a){const{inputs:o,backend:d,attrs:c}=a,{x:f}=o,{dtype:w}=c;if(w==="complex64"){if(f.dtype==="complex64")return ta({inputs:{x:f},backend:d});const C=t.zeros(f.shape),T=k({inputs:{x:f},backend:d,attrs:{dtype:"float32"}}),P=ia({inputs:{real:T,imag:C},backend:d});return C.dispose(),d.disposeIntermediateTensorInfo(T),P}if(f.dtype==="complex64"){const C=Mr({inputs:{input:f},backend:d}),T=k({inputs:{x:C},backend:d,attrs:{dtype:w}});return d.disposeIntermediateTensorInfo(C),T}if(!t.util.hasEncodingLoss(f.dtype,w)){const C=ta({inputs:{x:f},backend:d});return{dataId:C.dataId,shape:C.shape,dtype:w}}if(d.shouldExecuteOnCPU([f])){const C=d.texData.get(f.dataId).values,[T,P,z]=rn(C,f.shape,f.dtype,w);return d.makeTensorInfo(T,P,z)}if(w==="int32")return function(C,T){const P=new Yr(C.shape,"return float(int(x));"),z=T.runWebGLProgram(P,[C],"int32");return{dataId:z.dataId,shape:z.shape,dtype:z.dtype}}(f,d);if(w==="bool"){const C=d.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1)),T=hr({inputs:{a:f,b:C},backend:d});return d.disposeIntermediateTensorInfo(C),T}throw new Error(`Error in Cast: failed to cast ${f.dtype} to ${w}`)}},Ar="return ceil(x);",aa=pr({opSnippet:Ar,packedOpSnippet:Ar,cpuKernelImpl:Xn}),ya={kernelName:t.Ceil,backendName:"webgl",kernelFunc:aa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xa{constructor(a){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class as{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Us={kernelName:t.ClipByValue,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{clipValueMin:f,clipValueMax:w}=d;let C;C=Object(t.env)().getBool("WEBGL_PACK_CLIP")?new as(c.shape):new Xa(c.shape);const T=[[f],[w]];return o.runWebGLProgram(C,[c],c.dtype,T)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Is{constructor(a){this.variableNames=["real","imag"],this.outputShape=a,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(k,a){return{dataId:a.dataId,dtype:a.dtype,shape:k.shape}}const ds={kernelName:t.ComplexAbs,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{x:d}=a,c=o.texData.get(d.dataId),f=new Is(d.shape),w=[Ya(d,c.complexTensorInfos.real),Ya(d,c.complexTensorInfos.imag)];return o.runWebGLProgram(f,w,w[0].dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hs{constructor(a){this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(a,1),this.variableNames=a.map((w,C)=>`T${C}`);const o=new Array(a.length-1);o[0]=a[0][1];for(let w=1;w<o.length;w++)o[w]=o[w-1]+a[w][1];const d=[`if (yC < ${o[0]}) setOutput(getT0(yR, yC));`];for(let w=1;w<o.length;w++){const C=o[w-1];d.push(`else if (yC < ${o[w]}) setOutput(getT${w}(yR, yC-${C}));`)}const c=o.length,f=o[o.length-1];d.push(`else setOutput(getT${c}(yR, yC-${f}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${d.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ws{constructor(a,o){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(a,o);const d=this.outputShape,c=d.length,f=oe(c),w=_n("coords",c),C=["x","y","z","w","u","v"].slice(0,c);this.variableNames=a.map((Pe,Le)=>`T${Le}`);const T=new Array(a.length-1);T[0]=a[0][o];for(let Pe=1;Pe<T.length;Pe++)T[Pe]=T[Pe-1]+a[Pe][o];const P=C[o],z=C.slice(-2),te=C.join();let Y=`if (${P} < ${T[0]}) {
        return getChannel(
            getT0(${te}), vec2(${z.join()}));
        }`;for(let Pe=1;Pe<T.length;Pe++){const Le=T[Pe-1];Y+=`
        if (${P} < ${T[Pe]}  && ${P} >= ${T[Pe-1]}) {
          return getChannel(
            getT${Pe}(${fa(C,P,Le)}),
            vec2(${fa(z,P,Le)}));
        }`}const Ce=T.length,fe=T[T.length-1];Y+=`
        return getChannel(
          getT${Ce}(${fa(C,P,fe)}),
          vec2(${fa(z,P,fe)}));`,this.userCode=`
      float getValue(${C.map(Pe=>"int "+Pe)}) {
        ${Y}
      }

      void main() {
        ${f} coords = getOutputCoords();
        vec4 result = vec4(getValue(${w}), 0., 0., 0.);

        ${w[c-1]} = ${w[c-1]} + 1;
        if (${w[c-1]} < ${d[c-1]}) {
          result.g = getValue(${w});
        }

        ${w[c-2]} = ${w[c-2]} + 1;
        if (${w[c-2]} < ${d[c-2]}) {
          result.a = getValue(${w});
        }

        ${w[c-1]} = ${w[c-1]} - 1;
        if (${w[c-2]} < ${d[c-2]} &&
            ${w[c-1]} < ${d[c-1]}) {
          result.b = getValue(${w});
        }
        setOutput(result);
      }
    `}}function fa(k,a,o){const d=k.indexOf(a);return k.map((c,f)=>f===d?`${c} - ${o}`:c).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vs(k){const{inputs:a,backend:o}=k,{input:d}=a;return ta({inputs:{x:o.texData.get(d.dataId).complexTensorInfos.imag},backend:o})}const wi={kernelName:t.Imag,backendName:"webgl",kernelFunc:Vs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(k,a,o){const d=k[0].dtype;if(d==="complex64"){const te=k.map(Le=>Mr({inputs:{input:Le},backend:o})),Y=k.map(Le=>Vs({inputs:{input:Le},backend:o})),Ce=Gs(te,a,o),fe=Gs(Y,a,o),Pe=ia({inputs:{real:Ce,imag:fe},backend:o});return te.forEach(Le=>o.disposeIntermediateTensorInfo(Le)),Y.forEach(Le=>o.disposeIntermediateTensorInfo(Le)),o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(fe),Pe}let c=o.shouldExecuteOnCPU(k);if(d==="string"&&(c=!0),c){const te=k.map(je=>{const qt=t.util.sizeFromShape(je.shape.slice(a));return In({inputs:{x:je},backend:o,attrs:{shape:[-1,qt]}})}),Y=te.map(je=>({vals:o.readSync(je.dataId),shape:je.shape})),Ce=t.backend_util.computeOutShape(te.map(je=>je.shape),1),fe=te[0].shape[0]===1,Pe=xr(Y,Ce,d,fe),Le=t.backend_util.computeOutShape(k.map(je=>je.shape),a),_e=o.makeTensorInfo(Le,d,Pe);return te.forEach(je=>o.disposeIntermediateTensorInfo(je)),_e}const f=Object(t.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(k.length>f){const te=[];for(let Ce=0;Ce<k.length;Ce+=f){const fe=k.slice(Ce,Ce+f);te.push(Gs(fe,a,o))}const Y=Gs(te,a,o);for(const Ce of te)o.disposeIntermediateTensorInfo(Ce);return Y}if(Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&k[0].shape.length>1){const te=new Ws(k.map(Y=>Y.shape),a);return o.runWebGLProgram(te,k,d)}const{tensors2D:w,outShape:C}=function(te,Y,Ce){const fe=t.backend_util.computeOutShape(te.map(Pe=>Pe.shape),Y);return{tensors2D:te.map(Pe=>In({inputs:{x:Pe},attrs:{shape:[-1,t.util.sizeFromShape(Pe.shape.slice(Y))]},backend:Ce})),outShape:fe}}(k,a,o),T=new hs(w.map(te=>te.shape)),P=o.runWebGLProgram(T,w,d);w.forEach(te=>o.disposeIntermediateTensorInfo(te));const z=In({inputs:{x:P},attrs:{shape:C},backend:o});return o.disposeIntermediateTensorInfo(P),z}function ki(k){const{inputs:a,backend:o,attrs:d}=k,{axis:c}=d,f=t.util.parseAxisParam(c,a[0].shape)[0],w=t.backend_util.computeOutShape(a.map(P=>P.shape),f);if(t.util.sizeFromShape(w)===0)return o.makeTensorInfo(w,a[0].dtype,[]);const C=a.filter(P=>t.util.sizeFromShape(P.shape)>0);if(C.length===1)return ta({inputs:{x:C[0]},backend:o});const T=C.map(P=>P.shape);return t.backend_util.assertParamsConsistent(T,f),Gs(C,f,o)}const no={kernelName:t.Concat,backendName:"webgl",kernelFunc:ki};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wi{constructor(a,o=!1,d=null,c=!1,f=!1){this.variableNames=["x","W"],this.outputShape=a.outShape;const w=a.padInfo.top,C=a.padInfo.left,T=a.strideHeight,P=a.strideWidth,z=a.dilationHeight,te=a.dilationWidth,Y=a.filterHeight,Ce=a.filterWidth,fe=4*Math.floor(a.inChannels/4),Pe=a.inChannels%4,Le=a.dataFormat==="channelsLast",_e=Le?1:2,je=Le?2:3,qt=Le?3:1;let sn="",vn="";d&&(sn=c?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${d}
        }`:f?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${d}
        }`:`
          float activation(float x) {
            ${d}
          }
        `,vn="result = activation(result);");const En=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${sn}

      const ivec2 strides = ivec2(${T}, ${P});
      const ivec2 pads = ivec2(${w}, ${C});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${qt}];

        ivec2 xRCCorner =
            ivec2(coords[${_e}], coords[${je}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${Y}; wR++) {
          int xR = xRCorner + wR * ${z};

          if (xR < 0 || xR >= ${a.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${Ce}; wC++) {
            int xC = xCCorner + wC * ${te};

            if (xC < 0 || xC >= ${a.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${fe}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${Le}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${Pe===1}) {

              if (${Le}) {
                dotProd +=
                    getX(batch, xR, xC, ${fe}) *
                    getW(wR, wC, ${fe}, d2);
              } else {
                dotProd +=
                    getX(batch, ${fe}, xR, xC) *
                    getW(wR, wC, ${fe}, d2);
              }

            } else if (${Pe===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${fe}, d2),
                getW(wR, wC, ${fe} + 1, d2)
              );

              if (${Le}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${fe}),
                  getX(batch, xR, xC, ${fe} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${fe}, xR, xC),
                  getX(batch, ${fe} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${Pe===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${fe}, d2),
                getW(wR, wC, ${fe} + 1, d2),
                getW(wR, wC, ${fe} + 2, d2)
              );

              if (${Le}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${fe}),
                  getX(batch, xR, xC, ${fe} + 1),
                  getX(batch, xR, xC, ${fe} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${fe}, xR, xC),
                  getX(batch, ${fe} + 1, xR, xC),
                  getX(batch, ${fe} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${En}
        ${vn}
        setOutput(result);
      }
    `}}class ro{constructor(a){this.variableNames=["x","W"],this.outputShape=a.outShape;const o=a.padInfo.front,d=a.padInfo.top,c=a.padInfo.left,f=a.strideDepth,w=a.strideHeight,C=a.strideWidth,T=a.dilationDepth,P=a.dilationHeight,z=a.dilationWidth,te=a.filterDepth,Y=a.filterHeight,Ce=a.filterWidth,fe=4*Math.floor(a.inChannels/4),Pe=a.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${f}, ${w}, ${C});
      const ivec3 pads = ivec3(${o}, ${d}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${te}; wF++) {
          int xF = xFCorner + wF * ${T};

          if (xF < 0 || xF >= ${a.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${Y}; wR++) {
            int xR = xRCorner + wR * ${P};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${Ce}; wC++) {
              int xC = xCCorner + wC * ${z};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${fe}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${Pe===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${fe}) *
                  getW(wF, wR, wC, ${fe}, d2);
              } else if (${Pe===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${fe}),
                  getX(batch, xF, xR, xC, ${fe} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${fe}, d2),
                  getW(wF, wR, wC, ${fe} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${Pe===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${fe}),
                  getX(batch, xF, xR, xC, ${fe} + 1),
                  getX(batch, xF, xR, xC, ${fe} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${fe}, d2),
                  getW(wF, wR, wC, ${fe} + 1, d2),
                  getW(wF, wR, wC, ${fe} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vi{constructor(a,o=!1,d=null,c=!1,f=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=ir(this.outputShape.length);const w=a.padInfo.left,C=a.strideWidth,T=a.dilationWidth,P=a.filterHeight,z=a.filterWidth,te=z;let Y=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let Le=0;Le<z;Le++)Y+=`
           vec4 xTexelC${2*Le};
           int xTexelC${2*Le}Ready;
           vec4 xTexelC${2*Le+1};
           int xTexelC${2*Le+1}Ready;
           vec4 xC${Le};`;Y+=`
     for (int r = 0; r < ${P}; r++) {
      for (int d1 = 0; d1 < ${a.inChannels}; d1 += 2) {
       `;for(let Le=0;Le<z;Le++)Y+=`
           xTexelC${2*Le} = vec4(0.0);
           xTexelC${2*Le}Ready = 0;
           xTexelC${2*Le+1} = vec4(0.0);
           xTexelC${2*Le+1}Ready = 0;
           xC${Le} = vec4(0.0);`;Y+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let Le=0;Le<(te+1)/2;Le++){const _e=2*Le;if(Y+=`
           xC = xCCorner + ${_e*T};
           `,C===1){if(_e<z&&(w%2==1?(Y+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_e}Ready == 0) {
                   xTexelC${_e} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_e}.zw = vec2(0.0);
                   }
                   xTexelC${_e}Ready = 1;
                 }
               `,Y+=T===1&&_e>0?`
                 xC${_e} = vec4(xTexelC${_e-2}.zw, xTexelC${_e}.xy);
                 `:`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${_e} = vec4(previous.zw, xTexelC${_e}.xy);
                   } else {
                     xC${_e} = vec4(0.0, 0.0, xTexelC${_e}.xy);
                   }
                   `):Y+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${_e}Ready == 0) {
                   xTexelC${_e} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${_e}.zw = vec2(0.0);
                   }
                   xTexelC${_e}Ready = 1;
                 }

                 xC${_e} = xTexelC${_e};
                 `,_e+1<z)){const je=w%2==0?t.util.nearestLargerEven(T):T;T%2==0&&w%2==1||T%2!=0&&w%2!=1?(Y+=`
                   xCOffset = xC + imod(pads[1], 2) + ${je};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_e+1}Ready == 0) {
                     xTexelC${_e+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${_e+1}.zw = vec2(0.0);
                     }
                     xTexelC${_e+1}Ready = 1;
                   }
                   `,Y+=T>1?`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${_e+1} = vec4(previous.zw, xTexelC${_e+1}.xy);
                     } else {
                      xC${_e+1} = vec4(0.0, 0.0, xTexelC${_e+1}.xy);
                     }
                     `:`
                     xC${_e+1} = vec4(xTexelC${_e}.zw, xTexelC${_e+1}.xy);
                     `):Y+=je===1?`
                     xC${_e+1} = xTexelC${_e};
                     `:`
                     xCOffset = xC + ${je};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_e+1}Ready == 0) {
                       xTexelC${_e+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${_e+1}.zw = vec2(0.0);
                       }
                       xTexelC${_e+1}Ready = 1;
                     }

                     xC${_e+1} = xTexelC${_e+1};
                     `}}else _e<z&&(w%2==1?(Y+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_e}Ready == 0) {
                   xTexelC${_e} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_e}.zw = vec2(0.0);
                   }
                   xTexelC${_e}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_e+1}Ready == 0) {
                   xTexelC${_e+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${_e+1}.zw = vec2(0.0);
                   }
                   xTexelC${_e+1}Ready = 1;
                 }

                 xC${_e} = vec4(xTexelC${_e}.zw, xTexelC${_e+1}.zw);
               `,_e+1<z&&(Y+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${_e+1} = vec4(xTexelC${_e+1}.xy, final.xy);
                 `)):(Y+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${_e}Ready == 0) {
                   xTexelC${_e} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${_e}.zw = vec2(0.0);
                   }
                   xTexelC${_e}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_e+1}Ready == 0) {
                   xTexelC${_e+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${_e+1}.zw = vec2(0.);
                   }
                   xTexelC${_e+1}Ready = 1;
                 }

                 xC${_e} = vec4(
                   xTexelC${_e}.xy, xTexelC${_e+1}.xy);
               `,_e+1<z&&(Y+=`
                   xC${_e+1} = vec4(xTexelC${_e}.zw, xTexelC${_e+1}.zw);
                 `)));_e<z&&(Y+=`
             wTexel = getW(r, ${_e}, d1, d2);
             dotProd += xC${_e}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${a.inChannels}) {
               dotProd += xC${_e}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,_e+1<z&&(Y+=`
               wTexel = getW(r, ${_e+1}, d1, d2);
               dotProd += xC${_e+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${a.inChannels}) {
                 dotProd += xC${_e+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}Y+=`
     }
   `,Y+=`
     }
   `,Y+=`
     }
   `;let Ce="",fe="";d&&(Ce=c?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${d}
         }`:f?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${d}
         }`:`vec4 activation(vec4 x) {
           ${d}
         }`,fe="result = activation(result);");const Pe=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${Ce}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${Y}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${Pe}
         ${fe}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mi{constructor(a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=a,this.enableShapeUniforms=ir(this.outputShape.length);const{dataFormat:d}=o,c=yn(),f=d==="channelsLast",w=f?1:2,C=f?2:3,T=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${a[2]} && pos < ${a[1]}) {`;let P="";for(let z=0;z<=1;z++)for(let te=0;te<=1;te++)P+=`
          blockIndex = rc.z + ${te};
          pos = rc.y + ${z};

          ${T}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${w}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${C}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${f}) {
                  innerDims = vec2(d1, ch);
                  result[${2*z+te}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*z+te}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${P}

        ${c.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _i(k,a){const o=k.length;return o>=3?a?[...k.slice(0,-3),k[o-3]*k[o-2],k[o-1]]:[...k.slice(0,-3),k[o-3],k[o-2]*k[o-1]]:!a&&o===1&&k[0]>1?[k[0],1]:null}function Gi({x:k,filter:a,convInfo:o,backend:d,bias:c=null,preluActivationWeights:f=null,leakyreluAlpha:w=0,activation:C=null}){const T=k.shape,P=d.texData.get(k.dataId),z=o.inChannels,te=T[0]*T[1]*T[2],Y=o.outChannels,Ce=o.dataFormat==="channelsLast";let fe;const Pe=[];if(f!=null){const Le=_i(f.shape,Ce);Le!=null&&(f=In({inputs:{x:f},backend:d,attrs:{shape:Le}}),Pe.push(f))}if(c!=null){const Le=_i(c.shape,Ce);Le!=null&&(c=In({inputs:{x:c},backend:d,attrs:{shape:Le}}),Pe.push(c))}if(!((te===1||Y===1)&&z>1e3)&&P.isPacked&&Ce&&P.texture!=null&&T[2]%2!=0&&t.util.arraysEqual(P.shape.slice(-3),T.slice(-3))){const Le=T[0]*T[1]*(T[2]+1),_e={dataId:k.dataId,shape:[1,Le,o.inChannels],dtype:k.dtype},je=P.shape;P.shape=P.shape.slice(),P.shape[P.shape.length-2]++,t.util.assert(It(P.shape,_e.shape),()=>`packed reshape ${P.shape} to ${_e.shape} isn't free`);const qt=In({inputs:{x:a},backend:d,attrs:{shape:[1,o.inChannels,o.outChannels]}});Pe.push(qt);const sn=ls({a:_e,b:qt,backend:d,transposeA:!1,transposeB:!1,bias:c,activation:C,preluActivationWeights:f,leakyreluAlpha:w}),vn=d.texData.get(sn.dataId);t.util.assert(vn.isPacked,()=>"batchMatMul result is expected to be packed"),P.shape=je,vn.shape=o.outShape,fe=ta({inputs:{x:sn},backend:d}),fe.shape=o.outShape,Pe.push(sn)}else{const Le=o.outHeight*o.outWidth,_e=In({inputs:{x:k},backend:d,attrs:{shape:Ce?[o.batchSize,Le,o.inChannels]:[o.batchSize,o.inChannels,Le]}}),je=In({inputs:{x:a},backend:d,attrs:{shape:[1,o.inChannels,o.outChannels]}}),qt=ls({a:Ce?_e:je,b:Ce?je:_e,transposeA:!Ce,transposeB:!1,backend:d,bias:c,activation:C,preluActivationWeights:f,leakyreluAlpha:w});fe=In({inputs:{x:qt},backend:d,attrs:{shape:o.outShape}}),Pe.push(_e),Pe.push(je),Pe.push(qt)}for(const Le of Pe)d.disposeIntermediateTensorInfo(Le);return fe}function Di({x:k,filter:a,convInfo:o,backend:d,bias:c=null,preluActivationWeights:f=null,leakyreluAlpha:w=0,activation:C=null}){const{filterWidth:T,filterHeight:P,inChannels:z,outWidth:te,outHeight:Y,dataFormat:Ce}=o,fe=Ce==="channelsLast",Pe=T*P*z,Le=Y*te,_e=[o.batchSize,Pe,Le],je=[];if(f!=null){const p=_i(f.shape,fe);p!=null&&(f=In({inputs:{x:f},backend:d,attrs:{shape:p}}),je.push(f))}if(c!=null){const p=_i(c.shape,fe);p!=null&&(c=In({inputs:{x:c},backend:d,attrs:{shape:p}}),je.push(c))}const qt=In({inputs:{x:a},backend:d,attrs:{shape:[1,Pe,t.util.sizeFromShape(a.shape)/Pe]}});je.push(qt);const sn=new Mi(_e,o),vn=[k.shape,[o.padInfo.top,o.padInfo.left],[o.strideHeight,o.strideWidth],[o.dilationHeight,o.dilationWidth],[o.inChannels],[o.filterWidth*o.inChannels],[o.outWidth]],En=d.runWebGLProgram(sn,[k],"float32",vn),Cn=In({inputs:{x:En},backend:d,attrs:{shape:_e}});je.push(En),je.push(Cn);const An=c!=null,kn=f!=null,Jn=C==="leakyrelu",qn=C?za(C,!0):null,s=new Es(fe?Cn.shape:qt.shape,fe?qt.shape:Cn.shape,fe?[o.batchSize,Le,o.outChannels]:[o.batchSize,o.outChannels,Le],!0,!1,An,qn,kn,Jn),r=fe?[Cn,qt]:[qt,Cn];if(c&&r.push(c),kn&&r.push(f),Jn){const p=d.makeTensorInfo([],"float32",t.util.createScalarValue(w,"float32"));r.push(p),je.push(p)}const i=d.runWebGLProgram(s,r,"float32"),u=In({inputs:{x:i},backend:d,attrs:{shape:o.outShape}});je.push(i);for(const p of je)d.disposeIntermediateTensorInfo(p);return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai={kernelName:t.Conv2D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f}=a,{strides:w,pad:C,dataFormat:T,dilations:P,dimRoundingMode:z}=d,te=t.backend_util.convertConv2DDataFormat(T),Y=t.backend_util.computeConv2DInfo(c.shape,f.shape,w,P,C,z,!1,te);let Ce;if(Y.filterHeight!==1||Y.filterWidth!==1||Y.dilationHeight!==1||Y.dilationWidth!==1||Y.strideHeight!==1||Y.strideWidth!==1||Y.padInfo.type!=="SAME"&&Y.padInfo.type!=="VALID")if(Y.strideWidth<=2&&te==="channelsLast"&&Object(t.env)().getBool("WEBGL_EXP_CONV")){const Pe=new Vi(Y),Le=[[Y.padInfo.top,Y.padInfo.left],[Y.strideHeight,Y.strideWidth],[Y.dilationHeight,Y.dilationWidth],[Y.inHeight,Y.inWidth]];Ce=o.runWebGLProgram(Pe,[c,f],"float32",Le)}else if(Object(t.env)().getBool("WEBGL_CONV_IM2COL"))Ce=Di({x:c,filter:f,convInfo:Y,backend:o});else{const Pe=new Wi(Y);Ce=o.runWebGLProgram(Pe,[c,f],"float32")}else Ce=Gi({x:c,filter:f,convInfo:Y,backend:o});const fe=In({inputs:{x:Ce},backend:o,attrs:{shape:Y.outShape}});return o.disposeIntermediateTensorInfo(Ce),fe}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ao{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const o=a.strideHeight,d=a.strideWidth,c=a.padInfo.top,f=a.padInfo.left,w=a.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yR = 0; yR < ${a.outHeight}; yR++) {
            int xR = wR + yR * ${o} - ${c};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${a.outWidth}; yC++) {
              int xC = wC + yC * ${d} - ${f};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              if (${w}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class so{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const o=a.filterHeight,d=a.filterWidth,c=a.strideHeight,f=a.strideWidth,w=a.dataFormat==="channelsLast",C=o-1-a.padInfo.top,T=d-1-a.padInfo.left,P=w?1:2,z=w?2:3,te=w?3:1;this.userCode=`
      const ivec2 pads = ivec2(${C}, ${T});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${te}];

        ivec2 dyCorner = ivec2(coords[${P}], coords[${z}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o}; wR++) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${o} - 1 - wR;

          for (int wC = 0; wC < ${d}; wC++) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${d} - 1 - wC;

            for (int d2 = 0; d2 < ${a.outChannels}; d2++) {

              if (${w}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class io{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const o=a.strideDepth,d=a.strideHeight,c=a.strideWidth,f=a.padInfo.front,w=a.padInfo.top,C=a.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yF = 0; yF < ${a.outDepth}; yF++) {
            int xF = wF + yF * ${o} - ${f};

            if (xF < 0 || xF >= ${a.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${a.outHeight}; yR++) {
              int xR = wR + yR * ${d} - ${w};

              if (xR < 0 || xR >= ${a.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${a.outWidth}; yC++) {
                int xC = wC + yC * ${c} - ${C};

                if (xC < 0 || xC >= ${a.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Hi{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const o=a.filterDepth,d=a.filterHeight,c=a.filterWidth,f=a.strideDepth,w=a.strideHeight,C=a.strideWidth,T=o-1-a.padInfo.front,P=d-1-a.padInfo.top,z=c-1-a.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${T}, ${P}, ${z});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${o}; wF++) {
          float dyF = float(dyFCorner + wF) / ${f}.0;

          if (dyF < 0.0 || dyF >= ${a.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${o} - 1 - wF;

          for (int wR = 0; wR < ${d}; wR++) {
            float dyR = float(dyRCorner + wR) / ${w}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${d} - 1 - wR;

            for (int wC = 0; wC < ${c}; wC++) {
              float dyC = float(dyCCorner + wC) / ${C}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${c} - 1 - wC;

              for (int d2 = 0; d2 < ${a.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ii={kernelName:t.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,dy:f}=a,{strides:w,pad:C,dataFormat:T,dimRoundingMode:P,filterShape:z}=d,te=t.backend_util.convertConv2DDataFormat(T),Y=t.backend_util.computeConv2DInfo(c.shape,z,w,1,C,P,!1,te),Ce=new ao(Y);return o.runWebGLProgram(Ce,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi={kernelName:t.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,filter:f}=a,{inputShape:w,strides:C,pad:T,dataFormat:P,dimRoundingMode:z}=d,te=t.backend_util.convertConv2DDataFormat(P),Y=t.backend_util.computeConv2DInfo(w,f.shape,C,1,T,z,!1,te),Ce=new so(Y);return o.runWebGLProgram(Ce,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qi={kernelName:t.Conv3D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f}=a,{strides:w,pad:C,dilations:T}=d,P=t.backend_util.computeConv3DInfo(c.shape,f.shape,w,T,C),z=new ro(P);return o.runWebGLProgram(z,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo={kernelName:t.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,dy:f}=a,{strides:w,pad:C,filterShape:T}=d,P=t.backend_util.computeConv3DInfo(c.shape,T,w,1,C),z=new io(P);return o.runWebGLProgram(z,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fi={kernelName:t.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,filter:f}=a,{pad:w,strides:C,inputShape:T}=d,P=t.backend_util.computeConv3DInfo(T,f.shape,C,1,w),z=new Hi(P);return o.runWebGLProgram(z,[c,f],"float32")}},uo=pr({opSnippet:`if (isnan(x)) return x;
  return cos(x);
`}),co={kernelName:t.Cos,backendName:"webgl",kernelFunc:uo},Ki=pr({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),mi={kernelName:t.Cosh,backendName:"webgl",kernelFunc:Ki};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class si{constructor(a,o,d,c,f){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[w,C,T,P]=a,[z]=o,[te,Y]=d;this.outputShape=[z,te,Y,P];const Ce=c==="bilinear"?1:0,[fe,Pe]=[C-1+".0",T-1+".0"],[Le,_e,je]=te>1?[""+(C-1)/(te-1),"(y2-y1) * height_ratio",`y1*${fe} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${fe}`],[qt,sn,vn]=Y>1?[""+(T-1)/(Y-1),"(x2-x1) * width_ratio",`x1*${Pe} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${Pe}`];this.userCode=`
      const float height_ratio = float(${Le});
      const float width_ratio = float(${qt});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${w}) {
          return;
        }

        float height_scale = ${_e};
        float width_scale = ${sn};

        float in_y = ${je};
        if( in_y < 0.0 || in_y > ${fe} ) {
          setOutput(float(${f}));
          return;
        }
        float in_x = ${vn};
        if( in_x < 0.0 || in_x > ${Pe} ) {
          setOutput(float(${f}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${Ce} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Si={kernelName:t.CropAndResize,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{image:c,boxes:f,boxInd:w}=a,{cropSize:C,method:T,extrapolationValue:P}=d,z=new si(c.shape,f.shape,C,T,P);return o.runWebGLProgram(z,[c,f,w],"float32")}};var Br;(function(k){k.Prod="*",k.Sum="+"})(Br||(Br={}));class Bi{constructor(a,o,d,c){this.op=a,this.outputShape=o,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const f=this.outputShape.length,w=this.op===Br.Prod?"1.0":"0.0",C=d?w:`getX(${bi(f,"coords",this.op)})`,T=this.outputShape[this.outputShape.length-1];let P="",z="";d?(P=c?"end != "+(T-1):"end != 0",z=c?"end + 1":"end - 1"):(P=c?`end + pow2 < ${T}`:"end >= pow2",z=c?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${oe(f)} coords = getOutputCoords();
        int end = ${Xi(f,"coords",this.op)};
        float val = ${C};
        int pow2 = int(pow(2.0, index));
        if (${P}) {
          int idx = ${z};
          ${Xi(f,"coords",this.op)} = idx;
          val ${this.op}= getX(${bi(f,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function bi(k,a,o){if(k===1)return`${a}`;if(k===2)return`${a}.x, ${a}.y`;if(k===3)return`${a}.x, ${a}.y, ${a}.z`;if(k===4)return`${a}.x, ${a}.y, ${a}.z, ${a}.w`;throw new Error(`Cumulative ${o} for rank ${k} is not yet supported`)}function Xi(k,a,o){if(k===1)return`${a}`;if(k===2)return`${a}.y`;if(k===3)return`${a}.z`;if(k===4)return`${a}.w`;throw new Error(`Cumulative ${o} for rank ${k} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ps(k,a,o,d,c,f){const w=a.shape.length,C=t.backend_util.getAxesPermutation([d],w);let T=a;C!=null&&(T=ra({inputs:{x:a},backend:o,attrs:{perm:C}}));const P=t.backend_util.getInnerMostAxes(1,w)[0];if(P!==w-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${a.shape.length-1} but got axis=${d}`);const z=T.shape[P];let te=ta({inputs:{x:T},backend:o});for(let Y=0;Y<=Math.ceil(Math.log2(z))-1;Y++){const Ce=new Bi(k,T.shape,!1,f),fe=[[Y]],Pe=te;te=o.runWebGLProgram(Ce,[te],te.dtype,fe),o.disposeIntermediateTensorInfo(Pe)}if(c){const Y=new Bi(k,T.shape,c,f),Ce=te;te=o.runWebGLProgram(Y,[te],te.dtype),o.disposeIntermediateTensorInfo(Ce)}if(C!=null){const Y=ra({inputs:{x:te},backend:o,attrs:{perm:t.backend_util.getUndoAxesPermutation(C)}});return o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(T),Y}return te}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ve={kernelName:t.Cumprod,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,exclusive:w,reverse:C}=d;return ps(Br.Prod,c,o,f,w,C)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe={kernelName:t.Cumsum,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,exclusive:w,reverse:C}=d;return ps(Br.Sum,c,o,f,w,C)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j={kernelName:t.DenseBincount,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,weights:f}=a,{size:w,binaryOutput:C}=d;if(c.shape.length===1){const T=o.readSync(c.dataId),P=o.readSync(f.dataId),z=bn(T,P,f.dtype,f.shape,w);return o.makeTensorInfo([w],f.dtype,z)}if(c.shape.length===2){const T=o.bufferSync(c),P=o.bufferSync(f),z=xn(T,P,w,C);return o.makeTensorInfo(z.shape,f.dtype,z.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${c.shape.length}.`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ie{constructor(a,o,d){this.variableNames=["x"],this.outputShape=[],this.outputShape=a,this.blockSize=o,this.dataFormat=d,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${o};
      int offset_h = imod(h, ${o});
      int in_w = w / ${o};
      int offset_w = imod(w, ${o});
      int offset_d = (offset_h * ${o} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F={kernelName:t.DepthToSpace,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{blockSize:f,dataFormat:w}=d,C=c.shape[0],T=(w==="NHWC"?c.shape[1]:c.shape[2])*f,P=(w==="NHWC"?c.shape[2]:c.shape[3])*f,z=(w==="NHWC"?c.shape[3]:c.shape[1])/(f*f),te=new ie(w==="NHWC"?[C,T,P,z]:[C,z,T,P],f,w);return o.runWebGLProgram(te,[c],c.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ne{constructor(a,o=!1,d=null,c=!1,f=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=ir(this.outputShape.length);const w=a.filterHeight,C=a.filterWidth,T=a.outChannels/a.inChannels;let P="",z="";d&&(P=c?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${d}
        }`:f?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${d}
        }`:`
          float activation(float x) {
            ${d}
          }
        `,z="result = activation(result);");const te=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${P}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${T};
        int q = d2 - d1 * ${T};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${w}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${te}
        ${z}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ge{constructor(a,o=!1,d=null,c=!1,f=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=ir(this.outputShape.length);const w=a.outChannels/a.inChannels,C=a.padInfo.left,T=a.strideWidth,P=a.dilationWidth,z=a.filterHeight,te=a.filterWidth,Y=te;let Ce=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let _e=0;_e<te;_e++)Ce+=`
          vec4 xTexelC${2*_e};
          int xTexelC${2*_e}Ready;
          vec4 xTexelC${2*_e+1};
          int xTexelC${2*_e+1}Ready;
          vec4 xC${_e};`;Ce+=`
    for (int r = 0; r < ${z}; r++) {
      `;for(let _e=0;_e<te;_e++)Ce+=`
          xTexelC${2*_e} = vec4(0.0);
          xTexelC${2*_e}Ready = 0;
          xTexelC${2*_e+1} = vec4(0.0);
          xTexelC${2*_e+1}Ready = 0;
          xC${_e} = vec4(0.0);`;Ce+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let _e=0;_e<(Y+1)/2;_e++){const je=2*_e;if(Ce+=`
          xC = xCCorner + ${je*P};
          `,T===1){if(je<te&&(C%2==1?(Ce+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${je}Ready == 0) {
                  xTexelC${je} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${je}.zw = vec2(0.0);
                  }
                  xTexelC${je}Ready = 1;
                }
              `,Ce+=P===1&&je>0?`
                xC${je} = vec4(xTexelC${je-2}.zw, xTexelC${je}.xy);
                `:`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${je} = vec4(previous.zw, xTexelC${je}.xy);
                  } else {
                    xC${je} = vec4(0.0, 0.0, xTexelC${je}.xy);
                  }
                  `):Ce+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${je}Ready == 0) {
                  xTexelC${je} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${je}.zw = vec2(0.0);
                  }
                  xTexelC${je}Ready = 1;
                }

                xC${je} = xTexelC${je};
                `,je+1<te)){const qt=C%2==0?t.util.nearestLargerEven(P):P;P%2==0&&C%2==1||P%2!=0&&C%2!=1?(Ce+=`
                  xCOffset = xC + imod(pads[1], 2) + ${qt};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${je+1}Ready == 0) {
                    xTexelC${je+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${je+1}.zw = vec2(0.0);
                    }
                    xTexelC${je+1}Ready = 1;
                  }
                  `,Ce+=P>1?`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${je+1} = vec4(previous.zw, xTexelC${je+1}.xy);
                    } else {
                     xC${je+1} = vec4(0.0, 0.0, xTexelC${je+1}.xy);
                    }
                    `:`
                    xC${je+1} = vec4(xTexelC${je}.zw, xTexelC${je+1}.xy);
                    `):Ce+=qt===1?`
                    xC${je+1} = xTexelC${je};
                    `:`
                    xCOffset = xC + ${qt};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${je+1}Ready == 0) {
                      xTexelC${je+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${je+1}.zw = vec2(0.0);
                      }
                      xTexelC${je+1}Ready = 1;
                    }

                    xC${je+1} = xTexelC${je+1};
                    `}}else je<te&&(C%2==1?(Ce+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${je}Ready == 0) {
                  xTexelC${je} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${je}.zw = vec2(0.0);
                  }
                  xTexelC${je}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${je+1}Ready == 0) {
                  xTexelC${je+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${je+1}.zw = vec2(0.0);
                  }
                  xTexelC${je+1}Ready = 1;
                }

                xC${je} = vec4(xTexelC${je}.zw, xTexelC${je+1}.zw);
              `,je+1<te&&(Ce+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${je+1} = vec4(xTexelC${je+1}.xy, final.xy);
                `)):(Ce+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${je}Ready == 0) {
                  xTexelC${je} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${je}.zw = vec2(0.0);
                  }
                  xTexelC${je}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${je+1}Ready == 0) {
                  xTexelC${je+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${je+1}.zw = vec2(0.);
                  }
                  xTexelC${je+1}Ready = 1;
                }

                xC${je} = vec4(
                  xTexelC${je}.xy, xTexelC${je+1}.xy);
              `,je+1<te&&(Ce+=`
                  xC${je+1} = vec4(xTexelC${je}.zw, xTexelC${je+1}.zw);
                `)));je<te&&(Ce+=`
            wTexel = getW(r, ${je}, d1, q);
            dotProd += xC${je} * vec4(wTexel.xz, wTexel.xz);
          `,je+1<te&&(Ce+=`
              wTexel = getW(r, ${je+1}, d1, q);
              dotProd += xC${je+1} * vec4(wTexel.xz, wTexel.xz);
            `))}Ce+=`
    }
  `,Ce+=`
      }
    `;let fe="",Pe="";d&&(fe=c?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${d}
        }`:f?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${d}
        }`:`vec4 activation(vec4 x) {
          ${d}
        }`,Pe="result = activation(result);");const Le=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),f&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${fe}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${w};
        int q = d2 - d1 * ${w};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${Ce}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${Le}
        ${Pe}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ee={kernelName:t.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f}=a,{strides:w,pad:C,dilations:T,dimRoundingMode:P}=d;let z=T;z==null&&(z=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(w,z),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${w} and dilations '${z}'`);const te=t.backend_util.computeConv2DInfo(c.shape,f.shape,w,z,C,P,!0);let Y;Y=Object(t.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&te.strideWidth<=2&&te.outChannels/te.inChannels==1?new ge(te):new ne(te);const Ce=[[te.padInfo.top,te.padInfo.left],[te.strideHeight,te.strideWidth],[te.dilationHeight,te.dilationWidth],[te.inHeight,te.inWidth]];return o.runWebGLProgram(Y,[c,f],"float32",Ce)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $e{constructor(a){this.variableNames=["x","dy"],this.outputShape=a.filterShape;const o=a.strideHeight,d=a.strideWidth,c=a.padInfo.top,f=a.padInfo.left,w=a.outChannels/a.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${w} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${a.batchSize}; b++) {
          for (int yR = 0; yR < ${a.outHeight}; yR++) {
            int xR = wR + yR * ${o} - ${c};

            if (xR < 0 || xR >= ${a.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${a.outWidth}; yC++) {
              int xC = wC + yC * ${d} - ${f};

              if (xC < 0 || xC >= ${a.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class be{constructor(a){this.variableNames=["dy","W"],this.outputShape=a.inShape;const o=a.filterHeight,d=a.filterWidth,c=a.strideHeight,f=a.strideWidth,w=o-1-a.padInfo.top,C=d-1-a.padInfo.left,T=a.outChannels/a.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${w}, ${C});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${o}; wR++) {
          float dyR = float(dyRCorner + wR) / ${c}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${o} - 1 - wR;

          for (int wC = 0; wC < ${d}; wC++) {
            float dyC = float(dyCCorner + wC) / ${f}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${d} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${T}; dm++) {
              int d2 = d1 * ${T} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ye={kernelName:t.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,dy:f}=a,{strides:w,dilations:C,pad:T,dimRoundingMode:P,filterShape:z}=d,te=t.backend_util.computeConv2DInfo(c.shape,z,w,C,T,P,!0),Y=new $e(te);return o.runWebGLProgram(Y,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ue={kernelName:t.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,filter:f}=a,{strides:w,dilations:C,pad:T,dimRoundingMode:P,inputShape:z}=d,te=t.backend_util.computeConv2DInfo(z,f.shape,w,C,T,P,!0),Y=new be(te);return o.runWebGLProgram(Y,[c,f],"float32")}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Re{constructor(a){this.variableNames=["X"],this.outputShape=[a,a],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve={kernelName:t.Diag,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{x:d}=a,c=[...d.shape,...d.shape],f=t.util.sizeFromShape(d.shape),w=In({inputs:{x:d},backend:o,attrs:{shape:[f]}}),C=new Re(f),T=o.runWebGLProgram(C,[w],w.dtype),P=In({inputs:{x:T},backend:o,attrs:{shape:c}});return o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(T),P}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class st{constructor(a){this.variableNames=["x","W"],this.outputShape=a.outShape;const{inHeight:o,inWidth:d,padInfo:c,strideHeight:f,strideWidth:w,filterHeight:C,filterWidth:T,dilationHeight:P,dilationWidth:z}=a,{top:te,left:Y}=c;this.userCode=`
      const ivec2 strides = ivec2(${f}, ${w});
      const ivec2 pads = ivec2(${te}, ${Y});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${C}; h++) {
          int hIn = hBeg + h * ${P};

          if (hIn >= 0 && hIn < ${o}) {
            for (int w = 0; w < ${T}; w++) {
              int wIn = wBeg + w * ${z};

              if (wIn >= 0 && wIn < ${d}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tt={kernelName:t.Dilation2D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f}=a,{strides:w,pad:C,dilations:T}=d,P=t.backend_util.computeDilation2DInfo(c.shape,f.shape,w,C,"NHWC",T);let z;const te=new st(P);z=o.runWebGLProgram(te,[c,f],"float32");const Y=In({inputs:{x:z},backend:o,attrs:{shape:P.outShape}});return o.disposeIntermediateTensorInfo(z),Y}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const at={kernelName:t.Einsum,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{equation:c}=d,f=a,{allDims:w,summedDims:C,idDims:T}=t.backend_util.decodeEinsumEquation(c,f.length);t.backend_util.checkEinsumDimSizes(w.length,T,f);const{path:P,steps:z}=t.backend_util.getEinsumComputePath(C,T),te=z.length;let Y=null,Ce=w.length;const fe=[];for(let Pe=0;Pe<te;++Pe){for(const Le of z[Pe]){const{permutationIndices:_e,expandDims:je}=t.backend_util.getEinsumPermutation(Ce,T[Le]);let qt;t.backend_util.isIdentityPermutation(_e)?qt=f[Le]:(qt=ra({inputs:{x:f[Le]},backend:o,attrs:{perm:_e}}),fe.push(qt));const sn=qt.shape.slice();for(let vn=0;vn<je.length;++vn)sn.splice(je[vn],0,1);t.util.arraysEqual(qt.shape,sn)||(qt=In({inputs:{x:qt},backend:o,attrs:{shape:sn}}),fe.push(qt)),Y===null?Y=qt:(Y=vs({inputs:{a:qt,b:Y},backend:o}),fe.push(Y))}Pe<te-1&&(P[Pe]>=0&&(Y=cs({inputs:{x:Y},backend:o,attrs:{axis:P[Pe]-(w.length-Ce),keepDims:!1}}),fe.push(Y)),Ce--)}for(const Pe of fe)Pe!==Y&&o.disposeIntermediateTensorInfo(Pe);return Y}},ot=pr({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),bt={kernelName:t.Elu,backendName:"webgl",kernelFunc:ot},St={kernelName:t.EluGrad,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o}=k,{dy:d,y:c}=a,f=Object(t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ea(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,d.shape,c.shape):new qa("return (b >= 1.0) ? a : a * (b + 1.0);",d.shape,c.shape);return o.runWebGLProgram(f,[d,c],d.dtype)}},R=Jr({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:Lr}),v={kernelName:t.Equal,backendName:"webgl",kernelFunc:R},x=pr({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${t.backend_util.ERF_P};
  float a1 = ${t.backend_util.ERF_A1};
  float a2 = ${t.backend_util.ERF_A2};
  float a3 = ${t.backend_util.ERF_A3};
  float a4 = ${t.backend_util.ERF_A4};
  float a5 = ${t.backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),M={kernelName:t.Erf,backendName:"webgl",kernelFunc:x},N=pr({opSnippet:`if (isnan(x)) return x;
  return exp(x);
`,packedOpSnippet:`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:Wr,dtype:"float32"}),H={kernelName:t.Exp,backendName:"webgl",kernelFunc:N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ee(k){const{inputs:a,attrs:o,backend:d}=k,{dim:c}=o,{input:f}=a,w=f.shape.length,C=f.shape.slice();let T=c;return c<0&&(t.util.assert(-(w+1)<=c,()=>`Axis must be in the interval [${-(w+1)}, ${w}]`),T=w+c+1),C.splice(T,0,1),In({inputs:{x:f},backend:d,attrs:{shape:C}})}const se={kernelName:t.ExpandDims,backendName:"webgl",kernelFunc:ee},ce="return exp(x) - 1.0;",xe=pr({opSnippet:ce,packedOpSnippet:ce,cpuKernelImpl:vr}),De={kernelName:t.Expm1,backendName:"webgl",kernelFunc:xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ke{constructor(a,o,d){this.variableNames=["real","imag"];const c=o[1];this.outputShape=o;const f=d?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,w=d?`${c}.0`:"1.0";let C;if(a==="real")C="return real * expR - imag * expI;";else{if(a!=="imag")throw new Error(`FFT component must be either "real" or "imag", got ${a}.`);C="return real * expI + imag * expR;"}this.userCode=`
      const float exponentMultiplier = ${f};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${C}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${c});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${c}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${w};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(k,a,o){const d=o.texData.get(k.dataId),c=t.util.sizeFromShape(k.shape),f=k.shape[k.shape.length-1],w=In({inputs:{x:k},backend:o,attrs:{shape:[c/f,f]}}),C=w.shape,T=new Ke("real",C,a),P=new Ke("imag",C,a),z=[{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:C},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:C}],te=o.runWebGLProgram(T,z,"float32"),Y=o.runWebGLProgram(P,z,"float32"),Ce=ia({inputs:{real:te,imag:Y},backend:o});o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(Y);const fe=In({inputs:{x:Ce},backend:o,attrs:{shape:k.shape}});return o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(Ce),fe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ge={kernelName:t.FFT,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{input:d}=a;return Ze(d,!1,o)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nt{constructor(a,o){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=a,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Je(k){const{backend:a,attrs:o}=k,{shape:d,value:c}=o;let{dtype:f}=o;if(f=f||t.util.inferDtype(c),f==="string"){const w=t.util.getArrayFromDType(f,t.util.sizeFromShape(d));return w.fill(c),a.makeTensorInfo(d,f,w)}{const w=new nt(d,c),C=[[c]];return a.runWebGLProgram(w,[],f,C)}}const yt={kernelName:t.Fill,backendName:"webgl",kernelFunc:Je};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gt{constructor(a){this.variableNames=["Image"],this.outputShape=[];const o=a[2];this.outputShape=a,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${o} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${o}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kt={kernelName:t.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:k,backend:a})=>{const{image:o}=k,d=a,c=new gt(o.shape);return d.runWebGLProgram(c,[o],o.dtype)}},Tt="return floor(x);",Rt=pr({opSnippet:Tt,packedOpSnippet:Tt,cpuKernelImpl:ua}),Yt={kernelName:t.Floor,backendName:"webgl",kernelFunc:Rt},Ht=Jr({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),nn={kernelName:t.FloorDiv,backendName:"webgl",kernelFunc:Ht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gn{constructor(a){this.variableNames=["A"];const o=yn(),[d,c]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${d}.0);

        vec4 values = ${o.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ln{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const o=yn(),[d,c]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${c}.0, ${d}.0);
            vec4 values = ${o.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bn={kernelName:t.FromPixels,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k;let{pixels:c}=a;const{numChannels:f}=d,w=typeof HTMLVideoElement!="undefined"&&c instanceof HTMLVideoElement,C=typeof HTMLImageElement!="undefined"&&c instanceof HTMLImageElement,[T,P]=w?[c.videoWidth,c.videoHeight]:[c.width,c.height],z=[P,T],te=[P,T,f];if(C||w){const Pe=Object(t.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");wn!=null&&Pe===$n||($n=Pe,wn=document.createElement("canvas").getContext("2d",{willReadFrequently:$n})),wn.canvas.width=T,wn.canvas.height=P,wn.drawImage(c,0,0,T,P),c=wn.canvas}const Y=o.makeTensorInfo(z,"int32");o.texData.get(Y.dataId).usage=D.PIXELS,o.gpgpu.uploadPixelDataToTexture(o.getTexture(Y.dataId),c);const Ce=Object(t.env)().getBool("WEBGL_PACK")?new ln(te):new gn(te),fe=o.runWebGLProgram(Ce,[Y],"int32");return o.disposeData(Y.dataId),fe}};let wn,$n=Object(t.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const Wn={kernelName:t.FusedConv2D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f,bias:w,preluActivationWeights:C}=a,{strides:T,pad:P,dataFormat:z,dilations:te,dimRoundingMode:Y,activation:Ce,leakyreluAlpha:fe}=d,Pe=t.backend_util.convertConv2DDataFormat(z),Le=t.backend_util.computeConv2DInfo(c.shape,f.shape,T,te,P,Y,!1,Pe);let _e;const je=[],qt=w!=null,sn=C!=null,vn=Ce==="leakyrelu",En=()=>{const An=[c,f],kn=(Jn,qn)=>{if(qn==="NCHW"&&Jn.shape.length===1&&Jn.shape[0]!==1){const s=In({inputs:{x:Jn},backend:o,attrs:{shape:[Jn.shape[0],1,1]}});return je.push(s),s}return Jn};if(qt&&An.push(kn(w,z)),sn&&An.push(kn(C,z)),vn){const Jn=o.makeTensorInfo([],"float32",t.util.createScalarValue(fe,"float32"));An.push(Jn),je.push(Jn)}return An};if(Le.filterHeight!==1||Le.filterWidth!==1||Le.dilationHeight!==1||Le.dilationWidth!==1||Le.strideHeight!==1||Le.strideWidth!==1||Le.padInfo.type!=="SAME"&&Le.padInfo.type!=="VALID")if(Le.strideWidth<=2&&Pe==="channelsLast"&&Object(t.env)().getBool("WEBGL_EXP_CONV")){const An=Ce?za(Ce,!0):null,kn=new Vi(Le,qt,An,sn,vn),Jn=[[Le.padInfo.top,Le.padInfo.left],[Le.strideHeight,Le.strideWidth],[Le.dilationHeight,Le.dilationWidth],[Le.inHeight,Le.inWidth]],qn=En();_e=o.runWebGLProgram(kn,qn,"float32",Jn)}else if(Object(t.env)().getBool("WEBGL_CONV_IM2COL"))_e=Di({x:c,filter:f,convInfo:Le,backend:o,bias:w,activation:Ce,preluActivationWeights:C,leakyreluAlpha:fe});else{const An=Ce?za(Ce,!1):null,kn=new Wi(Le,qt,An,sn,vn),Jn=En();_e=o.runWebGLProgram(kn,Jn,"float32")}else _e=Gi({x:c,filter:f,convInfo:Le,backend:o,bias:w,activation:Ce,preluActivationWeights:C,leakyreluAlpha:fe});const Cn=In({inputs:{x:_e},backend:o,attrs:{shape:Le.outShape}});return je.push(_e),je.forEach(An=>o.disposeIntermediateTensorInfo(An)),Cn}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn={kernelName:t.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,filter:f,bias:w,preluActivationWeights:C}=a,{strides:T,pad:P,dilations:z,dimRoundingMode:te,activation:Y,leakyreluAlpha:Ce}=d,fe=[];let Pe=z;Pe==null&&(Pe=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(T,Pe),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${T} and dilations '${Pe}'`);const Le=t.backend_util.computeConv2DInfo(c.shape,f.shape,T,Pe,P,te,!0),_e=Object(t.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&Le.strideWidth<=2&&Le.outChannels/Le.inChannels==1,je=Y?za(Y,_e):null,qt=[c,f],sn=w!=null,vn=C!=null,En=Y==="leakyrelu";if(sn&&qt.push(w),vn&&qt.push(C),En){const Jn=o.makeTensorInfo([],"float32",t.util.createScalarValue(Ce,"float32"));qt.push(Jn),fe.push(Jn)}let Cn;Cn=_e?new ge(Le,sn,je,vn,En):new ne(Le,sn,je,vn,En);const An=[[Le.padInfo.top,Le.padInfo.left],[Le.strideHeight,Le.strideWidth],[Le.dilationHeight,Le.dilationWidth],[Le.inHeight,Le.inWidth]],kn=o.runWebGLProgram(Cn,qt,"float32",An);return fe.forEach(Jn=>o.disposeIntermediateTensorInfo(Jn)),kn}};class Dn{constructor(a,o,d,c){this.sliceDim=a,this.strides=o,this.paramsShape=c,this.variableNames=["x","indices"],this.outputShape=d;const f=oe(o.length),w=oe(d.length),C=this.sliceDim>1?"strides[j]":"strides",T=oe(c.length),P=c.length>1?"paramsShape[j]":"paramsShape";this.userCode=`
        ${f} strides = ${f}(${this.strides});
        ${T} paramsShape = ${T}(${this.paramsShape});
         void main() {
          ${w} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            out_of_bounds = out_of_bounds || index < 0;
            out_of_bounds = out_of_bounds || index >= ${P};
            flattenIndex += index * ${C};
          }
          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const er={kernelName:t.GatherNd,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{params:d,indices:c}=a,f=c.shape,w=f[f.length-1],C=t.util.sizeFromShape(d.shape),[T,P,z,te]=t.backend_util.prepareAndValidate(d,c),Y=In({inputs:{x:c},backend:o,attrs:{shape:[P,w]}}),Ce=In({inputs:{x:d},backend:o,attrs:{shape:[t.util.sizeFromShape(d.shape)/z,z]}});if(o.shouldExecuteOnCPU([d,c])||d.dtype==="string"){const _e=o.readSync(c.dataId),je=o.bufferSync(d),qt=ma(_e,je,d.dtype,P,w,z,te,d.shape,C);return o.makeTensorInfo(T,d.dtype,qt.values)}const fe=new Dn(w,te,[P,z],d.shape),Pe=o.runWebGLProgram(fe,[Ce,Y],Ce.dtype),Le=In({inputs:{x:Pe},backend:o,attrs:{shape:T}});return o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(Pe),Le}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yr{constructor(a,o){this.variableNames=["A","indices"],this.outputShape=o,this.rank=o.length;const d=oe(this.rank),c=function(f,w){const C=["resRC.x","resRC.y","resRC.z","resRC.w"],T=[];for(let P=0;P<f.length;P++)P===2?T.push("index"):T.push(`${C[P]}`);return T.join()}(a);this.userCode=`
      void main() {
        ${d} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${a[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${c}));
      }
    `}}function la(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,indices:f}=a,{axis:w,batchDims:C}=d,T=t.util.parseAxisParam(w,c.shape)[0];if(Object(t.env)().get("DEBUG")){const je=o.readSync(f.dataId),qt=c.shape[T];for(let sn=0;sn<je.length;++sn){const vn=je[sn];t.util.assert(vn<=qt-1&&vn>=0,()=>`GatherV2: the index value ${vn} is not in [0, ${qt-1}]`)}}const P=t.backend_util.segment_util.collectGatherOpShapeInfo(c,f,T,C),z=t.util.sizeFromShape(f.shape),te=[],Y=In({inputs:{x:c},backend:o,attrs:{shape:[P.batchSize,P.outerSize,P.dimSize,P.sliceSize]}}),Ce=In({inputs:{x:f},backend:o,attrs:{shape:[P.batchSize,z/P.batchSize]}});te.push(Y),te.push(Ce);const fe=[P.batchSize,P.outerSize,z/P.batchSize,P.sliceSize];if(o.shouldExecuteOnCPU([c,f])||c.dtype==="string"){const je=o.bufferSync(Ce),qt=o.bufferSync(Y),sn=Cr(qt,je,fe);return te.forEach(vn=>o.disposeIntermediateTensorInfo(vn)),o.makeTensorInfo(P.outputShape,sn.dtype,sn.values)}const Pe=new yr(Y.shape,fe),Le=o.runWebGLProgram(Pe,[Y,Ce],Y.dtype);te.push(Le);const _e=In({inputs:{x:Le},backend:o,attrs:{shape:P.outputShape}});return te.forEach(je=>o.disposeIntermediateTensorInfo(je)),_e}const Or={kernelName:t.GatherV2,backendName:"webgl",kernelFunc:la},Gr=Jr({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:Da,dtype:"bool"}),jr={kernelName:t.Greater,backendName:"webgl",kernelFunc:Gr},Na=Jr({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:kr}),ga={kernelName:t.GreaterEqual,backendName:"webgl",kernelFunc:Na};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ra={kernelName:t.IFFT,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{input:d}=a;return Ze(d,!0,o)}},Qa=pr({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Ss={kernelName:t.IsFinite,backendName:"webgl",kernelFunc:Qa},Cs=pr({opSnippet:"return float(isinf(x));",dtype:"bool"}),Li={kernelName:t.IsInf,backendName:"webgl",kernelFunc:Cs},Yi=pr({opSnippet:"return float(isnan(x));",dtype:"bool"}),Qi={kernelName:t.IsNan,backendName:"webgl",kernelFunc:Yi},ko=Jr({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:Pr,dtype:"bool"}),Ts={kernelName:t.Less,backendName:"webgl",kernelFunc:ko},Tu=Jr({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:qr,dtype:"bool"}),Ou={kernelName:t.LessEqual,backendName:"webgl",kernelFunc:Tu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $u={kernelName:t.LinSpace,backendName:"webgl",kernelFunc:function(k){const{backend:a,attrs:o}=k,{start:d,stop:c,num:f}=o,w=ha(d,c,f);return a.makeTensorInfo([w.length],"float32",w)}},Eu=pr({opSnippet:`if (isnan(x)) return x;
  return x < 0.0 ? 0./0. : log(x);
`,packedOpSnippet:`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,cpuKernelImpl:Zr}),Go={kernelName:t.Log,backendName:"webgl",kernelFunc:Eu},Au=pr({opSnippet:`if (isnan(x)) return x;
  return log(1.0 + x);
`}),Nu={kernelName:t.Log1p,backendName:"webgl",kernelFunc:Au},Ru=Jr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),Fu={kernelName:t.LogicalAnd,backendName:"webgl",kernelFunc:Ru},Mu=pr({opSnippet:"return float(!(x >= 1.0));"}),Du={kernelName:t.LogicalNot,backendName:"webgl",kernelFunc:Mu},Pu=Jr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),Bu={kernelName:t.LogicalOr,backendName:"webgl",kernelFunc:Pu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lu{constructor(a,o,d,c,f){this.variableNames=["x"],this.outputShape=[];const w=o,C=a[3]-1;let T;this.outputShape=a;const P=`float(${d}) + float(${c}) * sum`;T=f===.5?`inversesqrt(${P})`:f===1?`1.0/(${P})`:`exp(log(${P}) * float(-${f}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${w}; j <= ${w}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${C}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${T};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ju{constructor(a,o,d,c,f){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const w=o,C=a[3]-1;let T;this.outputShape=a;const P=`float(${d}) + float(${c}) * sum`;T=f===.5?`inversesqrt(${P})`:f===1?`1.0/(${P})`:`exp(log(${P}) * float(-${f}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${w};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${w}; j <= ${w}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${C}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${T};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zu={kernelName:t.LRN,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{depthRadius:f,bias:w,alpha:C,beta:T}=d,P=Object(t.env)().getBool("WEBGL_PACK_NORMALIZATION")?new ju(c.shape,f,w,C,T):new Lu(c.shape,f,w,C,T);return o.runWebGLProgram(P,[c],c.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uu{constructor(a,o,d,c,f){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=a,this.depth=a[3],this.depthRadius=o,this.bias=d,this.alpha=c,this.beta=f,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${o})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${o} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${c}) * norm + float(${d});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${c})
                * float(${f})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${f});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo={kernelName:t.LRNGrad,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{x:c,y:f,dy:w}=a,{depthRadius:C,bias:T,alpha:P,beta:z}=d,te=new Uu(c.shape,C,T,P,z);return o.runWebGLProgram(te,[c,f,w],c.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lo(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{reductionIndices:f,keepDims:w}=d,C=c.shape.length,T=t.util.parseAxisParam(f,c.shape);let P=T;const z=t.backend_util.getAxesPermutation(P,C),te=z!=null,Y=o.shouldExecuteOnCPU([c]);let Ce=c;if(te){if(Y){const je=o.texData.get(Ce.dataId).values,qt=new Array(C);for(let vn=0;vn<qt.length;vn++)qt[vn]=c.shape[z[vn]];const sn=Vt(je,c.shape,c.dtype,z,qt);Ce=o.makeTensorInfo(qt,c.dtype),o.texData.get(Ce.dataId).values=sn}else Ce=ys(c,z,o);P=t.backend_util.getInnerMostAxes(P.length,C)}t.backend_util.assertAxesAreInnerMostDims("max",P,C);const[fe,Pe]=t.backend_util.computeOutAndReduceShapes(Ce.shape,P);let Le,_e=fe;if(w&&(_e=t.backend_util.expandShapeToKeepDim(fe,T)),Y){const je=o.texData.get(Ce.dataId).values,qt=Vr(je,t.util.sizeFromShape(Pe),_e,c.dtype);Le=o.makeTensorInfo(_e,c.dtype),o.texData.get(Le.dataId).values=qt}else Le=function(je,qt,sn,vn){const En=t.util.sizeFromShape(qt),Cn=In({inputs:{x:je},attrs:{shape:[t.util.sizeFromShape(je.shape)/En,En]},backend:vn}),An=na(Cn,je.dtype,"max",vn),kn=In({inputs:{x:An},attrs:{shape:sn},backend:vn});return vn.disposeIntermediateTensorInfo(Cn),vn.disposeIntermediateTensorInfo(An),kn}(Ce,Pe,_e,o);return te&&o.disposeIntermediateTensorInfo(Ce),Le}const Ho={kernelName:t.Max,backendName:"webgl",kernelFunc:lo},ho=Jr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,cpuKernelImpl:Ca}),Ao={kernelName:t.Maximum,backendName:"webgl",kernelFunc:ho};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qo={kernelName:t.MaxPool,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a;Qt(c,"maxPool");const{filterSize:f,strides:w,pad:C,dimRoundingMode:T}=d;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(w,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${w} and dilations '1'`);const P=t.backend_util.computePool2DInfo(c.shape,f,w,1,C,T);if(P.filterWidth===1&&P.filterHeight===1&&t.util.arraysEqual(P.inShape,P.outShape))return ta({inputs:{x:c},backend:o});const z=new Xe(P,"max",!1);return o.runWebGLProgram(z,[c],c.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const No={kernelName:t.MaxPool3D,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{filterSize:f,strides:w,pad:C,dataFormat:T,dimRoundingMode:P}=d,z=t.backend_util.computePool3DInfo(c.shape,f,w,[1,1,1],C,P,T),te=new Te(z,"max",!1);return o.runWebGLProgram(te,[c],c.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class po{constructor(a){this.variableNames=["dy","maxPos"],this.outputShape=a.inShape;const o=a.strideHeight,d=a.strideWidth,c=a.dilationHeight,f=a.effectiveFilterHeight,w=a.effectiveFilterWidth,C=f-1-a.padInfo.top,T=w-1-a.padInfo.left,P=f*w-1;this.userCode=`
      const ivec2 pads = ivec2(${C}, ${T});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f};
          wR += ${c}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${a.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${w}; wC++) {
            float dyC = float(dyCCorner + wC) / ${d}.0;

            if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${P} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${w} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Ko{constructor(a){this.variableNames=["dy","maxPos"],this.outputShape=a.inShape;const o=a.strideDepth,d=a.strideHeight,c=a.strideWidth,f=a.dilationDepth,w=a.dilationHeight,C=a.dilationWidth,T=a.effectiveFilterDepth,P=a.effectiveFilterHeight,z=a.effectiveFilterWidth,te=T-1-a.padInfo.front,Y=P-1-a.padInfo.top,Ce=z-1-a.padInfo.left,fe=T*P*z-1;this.userCode=`
      const ivec3 pads = ivec3(${te}, ${Y}, ${Ce});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${T};
           wD += ${f}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${a.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${P};
              wR += ${w}) {
            float dyR = float(dyRCorner + wR) / ${d}.0;

            if (dyR < 0.0 || dyR >= ${a.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${z};
                wC += ${C}) {
              float dyC = float(dyCCorner + wC) / ${c}.0;

              if (dyC < 0.0 || dyC >= ${a.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${fe} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${P} * ${z} +
                  wR * ${z} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wu={kernelName:t.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,input:f}=a,w=f,{filterSize:C,strides:T,pad:P,dimRoundingMode:z}=d,te=t.backend_util.computePool3DInfo(w.shape,C,T,[1,1,1],P,z),Y=new Te(te,"max",!0),Ce=o.runWebGLProgram(Y,[w],w.dtype),fe=new Ko(te),Pe=o.runWebGLProgram(fe,[c,Ce],w.dtype);return o.disposeIntermediateTensorInfo(Ce),Pe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vu={kernelName:t.MaxPoolGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{dy:c,input:f,output:w}=a,C=f;Qt([f,w],"maxPoolGrad");const{filterSize:T,strides:P,pad:z,dimRoundingMode:te}=d,Y=t.backend_util.computePool2DInfo(C.shape,T,P,1,z,te),Ce=new Xe(Y,"max",!0),fe=o.runWebGLProgram(Ce,[C],C.dtype),Pe=new po(Y),Le=o.runWebGLProgram(Pe,[c,fe],C.dtype);return o.disposeIntermediateTensorInfo(fe),Le}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ro={kernelName:t.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:k,attrs:a,backend:o})=>{const{x:d}=k,{filterSize:c,strides:f,pad:w,includeBatchInIndex:C}=a,T=o;t.util.assert(d.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${d.shape.length}.`);const P=[1,1];t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(f,P),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${f} and dilations '${P}'`);const z=t.backend_util.computePool2DInfo(d.shape,c,f,P,w),[te,Y]=function(Ce,fe,Pe,Le){let _e=new Xe(Pe,"max",!1);const je=Le.runWebGLProgram(_e,[Ce],"float32");return _e=new Xe(Pe,"max",!0,!0,fe),[je,Le.runWebGLProgram(_e,[Ce],"float32")]}(d,C,z,T);return[te,Y]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hs={kernelName:t.Mean,backendName:"webgl",kernelFunc:({inputs:k,attrs:a,backend:o})=>{const{x:d}=k,{keepDims:c,axis:f}=a,w=o,C=d.shape.length,T=t.util.parseAxisParam(f,d.shape);let P=T;const z=t.backend_util.getAxesPermutation(P,C),te=z!=null,Y=w.shouldExecuteOnCPU([d]),Ce=[];let fe=d;if(te){if(Y){const qt=w.texData.get(fe.dataId).values,sn=new Array(C);for(let En=0;En<sn.length;En++)sn[En]=d.shape[z[En]];const vn=Vt(qt,d.shape,d.dtype,z,sn);fe=w.makeTensorInfo(sn,d.dtype),w.texData.get(fe.dataId).values=vn}else fe=ys(d,z,w);Ce.push(fe),P=t.backend_util.getInnerMostAxes(P.length,C)}t.backend_util.assertAxesAreInnerMostDims("sum",P,C);const[Pe,Le]=t.backend_util.computeOutAndReduceShapes(fe.shape,P);let _e=Pe;c&&(_e=t.backend_util.expandShapeToKeepDim(Pe,T));const je=function(qt,sn,vn,En){const Cn=t.util.sizeFromShape(sn),An=In({inputs:{x:qt},attrs:{shape:[t.util.sizeFromShape(qt.shape)/Cn,Cn]},backend:En}),kn=na(An,"float32","mean",En),Jn=In({inputs:{x:kn},attrs:{shape:vn},backend:En});return En.disposeIntermediateTensorInfo(An),En.disposeIntermediateTensorInfo(kn),Jn}(fe,Le,_e,w);for(const qt of Ce)w.disposeIntermediateTensorInfo(qt);return je}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo={kernelName:t.Min,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,keepDims:w}=d,C=c.shape.length,T=t.util.parseAxisParam(f,c.shape);let P=T;const z=t.backend_util.getAxesPermutation(P,C);let te=c;z!=null&&(te=ra({inputs:{x:c},backend:o,attrs:{perm:z}}),P=t.backend_util.getInnerMostAxes(P.length,c.shape.length)),t.backend_util.assertAxesAreInnerMostDims("min",P,C);const[Y,Ce]=t.backend_util.computeOutAndReduceShapes(te.shape,P),fe=In({inputs:{x:te},backend:o,attrs:{shape:[-1,t.util.sizeFromShape(Ce)]}}),Pe=na(fe,fe.dtype,"min",o);let Le;return w?Le=In({inputs:{x:Pe},backend:o,attrs:{shape:t.backend_util.expandShapeToKeepDim(Y,T)}}):Le=In({inputs:{x:Pe},backend:o,attrs:{shape:Y}}),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(Pe),z!=null&&o.disposeIntermediateTensorInfo(te),Le}},Gu=Jr({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,cpuKernelImpl:Ta}),Hu={kernelName:t.Minimum,backendName:"webgl",kernelFunc:Gu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qu{constructor(a,o,d){this.variableNames=["x"],this.outputShape=o.map((z,te)=>z[0]+a[te]+z[1]);const c=a.length,f=oe(c),w=o.map(z=>z[0]).join(","),C=o.map((z,te)=>z[0]+a[te]).join(","),T=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,c),P=d==="reflect"?0:1;this.userCode=c!==1?`
      ${f} start = ${f}(${w});
      ${f} end = ${f}(${C});

      void main() {
        ${f} outC = getOutputCoords();
        for (int i = 0; i < ${c}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${P};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${P};
          }
        }
        ${f} coords = outC - start;
        setOutput(getX(${T}));
      }
    `:`
        int start = ${w};
        int end = ${C};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${P};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${P};
          }
          setOutput(getX(outC - start));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ku{constructor(a,o,d){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.map((fe,Pe)=>fe[0]+a[Pe]+fe[1]);const c=a.length,f=oe(c),w=o.map(fe=>fe[0]).join(","),C=o.map((fe,Pe)=>fe[0]+a[Pe]).join(","),T=_n("rc",c),P=_n("source",c),z=`${T[c-1]} < ${this.outputShape[c-1]}`,te=c===1?"source":`vec2(${P.slice(-2).join()})`,Y=d==="reflect"?0:1;let Ce="";if(c===1){const fe=`
        ${f} source = rc;
        if (source < start) {
          source = start * 2 - source - ${Y};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${Y};
        }
        source -= start;
      `;Ce=`
        ${f} rc = outputLoc;
        ${fe}
        result[0] = getChannel(getX(${P.join()}), ${te});
        ${T[c-1]} += 1;
        if(${z}) {
          ${fe}
          result[1] = getChannel(getX(${P.join()}), ${te});
        }
      `}else{const fe=`
        ${f} source = rc;
        ${f} lt = ${f}(lessThan(source, start));
        ${f} gte = ${f}(greaterThanEqual(source, end));
        ${f} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${Y}) +
                gte * ((end - 1) * 2 - source + ${Y});
        source -= start;
      `;Ce=`
        ${f} rc = outputLoc;
        ${fe}
        result[0] = getChannel(getX(${P.join()}), ${te});
        ${T[c-1]} += 1;
        if(${z}) {
          ${fe}
          result[1] = getChannel(getX(${P.join()}), ${te});
        }
        rc = outputLoc;
        ${T[c-2]} += 1;
        if(${T[c-2]} < ${this.outputShape[c-2]}) {
          ${fe}
          result[2] = getChannel(getX(${P.join()}), ${te});
          ${T[c-1]} += 1;
          if(${z}) {
            ${fe}
            result[3] = getChannel(getX(${P.join()}), ${te});
          }
        }
      `}this.userCode=`
      const ${f} start = ${f}(${w});
      const ${f} end = ${f}(${C});

      void main() {
        ${f} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${Ce}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xu={kernelName:t.MirrorPad,backendName:"webgl",kernelFunc:({inputs:k,backend:a,attrs:o})=>{const{x:d}=k,{paddings:c,mode:f}=o,w=Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ku(d.shape,c,f):new qu(d.shape,c,f);return a.runWebGLProgram(w,[d],d.dtype)}},Yu=Jr({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),Qu={kernelName:t.Mod,backendName:"webgl",kernelFunc:Yu};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fo{constructor(a,o,d){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[a,d],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${o-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${o-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xo=Jr({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),Zu={kernelName:t.RealDiv,backendName:"webgl",kernelFunc:Xo},Mo="return a - b;",Do=Jr({opSnippet:Mo,packedOpSnippet:Mo,supportsComplex:!0,cpuKernelImpl:Fe}),Ju={kernelName:t.Sub,backendName:"webgl",kernelFunc:Do};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(k){const{inputs:a,backend:o,attrs:d}=k,{logits:c}=a,{dim:f}=d,w=t.util.parseAxisParam([f],c.shape),C=lo({inputs:{x:c},backend:o,attrs:{reductionIndices:w,keepDims:!1}}),T=t.backend_util.expandShapeToKeepDim(C.shape,w),P=In({inputs:{x:C},backend:o,attrs:{shape:T}}),z=Do({inputs:{a:c,b:P},backend:o}),te=N({inputs:{x:z},backend:o}),Y=cs({inputs:{x:te},backend:o,attrs:{axis:w,keepDims:!1}}),Ce=In({inputs:{x:Y},backend:o,attrs:{shape:T}}),fe=Xo({inputs:{a:te,b:Ce},backend:o});return o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(Ce),fe}const ec={kernelName:t.Softmax,backendName:"webgl",kernelFunc:Yo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tc={kernelName:t.Multinomial,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{logits:c}=a,{numSamples:f,seed:w,normalized:C}=d,T=C?c:Yo({inputs:{logits:c},backend:o,attrs:{dim:c.shape.length-1}}),P=T.shape[0],z=T.shape[1],te=new Fo(P,z,f),Y=[[w]],Ce=o.runWebGLProgram(te,[T],"int32",Y);return C||o.disposeIntermediateTensorInfo(T),Ce}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nc={kernelName:t.Neg,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{x:d}=a;if(o.shouldExecuteOnCPU([d])){const f=o.texData.get(d.dataId),[w,C]=is(f.values,d.shape,d.dtype);return o.makeTensorInfo(C,d.dtype,w)}let c;return c=Object(t.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $a(d.shape,`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`):new Yr(d.shape,`if (isnan(x)) return x;
  return -x;
`),o.runWebGLProgram(c,[d],d.dtype)}},rc=t.kernel_impls.nonMaxSuppressionV3Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qo={kernelName:t.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(k){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:a,backend:o,attrs:d}=k,{boxes:c,scores:f}=a,{maxOutputSize:w,iouThreshold:C,scoreThreshold:T}=d,P=o.readSync(c.dataId),z=o.readSync(f.dataId),{selectedIndices:te}=rc(P,z,w,C,T);return o.makeTensorInfo([te.length],"int32",new Int32Array(te))}},Po=t.kernel_impls.nonMaxSuppressionV4Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ac={kernelName:t.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(k){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:a,backend:o,attrs:d}=k,{boxes:c,scores:f}=a,{maxOutputSize:w,iouThreshold:C,scoreThreshold:T,padToMaxOutputSize:P}=d,z=o.readSync(c.dataId),te=o.readSync(f.dataId),{selectedIndices:Y,validOutputs:Ce}=Po(z,te,w,C,T,P);return[o.makeTensorInfo([Y.length],"int32",new Int32Array(Y)),o.makeTensorInfo([],"int32",new Int32Array([Ce]))]}},sc=t.kernel_impls.nonMaxSuppressionV5Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _o={kernelName:t.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(k){t.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:a,backend:o,attrs:d}=k,{boxes:c,scores:f}=a,{maxOutputSize:w,iouThreshold:C,scoreThreshold:T,softNmsSigma:P}=d,z=o.readSync(c.dataId),te=o.readSync(f.dataId),Y=w,Ce=C,fe=T,Pe=P,{selectedIndices:Le,selectedScores:_e}=sc(z,te,Y,Ce,fe,Pe);return[o.makeTensorInfo([Le.length],"int32",new Int32Array(Le)),o.makeTensorInfo([_e.length],"float32",new Float32Array(_e))]}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Io{constructor(a,o,d,c){this.variableNames=["indices"],this.outputShape=[a,o],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${c}), float(${d}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const So={kernelName:t.OneHot,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{indices:c}=a,{dtype:f,depth:w,onValue:C,offValue:T}=d,P=t.util.sizeFromShape(c.shape),z=new Io(P,w,C,T),te=In({inputs:{x:c},backend:o,attrs:{shape:[P]}}),Y=o.runWebGLProgram(z,[te],f);o.disposeIntermediateTensorInfo(te);const Ce=In({inputs:{x:Y},backend:o,attrs:{shape:[...c.shape,w]}});return o.disposeIntermediateTensorInfo(Y),Ce}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ji(k){const{inputs:a,backend:o}=k,{x:d}=a;if(d.dtype==="complex64"){const c=Mr({inputs:{input:d},backend:o}),f=ji({inputs:{x:c},backend:o}),w=Vs({inputs:{input:d},backend:o}),C=ji({inputs:{x:w},backend:o}),T=ia({inputs:{real:f,imag:C},backend:o});return o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(C),T}return Je({attrs:{shape:d.shape,dtype:d.dtype,value:d.dtype==="string"?"":0},backend:o})}const ic={kernelName:t.ZerosLike,backendName:"webgl",kernelFunc:ji};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oc={kernelName:t.OnesLike,backendName:"webgl",kernelFunc:function k(a){const{inputs:o,backend:d}=a,{x:c}=o;if(c.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(c.dtype==="complex64"){const f=Mr({inputs:{input:c},backend:d}),w=k({inputs:{x:f},backend:d}),C=Vs({inputs:{input:c},backend:d}),T=ji({inputs:{x:C},backend:d}),P=ia({inputs:{real:w,imag:T},backend:d});return d.disposeIntermediateTensorInfo(f),d.disposeIntermediateTensorInfo(w),d.disposeIntermediateTensorInfo(C),d.disposeIntermediateTensorInfo(T),P}return Je({attrs:{shape:c.shape,dtype:c.dtype,value:1},backend:d})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uc={kernelName:t.Pack,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{axis:c}=d;if(a.length===1)return ee({inputs:{input:a[0]},backend:o,attrs:{dim:c}});const f=a[0].shape,w=a[0].dtype;a.forEach(P=>{t.util.assertShapesMatch(f,P.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(w===P.dtype,()=>"All tensors passed to stack must have matching dtypes")});const C=[],T=ki({inputs:a.map(P=>{const z=ee({inputs:{input:P},backend:o,attrs:{dim:c}});return C.push(z),z}),backend:o,attrs:{axis:c}});return C.forEach(P=>o.disposeIntermediateTensorInfo(P)),T}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cc{constructor(a,o,d){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=o.map((P,z)=>P[0]+a[z]+P[1]);const c=a.length,f=oe(c),w=o.map(P=>P[0]).join(","),C=o.map((P,z)=>P[0]+a[z]).join(","),T=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,c);this.userCode=c!==1?`
      ${f} start = ${f}(${w});
      ${f} end = ${f}(${C});

      void main() {
        ${f} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${f} coords = outC - start;
          setOutput(getX(${T}));
        }
      }
    `:`
        int start = ${w};
        int end = ${C};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lc{constructor(a,o,d){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=o.map((Pe,Le)=>Pe[0]+a[Le]+Pe[1]);const c=a.length,f=oe(c),w=o.map(Pe=>Pe[0]).join(","),C=o.map((Pe,Le)=>Pe[0]+a[Le]).join(","),T=_n("rc",c),P=_n("source",c),z=`${T[c-1]} < ${this.outputShape[c-1]}`,te=c===1?"source":`vec2(${P.slice(-2).join()})`,Y=[`${f} rc = outputLoc;`,`${T[c-1]} += 1;
       if(${z}) {
      `,c===1?"":`}
       rc = outputLoc;
       ${T[c-2]} += 1;
       if(${T[c-2]} < ${this.outputShape[c-2]}) {`,c===1?"":`  ${T[c-1]} += 1;
         if(${z}) {`],Ce=c===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let fe="";for(let Pe=0,Le=c===1?2:4;Pe<Le;Pe++)fe+=`
        ${Y[Pe]}
        if (${Ce}) {
          result[${Pe}] = float(value);
        } else {
          ${f} source = rc - start;
          result[${Pe}] = getChannel(getX(${P.join()}), ${te});
        }
      `;fe+=c===1?"} ":"}}",this.userCode=`
      const ${f} start = ${f}(${w});
      const ${f} end = ${f}(${C});

      void main() {
        ${f} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${fe}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zo=k=>{const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{paddings:f,constantValue:w}=d;if(t.util.sizeFromShape(c.shape)===0)return Je({backend:o,attrs:{shape:f.map((P,z)=>P[0]+c.shape[z]+P[1]),value:w,dtype:c.dtype}});const C=Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lc(c.shape,f,w):new cc(c.shape,f,w),T=[[w]];return o.runWebGLProgram(C,[c],c.dtype,T)},Jo={kernelName:t.PadV2,backendName:"webgl",kernelFunc:Zo},eu=Jr({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),dc={kernelName:t.Pow,backendName:"webgl",kernelFunc:eu},hc={kernelName:t.Prod,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{axis:f,keepDims:w}=d,C=c.shape.length,T=[],P=t.util.parseAxisParam(f,c.shape);let z=P;const te=t.backend_util.getAxesPermutation(z,C);let Y,Ce=c;if(te!=null&&(Ce=ra({inputs:{x:c},backend:o,attrs:{perm:te}}),z=t.backend_util.getInnerMostAxes(z.length,C),T.push(Ce)),t.backend_util.assertAxesAreInnerMostDims("prod",z,C),o.shouldExecuteOnCPU([Ce])){const fe=o.texData.get(Ce.dataId).values,{outVals:Pe,outShape:Le,outDtype:_e}=Va(Ce.shape,Ce.dtype,fe,z);Y=o.makeTensorInfo(Le,_e,Pe)}else{const[fe,Pe]=t.backend_util.computeOutAndReduceShapes(Ce.shape,z),Le=t.util.sizeFromShape(Pe),_e=In({inputs:{x:Ce},backend:o,attrs:{shape:[-1,Le]}}),je=na(_e,Object(t.sumOutType)(c.dtype),"prod",o);Y=In({inputs:{x:je},backend:o,attrs:{shape:fe}}),T.push(_e),T.push(je)}if(w){T.push(Y);const fe=t.backend_util.expandShapeToKeepDim(Y.shape,P);Y=In({inputs:{x:Y},backend:o,attrs:{shape:fe}})}return T.forEach(fe=>o.disposeIntermediateTensorInfo(fe)),Y}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pc={kernelName:t.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{shape:c,values:f,defaultValue:w,rowPartitionTensors:C}=a,{rowPartitionTypes:T}=d,P=o.readSync(c.dataId),z=o.readSync(f.dataId),te=o.readSync(w.dataId),Y=C.map(Le=>o.readSync(Le.dataId)),Ce=C.map(Le=>Le.shape),[fe,Pe]=Ba(P,c.shape,z,f.shape,f.dtype,te,w.shape,Y,Ce,T);return o.makeTensorInfo(fe,f.dtype,Pe)}},tu=k=>{const{backend:a,attrs:o}=k,{start:d,stop:c,step:f,dtype:w}=o,C=wa(d,c,f,w);return a.makeTensorInfo([C.length],w,C)},fc={kernelName:t.Range,backendName:"webgl",kernelFunc:tu},Zi=pr({opSnippet:"return 1.0 / x;"}),mc={kernelName:t.Reciprocal,backendName:"webgl",kernelFunc:Zi},bc=pr({opSnippet:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),gc={kernelName:t.Relu,backendName:"webgl",kernelFunc:bc},nu=pr({opSnippet:`if (isnan(x)) return x;
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),ru={kernelName:t.Relu6,backendName:"webgl",kernelFunc:nu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class au{constructor(a,o,d,c,f){this.variableNames=["A"],this.outputShape=[];const[w,C,T,P]=a;this.outputShape=[w,o,d,P];const z=[c&&o>1?C-1:C,c&&d>1?T-1:T],te=[c&&o>1?o-1:o,c&&d>1?d-1:d];let Y;Y=f?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${z[0]/te[0]},
          ${z[1]/te[1]});
      const vec2 inputShapeRC = vec2(${C}.0, ${T}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Y};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bo{constructor(a,o,d,c,f){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[w,C,T,P]=a;this.outputShape=[w,o,d,P];const z=[c&&o>1?C-1:C,c&&d>1?T-1:T],te=[c&&o>1?o-1:o,c&&d>1?d-1:d];let Y;Y=f?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${z[0]/te[0]},
          ${z[1]/te[1]},
          ${z[1]/te[1]});
      const vec3 inputShapeRC = vec3(${C}.0, ${T}.0,
                                     ${T}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Y};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${P-1};
        bool hasNextRow = coords.z < ${d-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xc={kernelName:t.ResizeBilinear,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{images:c}=a,{alignCorners:f,halfPixelCenters:w,size:C}=d,[T,P]=C,z=Object(t.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Bo(c.shape,T,P,f,w):new au(c.shape,T,P,f,w);return o.runWebGLProgram(z,[c],"float32")}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vc{constructor(a,o,d){this.variableNames=["dy"],this.outputShape=[],this.outputShape=o;const[,c,f]=o,[,w,C]=a,T=[d&&w>1?c-1:c,d&&C>1?f-1:f],P=[d&&w>1?w-1:w,d&&C>1?C-1:C],z=T[0]/P[0],te=T[1]/P[1],Y=1/z,Ce=1/te,fe=2*Math.ceil(Y)+2,Pe=2*Math.ceil(Ce)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${z});
        const float widthScale = float(${te});

        const float invHeightScale = float(${Y});
        const float invWidthScale = float(${Ce});

        const int winHeight = int(${fe});
        const int winWidth = int(${Pe});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${w}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${C}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${c-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${f-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const su={kernelName:t.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{images:c,dy:f}=a,{alignCorners:w}=d,C=new vc(f.shape,c.shape,w);return o.runWebGLProgram(C,[f],f.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yc{constructor(a,o,d,c,f){this.variableNames=["A"],this.outputShape=[];const[w,C,T,P]=a;this.outputShape=[w,o,d,P];const z=[c&&o>1?C-1:C,c&&d>1?T-1:T],te=[c&&o>1?o-1:o,c&&d>1?d-1:d],Y=c?"0.5":"0.0";let Ce;Ce=f?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${z[0]/te[0]},
          ${z[1]/te[1]});
      const vec2 inputShapeRC = vec2(${C}.0, ${T}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${Ce};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Y})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wc{constructor(a,o,d,c,f){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[w,C,T,P]=a;this.outputShape=[w,o,d,P];const z=[c&&o>1?C-1:C,c&&d>1?T-1:T],te=[c&&o>1?o-1:o,c&&d>1?d-1:d],Y=c?"0.5":"0.0";let Ce;Ce=f?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${z[0]/te[0]},
          ${z[1]/te[1]},
          ${z[1]/te[1]});
      const vec3 inputShapeRC = vec3(${C}.0, ${T}.0,
                                     ${T}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${Ce};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${Y})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${P-1};
        bool hasNextRow = coords.z < ${d-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc={kernelName:t.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{images:c}=a,{alignCorners:f,halfPixelCenters:w,size:C}=d,[T,P]=C,z=Object(t.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wc(c.shape,T,P,f,w):new yc(c.shape,T,P,f,w);return o.runWebGLProgram(z,[c],c.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _c{constructor(a,o,d){this.variableNames=["dy"],this.outputShape=[],this.outputShape=o;const[,c,f]=o,[,w,C]=a,T=[d&&w>1?c-1:c,d&&C>1?f-1:f],P=[d&&w>1?w-1:w,d&&C>1?C-1:C],z=T[0]/P[0],te=T[1]/P[1],Y=1/z,Ce=1/te,fe=2*Math.ceil(Y)+2,Pe=2*Math.ceil(Ce)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${z});
        const float widthScale = float(${te});

        const float invHeightScale = float(${Y});
        const float invWidthScale = float(${Ce});

        const int winHeight = int(${fe});
        const int winWidth = int(${Pe});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${w}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${C}) {
              continue;
            }

            float sourceFracRow =
              float(${T[0]}) *
                (float(dyR) / float(${P[0]}));

            float sourceFracCol =
                float(${T[1]}) *
                  (float(dyC) / float(${P[1]}));

            int sourceNearestRow = int(min(
                float(int(${c}) - 1),
                ${d} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${f}) - 1),
                ${d} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ic={kernelName:t.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{images:c,dy:f}=a,{alignCorners:w}=d,C=new _c(f.shape,c.shape,w);return o.runWebGLProgram(C,[f],f.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sc{constructor(a,o){this.variableNames=["x"];const d=a.length;if(d>4)throw new Error(`WebGL backend: Reverse of rank-${d} tensor is not yet supported`);if(this.outputShape=a,d===1)return void(this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${a[0]} - coord - 1));
        }
      `);const c=a.map((w,C)=>(T=>o.indexOf(T)!==-1&&a[T]!==1?`${a[T]} - coords[${T}] - 1`:`coords[${T}]`)(C)).join(","),f=oe(d);this.userCode=`
      void main() {
        ${f} coords = getOutputCoords();
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cc{constructor(a,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const d=a.length;if(d>4)throw new Error(`WebGL backend: Reverse of rank-${d} tensor is not yet supported`);this.outputShape=a;const c=_n("rc",d),f=`${c[d-1]} + 1 < ${this.outputShape[d-1]}`,w=`${c[d-2]} + 1 < ${this.outputShape[d-2]}`,C=oe(d);function T(P){const z=a.map((te,Y)=>function(Ce,fe){return o.indexOf(Ce)!==-1&&a[Ce]!==1?`${a[Ce]} - ${fe[Ce]} - 1`:`${fe[Ce]}`}(Y,P));return`getChannel(getX(${z.join(",")}), vec2(${z.slice(-2).join(",")}))`}this.userCode=d===1?`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${a[0]} - rc - 1),
            ${a[0]} - rc - 1);
          if(${f}){
              result.g = getChannel(getX(${a[0]} - (rc  + 1) - 1),
                ${a[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:`
        void main() {
          ${C} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${function(P){return T(P)}(c.slice())};
          if(${f}){
            result.g = ${function(P){return P[d-1]="("+P[d-1]+" + 1)",T(P)}(c.slice())};
          }
          if(${w}) {
            result.b = ${function(P){return P[d-2]="("+P[d-2]+" + 1)",T(P)}(c.slice())};
            if(${f}) {
              result.a = ${function(P){return P[d-1]="("+P[d-1]+" + 1)",P[d-2]="("+P[d-2]+" + 1)",T(P)}(c.slice())};
            }
          }
          setOutput(result);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc={kernelName:t.Reverse,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{dims:f}=d,w=c.shape.length,C=t.util.parseAxisParam(f,c.shape);if(w===0)return ta({inputs:{x:c},backend:o});const T=Object(t.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Cc(c.shape,C):new Sc(c.shape,C);return o.runWebGLProgram(T,[c],c.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oc{constructor(a,o){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const d=a[1],c=a[2];this.outputShape=a;let f="";f=typeof o=="number"?`float outputValue = ${o.toFixed(2)};`:`
        vec3 fill = vec3(${o.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${f}
          if(coordX >= 0 && coordX < ${c} && coordY >= 0 && coordY < ${d}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $c={kernelName:t.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:k,attrs:a,backend:o})=>{const{image:d}=k,{radians:c,fillValue:f,center:w}=a,C=o,T=new Oc(d.shape,f),[P,z]=t.backend_util.getImageCenter(w,d.shape[1],d.shape[2]),te=[[P,z,Math.sin(c),Math.cos(c)]];return C.runWebGLProgram(T,[d],d.dtype,te)}},Ec=pr({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),iu={kernelName:t.Round,backendName:"webgl",kernelFunc:Ec},Ac=pr({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Ga}),Wa={kernelName:t.Rsqrt,backendName:"webgl",kernelFunc:Ac};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ii{constructor(a,o,d,c,f,w,C=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=w;const T=oe(f.length),P=oe(w.length);let z="";d===1?z="i":d===2&&(z="i, j");const te=`getIndices(${z})`;let Y="";c===1?Y="i":c===2&&(Y="i, coords[1]");const Ce=`getUpdates(${Y})`,fe=o>1?"strides[j]":"strides";this.userCode=`
        ${T} strides = ${T}(${f});

        void main() {
          ${P} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${a}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${o}; j++) {
              int index = round(${te});
              flattenedIndex += index * ${fe};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${Ce};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nc={kernelName:t.ScatterNd,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{indices:c,updates:f}=a,{shape:w}=d,{sliceRank:C,numUpdates:T,sliceSize:P,strides:z,outputSize:te}=t.backend_util.calculateShapes(f,c,w),Y=[te/P,P];if(te===0)return o.makeTensorInfo(w,c.dtype);const Ce=In({inputs:{x:c},backend:o,attrs:{shape:[T,C]}}),fe=In({inputs:{x:f},backend:o,attrs:{shape:[T,P]}}),Pe=o.makeTensorInfo([],"float32",new Float32Array([0])),Le=new ii(T,C,Ce.shape.length,fe.shape.length,z,Y),_e=o.runWebGLProgram(Le,[fe,Ce,Pe],fe.dtype),je=In({inputs:{x:_e},backend:o,attrs:{shape:w}});return o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(_e),o.disposeIntermediateTensorInfo(Pe),je}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rc{constructor(a,o,d,c){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[a,d];const f=`for (int i = 0; i < ${Math.ceil(Math.log2(o+1))}; ++i) { if (left >= right) break;`,w=Object(t.env)().getNumber("WEBGL_VERSION")===2?"while (left < right) {":f,C=c==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${w}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${C} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fc={kernelName:t.SearchSorted,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{sortedSequence:c,values:f}=a,{side:w}=d,C=new Rc(c.shape[0],c.shape[1],f.shape[1],w),T=[[c.shape[1]]];return o.runWebGLProgram(C,[c,f],"int32",T)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mc{constructor(a,o,d){let c,f;if(this.variableNames=["c","a","b"],this.outputShape=o,d>4)throw Error(`Where for rank ${d} is not yet supported`);if(d===1)f="resRC",c="resRC";else{const C=["resRC.x","resRC.y","resRC.z","resRC.w"],T=[],P=[];for(let z=0;z<o.length;z++)P.push(`${C[z]}`),z<a&&T.push(`${C[z]}`);c=T.join(),f=P.join()}const w=oe(d);this.userCode=`
      void main() {
        ${w} resRC = getOutputCoords();
        float cVal = getC(${c});
        if (cVal >= 1.0) {
          setOutput(getA(${f}));
        } else {
          setOutput(getB(${f}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dc={kernelName:t.Select,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{condition:d,t:c,e:f}=a,w=new Mc(d.shape.length,c.shape,c.shape.length);return o.runWebGLProgram(w,[d,c,f],Object(t.upcastType)(c.dtype,f.dtype))}},Pc=pr({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${t.backend_util.SELU_SCALEALPHA};
  float scale = ${t.backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),Bc={kernelName:t.Selu,backendName:"webgl",kernelFunc:Pc},Lc=pr({opSnippet:`if (isnan(x)) return x;
  return 1.0 / (1.0 + exp(-1.0 * x));
`,packedOpSnippet:`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpuKernelImpl:ka}),jc={kernelName:t.Sigmoid,backendName:"webgl",kernelFunc:Lc},zc=pr({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),Uc={kernelName:t.Sign,backendName:"webgl",kernelFunc:zc},Wc=pr({opSnippet:`if (isnan(x)) return x;
  return sin(x);
`}),Vc={kernelName:t.Sin,backendName:"webgl",kernelFunc:Wc},Gc=pr({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),Hc={kernelName:t.Sinh,backendName:"webgl",kernelFunc:Gc},qc=pr({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),Kc={kernelName:t.Softplus,backendName:"webgl",kernelFunc:qc},Xc={kernelName:t.SpaceToBatchND,backendName:"webgl",kernelFunc:k=>{const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{blockShape:f,paddings:w}=d;t.util.assert(c.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const C=f.reduce((_e,je)=>_e*je),T=[[0,0]];T.push(...w);for(let _e=1+f.length;_e<c.shape.length;++_e)T.push([0,0]);const P=[],z=Zo({inputs:{x:c},backend:o,attrs:{paddings:T,constantValue:0}}),te=t.backend_util.getReshaped(z.shape,f,C,!1),Y=t.backend_util.getPermuted(te.length,f.length,!1),Ce=t.backend_util.getReshapedPermuted(z.shape,f,C,!1),fe=In({inputs:{x:z},backend:o,attrs:{shape:te}}),Pe=ra({inputs:{x:fe},backend:o,attrs:{perm:Y}}),Le=In({inputs:{x:Pe},backend:o,attrs:{shape:Ce}});return P.push(z),P.push(fe),P.push(Pe),P.forEach(_e=>o.disposeIntermediateTensorInfo(_e)),Le}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yc={kernelName:t.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{indices:d,values:c,denseShape:f,defaultValue:w}=a;if(f.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${f.shape}`);if(d.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${d.shape}`);if(c.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${c.shape}`);if(w.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${w.shape}`);const C=o.readSync(d.dataId),T=o.readSync(c.dataId),P=o.readSync(f.dataId),z=o.readSync(w.dataId)[0],[te,Y,Ce,fe,Pe]=Za(C,d.shape,d.dtype,T,c.dtype,P,z);return[o.makeTensorInfo(Y,d.dtype,te),o.makeTensorInfo([Y[0]],c.dtype,Ce),o.makeTensorInfo([fe.length],"bool",new Uint8Array(fe.map(Le=>Number(Le)))),o.makeTensorInfo([Pe.length],d.dtype,new Int32Array(Pe))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc={kernelName:t.SparseReshape,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{inputIndices:d,inputShape:c,newShape:f}=a;if(d.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${d.shape}`);if(c.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${c.shape}`);if(f.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${f.shape}`);const w=Array.from(o.readSync(c.dataId)),C=o.readSync(d.dataId),T=Array.from(o.readSync(f.dataId)),[P,z,te]=La(C,d.shape,d.dtype,w,T);return[o.makeTensorInfo(z,d.dtype,P),o.makeTensorInfo([te.length],f.dtype,new Int32Array(te))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zc={kernelName:t.SparseSegmentMean,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{data:d,indices:c,segmentIds:f}=a;if(d.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(c.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${c.shape}`);if(f.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${f.shape}`);const w=o.readSync(d.dataId),C=o.readSync(c.dataId),T=o.readSync(f.dataId),[P,z]=wr(w,d.shape,d.dtype,C,T,!0);return o.makeTensorInfo(z,d.dtype,P)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jc={kernelName:t.SparseSegmentSum,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o}=k,{data:d,indices:c,segmentIds:f}=a;if(d.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(c.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${c.shape}`);if(f.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${f.shape}`);const w=o.readSync(d.dataId),C=o.readSync(c.dataId),T=o.readSync(f.dataId),[P,z]=wr(w,d.shape,d.dtype,C,T);return o.makeTensorInfo(z,d.dtype,P)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el={kernelName:t.SparseToDense,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{sparseIndices:c,sparseValues:f,defaultValue:w}=a,{outputShape:C}=d,{sliceRank:T,numUpdates:P,sliceSize:z,strides:te,outputSize:Y}=t.backend_util.calculateShapes(f,c,C);if(f.dtype==="string"){const Le=o.bufferSync(c),_e=o.bufferSync(f),je=t.util.decodeString(o.readSync(w.dataId)[0]),qt=Xr(Le,_e,C,Y,z,P,T,te,je,!1);return o.makeTensorInfo(C,qt.dtype,qt.values)}const Ce=new ii(P,T,c.shape.length,f.shape.length,te,[Y,1],!1),fe=o.runWebGLProgram(Ce,[f,c,w],f.dtype),Pe=In({inputs:{x:fe},backend:o,attrs:{shape:C}});return o.disposeIntermediateTensorInfo(fe),Pe}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oi={kernelName:t.SplitV,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{numOrSizeSplits:f,axis:w}=d,C=t.util.parseAxisParam(w,c.shape)[0],T=t.backend_util.prepareSplitSize(c,f,C),P=c.shape.length,z=new Array(P).fill(0),te=c.shape.slice();return T.map(Y=>{const Ce=[...te];Ce[C]=Y;const fe=Pt({inputs:{x:c},backend:o,attrs:{begin:z,size:Ce}});return z[C]+=Y,fe})}},ou="return sqrt(x);",tl=pr({opSnippet:ou,packedOpSnippet:ou,cpuKernelImpl:sa}),nl={kernelName:t.Sqrt,backendName:"webgl",kernelFunc:tl},rl=pr({opSnippet:"return x * x;"}),al={kernelName:t.Square,backendName:"webgl",kernelFunc:rl},uu="return (a - b) * (a - b);",sl=Jr({opSnippet:uu,packedOpSnippet:uu}),Lo={kernelName:t.SquaredDifference,backendName:"webgl",kernelFunc:sl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const il={kernelName:t.Step,backendName:"webgl",kernelFunc:function({inputs:k,attrs:a,backend:o}){const{x:d}=k,c=`if (isnan(x)) return x;
    return x > 0.0 ? 1.0 : float(${a.alpha});
  `,f=new Yr(d.shape,c);return o.runWebGLProgram(f,[d],d.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ol{constructor(a,o,d){this.variableNames=["x"],this.outputShape=d;const c=d.length,f=oe(d.length),w=oe(d.length);let C="";if(c===1)C="coords * strides + begin";else{let T=0;C=d.map((P,z)=>(T++,d.length===1?`coords * strides[${z}] + begin[${z}]`:`coords[${T-1}] * strides[${z}] + begin[${z}]`)).join(",")}this.userCode=`
      ${f} begin = ${f}(${a});
      ${f} strides = ${f}(${o});

      void main() {
        ${w} coords = getOutputCoords();
        setOutput(getX(${C}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ul={kernelName:t.StridedSlice,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{begin:f,end:w,strides:C,beginMask:T,endMask:P,ellipsisMask:z,newAxisMask:te,shrinkAxisMask:Y}=d,{finalShapeSparse:Ce,finalShape:fe,isIdentity:Pe,sliceDim0:Le,isSimpleSlice:_e,begin:je,end:qt,strides:sn}=t.slice_util.sliceInfo(c.shape,f,w,C,T,P,z,te,Y);let vn;if(Pe)vn=In({inputs:{x:c},backend:o,attrs:{shape:fe}});else if(Le||_e){t.util.assert(c.shape.length>=1,()=>`Input must have rank at least 1, got: ${c.shape.length}`);const Cn=t.slice_util.computeOutShape(je,qt,sn),An=Pt({inputs:{x:c},backend:o,attrs:{begin:je,size:Cn}});vn=In({inputs:{x:An},backend:o,attrs:{shape:fe}}),o.disposeIntermediateTensorInfo(An)}else if(o.shouldExecuteOnCPU([c])){const Cn=o.readSync(c.dataId),An=Object(t.buffer)(c.shape,c.dtype,Cn),kn=Ia(Ce,An,sn,je);vn=o.makeTensorInfo(fe,c.dtype,kn.values)}else{const Cn=new ol(je,sn,Ce);vn=o.runWebGLProgram(Cn,[c],c.dtype)}const En=In({inputs:{x:vn},backend:o,attrs:{shape:fe}});return o.disposeIntermediateTensorInfo(vn),En}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cl={kernelName:t.StringNGrams,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{separator:c,nGramWidths:f,leftPad:w,rightPad:C,padWidth:T,preserveShortSequences:P}=d,{data:z,dataSplits:te}=a,Y=o.readSync(z.dataId),Ce=o.readSync(te.dataId),[fe,Pe]=ba(Y,Ce,c,f,w,C,T,P);return[o.makeTensorInfo([fe.length],"string",fe),o.makeTensorInfo(te.shape,"int32",Pe)]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ll={kernelName:t.StringSplit,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{skipEmpty:c}=d,{input:f,delimiter:w}=a;if(f.dtype!=="string")throw new Error("Input must be of datatype string");if(f.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${f.shape}`);if(w.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${w.shape}`);const C=o.readSync(f.dataId),T=o.readSync(w.dataId)[0],[P,z,te]=ca(C,T,c),Y=z.length;return[o.makeTensorInfo([Y,2],"int32",P),o.makeTensorInfo([Y],"string",z),o.makeTensorInfo([2],"int32",new Int32Array(te))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dl={kernelName:t.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{numBuckets:c}=d,{input:f}=a;if(f.dtype!=="string")throw new Error("Input must be of datatype string");if(c<=0)throw new Error("Number of buckets must be at least 1");const w=o.readSync(f.dataId),C=Ja(w,c);return o.makeTensorInfo(f.shape,"int32",C)}},hl=pr({opSnippet:"return tan(x);"}),pl={kernelName:t.Tan,backendName:"webgl",kernelFunc:hl},fl=pr({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),ml={kernelName:t.Tanh,backendName:"webgl",kernelFunc:fl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bl{constructor(a,o){this.variableNames=["A"];const d=new Array(a.length);for(let w=0;w<d.length;w++)d[w]=a[w]*o[w];this.outputShape=d,this.rank=d.length;const c=oe(this.rank),f=function(w){const C=w.length;if(C>5)throw Error(`Tile for rank ${C} is not yet supported`);if(C===1)return`imod(resRC, ${w[0]})`;const T=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],P=[];for(let z=0;z<w.length;z++)P.push(`imod(${T[z]}, ${w[z]})`);return P.join()}(a);this.userCode=`
      void main() {
        ${c} resRC = getOutputCoords();
        setOutput(getA(${f}));
      }
    `}}function cu(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{reps:f}=d;if(c.dtype==="string"||c.shape.length>5){const C=o.readSync(c.dataId),T=c.dtype==="string"?C.map(te=>t.util.decodeString(te)):C,P=Object(t.buffer)(c.shape,c.dtype,T),z=dt(P,f);return o.makeTensorInfo(z.shape,z.dtype,z.values)}const w=new bl(c.shape,f);return o.runWebGLProgram(w,[c],c.dtype)}const gl={kernelName:t.Tile,backendName:"webgl",kernelFunc:cu};class xl{constructor(a){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=a,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class vl{constructor(a){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=a,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ci(k,a){a!==null&&k.disposeIntermediateTensorInfo(a)}function lu(k){let a=1;for(;a<k;)a*=2;return a}const yl={kernelName:t.TopK,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c}=a,{k:f,sorted:w}=d,C=Object(t.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),T=Object(t.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),P=c.shape,z=P[P.length-1];if(o.shouldExecuteOnCPU([c])||z<C||f>T){const kn=o.readSync(c.dataId),[Jn,qn]=Et(kn,P,c.dtype,f,w);return[o.makeTensorInfo(Jn.shape,Jn.dtype,Jn.values),o.makeTensorInfo(qn.shape,qn.dtype,qn.values)]}if(f===0)return P[P.length-1]=0,[o.makeTensorInfo(P,c.dtype,[]),o.makeTensorInfo(P,"int32",[])];if(z===1)return[c,Je({attrs:{shape:P,dtype:"int32",value:0},backend:o})];const te=o.texData.get(c.dataId),Y=te!==null&&te.isPacked,Ce=Y?o.unpackTensor(c):c,fe=t.util.sizeFromShape(P)/z,Pe=In({inputs:{x:Ce},attrs:{shape:[fe,z]},backend:o});Y&&Ci(o,Ce);const Le=lu(f),_e=lu(z);let je=null;const qt=()=>je===null?[Pe,Pe]:[Pe,je],sn=(kn,Jn,qn)=>{const s=qt(),r=new xl(qn),i=[[z],[je===null?1:0],[Number.NEGATIVE_INFINITY],[kn],[Jn]],u=je;je=o.runWebGLProgram(r,s,"int32",i),Ci(o,u)};for(let kn=1;kn<Le;kn*=2){const Jn=2*kn;for(let qn=kn;qn>=1;qn/=2)sn(Jn,qn,[fe,_e])}for(let kn=_e;kn>Le;kn/=2){const Jn=qt(),qn=new vl([fe,kn/2]),s=[[z],[je===null?1:0],[Le]],r=je;je=o.runWebGLProgram(qn,Jn,"int32",s),Ci(o,r);const i=Le/2,u=2*i;for(let p=i;p>=1;p/=2)sn(u,p,je.shape)}let vn=je;je=Pt({inputs:{x:je},backend:o,attrs:{begin:0,size:[fe,f]}}),Ci(o,vn);let En=la({inputs:{x:Pe,indices:je},backend:o,attrs:{axis:1,batchDims:1}});Ci(o,Pe);const Cn=P.slice(0,-1);Cn.push(f),vn=je,je=In({inputs:{x:je},attrs:{shape:Cn},backend:o}),Ci(o,vn);const An=En;return En=In({inputs:{x:En},attrs:{shape:Cn},backend:o}),Ci(o,An),[En,je]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wl{constructor(a,o,d,c,f,w){this.variableNames=["Image","Transforms"],this.outputShape=w;const C=d==="nearest"?1:2;let T;switch(c){case"constant":default:T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${T} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${T} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${T} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${a} && 0 <= coordX && coordX < ${o}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${f});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${f});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${o}));
                float mapY = mapCoord(inY, float(${a}));

                if (${C} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kl={kernelName:t.Transform,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{image:c,transforms:f}=a,{interpolation:w,fillMode:C,fillValue:T,outputShape:P}=d,[z,te,Y,Ce]=c.shape,[fe,Pe]=P!=null?P:[te,Y],Le=new wl(te,Y,w,C,T,[z,fe,Pe,Ce]);return o.runWebGLProgram(Le,[c,f],"float32")}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _l={kernelName:t.Unique,backendName:"webgl",kernelFunc:function(k){const{inputs:a,attrs:o,backend:d}=k,{axis:c}=o,{x:f}=a;Qt(f,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const w=d.readSync(f.dataId),{outputValues:C,outputShape:T,indices:P}=an(w,c,f.shape,f.dtype);return[d.makeTensorInfo(T,f.dtype,C),d.makeTensorInfo([P.length],"int32",P)]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Il={kernelName:t.Unpack,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{value:c}=a;let{axis:f}=d;f<0&&(f+=c.shape.length);const w=c,C=w.shape.length,T=c.shape[f],P=new Array(C-1);let z=0;for(let Pe=0;Pe<C;Pe++)Pe!==f&&(P[z++]=w.shape[Pe]);const te=[],Y=new Array(C).fill(0),Ce=w.shape.slice();Ce[f]=1;const fe=new Array(T);for(let Pe=0;Pe<fe.length;Pe++){Y[f]=Pe;const Le=Pt({inputs:{x:w},backend:o,attrs:{begin:Y,size:Ce}}),_e=In({inputs:{x:Le},backend:o,attrs:{shape:P}});fe[Pe]=_e,te.push(Le)}return te.forEach(Pe=>o.disposeIntermediateTensorInfo(Pe)),fe}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sl{constructor(a,o){this.variableNames=["x","segmentIds"];const d=a.windowSize,c=a.batchSize,f=a.inSize,w=a.numSegments,C=w*Math.ceil(f/d);this.outputShape=[c,C];const T=4*Math.floor(d/4),P=d%4,z=`
        sumValue += dot(values, segFilter);
    `;let te="";f%d>0&&(te=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return initializationValue;
        }
      `);let Y="";f%d>0&&(Y=`
        if (inIdx < 0 || inIdx >= ${f}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${te}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${Y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${w})) * float(${d}));
        int currentSeg = int(mod(float(outIdx), float(${w})));

        float sumValue = 0.0;

        for (int i = 0; i < ${T}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${z}
        }

        int inIdx = inOffset + ${T};
        if (${P===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${z}
        } else if (${P===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${z}
        } else if (${P===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${z}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cl=[Tr,Rs,ws,ur,ei,ti,Ps,ns,js,Ni,zs,vi,Fi,Ne,Be,Ye,it,ft,pt,zt,_t,Fn,nr,dr,Dr,ya,Us,Aa,ds,no,ai,Ii,Pi,qi,oo,fi,co,mi,Si,ve,Oe,j,F,Ee,ye,Ue,Ve,tt,at,bt,St,v,M,H,se,De,Ge,yt,kt,Yt,nn,Bn,Wn,Hn,er,Or,jr,ga,Ys,Ra,wi,Ss,Li,Qi,hi,Ts,Ou,$u,Go,Nu,Fu,Du,Bu,zu,Eo,Ho,Ao,qo,No,Wu,Vu,Ro,Hs,fo,Hu,Xu,Qu,tc,Yn,nc,Qo,ac,_o,cr,So,oc,uc,Jo,dc,pi,hc,pc,fc,Sr,Zu,mc,gc,ru,Fr,xc,su,kc,Ic,Tc,$c,iu,Wa,Nc,Fc,Dc,Bc,jc,Uc,Vc,Hc,hn,ec,Kc,Xc,Yc,Qc,Zc,Jc,el,oi,nl,al,Lo,il,ul,cl,ll,dl,Ju,xi,pl,ml,gl,yl,kl,Ua,_l,Il,{kernelName:t.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(k){const{inputs:a,backend:o,attrs:d}=k,{x:c,segmentIds:f}=a,{numSegments:w}=d,C=c.shape.length,T=[];let P=0;const z=t.backend_util.getAxesPermutation([P],C);let te=c;z!=null&&(te=ra({inputs:{x:c},backend:o,attrs:{perm:z}}),T.push(te),P=t.backend_util.getInnerMostAxes(1,C)[0]);const Y=t.backend_util.segment_util.computeOutShape(te.shape,P,w),Ce=t.util.sizeFromShape([te.shape[P]]),fe=In({inputs:{x:te},backend:o,attrs:{shape:[-1,Ce]}});T.push(fe);const Pe=Object(t.sumOutType)(c.dtype),Le=(qt,sn,vn,En,Cn)=>{const An=qt.shape[0],kn=qt.shape[1],Jn=t.backend_util.segment_util.segOpComputeOptimalWindowSize(kn,Cn),qn=new Sl({windowSize:Jn,inSize:kn,batchSize:An,numSegments:Cn},sn),s=o.compileAndRun(qn,[qt,vn],En);if(T.push(s),s.shape[1]===Cn)return s;const r=tu({backend:o,attrs:{start:0,stop:Cn,step:1,dtype:"float32"}}),i=cu({inputs:{x:r},backend:o,attrs:{reps:[kn/Jn]}});return T.push(r),T.push(i),Le(s,sn,i,En,Cn)},_e=In({inputs:{x:Le(fe,"unsortedSegmentSum",f,Pe,w)},backend:o,attrs:{shape:Y}});let je=_e;if(z!=null){T.push(_e);const qt=t.backend_util.getUndoAxesPermutation(z);je=ra({inputs:{x:je},backend:o,attrs:{perm:qt}})}return T.forEach(qt=>o.disposeIntermediateTensorInfo(qt)),je}},ic];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const k of Cl)Object(t.registerKernel)(k);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(I,n,e){var t=e(0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m=Object(t.env)();m.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),m.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),m.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),m.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1),m.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),m.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),m.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),m.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h{constructor(v){this.device=v,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(v,x){return this.acquireBuffer(v,x,!0)}acquireBuffer(v,x,M=!1){const N=b(v,x);if(this.freeBuffers.has(N)||this.freeBuffers.set(N,[]),this.usedBuffers.has(N)||this.usedBuffers.set(N,[]),this.numBytesUsed+=v,this.numUsedBuffers++,this.freeBuffers.get(N).length>0){this.numFreeBuffers--;const ee=this.freeBuffers.get(N).shift();return this.usedBuffers.get(N).push(ee),ee}this.numBytesAllocated+=v;const H=this.device.createBuffer({size:v,usage:x,mappedAtCreation:M});return this.usedBuffers.get(N).push(H),H}releaseBuffer(v,x,M){if(this.freeBuffers.size===0)return;const N=b(x,M);this.freeBuffers.has(N)||this.freeBuffers.set(N,[]),this.freeBuffers.get(N).push(v),this.numFreeBuffers++,this.numUsedBuffers--;const H=this.usedBuffers.get(N),ee=H.indexOf(v);if(ee<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");H.splice(ee,1),this.numBytesUsed-=x}releaseUploadBuffer(v,x,M){v.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(v,x,M)},N=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((v,x)=>{v.forEach(M=>{M.destroy()})}),this.usedBuffers.forEach((v,x)=>{v.forEach(M=>{M.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function b(R,v){return`${R}_${v}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A{constructor(v){this.device=v,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(v,x,M,N){const H=v*x*y(M),ee=D(v,x,M,N);if(this.freeTextures.has(ee)||this.freeTextures.set(ee,[]),this.usedTextures.has(ee)||this.usedTextures.set(ee,[]),this.numBytesUsed+=H,this.numUsedTextures++,this.freeTextures.get(ee).length>0){this.numFreeTextures--;const ce=this.freeTextures.get(ee).shift();return this.usedTextures.get(ee).push(ce),ce}this.numBytesAllocated+=H;const se=this.device.createTexture({size:[v,x],format:M,usage:N});return this.usedTextures.get(ee).push(se),se}releaseTexture(v,x,M,N,H){if(this.freeTextures.size===0)return;const ee=D(x,M,N,H);this.freeTextures.has(ee)||this.freeTextures.set(ee,[]),this.freeTextures.get(ee).push(v),this.numFreeTextures++,this.numUsedTextures--;const se=this.usedTextures.get(ee),ce=se.indexOf(v);if(ce<0)throw new Error("Cannot release a texture that was never provided by this texture manager");se.splice(ce,1);const xe=x*M*y(N);this.numBytesUsed-=xe}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((v,x)=>{v.forEach(M=>{M.destroy()})}),this.usedTextures.forEach((v,x)=>{v.forEach(M=>{M.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function D(R,v,x,M){return`${R}_${v}_${x}_${M}`}function y(R){if(R==="rgba8unorm")return 16;throw new Error(`${R} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E(R,v){if(Math.max(...R)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const x=R.length,M=R.map(H=>`${v}[${H}]`),N=new Array(x-1);N[x-2]=M[x-1];for(let H=x-3;H>=0;--H)N[H]=`(${N[H+1]} * ${M[H+1]})`;return N}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S=(R,v,x,M)=>{const N=function(ee,se,ce){const xe=[];if(xe.push(`
      const workGroupSizeX = ${ce.workGroupSize[0]}u;
      const workGroupSizeY = ${ce.workGroupSize[1]}u;
      const workGroupSizeZ = ${ce.workGroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${de(ce)?"  return i32(globalId.x);":`  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
                   localId.y * workGroupSizeX + localId.x;
               let workGroupID = (globalId - localId)/vec3<u32>(
                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);

               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
                   workGroupID.y * numWorkgroups.x + workGroupID.x) *
                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
                   localInvocationIndex);
        `}
      }
    `),ce.isFromPixels)return xe.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${ke(se.dtype,ce.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `),[L,xe.join(`
`),g(se.shape),ce.getUserCode()].join(`
`);let De="struct Uniforms { NAN : f32, ";ce.variableNames.forEach((yt,gt)=>{const kt=l(ee[gt].shape.length);De+=`${yt.charAt(0).toLowerCase()+yt.slice(1)}Shape : ${kt}, `}),De+=`outShape : ${l(se.shape.length)}, `,De+=`
         outShapeStrides: ${l(se.shape.length-1)}, `,ce.size&&(De+="size : i32, "),ce.uniforms&&(De+=ce.uniforms),De+="};",De=function(yt){const gt=/(\w+)\s*:\s*vec(5|6)/g;yt=yt.replace(gt,Tt=>"@align(16) "+Tt);const kt=/vec(5|6)\s*,\s*(\w+)/g;return yt=yt.replace(kt,(Tt,Rt,Yt)=>`vec${Rt}, @align(16) ${Yt}`)}(De),xe.push(De),ce.atomic?xe.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):xe.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${ke(se.dtype,ce.isVec4)}>;
    `),ce.variableNames.forEach((yt,gt)=>{xe.push(`
      @group(0) @binding(${1+gt}) var<storage, read> ${yt}: array<${ce.variableTypes?ce.variableTypes[gt]:ke(ee[gt].dtype,ce.isVec4)}>;
        `)}),De!==""&&xe.push(`
      @group(0) @binding(${1+ce.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const Ge=function(yt,gt){const{x:kt,y:Tt=[],z:Rt=[]}=gt,Yt=yt.length;if(kt.length===Yt)return`fn getOutputCoords() -> ${l(Yt)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let Ht="";const nn=[kt,Tt,Rt];let gn=0;for(let $n=0;$n<nn.length;$n++){const Wn=nn[$n];if(Wn.length!==0)if(gn+=Wn.length,Wn.length===1)Ht+=`let d${Wn[0]} = i32(globalId[${$n}]);`;else{const Hn=E(Wn,"uniforms.outShape");Ht+=`var index${$n} = i32(globalId[${$n}]);`;for(let Dn=0;Dn<Hn.length;Dn++)Ht+=`let d${Wn[Dn]} = index${$n} / ${Hn[Dn]};`,Dn===Hn.length-1?Ht+=`let d${Wn[Dn+1]} = index${$n} - d${Wn[Dn]} * ${Hn[Dn]};`:Ht+=`index${$n} = index${$n} - d${Wn[Dn]} * ${Hn[Dn]};`}}const ln=[];for(let $n=0;$n<gn;$n++)ln.push(`d${$n}`);const Bn=l(gn);let wn=`fn getOutputCoords() -> ${Bn} {
  ${Ht}
`;return ln.length===0?wn+=`return ${Bn}(0); }`:wn+=`return ${Bn}(${ln.join(",")}); }`,wn}(se.shape,ce.dispatchLayout),nt=[L,xe.join(`
`),g(se.shape),Ge,W(se.shape.length)];ce.atomic||nt.push(function(yt,gt,kt){const Tt=yt.length,Rt=ke(gt,kt);let Yt;if(Yt=kt?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${Rt}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${Rt}(value);
    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${Rt}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${Rt}(value);
    }`,Tt>=2){const Ht=["d0","d1","d2","d3","d4","d5"].slice(0,Tt),nn=l(Tt);Yt+=kt?`
      fn setOutputAtCoords(${Ht.map(gn=>`${gn} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${nn}(${Ht.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${Ht.map(gn=>`${gn} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${nn}(${Ht.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:`
      fn setOutputAtCoords(${Ht.map(gn=>`${gn} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${nn}(${Ht.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${Ht.map(gn=>`${gn} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${nn}(${Ht.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return Yt}(se.shape,se.dtype,ce.isVec4));const Je=ee.map((yt,gt)=>function(kt,Tt,Rt,Yt){let Ht=function(nn,gn){const ln=nn.name,Bn=nn.shape.length,wn=l(Bn),$n="get"+ln.charAt(0).toUpperCase()+ln.slice(1),Wn=["d0","d1","d2","d3","d4","d5"].slice(0,Bn),Hn=Wn.map(yr=>`${yr} : i32`).join(", ");if(Bn<1)return gn?`
        fn ${$n}() -> vec4<f32> {
          return vec4<f32>(${ln}[0]);
        }
      `:`
      fn ${$n}() ->f32 {
        return f32(${ln}[0]);
      }
    `;const Dn=`uniforms.${ln.charAt(0).toLowerCase()+ln.slice(1)}Shape`;let er=`${Bn}D`;return Bn===0&&(er="1D"),gn?`
      fn ${$n}(${Hn}) -> vec4<f32> {
        return vec4<f32>(${ln}[getIndexFromCoords${er}(${wn}(${Wn.join(",")}),
          ${Dn}) / 4]);
      }
      `:`
    fn ${$n}(${Hn}) -> f32 {
      return f32(${ln}[getIndexFromCoords${er}(${wn}(${Wn.join(",")}),
        ${Dn})]);
    }
   `}(kt,Rt);return kt.shape.length<=Tt.length&&(Ht+=function(nn,gn,ln,Bn){const wn=nn.name,$n=wn.charAt(0).toUpperCase()+wn.slice(1),Wn="get"+$n+"ByOutput",Hn=nn.shape.length,Dn=gn.length,er=l(Dn);if(t.util.arraysEqual(nn.shape,gn)&&Bn)return ln?`
      fn ${Wn}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${wn}[globalIndex]);
      }

      fn ${Wn}Coords(coords : ${er}) -> vec4<f32> {
        return vec4<f32>(${wn}[${Dn>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${Wn}Index(globalIndex : i32) -> f32 {
      return f32(${wn}[globalIndex]);
    }

    fn ${Wn}Coords(coords : ${er}) -> f32 {
      return f32(${wn}[${Dn>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;const yr=t.backend_util.getBroadcastDims(nn.shape,gn),la=Dn-Hn;let Or="";if(Hn===0)return ln?`
    fn ${Wn}Index(globalIndex : i32) -> vec4<f32> {
      return get${$n}();
    }

    fn ${Wn}Coords(coords : ${er}) -> vec4<f32> {
      return get${$n}();
    }
  `:`
    fn ${Wn}Index(globalIndex : i32) -> f32{
      return get${$n}();
    }

    fn ${Wn}Coords(coords : ${er}) -> f32{
      return get${$n}();
    }
  `;Or=Dn<2&&yr.length>=1?"coords = 0;":yr.map(ga=>`coords.${B(ga+la)} = 0;`).join(`
`);let Gr="";if(Dn<2&&Hn>0)Gr="coords";else if(Dn>1){const ga=l(Hn),Ra=nn.shape.map((Qa,Ss)=>`coords.${B(Ss+la)}`).join(", ");Gr=`${ga}(${Ra})`}else Gr="coords";const jr=`uniforms.${wn.charAt(0).toLowerCase()+wn.slice(1)}Shape`,Na=`${Hn}D`;return ln?`
    fn ${Wn}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${Or}
      return ${wn}[getIndexFromCoords${Na}(${Gr}, ${jr}) / 4];
    }

    fn ${Wn}Coords(coordsIn : ${er}) -> vec4<f32> {
      var coords = coordsIn;
      ${Or}
      return ${wn}[getIndexFromCoords${Na}(${Gr}, ${jr}) / 4];
    }
  `:`
  fn ${Wn}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${Or}
    return f32(${wn}[getIndexFromCoords${Na}(${Gr}, ${jr})]);
  }

  fn ${Wn}Coords(coordsIn : ${er}) -> f32 {
    var coords = coordsIn;
    ${Or}
    return f32(${wn}[getIndexFromCoords${Na}(${Gr}, ${jr})]);
  }
`}(kt,Tt,Rt,Yt)),Ht}(yt,se.shape,ce.variableTypes?ce.variableTypes[gt]==="vec4<f32>":ce.isVec4,ce.dispatchLayout.x.length===se.shape.length)).join(`
`);return nt.push(Je),nt.push(ce.getUserCode()),nt.join(`
`)}(x,{dtype:M.dtype,shape:M.shape},v),H=R.createShaderModule({code:N,label:v.constructor.name});return R.createComputePipeline({compute:{module:H,entryPoint:"_start"},label:v.constructor.name,layout:"auto"})};function l(R){if(R<=1)return"i32";if(R===2)return"vec2<i32>";if(R===3)return"vec3<i32>";if(R===4)return"vec4<i32>";if(R===5)return"vec5";if(R===6)return"vec6";throw Error(`GPU for rank ${R} is not yet supported`)}function B(R){if(R===0)return"x";if(R===1)return"y";if(R===2)return"z";if(R===3)return"w";if(R===4)return"u";if(R===5)return"v";throw Error(`Index ${R} is not yet supported`)}function O(...R){let v;switch(R.length){case 0:v=`
        ${V()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main();
        }

        fn main()
      `;break;case 1:v=`
        ${V()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main(getGlobalIndex());
        }

        fn main(${R[0]} : i32)
      `;break;default:throw Error("Unreachable")}return v}function V(){return`
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`}const L=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;function g(R){const v=R.length;if(v<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const x=t.util.computeStrides(R),M=l(v),N=[];for(let ee=0;ee<v;ee++)N.push(`d${ee}`);if(x.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let H;return H="var index2 = index;"+x.map((ee,se)=>`${`let ${N[se]} = index2 / uniforms.outShapeStrides.${B(se)}`}; ${se===x.length-1?`let ${N[se+1]} = index2 - ${N[se]} * uniforms.outShapeStrides.${B(se)}`:`index2 = index2 - ${N[se]} * uniforms.outShapeStrides.${B(se)}`};`).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${M} {
      ${H}
      return ${M}(${N.join(",")});
    }
  `}function W(R){let v="";switch(R){case 0:case 1:v+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:v+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:v+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:v+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:v+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:v+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:t.util.assert(!1,()=>`Unsupported ${R}D shape`)}return v}function de(R){return R.dispatch[1]===1&&R.dispatch[2]===1}function ke(R,v){return R==="float32"?v?"vec4<f32>":"f32":R==="int32"||R==="bool"?v?"vec4<i32>":"i32":R}const Ie=R=>{let v=1;for(let x=0;x<R.length;x++)v*=R[x];return v};function he(R,v,x=[1,1,1],M=[1,1,1]){const[N,H,ee]=[Math.ceil(Ie(R.x.map(se=>v[se]))/(x[0]*M[0])),R.y?Math.ceil(Ie(R.y.map(se=>v[se]))/(x[1]*M[1])):1,R.z?Math.ceil(Ie(R.z.map(se=>v[se]))/(x[2]*M[2])):1];return[N,H,ee]}function Q(R,v,x=!1){if(x)return[8,8,1];const M=Ie(R.x.map(H=>v[H])),N=Ie(R.y.map(H=>v[H]));return M<=4?[4,16,1]:N<=4?[16,4,1]:[16,16,1]}function Se(R,v,x=!1){if(x)return[4,4,1];const M=Ie(R.x.map(H=>v[H])),N=Ie(R.y.map(H=>v[H]));return M<=4?[1,2,1]:N<=4?[2,1,1]:[2,2,1]}function Z(R){return{x:R.map((v,x)=>x)}}function G(){return(typeof window!="undefined"||typeof WorkerGlobalScope!="undefined")&&!!navigator.gpu}var He;(function(R){R[R.MatMulReduceProgram=0]="MatMulReduceProgram",R[R.MatMulSplitKProgram=1]="MatMulSplitKProgram",R[R.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",R[R.MatMulPackedProgram=3]="MatMulPackedProgram",R[R.MatMulMax=4]="MatMulMax"})(He||(He={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const me=Object(t.env)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class et extends t.KernelBackend{constructor(v){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!G())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=v,this.queue=v.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=v.features.has("timestamp-query"),this.bufferManager=new h(this.device),this.textureManager=new A(this.device),this.tensorMap=new t.DataStorage(this,Object(t.engine)()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),Object(t.env)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:v,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return et.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(v,x=!1){if(this.tensorDataPendingDisposal.indexOf(v)>=0)return!1;if(!this.tensorMap.has(v))return!0;const M=this.tensorMap.get(v);if(this.decRef(v),!x&&M.refCount>0)return!1;if(this.commandQueueOwnedIds.has(v))return this.tensorDataPendingDisposal.push(v),!1;const{complexTensorInfos:N}=this.tensorMap.get(v);return N!=null&&(this.disposeData(N.real.dataId,x),this.disposeData(N.imag.dataId,x)),this.releaseResource(v),this.tensorMap.delete(v),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(v){const x=this.tensorMap.get(v);if(x&&x.resourceInfo){if("texture"in x.resourceInfo){const M=x.resourceInfo;M.texture instanceof GPUTexture&&this.textureManager.releaseTexture(M.texture,M.width,M.height,M.format,M.usage),M.texture=null}else{const M=x.resourceInfo;this.bufferManager.releaseBuffer(M.buffer,M.size,M.usage),M.buffer=null}x.resourceInfo=null}}refCount(v){return this.tensorMap.has(v)?this.tensorMap.get(v).refCount:0}incRef(v){this.tensorMap.get(v).refCount++}decRef(v){this.tensorMap.has(v)&&this.tensorMap.get(v).refCount--}write(v,x,M){if(M==="complex64"&&v!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const N={id:this.nextDataId()};return this.tensorMap.set(N,{dtype:M,shape:x,values:v,refCount:1}),N}move(v,x,M,N,H){if(N==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(v,{dtype:N,shape:M,values:x,refCount:H})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(v=>{this.releaseResource(v),this.tensorMap.delete(v)}),this.uniformPendingDisposal.forEach(v=>this.bufferManager.releaseBuffer(v.buffer,v.size,v.usage)),this.stagingPendingDisposal.forEach(v=>this.bufferManager.releaseUploadBuffer(v.buffer,v.size,v.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(v,x){const M=this.bufferManager.acquireBuffer(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(v,0,M,0,x),this.submitQueue(),await M.mapAsync(GPUMapMode.READ);const N=M.getMappedRange().slice(0);return M.unmap(),M!=null&&this.bufferManager.releaseBuffer(M,x,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),Object(t.env)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(t.util.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),N}convertAndCacheOnCPU(v,x){const M=this.tensorMap.get(v);return this.releaseResource(v),M.values=x,M.values}readSync(v){const x=this.tensorMap.get(v),{values:M}=x;if(M==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return M}async read(v){if(!this.tensorMap.has(v))throw new Error(`Tensor ${v} was not registered!`);const x=this.tensorMap.get(v),{values:M}=x;if(M!=null)return this.convertAndCacheOnCPU(v,M);let N;if(x.dtype==="complex64"){const H=await Promise.all([this.read(x.complexTensorInfos.real.dataId),this.read(x.complexTensorInfos.imag.dataId)]),ee=H[0],se=H[1];N=t.backend_util.mergeRealAndImagArrays(ee,se)}else{const H=x.resourceInfo;N=function(ee,se){if(se==="float32")return new Float32Array(ee);if(se==="int32")return new Int32Array(ee);if(se==="bool"||se==="string")return Uint8Array.from(new Int32Array(ee));throw new Error(`Unknown dtype ${se}`)}(await this.getBufferData(H.buffer,H.size),x.dtype)}return this.convertAndCacheOnCPU(v,N),N}readToGPU(v){const x=this.tensorMap.get(v),{values:M,dtype:N,shape:H,resourceInfo:ee}=x;if(N==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(ee==null)throw M!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const se=ee.size,ce=this.bufferManager.acquireBuffer(se,ee.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(ee.buffer,0,ce,0,se),this.submitQueue();const xe=this.makeTensorInfo(H,N),De=Object(t.engine)().makeTensorFromTensorInfo(xe);return this.tensorMap.get(xe.dataId).resourceInfo={size:se,usage:this.defaultGpuBufferUsage(),buffer:ce},{tensorRef:De,buffer:ce,bufSize:se}}bufferSync(v){const x=this.readSync(v.dataId);if(v.dtype==="string")try{const M=x.map(N=>t.util.decodeString(N));return Object(t.buffer)(v.shape,v.dtype,M)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(t.buffer)(v.shape,v.dtype,x)}async time(v){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const x=this.activeTimers,M=[];let N=!1;this.programTimersStack==null?(this.programTimersStack=M,N=!0):this.activeTimers.push(M),this.activeTimers=M,v();const H=t.util.flatten(this.activeTimers.map(xe=>xe.query)).filter(xe=>xe!=null),ee=t.util.flatten(this.activeTimers.map(xe=>xe.name)).filter(xe=>xe!=null);this.activeTimers=x,N&&(this.programTimersStack=null);const se={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},ce=await Promise.all(H);return se.kernelMs=t.util.sum(ce),se.getExtraProfileInfo=()=>ce.map((xe,De)=>({name:ee[De],ms:xe})).map(xe=>`${xe.name}: ${xe.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,se}makeTensorInfo(v,x,M){return x==="string"&&M!=null&&M.length>0&&t.util.isString(M[0])&&(M=M.map(N=>t.util.encodeString(N))),{dataId:this.write(M,v,x),shape:v,dtype:x}}tensorToBinding(v){if(!v)return null;const x=this.tensorMap.get(v.dataId);if("texture"in x.resourceInfo){const N=x.resourceInfo;return N.texture instanceof GPUExternalTexture?N.texture:N.texture.createView()}const M=x.resourceInfo;return{offset:0,size:M.size,buffer:M.buffer}}async getQueryTime(v){return this.supportTimeQuery?this.getTimeFromQuerySet(v):0}uploadToGPU(v){const x=this.tensorMap.get(v);if(x.resourceInfo)return;const M=function(H){if(H==="float32"||H==="int32"||H==="bool"||H==="string")return 4;if(H==="complex64")return 8;throw new Error(`Unknown dtype ${H}`)}(x.dtype)*t.util.sizeFromShape(x.shape),N=this.bufferManager.acquireBuffer(M,this.defaultGpuBufferUsage());if(x.resourceInfo={size:M,usage:this.defaultGpuBufferUsage(),buffer:N},x.values){const H=this.bufferManager.acquireUploadBuffer(M,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),ee=H.getMappedRange();x.dtype==="int32"||x.dtype==="bool"?new Int32Array(ee).set(x.values):new Float32Array(ee).set(x.values),H.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(H,0,N,0,M);const se={size:M,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:H};this.stagingPendingDisposal.push(se)}}makeUniforms(v){let x=0,M=0;const N=[];v.forEach(ce=>{let xe;switch(ce.data.length===0&&(ce.data=[1]),ce.data.length){case 1:xe=4;break;case 2:xe=8;break;case 3:case 4:case 5:case 6:xe=16;break;default:t.util.assert(!1,()=>`Unsupported ${ce.data.length}D shape`)}M!==5&&M!==6||(xe=16),x=Math.ceil(x/xe)*xe,M=ce.data.length,N.push(x),x+=4*ce.data.length});const H=new ArrayBuffer(x);v.forEach((ce,xe)=>{const De=N[xe];ce.type==="int32"?new Int32Array(H,De,ce.data.length).set(ce.data):ce.type==="uint32"?new Uint32Array(H,De,ce.data.length).set(ce.data):new Float32Array(H,De,ce.data.length).set(ce.data)});const ee=this.bufferManager.acquireBuffer(x,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(ee,0,H,0,x);const se={size:x,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:ee};return this.uniformPendingDisposal.push(se),{offset:0,size:x,buffer:ee}}runWebGPUProgram(v,x,M,N,H){if(H||(H=this.makeTensorInfo(v.outputShape,M)),t.util.sizeFromShape(H.shape)===0)return this.tensorMap.get(H.dataId).values=t.util.getTypedArrayFromDType(H.dtype,0),H;this.uploadToGPU(H.dataId),v.dispatch=((Je,yt)=>{const gt=Je.limits.maxComputeWorkgroupsPerDimension,kt=yt.dispatchLayout,Tt=yt.dispatch;if(Tt.every(Yt=>Yt<=gt))return Tt;t.util.assert(Tt[0]>gt&&kt.y===void 0&&kt.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let Rt=Math.ceil(Math.sqrt(Tt[0]));return Rt>gt?(Rt=Math.ceil(Math.cbrt(Tt[0])),t.util.assert(Rt<=gt,()=>"Total dispatch size exceeds WebGPU maximum."),[Rt,Rt,Rt]):[Rt,Rt,1]})(this.device,v);let ee=[],se=[];if(!v.isFromPixels){ee.push({type:"float32",data:[NaN]}),se=x.concat(H).map(gt=>gt.shape);const Je="int32";se.map(gt=>{ee.push({type:Je,data:gt})});const yt=t.util.computeStrides(H.shape);if(ee.push({type:Je,data:yt}),v.size){const gt=t.util.sizeFromShape(v.outputShape);ee.push({type:Je,data:[v.isVec4?gt/4:gt]})}}const ce=x.map((Je,yt)=>{if(Je.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(Je.dataId),{dtype:this.tensorMap.get(Je.dataId).dtype,shape:Je.shape,name:v.variableNames[yt]}}),xe=function(Je,yt,gt,kt){let Tt=Je.shaderKey;if(Je.isFromPixels)return Tt;const Rt=gt.map(ln=>ln.dtype).concat(kt.dtype),Yt=gt.map(ln=>t.backend_util.getBroadcastDims(ln.shape,kt.shape)),Ht=gt.map(ln=>t.util.arraysEqual(ln.shape,kt.shape)).join("_"),nn=Yt.map(ln=>ln.join("_")).join(";"),gn=de(Je)?"flatDispatch":"";return Tt+="_"+(Je.workGroupSize?Je.workGroupSize.join(","):"")+yt.map(ln=>ln.length).join(",")+Rt.join(",")+Je.variableNames.join(",")+nn+Ht+gn,Tt}(v,se,ce,H);let De;xe in this.pipelineCache?De=this.pipelineCache[xe]:(De=S(this.device,v,ce,H),this.pipelineCache[xe]=De),N&&(ee=[...ee,...N]);const Ke=[this.tensorToBinding(H),...x.map(Je=>this.tensorToBinding(Je)),this.makeUniforms(ee)],Ze=this.device.createBindGroup({layout:De.getBindGroupLayout(0),entries:Ke.map((Je,yt)=>({binding:yt,resource:Je}))});this.ensureCommandEncoderReady();const Ge=this.getComputePass(),nt=this.activeTimers!=null;return nt&&this.supportTimeQuery&&Ge.writeTimestamp(this.querySet,0),Ge.setPipeline(De),Ge.setBindGroup(0,Ze),Ge.dispatchWorkgroups(v.dispatch[0],v.dispatch[1],v.dispatch[2]),nt&&this.supportTimeQuery&&Ge.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,x.forEach(Je=>{this.commandQueueOwnedIds.add(Je.dataId)}),this.commandQueueOwnedIds.add(H.dataId),Object(t.env)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),nt&&this.activeTimers.push({name:v.constructor.name,query:this.getQueryTime(this.querySet)}),H}async getTimeFromQuerySet(v){const x=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),M=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(v,0,2,x,0),this.currentCommandEncoder.copyBufferToBuffer(x,0,M,0,16),this.submitQueue(),await M.mapAsync(GPUMapMode.READ);const N=new BigUint64Array(M.getMappedRange()),H=Number(N[1]-N[0]);return M.unmap(),this.bufferManager.releaseBuffer(M,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(x,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),H/1e6}shouldExecuteOnCPU(v,x=me){return Object(t.env)().getBool("WEBGPU_CPU_FORWARD")&&v.every(M=>this.tensorMap.get(M.dataId).resourceInfo==null&&t.util.sizeFromShape(M.shape)<x)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var rt;et.nextDataId=0,G()&&Object(t.registerBackend)("webgpu",async()=>{Object(t.env)().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const R={powerPreference:Object(t.env)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},v=await navigator.gpu.requestAdapter(R),x=v.limits,M={},N=v.features.has("timestamp-query");M.requiredLimits={maxComputeWorkgroupStorageSize:x.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:x.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:x.maxStorageBufferBindingSize},N&&(M.requiredFeatures=["timestamp-query"]);const H=await v.requestDevice(M);return new et(H)},3),function(R){R[R.MUL=0]="MUL",R[R.ADD=1]="ADD",R[R.ATAN2=2]="ATAN2",R[R.SUB=3]="SUB",R[R.DIV=4]="DIV",R[R.EQUAL=5]="EQUAL",R[R.GREATER=6]="GREATER",R[R.GREATER_EQUAL=7]="GREATER_EQUAL",R[R.LESS=8]="LESS",R[R.LESS_EQUAL=9]="LESS_EQUAL",R[R.LOGICAL_AND=10]="LOGICAL_AND",R[R.NOT_EQUAL=11]="NOT_EQUAL",R[R.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",R[R.INT_DIV=13]="INT_DIV",R[R.POW=14]="POW",R[R.PRELU=15]="PRELU",R[R.MAX=16]="MAX",R[R.MIN=17]="MIN",R[R.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",R[R.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"}(rt||(rt={}));const It=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,X=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${It}
  `,$t=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${X}

  return resultTemp;
`,Ct=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;
  let valueForNaN = uniforms.NAN;
  ${It}
  return resultTemp;
  `;function Gt(R,v,x="uniforms.NAN"){const M=v?X:`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `;return v?`
    let valueForNaN = ${x};
    var resultTemp = vec4<f32>(${R}(a, b));
    `+M+`
    return resultTemp;
  `:M+`
    return ${R}(a, b);
  `}function Wt(R,v){switch(R){case rt.MUL:return"return a * b;";case rt.ADD:return"return a + b;";case rt.ATAN2:return Gt("atan2",v);case rt.SUB:return"return a - b;";case rt.DIV:return"return a / b;";case rt.EQUAL:return v?"return vec4<f32>(a == b);":"return f32(a == b);";case rt.GREATER:return v?"return vec4<f32>(a > b);":"return f32(a > b);";case rt.GREATER_EQUAL:return v?"return vec4<f32>(a >= b);":"return f32(a >= b);";case rt.LESS:return v?"return vec4<f32>(a < b);":"return f32(a < b);";case rt.LESS_EQUAL:return v?"return vec4<f32>(a <= b);":"return f32(a <= b);";case rt.LOGICAL_AND:return v?`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`:"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case rt.NOT_EQUAL:return v?$t:`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`;case rt.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case rt.INT_DIV:return v?`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `:`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `;case rt.PRELU:return v?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `:"if (a < 0.0) { return b * a; }  return a;";case rt.MAX:return Gt("max",v);case rt.MIN:return Gt("min",v);case rt.POW:return v?Ct:`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `;case rt.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case rt.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error(`BinaryType ${R} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var lt;(function(R){R[R.ABS=0]="ABS",R[R.CEIL=1]="CEIL",R[R.COS=2]="COS",R[R.COSH=3]="COSH",R[R.ELU=4]="ELU",R[R.EXP=5]="EXP",R[R.EXPM1=6]="EXPM1",R[R.FLOOR=7]="FLOOR",R[R.IS_NAN=8]="IS_NAN",R[R.LINEAR=9]="LINEAR",R[R.LOG=10]="LOG",R[R.LOGICAL_NOT=11]="LOGICAL_NOT",R[R.NEG=12]="NEG",R[R.RELU=13]="RELU",R[R.RELU6=14]="RELU6",R[R.LEAKYRELU=15]="LEAKYRELU",R[R.RECIPROCAL=16]="RECIPROCAL",R[R.RSQRT=17]="RSQRT",R[R.SIN=18]="SIN",R[R.SINH=19]="SINH",R[R.SIGMOID=20]="SIGMOID",R[R.SQRT=21]="SQRT",R[R.SQUARE=22]="SQUARE",R[R.TANH=23]="TANH",R[R.TO_INT=24]="TO_INT"})(lt||(lt={}));function Qt(R,v){switch(R){case lt.ABS:return"return abs(a);";case lt.COS:return"return cos(a);";case lt.COSH:return`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;case lt.CEIL:return"return ceil(a);";case lt.ELU:return v?`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`:"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case lt.EXP:return"return exp(a);";case lt.EXPM1:return"return exp(a) - 1.0;";case lt.FLOOR:return"return floor(a);";case lt.IS_NAN:return"return f32(isnan(a));";case lt.LINEAR:return"return a;";case lt.LOG:return`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`;case lt.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case lt.NEG:return"return -a;";case lt.LEAKYRELU:return v?`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`:"if (a < 0.0) { return uniforms.alpha * a; } return a;";case lt.RECIPROCAL:return"return 1.0 / a;";case lt.RELU:return v?`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`:"return select(a, 0.0, a < 0.0);";case lt.RELU6:return v?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case lt.RSQRT:return"return 1.0/sqrt(a);";case lt.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case lt.SIN:return"return sin(a);";case lt.SINH:return`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;case lt.SQRT:return"return sqrt(a);";case lt.SQUARE:return"return a * a;";case lt.TANH:return`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;case lt.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${R} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ft=R=>{switch(R){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${R}-component is not supported.`)}};function yn(R,v=!1,x=!1,M=3){if(R===null)return"";let N="";if(R==="linear")N=Qt(lt.LINEAR);else if(R==="relu")N=Qt(lt.RELU,x);else if(R==="elu")N=Qt(lt.ELU,x);else if(R==="relu6")N=Qt(lt.RELU6,x);else if(R==="prelu")N=Wt(rt.PRELU,x);else if(R==="sigmoid")N=Qt(lt.SIGMOID,x);else{if(R!=="leakyrelu")throw new Error(`Activation ${R} has not been implemented for the WebGPU backend.`);N=Qt(lt.LEAKYRELU,x)}const H=Ft(x?4:1);let ee="";return ee=v?`
      fn activation(a : ${H}, coords : vec${M}<i32>) -> ${H} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${N}
      }`:`
      fn activation(a : ${H}, coords : vec${M}<i32>) -> ${H} {
        ${N}
      }`,ee}function Nn(R,v){return`
      ${R?"value = value + getBiasByOutputCoords(coords);":""}
      ${v?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kn(R,v,x,M,N=!1,H=!1,ee=!1,se=1){t.util.assert(x&&se===1||!x,()=>`transposeA ${x} is not compatible with component size ${se}`);const ce=`
      let batch = ${R?"0":"batchIn"};
      let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
      ${x?`value = A[(batch * batchASize + col * uniforms.aShape[2] + row) / ${se}];`:`value = A[(batch * batchASize + row * uniforms.aShape[2] + col) / ${se}];`}

    `;let xe;return xe=M===!1?`value = B[(batch * batchBSize + row * uniforms.bShape[2] + col) / ${se}];`:`value = B[(batch * batchBSize + col * uniforms.bShape[2] + row) / ${se}];`,`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${Ft(se)} {
    var value = ${Ft(se)}(0.0);
    let col = colIn * ${se};
    ${N&&ee?ce:`
    ${x?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${ce}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${Ft(se)} {
    let col = colIn * ${se};
    let batch = ${v?"0":"batchIn"};
    let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
    var value = ${Ft(se)}(0.0);
    ${xe}
    return value;
  }
  `}function zn(R,v,x,M,N,H,ee=!1,se=!1,ce=!1,xe=1){return`
  ${Kn(x,M,N,H,ee,se,ce,xe)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ft(xe)}) {
    let col = colIn * ${xe};
    ${ee&&se?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Nn(R,v)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}function sr(R,v,x=!1,M=32,N=!1,H=32,ee=!1){const se=v[1]*R[1],ce=v[0]*R[0],xe=x?se:M,De=x?M:se,Ke=xe/v[0],Ze=M/v[1];return t.util.assert((x&&Ke===4&&R[1]===4||!x&&(Ke===3||Ke===4))&&xe%v[0]==0&&M%v[1]==0&&R[0]===4,()=>`If transposeA ${x} is true, innerElementSize ${Ke} and workPerThread[1] ${R[1]} must be 4.
          Otherwise, innerElementSize ${Ke} must be 3 or 4.
      tileAWidth ${xe} must be divisible by workGroupSize[0]${v[0]}. tileInner ${M} must be divisible by workGroupSize[1] ${v[1]}. ColPerThread ${R[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${Ke}<f32>, ${xe/Ke}>, ${De}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${ce/R[0]}>, ${M}>;

  const RowPerThread = ${R[1]};
  const ColPerThread = ${R[0]};
  const InnerElementSize = ${Ke};
  const TileInner = ${M};

  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
            @builtin(workgroup_id) workgroupId: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;

    let localRow = i32(localId.y);
    let tileRow = ${ee?"0":"localRow * RowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${ee?"0":"i32(globalId.y) * RowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${N?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${se};

    let numTiles = ${N?`${Math.ceil(H/M)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
    var kStart = ${N?`i32(globalId.z) * ${H}`:"0"};

    var acc: array<vec4<f32>, RowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${Ze};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${(Ge=>Ge?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / InnerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / InnerElementSize + inputCol);
        `)(x)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${Ze}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];
            ${Ke===3?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}

            ${((Ge,nt)=>Ge?`
        let ACached0 = mm_Asub[k * InnerElementSize][localRow];
        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];
        ${nt===3?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}
        for (var i = 0; i < RowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${nt===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < RowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${nt===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(x,Ke)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}function K(R,v,x=!1,M=32,N=!1,H=32){const ee=R[1]*v[1],se=R[0]*v[0],ce=x?ee:M,xe=x?M:ee;t.util.assert(xe%v[1]==0&&ce%v[0]==0&&M%v[1]==0,()=>`tileAHight ${xe} must be divisible by workGroupSize[1]${v[1]}, tileAWidth ${ce} must be divisible by workGroupSize[0]${v[0]}, tileInner ${M} must be divisible by workGroupSize[1]${v[1]}`);const De=xe/v[1],Ke=ce/v[0],Ze=M/v[1];return`
    var<workgroup> mm_Asub : array<array<f32, ${ce}>, ${xe}>;
    var<workgroup> mm_Bsub : array<array<f32, ${se}>, ${M}>;
    const RowPerThread = ${R[1]};
    const ColPerThread = ${R[0]};
    const TileInner = ${M};

    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
              @builtin(workgroup_id) workgroupId: vec3<u32>) {
      localId = LocalId;
      globalId = GlobalId;
      numWorkgroups = NumWorkgroups;

      let tileRow = i32(localId.y) * RowPerThread;
      let tileCol = i32(localId.x) * ColPerThread;

      let globalRow = i32(globalId.y) * RowPerThread;
      let globalCol = i32(globalId.x) * ColPerThread;
      let batch = ${N?"0":"i32(globalId.z)"};
      let globalRowStart = i32(workgroupId.y) * ${ee};

      let numTiles = ${N?`${Math.ceil(H/M)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
      var kStart = ${N?`i32(globalId.z) * ${H}`:"0"};

      var acc : array<array<f32, ColPerThread>, RowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let tileRowA = i32(localId.y) * ${De};
      let tileColA = i32(localId.x) * ${Ke};
      let tileRowB = i32(localId.y) * ${Ze};
      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${De}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${Ke}; innerCol = innerCol + 1) {
            let inputRow = tileRowA + innerRow;
            let inputCol = tileColA + innerCol;
            ${(Ge=>Ge?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `)(x)}
          }
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${Ze}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalCol + innerCol);
          }
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ColPerThread>;
        for (var k = 0; k < TileInner; k = k + 1) {
          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            ${(Ge=>Ge?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(x)}
            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          mm_write(batch, globalRow + innerRow, globalCol + innerCol,
              acc[innerRow][innerCol]);
        }
      }
    }
  `}class J{constructor(v,x,M,N,H=!1,ee=!1,se=null,ce=null,xe=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=x,this.dispatchLayout={x:[2],y:[1],z:[0]};const De=H?v[1]:v[2];if(this.isVec4=(De%4==0&&!H||x[1]%4==0&&H)&&x[2]%4==0&&!ee,this.isVectorA=x[1]===1&&!H,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{const Ge=function(nt,Je,yt,gt=!1){const kt=[8,8,1],Tt=[4,4,1];return gt||(nt<=8&&(Tt[1]=1),Je<=16&&yt<=16&&(kt[0]=4)),{workGroupSize:kt,elementsPerThread:Tt}}(x[1],De,x[2],H);this.workGroupSize=Ge.workGroupSize,this.elementsPerThread=Ge.elementsPerThread}this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);const Ke=se!=null,Ze=xe!=null;Ke&&this.variableNames.push("bias"),Ze&&this.variableNames.push("preluActivationWeights"),this.transposeA=H,this.transposeB=ee,this.addBias=Ke,this.activation=ce,this.hasPreluActivationWeights=Ze,this.batchAEqualOne=M,this.batchBEqualOne=N,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(x[1],x[2],De),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${H}_${ee}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getShapeFit(v,x,M){const N=this.workGroupSize[1]*this.elementsPerThread[1],H=this.workGroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workGroupSize[0]:this.tileInner=H,[v%N==0,x%H==0,M%this.tileInner==0]}getUserCode(){return`
      ${yn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${zn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?sr(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?function(x,M=!1){return t.util.assert(x[1]===1&&x[2]===1,()=>`A linear work group size is required. But got ${x}.`),`
    const TileSize = ${4*x[0]};
    var<workgroup> mm_Asub : array<vec4<f32>, ${x[0]}>;

    ${O()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${(N=>N?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `)(M)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}(this.workGroupSize,this.transposeA):K(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class we{constructor(v,x,M,N=!1,H=!1,ee=null,se=null,ce=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=v,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize);const xe=ee!=null,De=ce!=null;xe&&this.variableNames.push("bias"),De&&this.variableNames.push("preluActivationWeights"),this.transposeA=N,this.transposeB=H,this.addBias=xe,this.activation=se,this.hasPreluActivationWeights=De,this.batchAEqualOne=x,this.batchBEqualOne=M,this.shaderKey=`matMulReduce_${this.activation}_${N}_${H}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${yn(this.activation,this.hasPreluActivationWeights)}
      ${zn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${O()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vt{constructor(v,x,M,N=!1,H=!1,ee=null,se=null,ce=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=M,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(M[2]/this.workGroupSize[0]),Math.ceil(M[1]/this.workGroupSize[1]),M[0]];const xe=ee!=null;xe&&this.variableNames.push("bias");const De=ce!=null;De&&this.variableNames.push("preluActivationWeights"),this.transposeA=N,this.transposeB=H,this.addBias=xe,this.activation=se,this.hasPreluActivationWeights=De,this.batchAEqualOne=v[0]===1,this.batchBEqualOne=x[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${N}_${H}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${yn(this.activation,this.hasPreluActivationWeights)}
      ${zn(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${function(v){const x=v[1],M=v[0],N=x>M?x:M;return`
  var<workgroup> mm_Asub : array<array<f32, ${N}>, ${x}>;
  var<workgroup> mm_Bsub : array<array<f32, ${M}>, ${N}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${O()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${N} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${N};
    globalRowB = globalRowB + ${N};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${N};
      globalRowB = globalRowB + ${N};

      for (var k = 0; k < ${N}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}(this.workGroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wt{constructor(v,x,M,N,H=!1,ee=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,t.util.assert(v[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=v,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(H&&this.outputShape[1]%4==0||!H&&x%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=he(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],x],this.workGroupSize,this.elementsPerThread),this.transposeA=H,this.transposeB=ee,this.batchAEqualOne=M,this.batchBEqualOne=N,this.shaderKey=`matMulSplitK_${H}_${ee}_${M}_${N}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const v=this.isVec4?4:1;return`
      ${Kn(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,v)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${Ft(v)}) {
        let col = colIn * ${v};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${(M=>`
      for (var i = 0; i < ${M}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${M>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `)(v)}
        }
      }
      ${this.isVec4?sr(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):K(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Ot{constructor(v,x=null,M=null,N=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=x!=null,this.hasPreluActivationWeights=N!=null,this.activation=M,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${M}`}getUserCode(){return`
    ${yn(this.activation,this.hasPreluActivationWeights)}
    ${O("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Nn(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ae{constructor(v){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${O("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(R){const{backend:v,attrs:x}=R,{shape:M,value:N}=x;let{dtype:H}=x;if(H=H||t.util.inferDtype(N),H==="string"){const ee=t.util.getArrayFromDType(H,t.util.sizeFromShape(M));return ee.fill(N),v.makeTensorInfo(M,H,ee)}{const ee=new Ae(M),se=[{type:"float32",data:[N]}];return v.runWebGPUProgram(ee,[],H,se)}}const Mt={kernelName:t.Fill,backendName:"webgpu",kernelFunc:mt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nt(R){const{inputs:v,attrs:x}=R,{x:M}=v,{shape:N}=x,H=t.util.sizeFromShape(M.shape),ee=t.util.inferFromImplicitShape(N,H),se=t.util.sizeFromShape(ee);return t.util.assert(H===se,()=>`The new shape (${ee}) has ${se} elements and the old shape (${M.shape}) has ${H} elements. The new shape and old shape must have the same number of elements.`),R.backend.incRef(M.dataId),{dataId:M.dataId,shape:ee,dtype:M.dtype}}const un={kernelName:t.Reshape,backendName:"webgpu",kernelFunc:Nt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn({a:R,b:v,transposeA:x,transposeB:M,backend:N,bias:H=null,preluActivationWeights:ee=null,leakyreluAlpha:se=0,activation:ce=null}){const xe=R.shape.length,De=v.shape.length,Ke=x?R.shape[xe-2]:R.shape[xe-1],Ze=M?v.shape[De-1]:v.shape[De-2],Ge=x?R.shape[xe-1]:R.shape[xe-2],nt=M?v.shape[De-2]:v.shape[De-1],Je=R.shape.slice(0,-2),yt=v.shape.slice(0,-2),gt=t.util.sizeFromShape(Je),kt=t.util.sizeFromShape(yt),Tt=t.broadcast_util.assertAndGetBroadcastShape(R.shape.slice(0,-2),v.shape.slice(0,-2)).concat([Ge,nt]);t.util.assert(Ke===Ze,()=>`Error in matMul: inner shapes (${Ke}) and (${Ze}) of Tensors with shapes ${R.shape} and ${v.shape} and transposeA=${x} and transposeB=${M} must match.`);const Rt=x?[gt,Ke,Ge]:[gt,Ge,Ke],Yt=M?[kt,nt,Ze]:[kt,Ze,nt],Ht=Nt({inputs:{x:R},backend:N,attrs:{shape:Rt}}),nn=Nt({inputs:{x:v},backend:N,attrs:{shape:Yt}}),gn=[Ht,nn],ln=Math.max(gt,kt),Bn=gt===1,wn=kt===1,$n=[Ht,nn],Wn=[{type:"int32",data:[Ge]},{type:"int32",data:[nt]},{type:"int32",data:[Ke]}];let Hn,Dn;const er=[ln,Ge,nt];let yr=Object(t.env)().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(yr<0&&(yr=Ge*nt<=128?He.MatMulReduceProgram:ln===1&&Ge<=128&&nt<=48&&Ze>=2e3?He.MatMulSplitKProgram:Ge<=16&&(nt<=512||Ze>=2*nt)||nt<=16&&(Ge<=512||Ke>=2*Ge)?He.MatMulSmallOutputSizeProgram:He.MatMulPackedProgram),yr){case He.MatMulReduceProgram:Hn=new we(er,Bn,wn,x,M,H,ce,ee);break;case He.MatMulSplitKProgram:if(Dn=mt({backend:N,attrs:{shape:er,value:0,dtype:R.dtype}}),Hn=new wt(er,Ze,Bn,wn,x,M),H||ce){Dn=N.runWebGPUProgram(Hn,$n,R.dtype,Wn,Dn);const Or=new Ot(Dn.shape,H,ce,ee);let Gr=null;const jr=[Dn];H&&jr.push(H),ee&&jr.push(ee),ce==="leakyrelu"&&(Gr=[{type:"float32",data:[se]}],Or.uniforms+=" alpha : f32,");const Na=N.runWebGPUProgram(Or,jr,Dn.dtype,Gr);gn.push(Dn);const ga=Nt({inputs:{x:Na},backend:N,attrs:{shape:Tt}});gn.push(Na);for(const Ra of gn)N.disposeData(Ra.dataId);return ga}break;case He.MatMulSmallOutputSizeProgram:Hn=new vt(Rt,Yt,er,x,M,H,ce,ee);break;case He.MatMulPackedProgram:Hn=new J(Rt,er,Bn,wn,x,M,H,ce,ee);break;default:throw new Error(`Unsupported MatMulProgramType ${yr}.`)}H&&$n.push(H),ee&&$n.push(ee),ce==="leakyrelu"&&(Wn.push({type:"float32",data:[se]}),Hn.uniforms+=" alpha : f32,"),Dn=N.runWebGPUProgram(Hn,$n,R.dtype,Wn,Dn);const la=Nt({inputs:{x:Dn},backend:N,attrs:{shape:Tt}});gn.push(Dn);for(const Or of gn)N.disposeData(Or.dataId);return la}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oe={kernelName:t._FusedMatMul,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{a:N,b:H,bias:ee,preluActivationWeights:se}=v,{transposeA:ce,transposeB:xe,activation:De,leakyreluAlpha:Ke}=M;return Rn({a:N,b:H,transposeA:ce,transposeB:xe,backend:x,bias:ee,preluActivationWeights:se,leakyreluAlpha:Ke,activation:De})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class le{constructor(v,x,M){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(x,M),this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${v}`,this.op=v}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Wt(this.op,!1)}
      }

      ${O("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qe{constructor(v,x,M){this.size=!0,this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(x,M),this.dispatchLayout=Z(this.outputShape),this.op=v,this.useSharedMemoryWithA=x.length===1&&M.length>1&&x[0]<1024,this.useSharedMemoryWithB=M.length===1&&x.length>1&&M[0]<1024,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?M[0]:x[0],this.shaderKey=`binary_${this.type}_${v}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4):(t.util.arraysEqual(x,M)&&t.util.sizeFromShape(x)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${v}`,this.workGroupSize=[128,1,1]),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let v;if(this.type==="shared"){const x=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",M=this.useSharedMemoryWithB?`let a = getAByOutputCoords(coords);
          let b = sharedBuf[${x}];`:`let a = sharedBuf[${x}];
          let b = getBByOutputCoords(coords);`;v=`
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${Wt(this.op,this.isVec4)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${O("index")} {
          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;
            if(flatIndex < uniforms.size) {
              let coords = getCoordsFromIndex(flatIndex);

              ${M}
              setOutputAtIndex(flatIndex, binaryOperation(a, b));
            }
          }
        }
        `}else{const x=this.type==="vec4"?"vec4<f32>":"f32";v=`
       fn binaryOperation(a : ${x}, b : ${x}) -> ${x} {
         ${Wt(this.op,this.isVec4)}
       }
       ${O("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `}return v}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(R){const{inputs:v}=R,{x}=v;return R.backend.incRef(x.dataId),{dataId:x.dataId,shape:x.shape,dtype:x.dtype}}const zr={kernelName:t.Identity,backendName:"webgpu",kernelFunc:Mn};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(R){const{inputs:v,backend:x}=R,{real:M,imag:N}=v,H=x.makeTensorInfo(M.shape,"complex64"),ee=x.tensorMap.get(H.dataId),se=Mn({inputs:{x:M},backend:x}),ce=Mn({inputs:{x:N},backend:x});return ee.complexTensorInfos={real:se,imag:ce},H}const _r={kernelName:t.Complex,backendName:"webgpu",kernelFunc:Ur};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ir{constructor(v,x){this.variableNames=["A"],this.size=!0,this.workGroupSize=[128,1,1],this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=x,this.shaderKey=`unary_${x}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Qt(this.op,!1)}
      }
      ${O("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zn({opType:R,cpuKernelImpl:v,dtype:x}){return({inputs:M,backend:N})=>{const{x:H}=M,ee=N,se=x||H.dtype;if(ee.shouldExecuteOnCPU([H])&&v!=null){const xe=ee.tensorMap.get(H.dataId),De=v(xe.values,se);return ee.makeTensorInfo(H.shape,se,De)}const ce=new ir(H.shape,R);return ee.runWebGPUProgram(ce,[H],se)}}function $r({opType:R,cpuKernelImpl:v,supportsComplex:x=!1,dtype:M}){return({inputs:N,backend:H})=>{const{a:ee,b:se}=N,ce=H;if(x&&ee.dtype==="complex64"){const Ke=ce.tensorMap.get(ee.dataId),Ze=ce.tensorMap.get(se.dataId);let Ge,nt;if(R!==rt.MUL)[Ge,nt]=[[Ke.complexTensorInfos.real,Ze.complexTensorInfos.real],[Ke.complexTensorInfos.imag,Ze.complexTensorInfos.imag]].map(yt=>{const[gt,kt]=yt,Tt={dataId:gt.dataId,dtype:gt.dtype,shape:ee.shape},Rt={dataId:kt.dataId,dtype:kt.dtype,shape:se.shape},Yt=new qe(R,ee.shape,se.shape);return ce.runWebGPUProgram(Yt,[Tt,Rt],Object(t.upcastType)(gt.dtype,kt.dtype))});else{const yt=new le(rt.COMPLEX_MULTIPLY_REAL,ee.shape,se.shape),gt=new le(rt.COMPLEX_MULTIPLY_IMAG,ee.shape,se.shape),kt=[{dataId:Ke.complexTensorInfos.real.dataId,dtype:Ke.complexTensorInfos.real.dtype,shape:ee.shape},{dataId:Ke.complexTensorInfos.imag.dataId,dtype:Ke.complexTensorInfos.imag.dtype,shape:ee.shape},{dataId:Ze.complexTensorInfos.real.dataId,dtype:Ze.complexTensorInfos.real.dtype,shape:se.shape},{dataId:Ze.complexTensorInfos.imag.dataId,dtype:Ze.complexTensorInfos.imag.dtype,shape:se.shape}];Ge=ce.runWebGPUProgram(yt,kt,"float32"),nt=ce.runWebGPUProgram(gt,kt,"float32")}const Je=Ur({inputs:{real:Ge,imag:nt},backend:ce});return ce.disposeData(Ge.dataId),ce.disposeData(nt.dataId),Je}const xe=M||Object(t.upcastType)(ee.dtype,se.dtype);if((ee.dtype==="string"||se.dtype==="string"||ce.shouldExecuteOnCPU([ee,se]))&&v!=null){const Ke=ce.tensorMap.get(ee.dataId).values,Ze=ce.tensorMap.get(se.dataId).values,Ge=ee.dtype==="string"?t.backend_util.fromUint8ToStringArray(Ke):Ke,nt=ee.dtype==="string"?t.backend_util.fromUint8ToStringArray(Ze):Ze,[Je,yt]=v(ee.shape,se.shape,Ge,nt,xe);return ce.makeTensorInfo(yt,xe,Je)}const De=new qe(R,ee.shape,se.shape);return ce.runWebGPUProgram(De,[ee,se],xe)}}var en=e(28);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:mn,castImpl:Ln,ceilImpl:or,concatImpl:lr,equalImpl:Qn,expImpl:br,expm1Impl:gr,floorImpl:At,gatherNdImpl:q,gatherV2Impl:ae,greaterEqualImpl:Qe,greaterImpl:ht,lessEqualImpl:Bt,lessImpl:Kt,logImpl:Ut,maxImpl:tn,maximumImpl:bn,minimumImpl:xn,multiplyImpl:rn,negImpl:Xn,notEqualImpl:xr,prodImpl:Lr,rangeImpl:Wr,rsqrtImpl:vr,scatterImpl:ua,simpleAbsImpl:ma,sliceImpl:Cr,stridedSliceImpl:Da,stringNGramsImpl:kr,subImpl:Pr,tileImpl:qr,topKImpl:ha,transposeImpl:Zr,uniqueImpl:Vr}=en,Ca=Zn({opType:lt.ABS,cpuKernelImpl:ma}),Ta={kernelName:t.Abs,backendName:"webgpu",kernelFunc:Ca},Pa=$r({opType:rt.ADD,cpuKernelImpl:mn,supportsComplex:!0}),is={kernelName:t.Add,backendName:"webgpu",kernelFunc:Pa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ms{constructor(v){this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v[0],this.variableNames=v.map((x,M)=>`T${M}`),this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const v=[];this.variableNames.forEach(M=>{v.push(`let v${M} = get${M}ByOutputCoords(coords);`)});const x=this.variableNames.map(M=>`v${M}`).join(" + ");return`
      ${O("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${v.join(`
        `)}
            setOutputAtIndex(flatIndex, ${x});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Va={kernelName:t.AddN,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x}=R,M=v;if(M.length===1)return Mn({inputs:{x:M[0]},backend:x});const N=M.map(se=>se.dtype).reduce((se,ce)=>Object(t.upcastType)(se,ce)),H=M.map(se=>se.shape),ee=new ms(H);return x.runWebGPUProgram(ee,M,N)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ba{constructor(v,x,M){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const N=[x];this.op=M==="min"?"<":">";const[H,ee]=t.backend_util.computeOutAndReduceShapes(v,N);this.outputShape=H.length===0?[1]:H,this.dispatchLayout=Z(this.outputShape),t.util.sizeFromShape(ee)<32||t.util.sizeFromShape(H)>1e3?(this.type="plain",this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=he(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=v,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const v=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${B(this.inputShape.length-1)}`,x=()=>{let M="";if(this.outputShape.length===1)this.inputShape.length!==1&&(M+="outputCoords,");else for(let N=0;N<this.outputShape.length;N++)M+=`outputCoords.${B(N)},`;return M};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `}

      ${O("index")} {
        let outputIndex = index / i32(workGroupSizeX);
        let reduceLength = ${v()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = getX(${x()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${O("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${x()} 0);
          let reduceLength = ${v()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${x()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wa{constructor(v,x){this.variableNames=["A"],this.workGroupSize=[16,16,1];const M=new Array(v.length);for(let N=0;N<M.length;N++)M[N]=v[x[N]];this.outputShape=M,this.dispatchLayout={x:[0],y:[1]},this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      const TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,
                @builtin(workgroup_id) workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = A[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ga{constructor(v,x){this.variableNames=["A"],this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0;const M=new Array(v.length);for(let N=0;N<M.length;N++)M[N]=v[x[N]];this.outputShape=M,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=x,this.shaderKey=`transpose_${x}`}getUserCode(){const v=l(this.outputShape.length),x=function(M){const N=M.length;if(N>6)throw Error(`Transpose for rank ${N} is not yet supported`);const H=new Array(N);for(let ee=0;ee<M.length;ee++)H[M[ee]]=`resRC.${B(ee)}`;return H.join()}(this.newDim);return`
      ${O("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${v}(${x}), uniforms.aShape)]);
          }
        }
      }
    `}}function Xr(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{perm:H}=M,ee=x,se=N.shape.length,ce=new Array(se);for(let De=0;De<ce.length;De++)ce[De]=N.shape[H[De]];if(x.shouldExecuteOnCPU([N])){const De=ee.tensorMap.get(N.dataId).values,Ke=Zr(De,N.shape,N.dtype,H,ce);return x.makeTensorInfo(ce,N.dtype,Ke)}if(N.shape.length===2&&t.util.arraysEqual(H,[1,0])){const De=new wa(N.shape,H);return ee.runWebGPUProgram(De,[N],N.dtype)}const xe=new Ga(N.shape,H);return ee.runWebGPUProgram(xe,[N],N.dtype)}const ka={kernelName:t.Transpose,backendName:"webgpu",kernelFunc:Xr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _a={kernelName:t.ArgMax,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H}=M;let ee=t.util.parseAxisParam(H,N.shape);const se=t.backend_util.getAxesPermutation(ee,N.shape.length);let ce=N;const xe=[];se!=null&&(ce=Xr({inputs:{x:N},backend:x,attrs:{perm:se}}),xe.push(ce),ee=t.backend_util.getInnerMostAxes(ee.length,ce.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[ee[0]],ce.shape.length);const De=new Ba(ce.shape,ee[0],"max"),Ke=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],Ze=x.runWebGPUProgram(De,[ce],"int32",Ke);return xe.forEach(Ge=>x.disposeData(Ge.dataId)),Ze}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const os={kernelName:t.ArgMin,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H}=M;let ee=t.util.parseAxisParam(H,N.shape);const se=t.backend_util.getAxesPermutation(ee,N.shape.length);let ce=N;const xe=[];se!=null&&(ce=Xr({inputs:{x:N},backend:x,attrs:{perm:se}}),xe.push(ce),ee=t.backend_util.getInnerMostAxes(ee.length,ce.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[ee[0]],ce.shape.length);const De=new Ba(ce.shape,ee[0],"min"),Ke=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],Ze=x.runWebGPUProgram(De,[ce],"int32",Ke);return xe.forEach(Ge=>x.disposeData(Ge.dataId)),Ze}},Za=$r({opType:rt.ATAN2}),La={kernelName:t.Atan2,backendName:"webgpu",kernelFunc:Za};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wr{constructor(v,x){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=v.outShape,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${x}`,this.poolType=x}getUserCode(){let v="resultValue = max(value, resultValue);";this.poolType==="avg"&&(v="resultValue = resultValue + value; count = count + 1.0;");let x="resultValue";return this.poolType==="avg"&&(x="resultValue / count"),`
      ${O("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${v}
            }
          }

          setOutputAtIndex(index, ${x});
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sa{constructor(v){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=v.outShape,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ia{constructor(v,x){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[v.batchSize,v.inSize];const[M]=t.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=M.length===0?[1]:M,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=x,this.shaderKey=`reduce_${x}`}getUserCode(){let v="",x="0.0";this.reduceType==="min"||this.reduceType==="max"?(v=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,x="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?v=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(v=" bestValue = bestValue * candidate; ",x="1.0");const M=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${O("index")} {
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${x};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${v}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${v}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${M}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(R,v,x,M,N){const H=R.shape.length,ee=[],se=t.util.parseAxisParam(v,R.shape);let ce=se;const xe=t.backend_util.getAxesPermutation(ce,H);let De=R;xe!=null&&(De=Xr({inputs:{x:R},attrs:{perm:xe},backend:N}),ce=t.backend_util.getInnerMostAxes(ce.length,H),ee.push(De)),t.backend_util.assertAxesAreInnerMostDims(M,ce,H);const[Ke,Ze]=t.backend_util.computeOutAndReduceShapes(De.shape,ce);let Ge,nt=Ke;if(x&&(nt=t.backend_util.expandShapeToKeepDim(Ke,se)),M!=="max"&&M!=="prod"||!N.shouldExecuteOnCPU([De])){const Je=t.util.sizeFromShape(Ze),yt={windowSize:Je,inSize:Je,batchSize:t.util.sizeFromShape(De.shape)/Je,outSize:1},gt=M==="mean"?"float32":Object(t.sumOutType)(R.dtype),kt=[{type:"int32",data:[Je]}],Tt=new Ia(yt,M),Rt=N.runWebGPUProgram(Tt,[De],gt,kt);ee.push(Rt),Ge=Nt({inputs:{x:Rt},attrs:{shape:nt},backend:N})}else{const Je=N.tensorMap.get(De.dataId).values;switch(M){case"max":const yt=tn(Je,t.util.sizeFromShape(Ze),nt,R.dtype);Ge=N.makeTensorInfo(nt,R.dtype,yt);break;case"prod":const{outVals:gt,outShape:kt,outDtype:Tt}=Lr(De.shape,De.dtype,Je,ce);Ge=N.makeTensorInfo(kt,Tt,gt);break;default:throw new Error(`${M} CPU implementation is not yet supported.`)}}return ee.forEach(Je=>N.disposeData(Je.dataId)),Ge}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ca(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{reductionIndices:H,keepDims:ee}=M;return ba(N,H,ee,"max",x)}const Ja={kernelName:t.Max,backendName:"webgpu",kernelFunc:ca};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fe(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{keepDims:H,axis:ee}=M;return ba(N,ee,H,"mean",x)}const dt={kernelName:t.Mean,backendName:"webgpu",kernelFunc:Fe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(R,v,x,M){if(v.filterWidth===1&&v.filterHeight===1&&t.util.arraysEqual(v.inShape,v.outShape))return Mn({inputs:{x:R},backend:M});if(v.filterWidth===v.inWidth&&v.filterHeight===v.inHeight&&v.batchSize===1&&v.padInfo.type==="VALID"){const ee=R.shape.length,se=Nt({inputs:{x:R},backend:M,attrs:{shape:[R.shape[ee-3]*R.shape[ee-2],R.shape[ee-1]]}});let ce;x==="avg"?ce=Fe({inputs:{x:se},backend:M,attrs:{axis:0,keepDims:!1}}):(t.util.assert(x==="max",()=>`Invalid pool type ${x}`),ce=ca({inputs:{x:se},backend:M,attrs:{reductionIndices:0,keepDims:!1}}));const xe=Nt({inputs:{x:ce},backend:M,attrs:{shape:v.outShape}});return M.disposeData(se.dataId),M.disposeData(ce.dataId),xe}let N;const H=[{type:"int32",data:[v.strideHeight,v.strideWidth]}];return v.filterHeight===1&&v.filterWidth===1?N=new sa(v):(x==="avg"?N=new wr(v,"avg"):(t.util.assert(x==="max",()=>`Invalid pool type ${x}`),N=new wr(v,"max")),H.push({type:"int32",data:[v.padInfo.top,v.padInfo.left]},{type:"int32",data:[v.dilationHeight,v.dilationWidth]},{type:"int32",data:[v.inHeight,v.inWidth]},{type:"int32",data:[v.effectiveFilterHeight,v.effectiveFilterWidth]})),M.runWebGPUProgram(N,[R],R.dtype,H)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vt={kernelName:t.AvgPool,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{filterSize:H,strides:ee,pad:se,dimRoundingMode:ce}=M;return Et(N,t.backend_util.computePool2DInfo(N.shape,H,ee,1,se,ce),"avg",x)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const an={kernelName:t.BatchMatMul,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{a:N,b:H}=v,{transposeA:ee,transposeB:se}=M;return Rn({a:N,b:H,transposeA:ee,transposeB:se,backend:x})}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zt{constructor(v,x){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=x,this.rank=x.length,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=v,this.uniforms=`start : ${l(v.length)}, `,this.shaderKey="slice"}getUserCode(){const v=l(this.rank),x=function(N){if(N===1)return"sourceLoc";if(N<=6)return _n.slice(0,N).map(H=>`sourceLoc.${H}`).join(",");throw Error(`Slicing for rank ${N} is not yet supported`)}(this.rank);let M;return M=this.start.length===1?this.outputShape.map((N,H)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((N,H)=>`sourceLoc.${_n[H]} = uniforms.start.${B(H)} + coords.${_n[H]};`),`
      ${O("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${v};
          let coords = getCoordsFromIndex(index);
          ${M.join(`
`)}
          setOutputAtIndex(index, getSource(${x}));
        }
      }
    `}}const _n=["x","y","z","w","u","v"];function Gn(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{begin:H,size:ee}=M,[se,ce]=t.slice_util.parseSliceParams(N,H,ee);if(t.slice_util.assertParamsValid(N,se,ce),x.shouldExecuteOnCPU([N])||N.dtype==="string"){const Ke=x.tensorMap.get(N.dataId),Ze=Cr(Ke.values,se,ce,N.shape,N.dtype);return x.makeTensorInfo(ce,N.dtype,Ze)}if(t.util.sizeFromShape(ce)===0)return x.makeTensorInfo(ce,N.dtype,[]);const xe=new Zt(se,ce),De=[{type:"int32",data:se}];return x.runWebGPUProgram(xe,[N],N.dtype,De)}const ar={kernelName:t.Slice,backendName:"webgpu",kernelFunc:Gn},Rr={kernelName:t.BatchToSpaceND,backendName:"webgpu",kernelFunc:R=>{const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{blockShape:H,crops:ee}=M;t.util.assert(N.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const se=H.reduce((kt,Tt)=>kt*Tt),ce=t.backend_util.getReshaped(N.shape,H,se),xe=t.backend_util.getPermuted(ce.length,H.length),De=t.backend_util.getReshapedPermuted(N.shape,H,se),Ke=t.backend_util.getSliceBeginCoords(ee,H.length),Ze=t.backend_util.getSliceSize(De,ee,H.length),Ge=[],nt=Nt({inputs:{x:N},backend:x,attrs:{shape:ce}}),Je=Xr({inputs:{x:nt},backend:x,attrs:{perm:xe}}),yt=Nt({inputs:{x:Je},backend:x,attrs:{shape:De}}),gt=Gn({inputs:{x:yt},backend:x,attrs:{begin:Ke,size:Ze}});return Ge.push(nt),Ge.push(Je),Ge.push(yt),Ge.forEach(kt=>x.disposeData(kt.dataId)),gt}},Ir=$r({opType:rt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:xr}),xa={kernelName:t.NotEqual,backendName:"webgpu",kernelFunc:Ir};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Er(R){const{inputs:v,backend:x}=R,{input:M}=v;return Mn({inputs:{x:x.tensorMap.get(M.dataId).complexTensorInfos.real},backend:x})}const Yr={kernelName:t.Real,backendName:"webgpu",kernelFunc:Er};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ja={kernelName:t.Cast,backendName:"webgpu",kernelFunc:function R(v){const{inputs:x,backend:M,attrs:N}=v,{x:H}=x,{dtype:ee}=N;if(ee==="complex64"){if(H.dtype==="complex64")return Mn({inputs:{x:H},backend:M});const se=t.zeros(H.shape),ce=R({inputs:{x:H},backend:M,attrs:{dtype:"float32"}}),xe=Ur({inputs:{real:ce,imag:se},backend:M});return se.dispose(),M.disposeData(ce.dataId),xe}if(H.dtype==="complex64"){const se=Er({inputs:{input:H},backend:M}),ce=R({inputs:{x:se},backend:M,attrs:{dtype:ee}});return M.disposeData(se.dataId),ce}if(!t.util.hasEncodingLoss(H.dtype,ee)){const se=Mn({inputs:{x:H},backend:M});return{dataId:se.dataId,shape:se.shape,dtype:ee}}if(M.shouldExecuteOnCPU([H])){const se=M.tensorMap.get(H.dataId).values,[ce,xe,De]=Ln(se,H.shape,H.dtype,ee);return M.makeTensorInfo(ce,xe,De)}if(ee==="int32")return function(se,ce){const xe=new ir(se.shape,lt.TO_INT),De=ce.runWebGPUProgram(xe,[se],"int32");return{dataId:De.dataId,shape:De.shape,dtype:De.dtype}}(H,M);if(ee==="bool"){const se=M.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1)),ce=Ir({inputs:{a:H,b:se},backend:M});return M.disposeData(se.dataId),ce}throw new Error(`Error in Cast: failed to cast ${H.dtype} to ${ee}`)}},Oa=Zn({opType:lt.CEIL,cpuKernelImpl:or}),$a={kernelName:t.Ceil,backendName:"webgpu",kernelFunc:Oa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xs{constructor(v){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${O("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $s{constructor(v){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${O("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bs={kernelName:t.ClipByValue,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{clipValueMin:H,clipValueMax:ee}=M;let se;const ce=[{type:"float32",data:[H]},{type:"float32",data:[ee]}];return se=t.util.sizeFromShape(N.shape)%4==0?new Xs(N.shape):new $s(N.shape),x.runWebGPUProgram(se,[N],N.dtype,ce)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class di{constructor(v){this.uniforms="",this.workPerThread=4,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.backend_util.computeOutShape(v,1),this.variableNames=v.map((x,M)=>`T${M}`),this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=v.length-1;for(let x=0;x<this.offsetLength;x++)this.uniforms+=`offset${x} : i32,`;this.shaderKey="concat"}getUserCode(){const v=[];if(this.offsetLength>0){v.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let N=1;N<this.offsetLength;N++)v.push(`else if (yC < uniforms.offset${[N]}){ setOutputAtCoords(coords.x, coords.y, getT${N}(yR, yC - uniforms.offset${N-1})); }`);const x=this.offsetLength,M=this.offsetLength-1;v.push(`else { setOutputAtCoords(coords.x, coords.y, getT${x}(yR, yC - uniforms.offset${M})); }`)}else v.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${O("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${v.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(R){const{inputs:v,backend:x}=R,{input:M}=v;return Mn({inputs:{x:x.tensorMap.get(M.dataId).complexTensorInfos.imag},backend:x})}const qa={kernelName:t.Imag,backendName:"webgpu",kernelFunc:Ha};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(R,v,x){const M=R[0].dtype;if(M==="complex64"){const nt=R.map(Tt=>Er({inputs:{input:Tt},backend:x})),Je=R.map(Tt=>Ha({inputs:{input:Tt},backend:x})),yt=Ea(nt,v,x),gt=Ea(Je,v,x),kt=Ur({inputs:{real:yt,imag:gt},backend:x});return nt.forEach(Tt=>x.disposeData(Tt.dataId)),Je.forEach(Tt=>x.disposeData(Tt.dataId)),x.disposeData(yt.dataId),x.disposeData(gt.dataId),kt}let N=x.shouldExecuteOnCPU(R);if(M==="string"&&(N=!0),N){const nt=R.map(Yt=>{const Ht=t.util.sizeFromShape(Yt.shape.slice(v));return Nt({inputs:{x:Yt},backend:x,attrs:{shape:[-1,Ht]}})}),Je=nt.map(Yt=>({vals:x.readSync(Yt.dataId),shape:Yt.shape})),yt=t.backend_util.computeOutShape(nt.map(Yt=>Yt.shape),1),gt=nt[0].shape[0]===1,kt=lr(Je,yt,M,gt),Tt=t.backend_util.computeOutShape(R.map(Yt=>Yt.shape),v),Rt=x.makeTensorInfo(Tt,M,kt);return nt.forEach(Yt=>x.disposeData(Yt.dataId)),Rt}const H=x.device.limits.maxStorageBuffersPerShaderStage-1;if(R.length>H){const nt=[];for(let yt=0;yt<R.length;yt+=H){const gt=R.slice(yt,yt+H);nt.push(Ea(gt,v,x))}const Je=Ea(nt,v,x);for(const yt of nt)x.disposeData(yt.dataId);return Je}const{tensors2D:ee,outShape:se}=function(nt,Je,yt){const gt=t.backend_util.computeOutShape(nt.map(kt=>kt.shape),Je);return{tensors2D:nt.map(kt=>Nt({inputs:{x:kt},backend:yt,attrs:{shape:[t.util.sizeFromShape(kt.shape.slice(0,Je)),t.util.sizeFromShape(kt.shape.slice(Je))]}})),outShape:gt}}(R,v,x),ce=ee.map(nt=>nt.shape),xe=new di(ce),De=[],Ke=new Array(ce.length-1);if(Ke.length>0){Ke[0]=ce[0][1],De.push({type:"int32",data:[Ke[0]]});for(let nt=1;nt<Ke.length;nt++)Ke[nt]=Ke[nt-1]+ce[nt][1],De.push({type:"int32",data:[Ke[nt]]})}const Ze=x.runWebGPUProgram(xe,ee,ee[0].dtype,De);ee.forEach(nt=>x.disposeData(nt.dataId));const Ge=Nt({inputs:{x:Ze},backend:x,attrs:{shape:se}});return x.disposeData(Ze.dataId),Ge}function ta(R){const{inputs:v,backend:x,attrs:M}=R,{axis:N}=M,H=t.util.parseAxisParam(N,v[0].shape)[0],ee=t.backend_util.computeOutShape(v.map(xe=>xe.shape),H);if(t.util.sizeFromShape(ee)===0)return x.makeTensorInfo(ee,v[0].dtype,[]);const se=v.filter(xe=>t.util.sizeFromShape(xe.shape)>0);if(se.length===1)return Mn({inputs:{x:se[0]},backend:x});const ce=se.map(xe=>xe.shape);return t.backend_util.assertParamsConsistent(ce,H),Ea(se,H,x)}const Ys={kernelName:t.Concat,backendName:"webgpu",kernelFunc:ta};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ia{constructor(v,x,M,N,H=!1,ee=null,se=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=v.outShape,this.isChannelsLast=v.dataFormat==="channelsLast",this.isVec4=((v.inChannels%4==0||v.inChannels%3==0)&&this.isChannelsLast||v.outWidth%4==0&&!this.isChannelsLast)&&v.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=Q(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Se(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&v.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),H&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),se&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],H&&this.variableNames.push("bias"),se&&this.variableNames.push("preluActivationWeights")),this.addBias=H,this.activation=ee,this.hasPreluActivationWeights=se,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=x%this.tileAOuter==0,this.fitBOuter=M%this.tileBOuter==0,this.fitInner=N%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}`}getUserCode(){const v=this.isVec4?sr(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):K(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner),x=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${function(M,N,H,ee,se=!1,ce=null,xe=!1,De=4,Ke=4,Ze=4){const Ge=M?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,nt=M?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,Je=M?"uniforms.xShape[1]":"uniforms.xShape[2]",yt=M?"uniforms.xShape[2]":"uniforms.xShape[3]",gt=M?"row":"col",kt=M?"col":"row",Tt=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${M?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${gt} / outWidth;
      let outCol = ${gt} % outWidth;

      let WRow = ${kt} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${kt} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${kt} % inChannels;
      var resData = ${Ft(De)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${Je} && xCol >= 0 && xCol < ${yt}) {
        ${Ge}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${(ln=>{switch(ln){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${ln} is not supported.`)}})(De)}
      }
      return resData;`,Rt=M?N&&ee?`
      let col = colIn * ${De};
      ${Tt}`:`
      let col = colIn * ${De};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${Tt}
      }
      return ${Ft(De)}(0.0);`:ee&&H?`
      let col = colIn * ${De};
      ${Tt}`:`
      let col = colIn * ${De};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${Tt}
      }
      return ${Ft(De)}(0.0);`,Yt=`${(ln=>{switch(ln){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${ln} is not supported.`)}})(Ke)}`,Ht=Ft(Ze),nn=Ft(M?De:Ke),gn=Ft(M?Ke:De);return`
      ${yn(ce,xe,Ze===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${nn} {
        ${M?Rt:Yt}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${gn} {
        ${M?Yt:Rt}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Ht}) {
        let col = colIn * ${Ze};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${M?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${nt}
        ${Nn(se,ce)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,x[0],x[1],x[2])}
    ${v}
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(R,v){const x=R.length;return x>=3?v?[...R.slice(0,-3),R[x-3]*R[x-2],R[x-1]]:[...R.slice(0,-3),R[x-3],R[x-2]*R[x-1]]:!v&&x===1&&R[0]>1?[R[0],1]:null}function es({x:R,filter:v,convInfo:x,backend:M,bias:N=null,preluActivationWeights:H=null,leakyreluAlpha:ee=0,activation:se=null}){const ce=N!=null,xe=H!=null,De=x.dataFormat==="channelsLast";if(De&&x.filterHeight===x.inHeight&&x.filterWidth===x.inWidth&&x.padInfo.type==="VALID"||x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))return function({x:Rt,filter:Yt,convInfo:Ht,backend:nn,bias:gn=null,preluActivationWeights:ln=null,leakyreluAlpha:Bn=0,activation:wn=null}){const $n=Ht.dataFormat==="channelsLast",Wn=!$n,Hn=[];let Dn,er;if($n&&Ht.filterHeight===Ht.inHeight&&Ht.filterWidth===Ht.inWidth&&Ht.padInfo.type==="VALID"){const Or=Ht.inHeight*Ht.inWidth*Ht.inChannels;Dn=Nt({inputs:{x:Rt},backend:nn,attrs:{shape:[1,Ht.batchSize,Or]}}),er=Nt({inputs:{x:Yt},backend:nn,attrs:{shape:[1,Or,Ht.outChannels]}})}else Dn=Nt({inputs:{x:Rt},backend:nn,attrs:{shape:$n?[Ht.batchSize,Ht.inHeight*Ht.inWidth,Ht.inChannels]:[Ht.batchSize,Ht.inChannels,Ht.inHeight*Ht.inWidth]}}),er=Nt({inputs:{x:Yt},backend:nn,attrs:{shape:[1,Ht.inChannels,Ht.outChannels]}});if(Hn.push(Dn),Hn.push(er),ln!=null){const Or=Aa(ln.shape,$n);Or!=null&&(ln=Nt({inputs:{x:ln},backend:nn,attrs:{shape:Or}}),Hn.push(ln))}if(gn!=null){const Or=Aa(gn.shape,$n);Or!=null&&(gn=Nt({inputs:{x:gn},backend:nn,attrs:{shape:Or}}),Hn.push(gn))}const yr=Rn({a:$n?Dn:er,b:$n?er:Dn,transposeA:Wn,transposeB:!1,backend:nn,bias:gn,activation:wn,preluActivationWeights:ln,leakyreluAlpha:Bn}),la=Nt({inputs:{x:yr},backend:nn,attrs:{shape:Ht.outShape}});Hn.push(yr);for(const Or of Hn)nn.disposeData(Or.dataId);return la}({x:R,filter:v,convInfo:x,backend:M,bias:N,activation:se,preluActivationWeights:H,leakyreluAlpha:ee});const Ke=De?x.outHeight*x.outWidth:x.outChannels,Ze=De?x.outChannels:x.outHeight*x.outWidth,Ge=x.filterHeight*x.filterWidth*x.inChannels,nt=[x.padInfo.top,x.padInfo.left],Je=[{type:"int32",data:[x.filterHeight,x.filterWidth]},{type:"int32",data:[...nt]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]},{type:"int32",data:[Ke]},{type:"int32",data:[Ze]},{type:"int32",data:[Ge]}],yt=new ia(x,Ke,Ze,Ge,ce,se,xe),gt=[],kt=[R,v];ce&&(De||N.shape.length!==1||(N=Nt({inputs:{x:N},backend:M,attrs:{shape:[N.shape[0],1,1]}}),gt.push(N)),kt.push(N)),xe&&(De||H.shape.length!==1||(H=Nt({inputs:{x:H},backend:M,attrs:{shape:[H.shape[0],1,1]}}),gt.push(H)),kt.push(H)),se==="leakyrelu"&&(Je.push({type:"float32",data:[ee]}),yt.uniforms+=" alpha : f32,");const Tt=M.runWebGPUProgram(yt,kt,R.dtype,Je);for(const Rt of gt)M.disposeData(Rt.dataId);return Tt}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gs={kernelName:t.Conv2D,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,attrs:x,backend:M}=R,{x:N,filter:H}=v,{strides:ee,pad:se,dataFormat:ce,dilations:xe,dimRoundingMode:De}=x,Ke=t.backend_util.convertConv2DDataFormat(ce);return es({x:N,filter:H,convInfo:t.backend_util.computeConv2DInfo(N.shape,H.shape,ee,xe,se,De,!1,Ke),backend:M})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hi{constructor(v){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=v.inShape,t.util.assert(v.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=v.inChannels%4==0&&v.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Q(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Se(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const v=this.isVec4?sr(this.elementsPerThread,this.workGroupSize):K(this.elementsPerThread,this.workGroupSize);return`
    ${function(x=4){const M=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Ft(x)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Ft(x)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${x}];
      }
      return ${Ft(x)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ft(x)} {
    let col = colIn * ${x};
    ${M}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Ft(x)} {
    let col = colIn * ${x};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${(N=>{switch(N){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${N} is not supported.`)}})(x)}
    }
    return ${Ft(x)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${Ft(x)}) {
    let col = colIn * ${x};
    if (row < uniforms.dimAOuter && (col + ${x-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${x}] = value;
    }
  }`}(this.isVec4?4:1)}
    ${v}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xs{constructor(v){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v.inShape,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=v.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const v=this.isChannelsLast?1:2,x=this.isChannelsLast?2:3,M=this.isChannelsLast?3:1;return`
    ${O("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${M}];

        let dyCorner = vec2<i32>(coords[${v}]), coords[${x}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const us={kernelName:t.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{dy:N,filter:H}=v,{inputShape:ee,strides:se,pad:ce,dataFormat:xe,dimRoundingMode:De}=M,Ke=t.backend_util.convertConv2DDataFormat(xe),Ze=t.backend_util.computeConv2DInfo(ee,H.shape,se,1,ce,De,!1,Ke),Ge=[{type:"int32",data:[Ze.filterHeight,Ze.filterWidth]},{type:"int32",data:[Ze.filterHeight-1-Ze.padInfo.top,Ze.filterWidth-1-Ze.padInfo.left]},{type:"int32",data:[Ze.strideHeight,Ze.strideWidth]},{type:"int32",data:[Ze.batchSize,Ze.outHeight,Ze.outWidth,Ze.outChannels]}];let nt;if(Object(t.env)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))nt=new xs(Ze);else{nt=new hi(Ze);const Je=Ze.inShape[1]*Ze.inShape[2],yt=Ze.inShape[3],gt=Ze.filterHeight*Ze.filterWidth*Ze.outChannels;Ge.push({type:"uint32",data:[Je]},{type:"uint32",data:[yt]},{type:"uint32",data:[gt]})}return x.runWebGPUProgram(nt,[N,H],"float32",Ge)}},pi=Zn({opType:lt.COS}),pr={kernelName:t.Cos,backendName:"webgpu",kernelFunc:pi},Jr=Zn({opType:lt.COSH}),za={kernelName:t.Cosh,backendName:"webgpu",kernelFunc:Jr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Es{constructor(v,x,M,N){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;const[H]=x;this.outputShape=[H,M[0],M[1],v],this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=N==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[v,x]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[M,N,H]=this.cropHeightBiggerThan1?[`(${v} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${v} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${v}`],[ee,se,ce]=this.cropWidthBiggerThan1?[`(${x} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${x} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];return`
    ${O("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${M});
        let width_ratio = f32(${ee});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${N};
        let width_scale = ${se};
        let in_y = ${H};
        if( in_y < 0.0 || in_y > ${v} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${ce};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qs={kernelName:t.CropAndResize,backendName:"webgpu",kernelFunc:R=>{const{inputs:v,backend:x,attrs:M}=R,{image:N,boxes:H,boxInd:ee}=v,{cropSize:se,method:ce,extrapolationValue:xe}=M,De=new Es(N.shape[3],H.shape,se,ce),Ke=[{type:"float32",data:[xe]}];return x.runWebGPUProgram(De,[N,H,ee],"float32",Ke)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ts;(function(R){R.Prod="*",R.Sum="+"})(ts||(ts={}));class As{constructor(v,x,M,N){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workGroupSize=[128,1,1],this.outputShape=x,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=M,this.reverse=N,this.op=v,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const v=this.outputShape.length,x=this.op===ts.Prod?"1.0":"0.0",M=this.exclusive?x:`getX(${Ns(v,"coords",this.op)})`,N=this.outputShape[this.outputShape.length-1];let H="",ee="";return this.exclusive?(H=this.reverse?"end != "+(N-1):"end != 0",ee=this.reverse?"end + 1":"end - 1"):(H=this.reverse?`end + pow2 < ${N}`:"end >= pow2",ee=this.reverse?"end + pow2":"end - pow2"),`
      ${O("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${vs(v,"coords",this.op)};
         var val = ${M};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${H}) {
           let idx = ${ee};
           ${vs(v,"coords",this.op)} = idx;
           val ${this.op}= getX(${Ns(v,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function Ns(R,v,x){if(R===1)return`${v}`;if(R===2)return`${v}.x, ${v}.y`;if(R===3)return`${v}.x, ${v}.y, ${v}.z`;if(R===4)return`${v}.x, ${v}.y, ${v}.z, ${v}.w`;throw Error(`Cumulative ${x} for rank ${R} is not yet supported`)}function vs(R,v,x){if(R===1)return`${v}`;if(R===2)return`${v}.y`;if(R===3)return`${v}.z`;if(R===4)return`${v}.w`;throw Error(`Cumulative ${x} for rank ${R} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(R,v,x,M,N,H){const ee=v.shape.length,se=t.backend_util.getAxesPermutation([M],ee);let ce=v;se!=null&&(ce=Xr({inputs:{x:v},backend:x,attrs:{perm:se}}));const xe=t.backend_util.getInnerMostAxes(1,ee)[0];if(xe!==ee-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${v.shape.length-1} but got axis=${M}`);const De=ce.shape[xe];let Ke=Mn({inputs:{x:ce},backend:x});for(let Ze=0;Ze<=Math.ceil(Math.log2(De))-1;Ze++){const Ge=new As(R,ce.shape,!1,H),nt=Ke,Je=[{type:"float32",data:[Ze]}];Ke=x.runWebGPUProgram(Ge,[Ke],Ke.dtype,Je),x.disposeData(nt.dataId)}if(N){const Ze=new As(R,ce.shape,N,H),Ge=Ke,nt=[{type:"float32",data:[0]}];Ke=x.runWebGPUProgram(Ze,[Ke],Ke.dtype,nt),x.disposeData(Ge.dataId)}if(se!=null){const Ze=Xr({inputs:{x:Ke},backend:x,attrs:{perm:t.backend_util.getUndoAxesPermutation(se)}});return x.disposeData(Ke.dataId),x.disposeData(ce.dataId),Ze}return Ke}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const In={kernelName:t.Cumprod,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H,exclusive:ee,reverse:se}=M;return Yn(ts.Prod,N,x,H,ee,se)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fr={kernelName:t.Cumsum,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H,exclusive:ee,reverse:se}=M;return Yn(ts.Sum,N,x,H,ee,se)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sn{constructor(v,x){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${x}`,this.dataFormat=x}getUserCode(){return`
      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sa={kernelName:t.DepthToSpace,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{blockSize:H,dataFormat:ee}=M,se=N.shape[0],ce=(ee==="NHWC"?N.shape[1]:N.shape[2])*H,xe=(ee==="NHWC"?N.shape[2]:N.shape[3])*H,De=(ee==="NHWC"?N.shape[3]:N.shape[1])/(H*H),Ke=[{type:"int32",data:[H]}],Ze=new Sn(ee==="NHWC"?[se,ce,xe,De]:[se,De,ce,xe],ee);return x.runWebGPUProgram(Ze,[N],N.dtype,Ke)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class na{constructor(v,x,M,N=!1,H=null,ee=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=v,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),N&&this.variableNames.push("bias"),ee&&this.variableNames.push("preluActivationWeights"),this.addBias=N,this.activation=H,this.hasPreluActivation=ee,this.filterHeight=x,this.filterWidth=M,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const v=this.filterWidth*this.filterHeight,x=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],M=this.workGroupSize[1]+this.filterHeight-1,N=this.workGroupSize[0]+this.filterWidth-1;return`
      ${yn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${N}>, ${M}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
        localId = LocalId;
        globalId = GlobalId;
        let localIndex = i32(LocalIndex);
        numWorkgroups = NumWorkgroups;
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${M}; inputRow = inputRow + ${this.workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${N}; inputCol = inputCol + ${this.workGroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = localIndex;
        ${v<x?`if (wIndex < ${v})`:`for(; wIndex < ${v}; wIndex = wIndex + ${x})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Nn(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pa{constructor(v,x=!1,M=null,N=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.isVec4=!0,this.outputShape=v.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,4,1]),t.util.assert(v.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),x&&this.variableNames.push("bias"),N&&this.variableNames.push("preluActivationWeights"),this.convInfo=v,this.addBias=x,this.activation=M,this.hasPreluActivation=N,this.shaderKey=`depthwiseVec4_${M}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}`}getUserCode(){const v=4+this.convInfo.filterWidth-1;return`
      ${yn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, row, col, channel);
        }
        return value;
      }
      
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)

      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * 4;
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${v}>;
        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          for (var i = 0; i < ${v}; i++)
          {
            xVals[i] = readX(batch, xR, xCCorner + i, d1);
          }
          for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
            let wValue = getW(wR, wC, d1, 0);
            dotProd[0] = dotProd[0] + xVals[0 + wC] * wValue;
            dotProd[1] = dotProd[1] + xVals[1 + wC] * wValue;
            dotProd[2] = dotProd[2] + xVals[2 + wC] * wValue;
            dotProd[3] = dotProd[3] + xVals[3 + wC] * wValue;
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Nn(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zs{constructor(v,x=!1,M=null,N=!1){this.variableNames=["x","W"],this.uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`,this.workGroupSize=[256,1,1],this.outputShape=v.outShape,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=v.dataFormat==="channelsLast",x&&this.variableNames.push("bias"),N&&this.variableNames.push("preluActivationWeights"),this.convInfo=v,this.addBias=x,this.activation=M,this.hasPreluActivation=N,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const v=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${yn(this.activation,this.hasPreluActivation,!1,4)}

      ${O()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
        let d2 = coords[${this.isChannelsLast?3:1}];
        let channelMul = uniforms.wShape[3];
        let d1 = d2 / channelMul;
        let q = d2 % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
        var value = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = ${v};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = ${v};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          }
          ${Nn(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ys={kernelName:t.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N,filter:H}=v,{strides:ee,pad:se,dataFormat:ce,dilations:xe,dimRoundingMode:De}=M,Ke=t.backend_util.convertConv2DDataFormat(ce);let Ze=xe;Ze==null&&(Ze=[1,1]);const Ge=t.backend_util.computeConv2DInfo(N.shape,H.shape,ee,Ze,se,De,!0,Ke),nt=[{type:"int32",data:[Ge.padInfo.top,Ge.padInfo.left]},{type:"int32",data:[Ge.inHeight,Ge.inWidth]}],Je=Ge.dataFormat==="channelsLast";let yt;return!Je&&Ge.inHeight>16&&Ge.inWidth>16&&Ge.strideHeight===1&&Ge.strideWidth===1&&Ge.dilationWidth===1&&Ge.dilationHeight===1&&Ge.inChannels===Ge.outChannels?yt=new na(Ge.outShape,Ge.filterHeight,Ge.filterWidth):Je&&Ge.inHeight>4&&Ge.inWidth>4&&Ge.strideHeight===1&&Ge.strideWidth===1&&Ge.inChannels===Ge.outChannels&&Ge.dilationHeight===1&&Ge.dilationWidth===1&&Ge.inChannels%4==0?yt=new pa(Ge):(yt=new Zs(Ge),nt.push({type:"int32",data:[Ge.filterHeight]},{type:"int32",data:[Ge.filterWidth]},{type:"int32",data:[Ge.strideHeight,Ge.strideWidth]},{type:"int32",data:[Ge.dilationHeight,Ge.dilationWidth]})),x.runWebGPUProgram(yt,[N,H],N.dtype,nt)}},cs=$r({opType:rt.MUL,cpuKernelImpl:rn,supportsComplex:!0}),xi={kernelName:t.Multiply,backendName:"webgpu",kernelFunc:cs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H,keepDims:ee}=M;return ba(N,H,ee,"sum",x)}const Ua={kernelName:t.Sum,backendName:"webgpu",kernelFunc:ra};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ls={kernelName:t.Einsum,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{equation:N}=M,H=v,{allDims:ee,summedDims:se,idDims:ce}=t.backend_util.decodeEinsumEquation(N,H.length);t.backend_util.checkEinsumDimSizes(ee.length,ce,H);const{path:xe,steps:De}=t.backend_util.getEinsumComputePath(se,ce),Ke=De.length;let Ze=null,Ge=ee.length;const nt=[];for(let Je=0;Je<Ke;++Je){for(const yt of De[Je]){const{permutationIndices:gt,expandDims:kt}=t.backend_util.getEinsumPermutation(Ge,ce[yt]);let Tt;t.backend_util.isIdentityPermutation(gt)?Tt=H[yt]:(Tt=Xr({inputs:{x:H[yt]},backend:x,attrs:{perm:gt}}),nt.push(Tt));const Rt=Tt.shape.slice();for(let Yt=0;Yt<kt.length;++Yt)Rt.splice(kt[Yt],0,1);t.util.arraysEqual(Tt.shape,Rt)||(Tt=Nt({inputs:{x:Tt},backend:x,attrs:{shape:Rt}}),nt.push(Tt)),Ze===null?Ze=Tt:(Ze=cs({inputs:{a:Tt,b:Ze},backend:x}),nt.push(Ze))}Je<Ke-1&&(xe[Je]>=0&&(Ze=ra({inputs:{x:Ze},backend:x,attrs:{axis:xe[Je]-(ee.length-Ge),keepDims:!1}}),nt.push(Ze)),Ge--)}for(const Je of nt)Je!==Ze&&x.disposeData(Je.dataId);return Ze}},Tr=Zn({opType:lt.ELU}),Ka={kernelName:t.Elu,backendName:"webgpu",kernelFunc:Tr},Rs=$r({opType:rt.EQUAL,dtype:"bool",cpuKernelImpl:Qn}),Js={kernelName:t.Equal,backendName:"webgpu",kernelFunc:Rs},ws=Zn({opType:lt.EXP,cpuKernelImpl:br,dtype:"float32"}),ks={kernelName:t.Exp,backendName:"webgpu",kernelFunc:ws};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(R){const{inputs:v,attrs:x,backend:M}=R,{dim:N}=x,{input:H}=v,ee=H.shape.length,se=H.shape.slice();let ce=N;return N<0&&(t.util.assert(-(ee+1)<=N,()=>`Axis must be in the interval [${-(ee+1)}, ${ee}]`),ce=ee+N+1),se.splice(ce,0,1),Nt({inputs:{x:H},backend:M,attrs:{shape:se}})}const Fs={kernelName:t.ExpandDims,backendName:"webgpu",kernelFunc:ur},va=Zn({opType:lt.EXPM1,cpuKernelImpl:gr}),ei={kernelName:t.Expm1,backendName:"webgpu",kernelFunc:va};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ms{constructor(v){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ds={kernelName:t.FlipLeftRight,backendName:"webgpu",kernelFunc:({inputs:R,backend:v})=>{const{image:x}=R,M=v,N=new Ms(x.shape);return M.runWebGPUProgram(N,[x],x.dtype)}},ti=Zn({opType:lt.FLOOR,cpuKernelImpl:At}),Ps={kernelName:t.Floor,backendName:"webgpu",kernelFunc:ti},ns=$r({opType:rt.INT_DIV,dtype:"int32"}),Bs={kernelName:t.FloorDiv,backendName:"webgpu",kernelFunc:ns};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ai{constructor(v,x,M=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[x,1,1]),this.importVideo=M,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const v=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${O("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${v};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ls={kernelName:t.FromPixels,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R;let{pixels:N}=v;const{numChannels:H}=M;if(N==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const ee=typeof HTMLVideoElement!="undefined"&&N instanceof HTMLVideoElement,se=typeof HTMLImageElement!="undefined"&&N instanceof HTMLImageElement,ce=typeof HTMLCanvasElement!="undefined"&&N instanceof HTMLCanvasElement||typeof OffscreenCanvas!="undefined"&&N instanceof OffscreenCanvas,xe=typeof ImageBitmap!="undefined"&&N instanceof ImageBitmap,[De,Ke]=ee?[N.videoWidth,N.videoHeight]:[N.width,N.height],Ze=[Ke,De,H],Ge=Object(t.env)().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&ee,nt=ee||se;if(xe||ce||nt){let kt;if(Ge){const ln=N;if(!js.has(ln)||js.get(ln).expired){const Bn={source:ln};js.set(ln,x.device.importExternalTexture(Bn))}kt={width:De,height:Ke,format:null,usage:null,texture:js.get(ln)}}else{if(nt){const $n=Object(t.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");rs!=null&&$n===ni||(ni=$n,rs=document.createElement("canvas").getContext("2d",{willReadFrequently:ni})),rs.canvas.width=De,rs.canvas.height=Ke,rs.drawImage(N,0,0,De,Ke),N=rs.canvas}const ln=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,Bn="rgba8unorm",wn=x.textureManager.acquireTexture(Ze[1],Ze[0],Bn,ln);x.queue.copyExternalImageToTexture({source:N},{texture:wn},[Ze[1],Ze[0]]),kt={width:De,height:Ke,format:Bn,usage:ln,texture:wn}}const Tt=t.util.sizeFromShape(Ze),Rt=t.util.computeStrides(Ze),Yt=new Ai(Ze,H,Ge),Ht=[{type:"uint32",data:[Tt]},{type:"uint32",data:[H]},{type:"uint32",data:[...Rt]}],nn=x.makeTensorInfo([Ke,De],"int32");x.tensorMap.get(nn.dataId).resourceInfo=kt;const gn=x.runWebGPUProgram(Yt,[nn],"int32",Ht);return x.disposeData(nn.dataId),gn}const Je=N.data;let yt=Je;if(H!=null&&H!==4){yt=new Uint8Array(N.width*N.height*H);const kt=Je.length;let Tt=0;for(let Rt=0;Rt<kt;Rt++)Rt%4<H&&(yt[Tt++]=Je[Rt])}const gt=x.makeTensorInfo(Ze,"int32",new Int32Array(yt));return x.uploadToGPU(gt.dataId),gt}};let rs,ni=Object(t.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const js=new Map;class Ni{constructor(v,x,M,N,H){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(v,x),t.backend_util.assertAndGetBroadcastShape(v,M),this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),N!=null&&(t.backend_util.assertAndGetBroadcastShape(v,N),this.variableNames.push("offset")),H!=null&&(t.backend_util.assertAndGetBroadcastShape(v,H),this.variableNames.push("scale")),this.offsetShape=N,this.scaleShape=H,this.shaderKey="batchNorm"}getUserCode(){let v="0.0";this.offsetShape!=null&&(v="getOffsetByOutputIndex(index)");let x="1.0";return this.scaleShape!=null&&(x="getScaleByOutputIndex(index)"),`
      ${O("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${v};
          let scaleValue = ${x};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _s={kernelName:t.FusedBatchNorm,backendName:"webgpu",kernelFunc:({inputs:R,attrs:v,backend:x})=>{const{x:M,scale:N,offset:H,mean:ee,variance:se}=R,{varianceEpsilon:ce}=v,xe=x,De=[M,ee,se];let Ke=null;H!=null&&(Ke=H.shape,De.push(H));let Ze=null;N!=null&&(Ze=N.shape,De.push(N));const Ge=new Ni(M.shape,ee.shape,se.shape,Ke,Ze),nt=[{type:"float32",data:[ce]}];return xe.runWebGPUProgram(Ge,De,M.dtype,nt)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zs={kernelName:t.FusedConv2D,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N,filter:H,bias:ee,preluActivationWeights:se}=v,{strides:ce,pad:xe,dataFormat:De,dilations:Ke,dimRoundingMode:Ze,activation:Ge,leakyreluAlpha:nt}=M,Je=t.backend_util.convertConv2DDataFormat(De);return es({x:N,filter:H,convInfo:t.backend_util.computeConv2DInfo(N.shape,H.shape,ce,Ke,xe,Ze,!1,Je),backend:x,bias:ee,preluActivationWeights:se,leakyreluAlpha:nt,activation:Ge})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri={kernelName:t.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N,filter:H,bias:ee,preluActivationWeights:se}=v,{strides:ce,pad:xe,dilations:De,dimRoundingMode:Ke,activation:Ze,leakyreluAlpha:Ge}=M;let nt=De;nt==null&&(nt=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(ce,nt),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${ce} and dilations '${nt}'`);const Je=t.backend_util.computeConv2DInfo(N.shape,H.shape,ce,nt,xe,Ke,!0),yt=[N,H],gt=ee!=null,kt=se!=null;gt&&yt.push(ee),kt&&yt.push(se);const Tt=[{type:"int32",data:[Je.padInfo.top,Je.padInfo.left]},{type:"int32",data:[Je.inHeight,Je.inWidth]}];let Rt;return Je.inHeight>4&&Je.inWidth>4&&Je.strideHeight===1&&Je.strideWidth===1&&Je.inChannels===Je.outChannels&&Je.dilationHeight===1&&Je.dilationWidth===1&&Je.inChannels%4==0?Rt=new pa(Je,gt,Ze,kt):(Rt=new Zs(Je,gt,Ze,kt),Tt.push({type:"int32",data:[Je.filterHeight]},{type:"int32",data:[Je.filterWidth]},{type:"int32",data:[Je.strideHeight,Je.strideWidth]},{type:"int32",data:[Je.dilationHeight,Je.dilationWidth]})),Ze==="leakyrelu"&&(Tt.push({type:"float32",data:[Ge]}),Rt.uniforms+=" alpha : f32,"),x.runWebGPUProgram(Rt,yt,"float32",Tt)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vi{constructor(v,x){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=x,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${v}`,this.sliceDim=v,this.uniforms=`sliceDim : i32, strides : ${l(v)},`}getUserCode(){let v;return v=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`
      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${v};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ri={kernelName:t.GatherNd,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x}=R,{params:M,indices:N}=v,H=N.shape,ee=H[H.length-1],se=t.util.sizeFromShape(M.shape),[ce,xe,De,Ke]=t.backend_util.prepareAndValidate(M,N),Ze=Nt({inputs:{x:N},backend:x,attrs:{shape:[xe,ee]}}),Ge=Nt({inputs:{x:M},backend:x,attrs:{shape:[t.util.sizeFromShape(M.shape)/De,De]}});if(x.shouldExecuteOnCPU([M,N])||M.dtype==="string"){const kt=x.readSync(N.dataId),Tt=x.bufferSync(M),Rt=q(kt,Tt,M.dtype,xe,ee,De,Ke,M.shape,se);return x.makeTensorInfo(ce,M.dtype,Rt.values)}const nt=new vi(ee,[xe,De]),Je=[{type:"int32",data:[ee]},{type:"int32",data:Ke}],yt=x.runWebGPUProgram(nt,[Ge,Ze],Ge.dtype,Je),gt=Nt({inputs:{x:yt},backend:x,attrs:{shape:ce}});return x.disposeData(Ze.dataId),x.disposeData(Ge.dataId),x.disposeData(yt.dataId),gt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fi{constructor(v,x){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v.slice(),this.aShape=v,this.outputShape=x,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const v=function(x){const M=["resRC.x","resRC.y","resRC.z","resRC.w"],N=[];for(let H=0;H<x.length;H++)H===2?N.push("indexZ"):N.push(`${M[H]}`);return N.join()}(this.aShape);return`
      ${O("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${v}));
        }
      }
    `}}function yi(R){const{inputs:v,backend:x,attrs:M}=R,{x:N,indices:H}=v,{axis:ee,batchDims:se}=M,ce=t.util.parseAxisParam(ee,N.shape)[0],xe=t.backend_util.segment_util.collectGatherOpShapeInfo(N,H,ce,se),De=t.util.sizeFromShape(H.shape),Ke=[],Ze=Nt({inputs:{x:N},backend:x,attrs:{shape:[xe.batchSize,xe.outerSize,xe.dimSize,xe.sliceSize]}}),Ge=Nt({inputs:{x:H},backend:x,attrs:{shape:[xe.batchSize,De/xe.batchSize]}});Ke.push(Ze),Ke.push(Ge);const nt=[xe.batchSize,xe.outerSize,De/xe.batchSize,xe.sliceSize];if(x.shouldExecuteOnCPU([N,H])){const kt=x.tensorMap.get(Ge.dataId).values,Tt=Object(t.buffer)(Ge.shape,Ge.dtype,kt),Rt=x.tensorMap.get(Ze.dataId).values,Yt=Object(t.buffer)(Ze.shape,Ze.dtype,Rt),Ht=ae(Yt,Tt,nt);return Ke.forEach(nn=>x.disposeData(nn.dataId)),x.makeTensorInfo(xe.outputShape,Ht.dtype,Ht.values)}const Je=new Fi(Ze.shape,nt),yt=x.runWebGPUProgram(Je,[Ze,Ge],Ze.dtype);Ke.push(yt);const gt=Nt({inputs:{x:yt},backend:x,attrs:{shape:xe.outputShape}});return Ke.forEach(kt=>x.disposeData(kt.dataId)),gt}const Ne={kernelName:t.GatherV2,backendName:"webgpu",kernelFunc:yi},ue=$r({opType:rt.GREATER,cpuKernelImpl:ht,dtype:"bool"}),Be={kernelName:t.Greater,backendName:"webgpu",kernelFunc:ue},Xe=$r({opType:rt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Qe}),Te={kernelName:t.GreaterEqual,backendName:"webgpu",kernelFunc:Xe},Ye=Zn({opType:lt.IS_NAN,dtype:"bool"}),it={kernelName:t.IsNan,backendName:"webgpu",kernelFunc:Ye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt={kernelName:t.LeakyRelu,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{alpha:H}=M,ee=[{type:"float32",data:[H]}],se=new ir(N.shape,lt.LEAKYRELU);return se.uniforms="alpha : f32,",x.runWebGPUProgram(se,[N],"float32",ee)}},ut=$r({opType:rt.LESS,dtype:"bool",cpuKernelImpl:Kt}),ft={kernelName:t.Less,backendName:"webgpu",kernelFunc:ut},pt=$r({opType:rt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Bt}),zt={kernelName:t.LessEqual,backendName:"webgpu",kernelFunc:pt},Dt=Zn({opType:lt.LOG,cpuKernelImpl:Ut}),We={kernelName:t.Log,backendName:"webgpu",kernelFunc:Dt},_t=$r({opType:rt.LOGICAL_AND,dtype:"bool"}),jt={kernelName:t.LogicalAnd,backendName:"webgpu",kernelFunc:_t},Xt=Zn({opType:lt.LOGICAL_NOT}),on={kernelName:t.LogicalNot,backendName:"webgpu",kernelFunc:Xt},Pt=$r({opType:rt.MAX,cpuKernelImpl:bn}),hn={kernelName:t.Maximum,backendName:"webgpu",kernelFunc:Pt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fn={kernelName:t.MaxPool,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{filterSize:H,strides:ee,pad:se,dimRoundingMode:ce}=M;return Et(N,t.backend_util.computePool2DInfo(N.shape,H,ee,1,se,ce),"max",x)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nr={kernelName:t.Min,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H,keepDims:ee}=M;return ba(N,H,ee,"min",x)}},dr=$r({opType:rt.MIN,cpuKernelImpl:xn}),hr={kernelName:t.Minimum,backendName:"webgpu",kernelFunc:dr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cr{constructor(v,x,M){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=x.map((N,H)=>N[0]+v[H]+N[1]),this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=v,x.map((N,H)=>{this.uniforms+=` pad${H} : vec2<i32>,`}),this.offset=M==="reflect"?0:1,this.shaderKey=`mirrorPad_${M}`}getUserCode(){const v=this.xShape.length,x=this.xShape.map((xe,De)=>`uniforms.pad${De}[0]`).join(","),M=this.xShape.map((xe,De)=>`uniforms.pad${De}[0] + uniforms.xShape${v>1?`[${De}]`:""}`).join(","),N=v===1?"start":"start[i]",H=v===1?"end":"end[i]",ee=v===1?"outC":"outC[i]",se=l(v),ce=v>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,v):"coords";return`
      ${O("index")} {
        if (index < uniforms.size) {
          let start = ${se}(${x});
          let end = ${se}(${M});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${v}; i = i + 1) {
            if (${ee} < ${N}) {
              ${ee} = ${N} * 2 - ${ee} - ${this.offset};
            } else if(${ee} >= ${H}) {
              ${ee} = (${H} - 1) * 2 - ${ee} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${ce}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mr={kernelName:t.MirrorPad,backendName:"webgpu",kernelFunc:({inputs:R,attrs:v,backend:x})=>{const{x:M}=R,{paddings:N,mode:H}=v,ee=x,se=N.map(xe=>({type:"int32",data:[xe[0],xe[1]]})),ce=new cr(M.shape,N,H);return ee.runWebGPUProgram(ce,[M],M.dtype,se)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sr={kernelName:t.Neg,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x}=R,{x:M}=v;if(x.shouldExecuteOnCPU([M])){const H=x.tensorMap.get(M.dataId),[ee,se]=Xn(H.values,M.shape,M.dtype);return x.makeTensorInfo(se,M.dtype,ee)}const N=new ir(M.shape,lt.NEG);return x.runWebGPUProgram(N,[M],M.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dr={kernelName:t.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(R){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:v,backend:x,attrs:M}=R,{boxes:N,scores:H}=v,{maxOutputSize:ee,iouThreshold:se,scoreThreshold:ce}=M,xe=x.readSync(N.dataId),De=x.readSync(H.dataId),{selectedIndices:Ke}=t.kernel_impls.nonMaxSuppressionV3Impl(xe,De,ee,se,ce);return x.makeTensorInfo([Ke.length],"int32",new Int32Array(Ke))}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ar={kernelName:t.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(R){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:v,backend:x,attrs:M}=R,{boxes:N,scores:H}=v,{maxOutputSize:ee,iouThreshold:se,scoreThreshold:ce,softNmsSigma:xe}=M,De=x.readSync(N.dataId),Ke=x.readSync(H.dataId),Ze=ee,Ge=se,nt=ce,Je=xe,{selectedIndices:yt,selectedScores:gt}=t.kernel_impls.nonMaxSuppressionV5Impl(De,Ke,Ze,Ge,nt,Je);return[x.makeTensorInfo([yt.length],"int32",new Int32Array(yt)),x.makeTensorInfo([gt.length],"float32",new Float32Array(gt))]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(R){const{inputs:v,backend:x}=R,{x:M}=v;if(M.dtype==="complex64"){const N=Er({inputs:{input:M},backend:x}),H=aa({inputs:{x:N},backend:x}),ee=Ha({inputs:{input:M},backend:x}),se=aa({inputs:{x:ee},backend:x}),ce=Ur({inputs:{real:H,imag:se},backend:x});return x.disposeData(N.dataId),x.disposeData(H.dataId),x.disposeData(ee.dataId),x.disposeData(se.dataId),ce}return mt({attrs:{shape:M.shape,dtype:M.dtype,value:M.dtype==="string"?"":0},backend:x})}const ya={kernelName:t.ZerosLike,backendName:"webgpu",kernelFunc:aa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xa={kernelName:t.OnesLike,backendName:"webgpu",kernelFunc:function R(v){const{inputs:x,backend:M}=v,{x:N}=x;if(N.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(N.dtype==="complex64"){const H=Er({inputs:{input:N},backend:M}),ee=R({inputs:{x:H},backend:M}),se=Ha({inputs:{input:N},backend:M}),ce=aa({inputs:{x:se},backend:M}),xe=Ur({inputs:{real:ee,imag:ce},backend:M});return M.disposeData(H.dataId),M.disposeData(ee.dataId),M.disposeData(se.dataId),M.disposeData(ce.dataId),xe}return mt({attrs:{shape:N.shape,dtype:N.dtype,value:1},backend:M})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const as={kernelName:t.Pack,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{axis:N}=M;if(v.length===1)return ur({inputs:{input:v[0]},backend:x,attrs:{dim:N}});const H=v[0].shape,ee=v[0].dtype;v.forEach(xe=>{t.util.assertShapesMatch(H,xe.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(ee===xe.dtype,()=>"All tensors passed to stack must have matching dtypes")});const se=[],ce=ta({inputs:v.map(xe=>{const De=ur({inputs:{input:xe},backend:x,attrs:{dim:N}});return se.push(De),De}),backend:x,attrs:{axis:N}});return se.forEach(xe=>x.disposeData(xe.dataId)),ce}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Us{constructor(v,x){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=x.map((M,N)=>M[0]+v[N]+M[1]),this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),x.map((M,N)=>{this.uniforms+=` pad${N} : vec2<i32>,`}),this.xShape=v,this.shaderKey="pad"}getUserCode(){const v=this.xShape.length,x=l(v),M=this.xShape.map((De,Ke)=>`uniforms.pad${Ke}[0]`).join(","),N=this.xShape.map((De,Ke)=>`uniforms.pad${Ke}[0] + uniforms.xShape${v>1?`[${Ke}]`:""}`).join(","),H=v>1?`${x}(${M})`:`${M}`,ee=v>1?`${x}(${N})`:`${N}`,se=v>1?"any(outC < start)":"outC < start",ce=v>1?"any(outC >= end)":"outC >= end",xe=v>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,v):"coords";return`
      ${O("index")} {
        if (index < uniforms.size) {
          let start = ${H};
          let end = ${ee};
          let outC = getCoordsFromIndex(index);

          if (${se} || ${ce}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${xe}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Is=R=>{const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{paddings:H,constantValue:ee}=M;if(H.every(xe=>t.util.arraysEqual(xe,[0,0])))return Mn({inputs:{x:N},backend:x});if(t.util.sizeFromShape(N.shape)===0)return mt({backend:x,attrs:{shape:H.map((xe,De)=>xe[0]+N.shape[De]+xe[1]),value:ee,dtype:N.dtype}});const se=[{type:"float32",data:[ee]}];H.map(xe=>se.push({type:"int32",data:[xe[0],xe[1]]}));const ce=new Us(N.shape,H);return x.runWebGPUProgram(ce,[N],N.dtype,se)},Ya={kernelName:t.PadV2,backendName:"webgpu",kernelFunc:Is},ds=$r({opType:rt.POW}),hs={kernelName:t.Pow,backendName:"webgpu",kernelFunc:ds},Ws={kernelName:t.Prelu,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x}=R,{x:M,alpha:N}=v,H=new qe(rt.PRELU,M.shape,N.shape);return x.runWebGPUProgram(H,[M,N],"float32")}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa={kernelName:t.Prod,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{axis:H,keepDims:ee}=M;return ba(N,H,ee,"prod",x)}},Vs={kernelName:t.Range,backendName:"webgpu",kernelFunc:R=>{const{backend:v,attrs:x}=R,{start:M,stop:N,step:H,dtype:ee}=x,se=Wr(M,N,H,ee);return v.makeTensorInfo([se.length],ee,se)}},wi=$r({opType:rt.DIV}),Gs={kernelName:t.RealDiv,backendName:"webgpu",kernelFunc:wi},ki=Zn({opType:lt.RECIPROCAL}),no={kernelName:t.Reciprocal,backendName:"webgpu",kernelFunc:ki},Wi=Zn({opType:lt.RELU}),ro={kernelName:t.Relu,backendName:"webgpu",kernelFunc:Wi},Vi=Zn({opType:lt.RELU6}),Mi={kernelName:t.Relu6,backendName:"webgpu",kernelFunc:Vi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _i{constructor(v,x,M){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[v[0],x,M,v[3]],this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${O("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gi={kernelName:t.ResizeBilinear,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{images:N}=v,{alignCorners:H,size:ee,halfPixelCenters:se}=M,[ce,xe]=ee,De=[{type:"float32",data:[H&&ce>1?1:0,H&&xe>1?1:0]},{type:"float32",data:[se?.5:0]}],Ke=new _i(N.shape,ce,xe);return x.runWebGPUProgram(Ke,[N],"float32",De)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Di{constructor(v,x,M,N){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[v[0],x,M,v[3]],this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=N,this.shaderKey=`resizeNearest_${N}`}getUserCode(){let v;return v=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${v};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai={kernelName:t.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{images:N}=v,{alignCorners:H,halfPixelCenters:ee,size:se}=M,[ce,xe]=se,De=[{type:"float32",data:[H&&ce>1?1:0,H&&xe>1?1:0]},{type:"float32",data:[H?.5:0]}],Ke=new Di(N.shape,ce,xe,ee);return x.runWebGPUProgram(Ke,[N],N.dtype,De)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ao{constructor(v,x){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=v,typeof x=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${O("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const so={kernelName:t.RotateWithOffset,backendName:"webgpu",kernelFunc:({inputs:R,attrs:v,backend:x})=>{const{image:M}=R,{radians:N,fillValue:H,center:ee}=v,se=x,ce=new ao(M.shape,H),[xe,De]=t.backend_util.getImageCenter(ee,M.shape[1],M.shape[2]),Ke=[{type:"float32",data:[xe]},{type:"float32",data:[De]},{type:"float32",data:[Math.sin(N)]},{type:"float32",data:[Math.cos(N)]}];return typeof H=="number"?Ke.push({type:"float32",data:[Number.parseFloat(H.toFixed(2))]}):Ke.push({type:"float32",data:H}),se.runWebGPUProgram(ce,[M],M.dtype,Ke)}},io=Zn({opType:lt.RSQRT,cpuKernelImpl:vr}),Hi={kernelName:t.Rsqrt,backendName:"webgpu",kernelFunc:io};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ii{constructor(v,x,M,N,H,ee,se,ce=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=ee,this.type=se,this.sumDupeIndices=ce,this.dispatchLayout=Z(v),this.dispatch=he(this.dispatchLayout,v,this.workGroupSize),this.sliceDimGreaterThanOne=x>1,this.shaderKey=`scatter_${M}_${N}_${this.sliceDimGreaterThanOne}_${se}_${ce}`;const xe=l(H.length);this.uniforms=`sliceDim : i32, strides: ${xe}, size: i32,`,this.updatesRank=N,this.indicesRank=M}getUserCode(){let v="";this.indicesRank===1?v="coords[0]":this.indicesRank===2&&(v="coords[0], j");const x=`getIndices(${v})`,M=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let N="",H="";this.dispatchLayout.x.length===1?(N="flattenedIndex",H=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(N="vec2<i32>(flattenedIndex, coords[1])",H=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const ee=`getUpdates(${Array.from({length:this.updatesRank},(se,ce)=>`coords[${ce}]`).join(", ")})`;return`
    ${H}

      ${O("index")} {
        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${x}));
            flattenedIndex = flattenedIndex + indexInside * ${M};
          }
          let updateValue =
              ${ke(this.type,!1)}(${ee});
          let flatIndex = getOutputIndexFromCoords(${N});

          ${((se,ce)=>{let xe=`atomicAdd(${se}, bitcast<i32>(${ce}))`;this.type==="float32"&&(xe=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${ce});
            loop {
              let info = atomicCompareExchangeWeak(${se}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${ce});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);const De=`atomicStore(${se}, bitcast<i32>(${ce}));`;return this.sumDupeIndices?xe:De})("&result[flatIndex]","updateValue")};
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pi={kernelName:t.ScatterNd,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{indices:N,updates:H}=v,{shape:ee}=M,{sliceRank:se,numUpdates:ce,sliceSize:xe,strides:De,outputSize:Ke}=t.backend_util.calculateShapes(H,N,ee),Ze=[Ke/xe,xe];if(Ke===0)return x.makeTensorInfo(ee,N.dtype);const Ge=Nt({inputs:{x:N},backend:x,attrs:{shape:[ce,se]}}),nt=Nt({inputs:{x:H},backend:x,attrs:{shape:[ce,xe]}}),Je=nt.dtype,yt=mt({backend:x,attrs:{shape:Ze,value:0,dtype:Je}}),gt=[{type:"int32",data:[se]},{type:"int32",data:De},{type:"int32",data:[t.util.sizeFromShape(nt.shape)]}],kt=new Ii(nt.shape,se,Ge.shape.length,nt.shape.length,De,Ze,Je),Tt=x.runWebGPUProgram(kt,[nt,Ge],Je,gt,yt),Rt=Nt({inputs:{x:Tt},backend:x,attrs:{shape:ee}});return x.disposeData(Ge.dataId),x.disposeData(nt.dataId),x.disposeData(Tt.dataId),Rt}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qi{constructor(v,x,M){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=x,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=v,this.rank=M,this.shaderKey="select"}getUserCode(){let v,x;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)x="resRC",v="resRC";else{const M=["resRC.x","resRC.y","resRC.z","resRC.w"],N=[],H=[];for(let ee=0;ee<this.outputShape.length;ee++)H.push(`${M[ee]}`),ee<this.cRank&&N.push(`${M[ee]}`);v=N.join(),x=H.join()}return`
      ${O("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${v});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${x}));
          } else {
            setOutputAtIndex(index, getB(${x}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo={kernelName:t.Select,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x}=R,{condition:M,t:N,e:H}=v,ee=new qi(M.shape.length,N.shape,N.shape.length);return x.runWebGPUProgram(ee,[M,N,H],Object(t.upcastType)(N.dtype,H.dtype))}},fi=Zn({opType:lt.SIGMOID}),uo={kernelName:t.Sigmoid,backendName:"webgpu",kernelFunc:fi},co=Zn({opType:lt.SIN}),Ki={kernelName:t.Sin,backendName:"webgpu",kernelFunc:co},mi=Zn({opType:lt.SINH}),si={kernelName:t.Sinh,backendName:"webgpu",kernelFunc:mi},Si=$r({opType:rt.SUB,cpuKernelImpl:Pr,supportsComplex:!0}),Br={kernelName:t.Sub,backendName:"webgpu",kernelFunc:Si};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bi={kernelName:t.Softmax,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{logits:N}=v,{dim:H}=M,ee=t.util.parseAxisParam([H],N.shape),se=ca({inputs:{x:N},backend:x,attrs:{reductionIndices:ee,keepDims:!1}}),ce=t.backend_util.expandShapeToKeepDim(se.shape,ee),xe=Nt({inputs:{x:se},backend:x,attrs:{shape:ce}}),De=Si({inputs:{a:N,b:xe},backend:x}),Ke=ws({inputs:{x:De},backend:x}),Ze=ra({inputs:{x:Ke},backend:x,attrs:{axis:ee,keepDims:!1}}),Ge=Nt({inputs:{x:Ze},backend:x,attrs:{shape:ce}}),nt=wi({inputs:{a:Ke,b:Ge},backend:x});return x.disposeData(se.dataId),x.disposeData(xe.dataId),x.disposeData(De.dataId),x.disposeData(Ke.dataId),x.disposeData(Ze.dataId),x.disposeData(Ge.dataId),nt}},bi={kernelName:t.SpaceToBatchND,backendName:"webgpu",kernelFunc:R=>{const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{blockShape:H,paddings:ee}=M;t.util.assert(N.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const se=H.reduce((gt,kt)=>gt*kt),ce=[[0,0]];ce.push(...ee);for(let gt=1+H.length;gt<N.shape.length;++gt)ce.push([0,0]);const xe=[],De=Is({inputs:{x:N},backend:x,attrs:{paddings:ce,constantValue:0}}),Ke=t.backend_util.getReshaped(De.shape,H,se,!1),Ze=t.backend_util.getPermuted(Ke.length,H.length,!1),Ge=t.backend_util.getReshapedPermuted(De.shape,H,se,!1),nt=Nt({inputs:{x:De},backend:x,attrs:{shape:Ke}}),Je=Xr({inputs:{x:nt},backend:x,attrs:{perm:Ze}}),yt=Nt({inputs:{x:Je},backend:x,attrs:{shape:Ge}});return xe.push(De),xe.push(nt),xe.push(Je),xe.forEach(gt=>x.disposeData(gt.dataId)),yt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xi{constructor(v,x){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const M=new Array(v.length);for(let N=0;N<M.length;N++)M[N]=v[N]*x[N];this.outputShape=M,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const v=function(x,M=""){if(x>=5)throw Error(`Tile for rank ${x} is not yet supported`);if(x===1)return`(resRC % ${M}aShape)`;const N=["resRC.x","resRC.y","resRC.z","resRC.w"],H=[];for(let ee=0;ee<x;ee++)H.push(`(${N[ee]} % ${M}aShape[${ee}])`);return H.join()}(this.rank,"uniforms.");return`
      ${O("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${v}));
        }
      }
    `}}function ps(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{reps:H}=M;if(x.shouldExecuteOnCPU([N])||N.dtype==="string"||N.shape.length>=5){const se=x.readSync(N.dataId),ce=N.dtype==="string"?se.map(Ke=>t.util.decodeString(Ke)):se,xe=Object(t.buffer)(N.shape,N.dtype,ce),De=qr(xe,H);return x.makeTensorInfo(De.shape,De.dtype,De.values)}const ee=new Xi(N.shape,H);return x.runWebGPUProgram(ee,[N],N.dtype)}const ve={kernelName:t.Tile,backendName:"webgpu",kernelFunc:ps};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oe={kernelName:t.SparseToDense,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{sparseIndices:N,sparseValues:H,defaultValue:ee}=v,{outputShape:se}=M,{sliceRank:ce,numUpdates:xe,sliceSize:De,strides:Ke,outputSize:Ze}=t.backend_util.calculateShapes(H,N,se),Ge=!1;if(H.dtype==="string"){const nn=x.bufferSync(N),gn=x.bufferSync(H),ln=t.util.decodeString(x.readSync(ee.dataId)[0]),Bn=ua(nn,gn,se,Ze,De,xe,ce,Ke,ln,Ge);return x.makeTensorInfo(se,Bn.dtype,Bn.values)}const nt=[Ze/De,De],Je=Nt({inputs:{x:N},backend:x,attrs:{shape:[xe,ce]}}),yt=H.shape.length?Nt({inputs:{x:H},backend:x,attrs:{shape:[xe,De]}}):Mn({inputs:{x:H},backend:x}),gt=yt.dtype,kt=x.makeTensorInfo([],gt,t.util.makeZerosTypedArray(1,gt)),Tt=Nt({inputs:{x:ee},backend:x,attrs:{shape:Array(nt.length).fill(1)}}),Rt=ps({inputs:{x:Tt},backend:x,attrs:{reps:nt}}),Yt=[{type:"int32",data:[ce]},{type:"int32",data:Ke},{type:"int32",data:[t.util.sizeFromShape([xe,De])]}];switch(xe){case 0:break;case 1:{const nn=new Ii([xe,De],ce,Je.shape.length,yt.shape.length,Ke,nt,gt,Ge);x.runWebGPUProgram(nn,[yt,Je],gt,Yt,Rt)}break;default:{const nn=new Ii([xe,De],ce,Je.shape.length,kt.shape.length,Ke,nt,gt,Ge);x.runWebGPUProgram(nn,[kt,Je],gt,Yt,Rt)}{const nn=new Ii([xe,De],ce,Je.shape.length,yt.shape.length,Ke,nt,gt);x.runWebGPUProgram(nn,[yt,Je],gt,Yt,Rt)}}const Ht=Nt({inputs:{x:Rt},backend:x,attrs:{shape:se}});return x.disposeData(Je.dataId),x.disposeData(yt.dataId),x.disposeData(Tt.dataId),x.disposeData(kt.dataId),x.disposeData(Rt.dataId),Ht}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j={kernelName:t.SplitV,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{numOrSizeSplits:H,axis:ee}=M,se=t.util.parseAxisParam(ee,N.shape)[0],ce=t.backend_util.prepareSplitSize(N,H,se),xe=N.shape.length,De=new Array(xe).fill(0),Ke=N.shape.slice();return ce.map(Ze=>{const Ge=[...Ke];Ge[se]=Ze;const nt=Gn({inputs:{x:N},backend:x,attrs:{begin:De,size:Ge}});return De[se]+=Ze,nt})}},ie=Zn({opType:lt.SQRT}),F={kernelName:t.Sqrt,backendName:"webgpu",kernelFunc:ie},ne={kernelName:t.Square,backendName:"webgpu",kernelFunc:({inputs:R,backend:v})=>{const{x}=R,M=v,N=new ir(x.shape,lt.SQUARE);return M.runWebGPUProgram(N,[x],x.dtype)}},ge=$r({opType:rt.SQUARED_DIFFERENCE}),Ee={kernelName:t.SquaredDifference,backendName:"webgpu",kernelFunc:ge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $e{constructor(v){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const x=l(this.outputShape.length);this.uniforms=`begin : ${x},  strides : ${x}, `,this.shaderKey="stridedSlice"}getUserCode(){let v="";if(this.outputShape.length===1)v="coords * uniforms.strides + uniforms.begin";else{let x=0;v=this.outputShape.map((M,N)=>(x++,this.outputShape.length===1?`coords * uniforms.strides[${N}] + uniforms.begin[${N}]`:`coords[${x-1}] * uniforms.strides[${N}] + uniforms.begin[${N}]`)).join(",")}return`
       ${O("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${v}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const be={kernelName:t.StridedSlice,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{begin:H,end:ee,strides:se,beginMask:ce,endMask:xe,ellipsisMask:De,newAxisMask:Ke,shrinkAxisMask:Ze}=M,{finalShapeSparse:Ge,finalShape:nt,isIdentity:Je,sliceDim0:yt,isSimpleSlice:gt,begin:kt,end:Tt,strides:Rt}=t.slice_util.sliceInfo(N.shape,H,ee,se,ce,xe,De,Ke,Ze);let Yt;if(Je)Yt=Nt({inputs:{x:N},backend:x,attrs:{shape:nt}});else if(yt||gt){t.util.assert(N.shape.length>=1,()=>`Input must have rank at least 1, got: ${N.shape.length}`);const Ht=t.slice_util.computeOutShape(kt,Tt,Rt),nn=Gn({inputs:{x:N},backend:x,attrs:{begin:kt,size:Ht}});Yt=Nt({inputs:{x:nn},backend:x,attrs:{shape:nt}}),x.disposeData(nn.dataId)}else if(x.shouldExecuteOnCPU([N])){const Ht=x.readSync(N.dataId),nn=Object(t.buffer)(N.shape,N.dtype,Ht),gn=Da(Ge,nn,Rt,kt);Yt=x.makeTensorInfo(nt,N.dtype,gn.values)}else{const Ht=new $e(Ge),nn=[{type:"int32",data:kt},{type:"int32",data:Rt}],gn=x.runWebGPUProgram(Ht,[N],N.dtype,nn);Yt=Nt({inputs:{x:gn},backend:x,attrs:{shape:nt}}),x.disposeData(gn.dataId)}return Yt}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ye={kernelName:t.StringNGrams,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{separator:N,nGramWidths:H,leftPad:ee,rightPad:se,padWidth:ce,preserveShortSequences:xe}=M,{data:De,dataSplits:Ke}=v,Ze=x.readSync(De.dataId),Ge=x.readSync(Ke.dataId),[nt,Je]=kr(Ze,Ge,N,H,ee,se,ce,xe);return[x.makeTensorInfo([nt.length],"string",nt),x.makeTensorInfo(Ke.shape,"int32",Je)]}},Ue=Zn({opType:lt.TANH}),Re={kernelName:t.Tanh,backendName:"webgpu",kernelFunc:Ue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ve{constructor(v){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${O("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class st{constructor(v){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${O("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tt(R,v){v!==null&&R.disposeData(v.dataId)}function at(R){let v=1;for(;v<R;)v*=2;return v}const ot={kernelName:t.TopK,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{x:N}=v,{k:H,sorted:ee}=M,se=N.shape,ce=se[se.length-1];if(x.shouldExecuteOnCPU([N])){const Rt=x.readSync(N.dataId),[Yt,Ht]=ha(Rt,se,N.dtype,H,ee);return[x.makeTensorInfo(Yt.shape,Yt.dtype,Yt.values),x.makeTensorInfo(Ht.shape,Ht.dtype,Ht.values)]}if(H===0)return se[se.length-1]=0,[x.makeTensorInfo(se,N.dtype,[]),x.makeTensorInfo(se,"int32",[])];if(ce===1)return[N,mt({attrs:{shape:se,dtype:"int32",value:0},backend:x})];const xe=t.util.sizeFromShape(se)/ce,De=Nt({inputs:{x:N},attrs:{shape:[xe,ce]},backend:x}),Ke=at(H),Ze=at(ce);let Ge=null;const nt=()=>Ge===null?[De,De]:[De,Ge],Je=(Rt,Yt,Ht)=>{const nn=nt(),gn=new Ve(Ht),ln=[{type:"int32",data:[ce]},{type:"int32",data:[Ge===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[Rt]},{type:"int32",data:[Yt]}],Bn=Ge;Ge=x.runWebGPUProgram(gn,nn,"int32",ln),tt(x,Bn)};for(let Rt=1;Rt<Ke;Rt*=2){const Yt=2*Rt;for(let Ht=Rt;Ht>=1;Ht/=2)Je(Yt,Ht,[xe,Ze])}for(let Rt=Ze;Rt>Ke;Rt/=2){const Yt=nt(),Ht=new st([xe,Rt/2]),nn=[{type:"int32",data:[ce]},{type:"int32",data:[Ge===null?1:0]},{type:"int32",data:[Ke]}],gn=Ge;Ge=x.runWebGPUProgram(Ht,Yt,"int32",nn),tt(x,gn);const ln=Ke/2,Bn=2*ln;for(let wn=ln;wn>=1;wn/=2)Je(Bn,wn,Ge.shape)}let yt=Ge;Ge=Gn({inputs:{x:Ge},backend:x,attrs:{begin:0,size:[xe,H]}}),tt(x,yt);let gt=yi({inputs:{x:De,indices:Ge},backend:x,attrs:{axis:1,batchDims:1}});tt(x,De);const kt=se.slice(0,-1);kt.push(H),yt=Ge,Ge=Nt({inputs:{x:Ge},attrs:{shape:kt},backend:x}),tt(x,yt);const Tt=gt;return gt=Nt({inputs:{x:gt},attrs:{shape:kt},backend:x}),tt(x,Tt),[gt,Ge]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bt{constructor(v){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=v,this.dispatchLayout=Z(this.outputShape),this.dispatch=he(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${O("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const St=[oe,Ta,is,Va,_a,os,La,Vt,an,Rr,ja,$a,bs,_r,Ys,gs,us,pr,za,Qs,In,Fr,Sa,ys,ls,Ka,Js,ks,Fs,ei,Mt,Ds,Ls,Ps,Bs,_s,zs,ri,Ri,Ne,Be,Te,zr,qa,it,xt,ft,zt,We,jt,on,Ja,hn,Fn,dt,nr,hr,Mr,xi,Sr,Dr,Ar,xa,Xa,as,Ya,hs,Ws,fa,Vs,Yr,Gs,no,ro,Mi,un,Gi,ai,so,Hi,Pi,oo,uo,Ki,si,ar,be,ye,Bi,bi,Oe,j,F,ne,Ee,Br,Ua,Re,ve,ot,{kernelName:t.Transform,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{image:N,transforms:H}=v,{interpolation:ee,fillMode:se,fillValue:ce,outputShape:xe}=M,[De,Ke,Ze,Ge]=N.shape,[nt,Je]=xe!=null?xe:[Ke,Ze],yt=new bt([De,nt,Je,Ge]),gt=ee==="nearest"?1:2;let kt;switch(se){case"constant":default:kt=1;break;case"reflect":kt=2;break;case"wrap":kt=3;break;case"nearest":kt=4}const Tt=[{type:"int32",data:[gt]},{type:"int32",data:[kt]},{type:"float32",data:[ce]}];return x.runWebGPUProgram(yt,[N,H],"float32",Tt)}},ka,{kernelName:t.Unpack,backendName:"webgpu",kernelFunc:function(R){const{inputs:v,backend:x,attrs:M}=R,{value:N}=v;let{axis:H}=M;H<0&&(H+=N.shape.length);const ee=N,se=ee.shape.length,ce=N.shape[H],xe=new Array(se-1);let De=0;for(let Je=0;Je<se;Je++)Je!==H&&(xe[De++]=ee.shape[Je]);const Ke=[],Ze=new Array(se).fill(0),Ge=ee.shape.slice();Ge[H]=1;const nt=new Array(ce);for(let Je=0;Je<nt.length;Je++){Ze[H]=Je;const yt=Gn({inputs:{x:ee},backend:x,attrs:{begin:Ze,size:Ge}}),gt=Nt({inputs:{x:yt},backend:x,attrs:{shape:xe}});nt[Je]=gt,Ke.push(yt)}return Ke.forEach(Je=>x.disposeData(Je.dataId)),nt}},ya];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const R of St)Object(t.registerKernel)(R);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(I,n,e){var t=e(0),m=e(7);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h=t.kernel_impls.whereImpl;class b extends t.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new t.DataStorage(this,Object(t.engine)())}nextDataId(){return b.nextDataId++}write(Oe,j,ie){this.firstUse&&(this.firstUse=!1,Object(t.env)().get("IS_NODE")&&t.backend_util.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const F={id:this.nextDataId()};return this.data.set(F,{values:Oe,dtype:ie,refCount:1}),F}makeTensorInfo(Oe,j,ie){let F;if(j==="string"&&ie!=null&&ie.length>0&&t.util.isString(ie[0])){const ne=ie.map(ge=>t.util.encodeString(ge));F=this.write(ne,Oe,j)}else F=this.write(ie,Oe,j);return{dataId:F,shape:Oe,dtype:j}}refCount(Oe){return this.data.has(Oe)?this.data.get(Oe).refCount:0}incRef(Oe){this.data.get(Oe).refCount++}decRef(Oe){this.data.has(Oe)&&this.data.get(Oe).refCount--}move(Oe,j,ie,F,ne){this.data.set(Oe,{values:j,dtype:F,refCount:ne})}numDataIds(){return this.data.numDataIds()}async read(Oe){return this.readSync(Oe)}readSync(Oe){const{dtype:j,complexTensorInfos:ie}=this.data.get(Oe);if(j==="complex64"){const F=this.readSync(ie.real.dataId),ne=this.readSync(ie.imag.dataId);return t.backend_util.mergeRealAndImagArrays(F,ne)}return this.data.get(Oe).values}bufferSync(Oe){const j=this.readSync(Oe.dataId);if(Oe.dtype==="string")try{const ie=j.map(F=>t.util.decodeString(F));return Object(t.buffer)(Oe.shape,Oe.dtype,ie)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(t.buffer)(Oe.shape,Oe.dtype,j)}makeOutput(Oe,j,ie){return Object(t.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(j,ie,Oe),this)}disposeData(Oe,j=!1){if(this.data.has(Oe)){if(this.data.get(Oe).refCount--,!j&&this.data.get(Oe).refCount>0)return!1;const{complexTensorInfos:ie}=this.data.get(Oe);ie!=null&&(this.disposeData(ie.real.dataId,!0),this.disposeData(ie.imag.dataId,!0)),this.data.delete(Oe)}return!0}disposeIntermediateTensorInfo(Oe){this.disposeData(Oe.dataId)}async time(Oe){const j=t.util.now();return Oe(),{kernelMs:t.util.now()-j}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(Oe){Object(m.a)([Oe],"where");const j=this.readSync(Oe.dataId);return h(Oe.shape,j)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}b.nextDataId=0,Object(t.registerBackend)("cpu",()=>new b,1);var A=e(8);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D=Object(A.a)(t.Elu,ve=>ve>=0?ve:Math.exp(ve)-1),y={kernelName:t.Elu,backendName:"cpu",kernelFunc:D};var E=e(19);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{alpha:ne}=ie;Object(m.a)([F],"leakyRelu");const ge=t.util.sizeFromShape(F.shape),Ee=j.data.get(F.dataId).values,$e=t.util.getTypedArrayFromDType("float32",ge);for(let be=0;be<Ee.length;be++)$e[be]=Ee[be]<0?ne*Ee[be]:Ee[be];return j.makeTensorInfo(F.shape,"float32",$e)}const l={kernelName:t.LeakyRelu,backendName:"cpu",kernelFunc:S};var B=e(12);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O=Object(B.a)((ve,Oe)=>ve<0?Oe*ve:ve);function V(ve){const{inputs:Oe,backend:j}=ve,{x:ie,alpha:F}=Oe;Object(m.a)([ie,F],"prelu");const ne=j.data.get(ie.dataId).values,ge=j.data.get(F.dataId).values,[Ee,$e]=O(ie.shape,F.shape,ne,ge,"float32");return j.makeTensorInfo($e,"float32",Ee)}const L={kernelName:t.Prelu,backendName:"cpu",kernelFunc:V},g=Object(A.a)(t.Relu,ve=>Math.max(0,ve)),W={kernelName:t.Relu,backendName:"cpu",kernelFunc:g},de=Object(A.a)(t.Relu6,ve=>Math.min(Math.max(0,ve),6)),ke={kernelName:t.Relu6,backendName:"cpu",kernelFunc:de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ie=e(47);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function he(ve,Oe,j,ie,F){if(j==="linear")return Object(E.a)({inputs:{x:Oe},backend:ve});if(j==="relu")return g({inputs:{x:Oe},backend:ve});if(j==="elu")return D({inputs:{x:Oe},backend:ve});if(j==="relu6")return de({inputs:{x:Oe},backend:ve});if(j==="prelu")return V({inputs:{x:Oe,alpha:ie},backend:ve});if(j==="leakyrelu")return S({inputs:{x:Oe},backend:ve,attrs:{alpha:F}});if(j==="sigmoid")return Object(Ie.a)({inputs:{x:Oe},backend:ve});throw new Error(`Activation ${j} has not been implemented for the CPU backend.`)}var Q=e(24);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Se(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{shape:ne}=ie,ge=t.util.sizeFromShape(F.shape),Ee=t.util.inferFromImplicitShape(ne,ge),$e=t.util.sizeFromShape(Ee);t.util.assert(ge===$e,()=>`The new shape (${Ee}) has ${$e} elements and the old shape (${F.shape}) has ${ge} elements. The new shape and old shape must have the same number of elements.`),j.incRef(F.dataId);const be=j.data.get(F.dataId);if(be.complexTensorInfos!=null){const ye=be.complexTensorInfos.real,Ue=be.complexTensorInfos.imag;ye.shape=Ee,Ue.shape=Ee}return{dataId:F.dataId,shape:Ee,dtype:F.dtype}}const Z={kernelName:t.Reshape,backendName:"cpu",kernelFunc:Se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{a:F,b:ne}=Oe,{transposeA:ge,transposeB:Ee}=ie;Object(m.a)([F,ne],"matMul");const $e=F.shape.length,be=ne.shape.length,ye=ge?F.shape[$e-2]:F.shape[$e-1],Ue=Ee?ne.shape[be-1]:ne.shape[be-2],Re=ge?F.shape[$e-1]:F.shape[$e-2],Ve=Ee?ne.shape[be-2]:ne.shape[be-1],st=F.shape.slice(0,-2),tt=ne.shape.slice(0,-2),at=t.util.sizeFromShape(st),ot=t.util.sizeFromShape(tt),bt=t.broadcast_util.assertAndGetBroadcastShape(F.shape.slice(0,-2),ne.shape.slice(0,-2)).concat([Re,Ve]);t.util.assert(ye===Ue,()=>`Error in matMul: inner shapes (${ye}) and (${Ue}) of Tensors with shapes ${F.shape} and ${ne.shape} and transposeA=${ge} and transposeB=${Ee} must match.`);const St=Ee?[ot,Ve,Ue]:[ot,Ue,Ve],R=Se({inputs:{x:F},backend:j,attrs:{shape:ge?[at,ye,Re]:[at,Re,ye]}}),v=Se({inputs:{x:ne},backend:j,attrs:{shape:St}}),x=ge?R.shape[1]:R.shape[2],M=ge?R.shape[2]:R.shape[1],N=Ee?v.shape[1]:v.shape[2],H=Math.max(at,ot),ee=j.data.get(R.dataId).values,se=j.data.get(v.dataId).values,ce=t.util.computeStrides(R.shape),xe=t.util.computeStrides(v.shape),[De,Ke,Ze]=ge?[ce[0],1,ce[1]]:[ce[0],ce[1],1],[Ge,nt,Je]=Ee?[1,xe[1],xe[0]]:[xe[1],1,xe[0]],yt=M*N,gt=Object(t.buffer)([H,M,N],R.dtype),kt=gt.values,Tt=j.blockSize;for(let Rt=0;Rt<H;Rt++)for(let Yt=0;Yt<M;Yt+=Tt)for(let Ht=0;Ht<N;Ht+=Tt)for(let nn=0;nn<x;nn+=Tt){const gn=Math.min(Yt+Tt,M),ln=Math.min(Ht+Tt,N),Bn=Math.min(nn+Tt,x);for(let wn=Yt;wn<gn;wn++)for(let $n=Ht;$n<ln;$n++){let Wn=0;for(let Hn=nn;Hn<Bn;Hn++){const Dn=Math.min(Rt,at-1)*De,er=Math.min(Rt,ot-1)*Je;Wn+=ee[Dn+wn*Ke+Hn*Ze]*se[Hn*Ge+$n*nt+er]}kt[Rt*yt+(wn*N+$n)]+=Wn}}return j.disposeIntermediateTensorInfo(R),j.disposeIntermediateTensorInfo(v),j.makeTensorInfo(bt,gt.dtype,gt.values)}const He={kernelName:t.BatchMatMul,backendName:"cpu",kernelFunc:G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const me={kernelName:t._FusedMatMul,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{a:F,b:ne,bias:ge,preluActivationWeights:Ee}=Oe,{transposeA:$e,transposeB:be,activation:ye,leakyreluAlpha:Ue}=ie;let Re,Ve,st;const tt=[];Re=G({inputs:{a:F,b:ne},attrs:{transposeA:$e,transposeB:be},backend:j}),ge&&(Ve=Object(Q.a)({inputs:{a:Re,b:ge},backend:j}),tt.push(Re),Re=Ve),ye&&(st=he(j,Re,ye,Ee,Ue),tt.push(Re),Re=st);for(const at of tt)j.disposeIntermediateTensorInfo(at);return Re}};var et=e(56);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rt=Object(A.a)(t.Acos,ve=>Math.acos(ve)),It={kernelName:t.Acos,backendName:"cpu",kernelFunc:rt},X=Object(A.a)(t.Acosh,ve=>Math.acosh(ve)),$t={kernelName:t.Acosh,backendName:"cpu",kernelFunc:X},Ct={kernelName:t.AddN,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,ie=Oe;Object(m.a)(Oe,"addN");const F=ie.map(Ee=>j.data.get(Ee.dataId).values),ne=Object(t.buffer)(ie[0].shape,ie[0].dtype),ge=ne.values;for(let Ee=0;Ee<ie.length;Ee++){const $e=F[Ee];for(let be=0;be<ge.length;be++)ge[be]+=$e[be]}return j.makeTensorInfo(ne.shape,ne.dtype,ne.values)}};var Gt=e(16);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wt={kernelName:t.All,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,keepDims:ge}=ie;Object(m.a)(F,"all");const Ee=t.util.parseAxisParam(ne,F.shape);let $e=Ee;const be=t.backend_util.getAxesPermutation($e,F.shape.length);let ye=F;be!=null&&(ye=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:be}}),$e=t.backend_util.getInnerMostAxes($e.length,F.shape.length)),t.backend_util.assertAxesAreInnerMostDims("all",$e,ye.shape.length);const[Ue,Re]=t.backend_util.computeOutAndReduceShapes(ye.shape,$e),Ve=t.util.sizeFromShape(Re),st=t.util.makeZerosTypedArray(t.util.sizeFromShape(Ue),ye.dtype),tt=j.data.get(ye.dataId).values;for(let ot=0;ot<st.length;++ot){const bt=ot*Ve;let St=tt[bt];for(let R=0;R<Ve;++R){const v=tt[bt+R];St=St&&v}st[ot]=St}be!=null&&j.disposeIntermediateTensorInfo(ye);const at=j.makeTensorInfo(Ue,ye.dtype,st);if(ge){const ot=Se({inputs:{x:at},backend:j,attrs:{shape:t.backend_util.expandShapeToKeepDim(Ue,Ee)}});return j.disposeIntermediateTensorInfo(at),ot}return at}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lt={kernelName:t.Any,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,keepDims:ge}=ie;Object(m.a)(F,"any");const Ee=t.util.parseAxisParam(ne,F.shape);let $e=Ee;const be=t.backend_util.getAxesPermutation($e,F.shape.length);let ye=F;be!=null&&(ye=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:be}}),$e=t.backend_util.getInnerMostAxes($e.length,F.shape.length)),t.backend_util.assertAxesAreInnerMostDims("any",$e,ye.shape.length);const[Ue,Re]=t.backend_util.computeOutAndReduceShapes(ye.shape,$e),Ve=t.util.sizeFromShape(Re),st=t.util.makeZerosTypedArray(t.util.sizeFromShape(Ue),ye.dtype),tt=j.data.get(ye.dataId).values;for(let ot=0;ot<st.length;++ot){const bt=ot*Ve;let St=tt[bt];for(let R=0;R<Ve;++R){const v=tt[bt+R];St=St||v}st[ot]=St}be!=null&&j.disposeIntermediateTensorInfo(ye);const at=j.makeTensorInfo(Ue,ye.dtype,st);if(ge){const ot=Se({inputs:{x:at},backend:j,attrs:{shape:t.backend_util.expandShapeToKeepDim(Ue,Ee)}});return j.disposeIntermediateTensorInfo(at),ot}return at}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qt={kernelName:t.ArgMax,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne}=ie;Object(m.a)(F,"argMax");let ge=t.util.parseAxisParam(ne,F.shape);const Ee=t.backend_util.getAxesPermutation(ge,F.shape.length);let $e=F;const be=[];Ee!=null&&($e=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:Ee}}),be.push($e),ge=t.backend_util.getInnerMostAxes(ge.length,$e.shape.length)),ge=[ge[0]],t.backend_util.assertAxesAreInnerMostDims("argMax",ge,$e.shape.length);const[ye,Ue]=t.backend_util.computeOutAndReduceShapes($e.shape,ge),Re=t.util.sizeFromShape(ye),Ve=t.util.makeZerosTypedArray(Re,"int32"),st=t.util.sizeFromShape(Ue),tt=j.data.get($e.dataId).values;for(let at=0;at<Ve.length;++at){const ot=at*st;let bt=tt[ot],St=0;for(let R=0;R<st;++R){const v=tt[ot+R];v>bt&&(bt=v,St=R)}Ve[at]=St}return be.forEach(at=>j.disposeIntermediateTensorInfo(at)),j.makeTensorInfo(ye,"int32",Ve)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ft={kernelName:t.ArgMin,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne}=ie;Object(m.a)(F,"argMin");let ge=t.util.parseAxisParam(ne,F.shape);const Ee=t.backend_util.getAxesPermutation(ge,F.shape.length);let $e=F;const be=[];Ee!=null&&($e=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:Ee}}),be.push($e),ge=t.backend_util.getInnerMostAxes(ge.length,$e.shape.length)),ge=[ge[0]],t.backend_util.assertAxesAreInnerMostDims("argMin",ge,$e.shape.length);const[ye,Ue]=t.backend_util.computeOutAndReduceShapes($e.shape,ge),Re=t.util.sizeFromShape(ye),Ve=t.util.makeZerosTypedArray(Re,"int32"),st=t.util.sizeFromShape(Ue),tt=j.data.get($e.dataId).values;for(let at=0;at<Ve.length;++at){const ot=at*st;let bt=tt[ot],St=0;for(let R=0;R<st;++R){const v=tt[ot+R];v<bt&&(bt=v,St=R)}Ve[at]=St}return be.forEach(at=>j.disposeIntermediateTensorInfo(at)),j.makeTensorInfo(ye,"int32",Ve)}},yn=Object(A.a)(t.Asin,ve=>Math.asin(ve)),Nn={kernelName:t.Asin,backendName:"cpu",kernelFunc:yn},Kn=Object(A.a)(t.Asinh,ve=>Math.asinh(ve)),zn={kernelName:t.Asinh,backendName:"cpu",kernelFunc:Kn},sr=Object(A.a)(t.Atan,ve=>Math.atan(ve)),K={kernelName:t.Atan,backendName:"cpu",kernelFunc:sr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var J=e(13);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const we=Object(B.a)((ve,Oe)=>Math.atan2(ve,Oe)),vt=Object(J.a)(t.Atan2,we),wt={kernelName:t.Atan2,backendName:"cpu",kernelFunc:vt},Ot=Object(A.a)(t.Atanh,ve=>Math.atanh(ve)),Ae={kernelName:t.Atanh,backendName:"cpu",kernelFunc:Ot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mt(ve,Oe,j,ie,F,ne){const ge=F.strideHeight,Ee=F.strideWidth,$e=F.dilationHeight,be=F.dilationWidth,ye=F.effectiveFilterHeight,Ue=F.effectiveFilterWidth,Re=F.padInfo.top,Ve=F.padInfo.left,st=ne==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,tt=Object(t.buffer)(F.outShape,j),at=tt.values,ot=F.outShape[1]*F.outShape[2]*F.outShape[3],bt=F.outShape[2]*F.outShape[3],St=F.outShape[3];for(let R=0;R<F.batchSize;++R){const v=R*ot,x=R*ie[0];for(let M=0;M<F.inChannels;++M)for(let N=0;N<F.outHeight;++N){const H=N*ge-Re,ee=Math.max(0,H),se=Math.min(F.inHeight,ye+H),ce=v+N*bt;for(let xe=0;xe<F.outWidth;++xe){const De=xe*Ee-Ve,Ke=Math.max(0,De),Ze=Math.min(F.inWidth,Ue+De);let Ge=st,nt=0,Je=0;for(let yt=ee;yt<se;yt+=$e){const gt=x+yt*ie[1];for(let kt=Ke;kt<Ze;kt+=be){const Tt=ve[gt+kt*ie[2]+M];ne==="max"&&Tt>Ge?Ge=Tt:ne==="avg"&&(nt+=Tt,Je++)}if(isNaN(Ge))break}at[ce+xe*St+M]=ne==="avg"?nt/Je:Ge}}}return tt}function Mt(ve,Oe,j,ie,F=!1,ne=!1){const ge=Object(t.buffer)(ie.outShape,"int32"),Ee=ie.strideHeight,$e=ie.strideWidth,be=ie.dilationHeight,ye=ie.dilationWidth,Ue=ie.effectiveFilterHeight,Re=ie.effectiveFilterWidth,Ve=ie.padInfo.top,st=ie.padInfo.left,tt=Object(t.buffer)(Oe,j,ve);for(let at=0;at<ie.batchSize;++at)for(let ot=0;ot<ie.inChannels;++ot)for(let bt=0;bt<ie.outHeight;++bt){const St=bt*Ee-Ve;let R=St;for(;R<0;)R+=be;const v=Math.min(ie.inHeight,Ue+St);for(let x=0;x<ie.outWidth;++x){const M=x*$e-st;let N=M;for(;N<0;)N+=ye;const H=Math.min(ie.inWidth,Re+M);let ee=Number.NEGATIVE_INFINITY,se=-1;for(let ce=R;ce<v;ce+=be){const xe=ce-St;for(let De=N;De<H;De+=ye){const Ke=De-M,Ze=tt.get(at,ce,De,ot);Ze>ee&&(ee=Ze,se=F?ne?((at*ie.inHeight+ce)*ie.inWidth+De)*ie.inChannels+ot:(ce*ie.inWidth+De)*ie.inChannels+ot:xe*Re+Ke)}}ge.set(se,at,bt,x,ot)}}return ge}function Nt(ve,Oe,j,ie,F,ne){const ge=F.strideDepth,Ee=F.strideHeight,$e=F.strideWidth,be=F.dilationDepth,ye=F.dilationHeight,Ue=F.dilationWidth,Re=F.effectiveFilterDepth,Ve=F.effectiveFilterHeight,st=F.effectiveFilterWidth,tt=F.padInfo.front,at=F.padInfo.top,ot=F.padInfo.left,bt=ne==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,St=Object(t.buffer)(F.outShape,j),R=St.values,v=F.outShape[1]*F.outShape[2]*F.outShape[3]*F.outShape[4],x=F.outShape[2]*F.outShape[3]*F.outShape[4],M=F.outShape[3]*F.outShape[4],N=F.outShape[4];for(let H=0;H<F.batchSize;++H){const ee=H*v,se=H*ie[0];for(let ce=0;ce<F.inChannels;++ce)for(let xe=0;xe<F.outDepth;++xe){const De=xe*ge-tt;let Ke=De;for(;Ke<0;)Ke+=be;const Ze=Math.min(F.inDepth,Re+De),Ge=ee+xe*x;for(let nt=0;nt<F.outHeight;++nt){const Je=nt*Ee-at;let yt=Je;for(;yt<0;)yt+=ye;const gt=Math.min(F.inHeight,Ve+Je),kt=Ge+nt*M;for(let Tt=0;Tt<F.outWidth;++Tt){const Rt=Tt*$e-ot;let Yt=Rt;for(;Yt<0;)Yt+=Ue;const Ht=Math.min(F.inWidth,st+Rt),nn=kt+Tt*N;let gn=bt,ln=0,Bn=0;for(let wn=Ke;wn<Ze;wn+=be){const $n=se+wn*ie[1];for(let Wn=yt;Wn<gt;Wn+=ye){const Hn=$n+Wn*ie[2];for(let Dn=Yt;Dn<Ht;Dn+=Ue){const er=ve[Hn+Dn*ie[3]+ce];if(ne==="max"&&er>gn?gn=er:ne==="avg"&&(ln+=er,Bn++),isNaN(gn))break}if(isNaN(gn))break}if(isNaN(gn))break}R[nn+ce]=ne==="avg"?ln/Bn:gn}}}}return St}const un={kernelName:t.AvgPool,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe;Object(m.a)(F,"avgPool");const{filterSize:ne,strides:ge,pad:Ee,dimRoundingMode:$e}=ie;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(ge,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${ge} and dilations '1'`);const be=t.backend_util.computePool2DInfo(F.shape,ne,ge,1,Ee,$e);let ye;if(be.filterWidth===1&&be.filterHeight===1&&t.util.arraysEqual(be.inShape,be.outShape))ye=Object(E.a)({inputs:{x:F},backend:j});else{const Ue=j.data.get(F.dataId).values,Re=t.util.computeStrides(F.shape),Ve=mt(Ue,F.shape,F.dtype,Re,be,"avg");ye=j.makeTensorInfo(be.outShape,F.dtype,Ve.values)}return ye}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rn={kernelName:t.AvgPool3D,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{filterSize:ne,strides:ge,pad:Ee,dimRoundingMode:$e,dataFormat:be}=ie;Object(m.a)(F,"avgPool3d");const ye=t.backend_util.computePool3DInfo(F.shape,ne,ge,1,Ee,$e,be),Ue=Nt(j.data.get(F.dataId).values,F.shape,F.dtype,t.util.computeStrides(F.shape),ye,"avg");return j.makeTensorInfo(Ue.shape,"float32",Ue.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oe={kernelName:t.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,input:ne}=Oe,{filterSize:ge,strides:Ee,pad:$e,dimRoundingMode:be}=ie;Object(m.a)([F,ne],"avgPool3DGrad");const ye=t.backend_util.computePool3DInfo(ne.shape,ge,Ee,1,$e,be),Ue=ye.strideDepth,Re=ye.strideHeight,Ve=ye.strideWidth,st=ye.filterDepth,tt=ye.filterHeight,at=ye.filterWidth,ot=ye.dilationDepth,bt=ye.dilationHeight,St=ye.dilationWidth,R=ye.effectiveFilterDepth,v=ye.effectiveFilterHeight,x=ye.effectiveFilterWidth,M=R-1-ye.padInfo.front,N=x-1-ye.padInfo.left,H=v-1-ye.padInfo.top,ee=Object(t.buffer)(ne.shape,"float32"),se=1/(st*tt*at),ce=j.bufferSync(F);for(let xe=0;xe<ye.batchSize;++xe)for(let De=0;De<ye.inChannels;++De)for(let Ke=0;Ke<ye.inDepth;++Ke)for(let Ze=0;Ze<ye.inHeight;++Ze)for(let Ge=0;Ge<ye.inWidth;++Ge){const nt=Ke-M,Je=Ze-H,yt=Ge-N;let gt=0;for(let kt=0;kt<R;kt+=ot){const Tt=(nt+kt)/Ue;if(!(Tt<0||Tt>=ye.outDepth||Math.floor(Tt)!==Tt))for(let Rt=0;Rt<v;Rt+=bt){const Yt=(Je+Rt)/Re;if(!(Yt<0||Yt>=ye.outHeight||Math.floor(Yt)!==Yt))for(let Ht=0;Ht<x;Ht+=St){const nn=(yt+Ht)/Ve;nn<0||nn>=ye.outWidth||Math.floor(nn)!==nn||(gt+=ce.get(xe,Tt,Yt,nn,De))}}}ee.set(gt*se,xe,Ke,Ze,Ge,De)}return j.makeTensorInfo(ee.shape,ee.dtype,ee.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const le={kernelName:t.AvgPoolGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,input:ne}=Oe,ge=ne;Object(m.a)([F,ne],"avgPoolGrad");const{filterSize:Ee,strides:$e,pad:be}=ie,ye=t.backend_util.computePool2DInfo(ge.shape,Ee,$e,1,be),Ue=ye.strideHeight,Re=ye.strideWidth,Ve=ye.filterHeight,st=ye.filterWidth,tt=ye.dilationHeight,at=ye.dilationWidth,ot=ye.effectiveFilterHeight,bt=ye.effectiveFilterWidth,St=bt-1-ye.padInfo.left,R=ot-1-ye.padInfo.top,v=Object(t.buffer)(ge.shape,"float32"),x=1/(Ve*st),M=j.data.get(F.dataId).values,N=Object(t.buffer)(F.shape,"float32",M);for(let H=0;H<ye.batchSize;++H)for(let ee=0;ee<ye.inChannels;++ee)for(let se=0;se<ye.inHeight;++se)for(let ce=0;ce<ye.inWidth;++ce){const xe=se-R,De=ce-St;let Ke=0;for(let Ze=0;Ze<ot;Ze+=tt){const Ge=(xe+Ze)/Ue;if(!(Ge<0||Ge>=ye.outHeight||Math.floor(Ge)!==Ge))for(let nt=0;nt<bt;nt+=at){const Je=(De+nt)/Re;Je<0||Je>=ye.outWidth||Math.floor(Je)!==Je||(Ke+=N.get(H,Ge,Je,ee))}}v.set(Ke*x,H,se,ce,ee)}return j.makeTensorInfo(v.shape,v.dtype,v.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qe={kernelName:t.FusedBatchNorm,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,scale:ne,offset:ge,mean:Ee,variance:$e}=Oe;t.util.assert(Ee.shape.length===$e.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),t.util.assert(ge==null||Ee.shape.length===ge.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),t.util.assert(ne==null||Ee.shape.length===ne.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Object(m.a)([F,Ee,$e,ne,ge],"batchNorm");let{varianceEpsilon:be}=ie;be==null&&(be=.001);const ye=j.data.get(F.dataId).values,Ue=j.data.get(Ee.dataId).values,Re=j.data.get($e.dataId).values,Ve=ne?j.data.get(ne.dataId).values:new Float32Array([1]),st=ge?j.data.get(ge.dataId).values:new Float32Array([0]),tt=new Float32Array(ye.length),at=st.length,ot=Ve.length,bt=Re.length,St=Ue.length;let R=0,v=0,x=0,M=0;for(let N=0;N<ye.length;++N)tt[N]=st[R++]+(ye[N]-Ue[v++])*Ve[x++]/Math.sqrt(Re[M++]+be),R>=at&&(R=0),v>=St&&(v=0),x>=ot&&(x=0),M>=bt&&(M=0);return j.makeTensorInfo(F.shape,F.dtype,tt)}};var Mn=e(23);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zr={kernelName:t.BatchToSpaceND,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{blockShape:ne,crops:ge}=ie;Object(m.a)([F],"batchToSpaceND");const Ee=ne.reduce((ot,bt)=>ot*bt),$e=t.backend_util.getReshaped(F.shape,ne,Ee),be=t.backend_util.getPermuted($e.length,ne.length),ye=t.backend_util.getReshapedPermuted(F.shape,ne,Ee),Ue=t.backend_util.getSliceBeginCoords(ge,ne.length),Re=t.backend_util.getSliceSize(ye,ge,ne.length),Ve=Se({inputs:{x:F},backend:j,attrs:{shape:$e}}),st=Object(Gt.a)({inputs:{x:Ve},backend:j,attrs:{perm:be}}),tt=Se({inputs:{x:st},backend:j,attrs:{shape:ye}}),at=Object(Mn.a)({inputs:{x:tt},backend:j,attrs:{begin:Ue,size:Re}});return j.disposeIntermediateTensorInfo(Ve),j.disposeIntermediateTensorInfo(st),j.disposeIntermediateTensorInfo(tt),at}};var Ur=e(35);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _r={kernelName:t.Bincount,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,weights:ne}=Oe,{size:ge}=ie,Ee=j.data.get(F.dataId).values,$e=j.data.get(ne.dataId).values,be=Object(Ur.a)(Ee,$e,ne.dtype,ne.shape,ge);return j.makeTensorInfo([ge],ne.dtype,be)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ir={kernelName:t.BroadcastArgs,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{s0:ie,s1:F}=Oe,ne=j.data.get(ie.dataId).values,ge=j.data.get(F.dataId).values,Ee=t.backend_util.assertAndGetBroadcastShape(Array.from(ne),Array.from(ge));return j.makeTensorInfo([Ee.length],"int32",Int32Array.from(Ee))}};var Zn=e(25),$r=e(57);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const en=Object(A.a)(t.ClipByValue,(ve,Oe)=>{const j=Oe;return ve>j.clipValueMax?j.clipValueMax:ve<j.clipValueMin?j.clipValueMin:ve}),mn={kernelName:t.ClipByValue,backendName:"cpu",kernelFunc:en};var Ln=e(18);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const or={kernelName:t.ComplexAbs,backendName:"cpu",kernelFunc:ve=>{const{x:Oe}=ve.inputs,j=ve.backend,ie=new Float32Array(t.util.sizeFromShape(Oe.shape)),F=j.data.get(Oe.dataId),ne=F.complexTensorInfos.real,ge=F.complexTensorInfos.imag,Ee=j.data.get(ne.dataId).values,$e=j.data.get(ge.dataId).values;for(let be=0;be<Ee.length;be++){const ye=Ee[be],Ue=$e[be];ie[be]=Math.hypot(ye,Ue)}return j.makeOutput(ie,Oe.shape,"float32")}};var lr=e(58);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(ve){const{inputs:Oe,backend:j}=ve,{input:ie}=Oe,F=j.data.get(ie.dataId).complexTensorInfos.imag,ne=j.data.get(F.dataId).values;return j.makeTensorInfo(F.shape,F.dtype,ne)}const br={kernelName:t.Imag,backendName:"cpu",kernelFunc:Qn};var gr=e(26);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{axis:F}=ie,ne=t.util.parseAxisParam(F,Oe[0].shape)[0];let ge=t.backend_util.computeOutShape(Oe.map(tt=>tt.shape),ne);if(t.util.sizeFromShape(ge)===0)return j.makeTensorInfo(ge,Oe[0].dtype,[]);const Ee=Oe.filter(tt=>t.util.sizeFromShape(tt.shape)>0);if(Ee.length===1)return Object(E.a)({inputs:{x:Ee[0]},backend:j});const $e=Ee.map(tt=>tt.shape);if(t.backend_util.assertParamsConsistent($e,ne),Ee[0].dtype==="complex64"){const tt=Ee.map(R=>Object(gr.a)({inputs:{input:R},backend:j})),at=Ee.map(R=>Qn({inputs:{input:R},backend:j})),ot=At({inputs:tt,backend:j,attrs:{axis:ne}}),bt=At({inputs:at,backend:j,attrs:{axis:ne}}),St=Object(Ln.a)({inputs:{real:ot,imag:bt},backend:j});return tt.forEach(R=>j.disposeIntermediateTensorInfo(R)),at.forEach(R=>j.disposeIntermediateTensorInfo(R)),j.disposeIntermediateTensorInfo(ot),j.disposeIntermediateTensorInfo(bt),St}const be=Ee.map(tt=>{const at=t.util.sizeFromShape(tt.shape.slice(ne));return Se({inputs:{x:tt},backend:j,attrs:{shape:[-1,at]}})}),ye=be.map(tt=>({vals:j.data.get(tt.dataId).values,shape:tt.shape}));ge=t.backend_util.computeOutShape(be.map(tt=>tt.shape),1);const Ue=be[0].shape[0]===1,Re=Object(lr.a)(ye,ge,Oe[0].dtype,Ue),Ve=t.backend_util.computeOutShape(Ee.map(tt=>tt.shape),ne),st=j.makeTensorInfo(Ve,Oe[0].dtype,Re);return be.forEach(tt=>j.disposeIntermediateTensorInfo(tt)),st}const q={kernelName:t.Concat,backendName:"cpu",kernelFunc:At};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ae(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,filter:ne}=Oe,{strides:ge,pad:Ee,dataFormat:$e,dilations:be,dimRoundingMode:ye}=ie;Object(m.a)([F,ne],"conv2d");const Ue=t.backend_util.convertConv2DDataFormat($e),Re=t.backend_util.computeConv2DInfo(F.shape,ne.shape,ge,be,Ee,ye,!1,Ue),Ve=Re.filterHeight,st=Re.filterWidth,tt=Re.dilationHeight,at=Re.dilationWidth,ot=Re.padInfo.left,bt=Re.padInfo.top,St=Re.dataFormat==="channelsLast",R=new t.TensorBuffer(Re.outShape,F.dtype),v=t.util.computeStrides(F.shape),x=t.util.computeStrides(ne.shape),M=v[0],N=St?v[1]:v[2],H=St?v[2]:1,ee=St?1:v[1],se=R.strides[0],ce=St?R.strides[1]:R.strides[2],xe=St?R.strides[2]:1,De=St?1:R.strides[1],Ke=j.data.get(F.dataId).values,Ze=j.data.get(ne.dataId).values,Ge=R.values;for(let nt=0;nt<Re.batchSize;++nt){const Je=nt*M,yt=nt*se;for(let gt=0;gt<Re.outHeight;++gt){const kt=yt+gt*ce,Tt=gt*Re.strideHeight-bt;for(let Rt=0;Rt<Ve;++Rt){const Yt=Tt+Rt*tt;if(Yt<0||Yt>=Re.inHeight)continue;const Ht=Rt*x[0],nn=Je+Yt*N;for(let gn=0;gn<Re.outWidth;++gn){const ln=kt+gn*xe,Bn=gn*Re.strideWidth-ot;for(let wn=0;wn<st;++wn){const $n=Bn+wn*at;if($n<0||$n>=Re.inWidth)continue;const Wn=nn+$n*H;let Hn=Ht+wn*x[1];for(let Dn=0;Dn<Re.inChannels;++Dn){const er=Ke[Wn+Dn*ee];for(let yr=0;yr<Re.outChannels;++yr)Ge[ln+yr*De]+=er*Ze[Hn+yr];Hn+=Re.outChannels}}}}}}return j.makeTensorInfo(R.shape,R.dtype,Ge)}const Qe={kernelName:t.Conv2D,backendName:"cpu",kernelFunc:ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ht={kernelName:t.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,dy:ne}=Oe,{strides:ge,pad:Ee,dataFormat:$e,dimRoundingMode:be,filterShape:ye}=ie;Object(m.a)([F,ne],"conv2dBackpropFilter");const Ue=t.backend_util.convertConv2DDataFormat($e),Re=t.backend_util.computeConv2DInfo(F.shape,ye,ge,1,Ee,be,!1,Ue),{strideHeight:Ve,strideWidth:st,filterHeight:tt,filterWidth:at}=Re,ot=Re.dataFormat==="channelsLast",bt=new t.TensorBuffer(Re.filterShape,"float32"),St=Re.padInfo.left,R=Re.padInfo.top,v=j.data.get(F.dataId).values,x=j.data.get(ne.dataId).values,M=new t.TensorBuffer(F.shape,F.dtype,v),N=new t.TensorBuffer(ne.shape,ne.dtype,x);for(let H=0;H<tt;++H){const ee=Math.max(0,Math.ceil((R-H)/Ve)),se=Math.min(Re.outHeight,(Re.inHeight+R-H)/Ve);for(let ce=0;ce<at;++ce){const xe=Math.max(0,Math.ceil((St-ce)/st)),De=Math.min(Re.outWidth,(Re.inWidth+St-ce)/st);for(let Ke=0;Ke<Re.inChannels;++Ke)for(let Ze=0;Ze<Re.outChannels;++Ze){let Ge=0;for(let nt=0;nt<Re.batchSize;++nt)for(let Je=ee;Je<se;++Je){const yt=H+Je*Ve-R;for(let gt=xe;gt<De;++gt){const kt=ce+gt*st-St;Ge+=ot?M.get(nt,yt,kt,Ke)*N.get(nt,Je,gt,Ze):M.get(nt,Ke,yt,kt)*N.get(nt,Ze,Je,gt)}}bt.set(Ge,H,ce,Ke,Ze)}}}return j.makeTensorInfo(bt.shape,bt.dtype,bt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bt={kernelName:t.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,filter:ne}=Oe,{inputShape:ge,strides:Ee,pad:$e,dataFormat:be,dimRoundingMode:ye}=ie;Object(m.a)([F,ne],"conv2dBackpropInput");const Ue=t.util.computeStrides(ne.shape),Re=t.util.computeStrides(F.shape);let Ve=t.backend_util.convertConv2DDataFormat(be);const st=t.backend_util.computeConv2DInfo(ge,ne.shape,Ee,1,$e,ye,!1,Ve),tt=new t.TensorBuffer(st.inShape,"float32"),at=tt.values,ot=j.data.get(F.dataId).values,bt=j.data.get(ne.dataId).values,[St,R,v]=Ue,{batchSize:x,filterHeight:M,filterWidth:N,inChannels:H,inHeight:ee,inWidth:se,outChannels:ce,outHeight:xe,outWidth:De,strideHeight:Ke,strideWidth:Ze}=st;Ve=st.dataFormat;const Ge=M-1-st.padInfo.top,nt=N-1-st.padInfo.left,Je=Ve==="channelsLast",yt=tt.strides[0],gt=Je?tt.strides[1]:tt.strides[2],kt=Je?tt.strides[2]:1,Tt=Je?1:tt.strides[1],Rt=Re[0],Yt=Je?Re[1]:Re[2],Ht=Je?Re[2]:1,nn=Je?1:Re[1];for(let gn=0;gn<x;++gn)for(let ln=0;ln<H;++ln)for(let Bn=0;Bn<ee;++Bn){const wn=Bn-Ge,$n=Math.max(0,Math.ceil(wn/Ke)),Wn=Math.min(xe,(M+wn)/Ke);for(let Hn=0;Hn<se;++Hn){const Dn=Hn-nt,er=Math.max(0,Math.ceil(Dn/Ze)),yr=Math.min(De,(N+Dn)/Ze);let la=0;for(let Or=$n;Or<Wn;++Or){const Gr=Or*Ke-wn;for(let jr=er;jr<yr;++jr){const Na=Rt*gn+Yt*Or+Ht*jr,ga=St*(M-1-Gr)+R*(N-1-(jr*Ze-Dn))+v*ln;for(let Ra=0;Ra<ce;++Ra)la+=ot[Na+nn*Ra]*bt[ga+Ra]}}at[yt*gn+gt*Bn+kt*Hn+Tt*ln]=la}}return j.makeTensorInfo(tt.shape,tt.dtype,tt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kt={kernelName:t.Conv3D,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,filter:ne}=Oe,{strides:ge,pad:Ee,dilations:$e}=ie;Object(m.a)([F,ne],"conv3d");const be=t.backend_util.computeConv3DInfo(F.shape,ne.shape,ge,$e,Ee),{filterDepth:ye,filterHeight:Ue,filterWidth:Re,dilationDepth:Ve,dilationHeight:st,dilationWidth:tt,padInfo:at}=be,ot=at.front,bt=at.left,St=at.top,R=new t.TensorBuffer(be.outShape,F.dtype),v=j.data.get(F.dataId).values,x=j.data.get(ne.dataId).values,M=R.values,N=t.util.computeStrides(F.shape),H=t.util.computeStrides(ne.shape);for(let ee=0;ee<be.batchSize;++ee){const se=ee*N[0],ce=ee*R.strides[0];for(let xe=0;xe<be.outDepth;++xe){const De=ce+xe*R.strides[1],Ke=xe*be.strideDepth-ot;for(let Ze=0;Ze<ye;++Ze){const Ge=Ke+Ze*Ve;if(Ge<0||Ge>=be.inDepth)continue;const nt=Ze*H[0],Je=se+Ge*N[1];for(let yt=0;yt<be.outHeight;++yt){const gt=De+yt*R.strides[2],kt=yt*be.strideHeight-St;for(let Tt=0;Tt<Ue;++Tt){const Rt=kt+Tt*st;if(Rt<0||Rt>=be.inHeight)continue;const Yt=nt+Tt*H[1],Ht=Je+Rt*N[2];for(let nn=0;nn<be.outWidth;++nn){const gn=gt+nn*be.outChannels,ln=nn*be.strideWidth-bt;for(let Bn=0;Bn<Re;++Bn){const wn=ln+Bn*tt;if(wn<0||wn>=be.inWidth)continue;const $n=Yt+Bn*H[2],Wn=Ht+wn*be.inChannels;let Hn=$n;for(let Dn=0;Dn<be.inChannels;++Dn){const er=v[Wn+Dn];for(let yr=0;yr<be.outChannels;++yr)M[gn+yr]+=er*x[Hn+yr];Hn+=be.outChannels}}}}}}}}return j.makeTensorInfo(R.shape,R.dtype,R.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ut={kernelName:t.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,dy:ne}=Oe,{strides:ge,pad:Ee,filterShape:$e}=ie;Object(m.a)([F,ne],"conv3dBackpropFilterV2");const be=t.util.computeStrides(F.shape),ye=t.util.computeStrides(ne.shape),Ue=t.backend_util.computeConv3DInfo(F.shape,$e,ge,1,Ee),Re=Ue.strideDepth,Ve=Ue.strideHeight,st=Ue.strideWidth,tt=Ue.filterDepth,at=Ue.filterHeight,ot=Ue.filterWidth,bt=new t.TensorBuffer(Ue.filterShape,"float32"),St=bt.values,[R,v,x,M]=bt.strides,N=j.data.get(ne.dataId).values,[H,ee,se,ce]=ye,xe=j.data.get(F.dataId).values,[De,Ke,Ze,Ge]=be,nt=Ue.padInfo.front,Je=Ue.padInfo.left,yt=Ue.padInfo.top;for(let gt=0;gt<tt;++gt){const kt=Math.max(0,Math.ceil((nt-gt)/Re)),Tt=Math.min(Ue.outDepth,(Ue.inDepth+nt-gt)/Re),Rt=gt*R;for(let Yt=0;Yt<at;++Yt){const Ht=Math.max(0,Math.ceil((yt-Yt)/Ve)),nn=Math.min(Ue.outHeight,(Ue.inHeight+yt-Yt)/Ve),gn=Yt*v+Rt;for(let ln=0;ln<ot;++ln){const Bn=Math.max(0,Math.ceil((Je-ln)/st)),wn=Math.min(Ue.outWidth,(Ue.inWidth+Je-ln)/st),$n=ln*x+gn;for(let Wn=0;Wn<Ue.inChannels;++Wn){const Hn=Wn*M+$n;for(let Dn=0;Dn<Ue.outChannels;++Dn){let er=0;for(let yr=0;yr<Ue.batchSize;++yr){const la=yr*De,Or=yr*H;for(let Gr=kt;Gr<Tt;++Gr){const jr=(gt+Gr*Re-nt)*Ke+la,Na=Gr*ee+Or;for(let ga=Ht;ga<nn;++ga){const Ra=(Yt+ga*Ve-yt)*Ze+jr,Qa=ga*se+Na;for(let Ss=Bn;Ss<wn;++Ss){const Cs=Ss*ce+Qa;er+=xe[(ln+Ss*st-Je)*Ge+Ra+Wn]*N[Cs+Dn]}}}}St[Hn+Dn]=er}}}}}return j.makeTensorInfo(bt.shape,bt.dtype,bt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tn={kernelName:t.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,filter:ne}=Oe,{pad:ge,strides:Ee,inputShape:$e}=ie;Object(m.a)([F],"conv3dBackpropInputV2");const be=t.util.computeStrides(F.shape),ye=t.util.computeStrides(ne.shape),Ue=t.backend_util.computeConv3DInfo($e,ne.shape,Ee,1,ge),Re=new t.TensorBuffer(Ue.inShape,"float32"),Ve=Re.values,[st,tt,at,ot]=Re.strides,bt=j.data.get(F.dataId).values,[St,R,v,x]=be,M=j.data.get(ne.dataId).values,[N,H,ee,se]=ye,{batchSize:ce,filterDepth:xe,filterHeight:De,filterWidth:Ke,inChannels:Ze,inDepth:Ge,inHeight:nt,inWidth:Je,outChannels:yt,outDepth:gt,outHeight:kt,outWidth:Tt,strideDepth:Rt,strideHeight:Yt,strideWidth:Ht}=Ue,nn=xe-1-Ue.padInfo.front,gn=De-1-Ue.padInfo.top,ln=Ke-1-Ue.padInfo.left;for(let Bn=0;Bn<ce;++Bn)for(let wn=0;wn<Ze;++wn)for(let $n=0;$n<Ge;++$n){const Wn=$n-nn,Hn=Math.max(0,Math.ceil(Wn/Rt)),Dn=Math.min(gt,(xe+Wn)/Rt);for(let er=0;er<nt;++er){const yr=er-gn,la=Math.max(0,Math.ceil(yr/Yt)),Or=Math.min(kt,(De+yr)/Yt);for(let Gr=0;Gr<Je;++Gr){const jr=Gr-ln,Na=Math.max(0,Math.ceil(jr/Ht)),ga=Math.min(Tt,(Ke+jr)/Ht);let Ra=0;for(let Qa=Hn;Qa<Dn;++Qa){const Ss=Qa*Rt-Wn;for(let Cs=la;Cs<Or;++Cs){const Li=Cs*Yt-yr;for(let Yi=Na;Yi<ga;++Yi){const Qi=St*Bn+R*Qa+v*Cs+x*Yi,ko=N*(xe-1-Ss)+H*(De-1-Li)+ee*(Ke-1-(Yi*Ht-jr))+se*wn;for(let Ts=0;Ts<yt;++Ts)Ra+=bt[Qi+Ts]*M[ko+Ts]}}}Ve[st*Bn+tt*$n+at*er+ot*Gr+wn]=Ra}}}return j.makeTensorInfo(Re.shape,Re.dtype,Re.values)}},bn=Object(A.a)(t.Cos,ve=>Math.cos(ve)),xn={kernelName:t.Cos,backendName:"cpu",kernelFunc:bn},rn=Object(A.a)(t.Cosh,ve=>Math.cosh(ve)),Xn={kernelName:t.Cosh,backendName:"cpu",kernelFunc:rn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xr={kernelName:t.CropAndResize,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{image:F,boxes:ne,boxInd:ge}=Oe,{cropSize:Ee,method:$e,extrapolationValue:be}=ie,[ye,Ue,Re,Ve]=F.shape,st=ne.shape[0],[tt,at]=Ee,ot=Object(t.buffer)([st,tt,at,Ve],"float32"),bt=j.data.get(ne.dataId).values,St=j.data.get(ge.dataId).values,R=j.data.get(F.dataId).values,v=t.util.computeStrides(F.shape),x=t.util.computeStrides(ot.shape);for(let M=0;M<st;M++){const N=4*M,H=bt[N],ee=bt[N+1],se=bt[N+2],ce=bt[N+3],xe=St[M];if(xe>=ye)continue;const De=tt>1?(se-H)*(Ue-1)/(tt-1):0,Ke=at>1?(ce-ee)*(Re-1)/(at-1):0;for(let Ze=0;Ze<tt;Ze++){const Ge=tt>1?H*(Ue-1)+Ze*De:.5*(H+se)*(Ue-1);if(Ge<0||Ge>Ue-1)for(let nt=0;nt<at;nt++)for(let Je=0;Je<Ve;Je++){const yt=Je+nt*x[2]+Ze*x[1]+M*x[0];ot.values[yt]=be}else if($e==="bilinear"){const nt=Math.floor(Ge),Je=Math.ceil(Ge),yt=Ge-nt;for(let gt=0;gt<at;gt++){const kt=at>1?ee*(Re-1)+gt*Ke:.5*(ee+ce)*(Re-1);if(kt<0||kt>Re-1){for(let Ht=0;Ht<Ve;Ht++){const nn=Ht+gt*x[2]+Ze*x[1]+M*x[0];ot.values[nn]=be}continue}const Tt=Math.floor(kt),Rt=Math.ceil(kt),Yt=kt-Tt;for(let Ht=0;Ht<Ve;Ht++){let nn=Ht+Tt*v[2]+nt*v[1]+xe*v[0];const gn=R[nn];nn=Ht+Rt*v[2]+nt*v[1]+xe*v[0];const ln=R[nn];nn=Ht+Tt*v[2]+Je*v[1]+xe*v[0];const Bn=R[nn];nn=Ht+Rt*v[2]+Je*v[1]+xe*v[0];const wn=gn+(ln-gn)*Yt,$n=Bn+(R[nn]-Bn)*Yt;nn=Ht+gt*x[2]+Ze*x[1]+M*x[0],ot.values[nn]=wn+($n-wn)*yt}}}else for(let nt=0;nt<at;++nt){const Je=at>1?ee*(Re-1)+nt*Ke:.5*(ee+ce)*(Re-1);if(Je<0||Je>Re-1){for(let kt=0;kt<Ve;kt++){const Tt=kt+nt*x[2]+Ze*x[1]+M*x[0];ot.values[Tt]=be}continue}const yt=Math.round(Je),gt=Math.round(Ge);for(let kt=0;kt<Ve;kt++){const Tt=kt+yt*v[2]+gt*v[1]+xe*v[0],Rt=kt+nt*x[2]+Ze*x[1]+M*x[0];ot.values[Rt]=R[Tt]}}}}return j.makeTensorInfo(ot.shape,ot.dtype,ot.values)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lr={kernelName:t.Cumprod,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,exclusive:ge,reverse:Ee}=ie;Object(m.a)(F,"cumprod");const $e=t.backend_util.getAxesPermutation([ne],F.shape.length);let be=F;$e!=null&&(be=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:$e}}));const ye=t.backend_util.getInnerMostAxes(1,F.shape.length)[0];if(ye!==be.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${be.shape.length-1} but got axis=${ye}`);const Ue=Object(t.upcastType)(be.dtype,"int32"),Re=t.util.makeOnesTypedArray(t.util.sizeFromShape(be.shape),Ue),Ve=j.data.get(be.dataId).values,st=be.shape[be.shape.length-1],tt=Ee?(ot,bt)=>ot+st-bt-1:(ot,bt)=>ot+bt;for(let ot=0;ot<Ve.length;ot+=st)for(let bt=0;bt<st;bt++){const St=tt(ot,bt);if(bt===0)Re[St]=ge?1:Ve[St];else{const R=tt(ot,bt-1);Re[St]=ge?Ve[R]*Re[R]:Ve[St]*Re[R]}}const at=j.makeTensorInfo(be.shape,Ue,Re);if($e!=null){const ot=t.backend_util.getUndoAxesPermutation($e),bt=Object(Gt.a)({inputs:{x:at},backend:j,attrs:{perm:ot}});return j.disposeIntermediateTensorInfo(at),j.disposeIntermediateTensorInfo(be),bt}return at}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wr={kernelName:t.Cumsum,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,exclusive:ge,reverse:Ee}=ie;Object(m.a)(F,"cumsum");const $e=t.backend_util.getAxesPermutation([ne],F.shape.length);let be=F;$e!=null&&(be=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:$e}}));const ye=t.backend_util.getInnerMostAxes(1,F.shape.length)[0];if(ye!==be.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${be.shape.length-1} but got axis=${ye}`);const Ue=Object(t.upcastType)(be.dtype,"int32"),Re=t.util.makeZerosTypedArray(t.util.sizeFromShape(be.shape),Ue),Ve=j.data.get(be.dataId).values,st=be.shape[be.shape.length-1],tt=Ee?(ot,bt)=>ot+st-bt-1:(ot,bt)=>ot+bt;for(let ot=0;ot<Ve.length;ot+=st)for(let bt=0;bt<st;bt++){const St=tt(ot,bt);if(bt===0)Re[St]=ge?0:Ve[St];else{const R=tt(ot,bt-1);Re[St]=ge?Ve[R]+Re[R]:Ve[St]+Re[R]}}const at=j.makeTensorInfo(be.shape,Ue,Re);if($e!=null){const ot=t.backend_util.getUndoAxesPermutation($e),bt=Object(Gt.a)({inputs:{x:at},backend:j,attrs:{perm:ot}});return j.disposeIntermediateTensorInfo(at),j.disposeIntermediateTensorInfo(be),bt}return at}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vr={kernelName:t.DenseBincount,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,weights:ne}=Oe,{size:ge,binaryOutput:Ee}=ie;if(F.shape.length===1){const $e=j.data.get(F.dataId).values,be=j.data.get(ne.dataId).values,ye=Object(Ur.a)($e,be,ne.dtype,ne.shape,ge);return j.makeTensorInfo([ge],ne.dtype,ye)}if(F.shape.length===2){const $e=j.bufferSync(F),be=j.bufferSync(ne),ye=Object(Ur.b)($e,be,ge,Ee);return j.makeTensorInfo(ye.shape,ne.dtype,ye.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${F.shape.length}.`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ua={kernelName:t.DepthToSpace,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{blockSize:ne,dataFormat:ge}=ie;t.util.assert(ge==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${ge}`);const Ee=F.shape[0],$e=F.shape[1],be=F.shape[2],ye=F.shape[3],Ue=$e*ne,Re=be*ne,Ve=ye/(ne*ne),st=j.data.get(F.dataId).values,tt=new Float32Array(Ee*Ue*Re*Ve);let at=0;for(let ot=0;ot<Ee;++ot)for(let bt=0;bt<Ue;++bt){const St=Math.floor(bt/ne),R=bt%ne;for(let v=0;v<Re;++v){const x=Math.floor(v/ne),M=(R*ne+v%ne)*Ve;for(let N=0;N<Ve;++N){const H=N+M+ye*(x+be*(St+$e*ot));tt[at++]=st[H]}}}return j.makeTensorInfo([Ee,Ue,Re,Ve],F.dtype,tt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ma(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,filter:ne}=Oe,{strides:ge,pad:Ee,dilations:$e,dimRoundingMode:be}=ie;Object(m.a)([F,ne],"depthwiseConv2DNative");const ye=t.util.computeStrides(F.shape),Ue=t.util.computeStrides(ne.shape);let Re=$e;Re==null&&(Re=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(ge,Re),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${ge} and dilations '${Re}'`);const Ve=t.backend_util.computeConv2DInfo(F.shape,ne.shape,ge,Re,Ee,be,!0),{filterHeight:st,filterWidth:tt,dilationHeight:at,dilationWidth:ot,padInfo:bt}=Ve,St=bt.left,R=bt.top,v=Ve.outChannels/Ve.inChannels,x=new t.TensorBuffer(Ve.outShape,F.dtype),M=j.data.get(F.dataId).values,N=j.data.get(ne.dataId).values,H=x.values;for(let ee=0;ee<Ve.batchSize;++ee){const se=ee*ye[0],ce=ee*x.strides[0];for(let xe=0;xe<Ve.outHeight;++xe){const De=ce+xe*x.strides[1],Ke=xe*Ve.strideHeight-R;for(let Ze=0;Ze<st;++Ze){const Ge=Ke+Ze*at;if(Ge<0||Ge>=Ve.inHeight)continue;const nt=Ze*Ue[0],Je=se+Ge*ye[1];for(let yt=0;yt<Ve.outWidth;++yt){const gt=De+yt*x.strides[2],kt=yt*Ve.strideWidth-St;for(let Tt=0;Tt<tt;++Tt){const Rt=kt+Tt*ot;if(Rt<0||Rt>=Ve.inWidth)continue;const Yt=nt+Tt*Ue[1],Ht=Je+Rt*Ve.inChannels;let nn=gt,gn=Yt;for(let ln=0;ln<Ve.inChannels;++ln){const Bn=M[Ht+ln];for(let wn=0;wn<v;++wn)H[nn+wn]+=Bn*N[gn+wn];nn+=v,gn+=v}}}}}}return j.makeTensorInfo(x.shape,x.dtype,x.values)}const Cr={kernelName:t.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:ma};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Da={kernelName:t.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,dy:ne}=Oe,{strides:ge,dilations:Ee,pad:$e,dimRoundingMode:be,filterShape:ye}=ie;Object(m.a)([F,ne],"depthwiseConv2dNativeBackpropFilter");const Ue=t.backend_util.computeConv2DInfo(F.shape,ye,ge,Ee,$e,be,!0),{strideHeight:Re,strideWidth:Ve,filterHeight:st,filterWidth:tt}=Ue,at=new t.TensorBuffer(Ue.filterShape,"float32"),ot=Ue.padInfo.left,bt=Ue.padInfo.top,St=Ue.outChannels/Ue.inChannels,R=j.data.get(F.dataId).values,v=new t.TensorBuffer(F.shape,F.dtype,R),x=j.data.get(ne.dataId).values,M=new t.TensorBuffer(ne.shape,ne.dtype,x);for(let N=0;N<st;++N){const H=Math.max(0,Math.ceil((bt-N)/Re)),ee=Math.min(Ue.outHeight,(Ue.inHeight+bt-N)/Re);for(let se=0;se<tt;++se){const ce=Math.max(0,Math.ceil((ot-se)/Ve)),xe=Math.min(Ue.outWidth,(Ue.inWidth+ot-se)/Ve);for(let De=0;De<Ue.outChannels;++De){const Ke=Math.trunc(De/St),Ze=De%St;let Ge=0;for(let nt=0;nt<Ue.batchSize;++nt)for(let Je=H;Je<ee;++Je){const yt=N+Je*Re-bt;for(let gt=ce;gt<xe;++gt){const kt=se+gt*Ve-ot;Ge+=v.get(nt,yt,kt,Ke)*M.get(nt,Je,gt,De)}}at.set(Ge,N,se,Ke,Ze)}}}return j.makeTensorInfo(at.shape,at.dtype,at.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kr={kernelName:t.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,filter:ne}=Oe,{strides:ge,dilations:Ee,pad:$e,dimRoundingMode:be,inputShape:ye}=ie;Object(m.a)([F,ne],"depthwiseConv2DNativeBackpropInput");const Ue=t.util.computeStrides(F.shape),Re=t.util.computeStrides(ne.shape),Ve=t.backend_util.computeConv2DInfo(ye,ne.shape,ge,Ee,$e,be,!0),st=new t.TensorBuffer(Ve.inShape,"float32"),tt=st.values,[at,ot,bt]=st.strides,St=j.data.get(F.dataId).values,[R,v,x]=Ue,M=j.data.get(ne.dataId).values,[N,H,ee]=Re,{batchSize:se,filterHeight:ce,filterWidth:xe,inChannels:De,inHeight:Ke,inWidth:Ze,outChannels:Ge,outHeight:nt,outWidth:Je,strideHeight:yt,strideWidth:gt}=Ve,kt=ce-1-Ve.padInfo.top,Tt=xe-1-Ve.padInfo.left,Rt=Ge/De;for(let Yt=0;Yt<se;++Yt)for(let Ht=0;Ht<De;++Ht)for(let nn=0;nn<Ke;++nn){const gn=nn-kt,ln=Math.max(0,Math.ceil(gn/yt)),Bn=Math.min(nt,(ce+gn)/yt);for(let wn=0;wn<Ze;++wn){const $n=wn-Tt,Wn=Math.max(0,Math.ceil($n/gt)),Hn=Math.min(Je,(xe+$n)/gt);let Dn=0;for(let er=ln;er<Bn;++er){const yr=er*yt-gn;for(let la=Wn;la<Hn;++la){const Or=R*Yt+v*er+x*la,Gr=N*(ce-1-yr)+H*(xe-1-(la*gt-$n))+ee*Ht;for(let jr=0;jr<Rt;++jr)Dn+=St[Or+(Ht*Rt+jr)]*M[Gr+jr]}}tt[at*Yt+ot*nn+bt*wn+Ht]=Dn}}return j.makeTensorInfo(st.shape,st.dtype,st.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pr={kernelName:t.Diag,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{x:ie}=Oe,F=t.util.sizeFromShape(ie.shape),ne=j.data.get(ie.dataId).values,ge=Object(t.buffer)([F,F],ie.dtype),Ee=ge.values;for(let be=0;be<ne.length;be++)Ee[be*F+be]=ne[be];const $e=[...ie.shape,...ie.shape];return j.makeTensorInfo($e,ge.dtype,ge.values)}},qr={kernelName:t.Dilation2D,backendName:"cpu",kernelFunc:({inputs:ve,backend:Oe,attrs:j})=>{const{x:ie,filter:F}=ve,{strides:ne,pad:ge,dilations:Ee}=j,$e=Oe,be=$e.data.get(ie.dataId).values,ye=ie.shape.length,Ue=$e.data.get(F.dataId).values,Re=F.shape.length,{batchSize:Ve,inHeight:st,inWidth:tt,inChannels:at,outHeight:ot,outWidth:bt,padInfo:St,strideHeight:R,strideWidth:v,filterHeight:x,filterWidth:M,dilationHeight:N,dilationWidth:H,outShape:ee}=t.backend_util.computeDilation2DInfo(ie.shape,F.shape,ne,ge,"NHWC",Ee),se=t.util.sizeFromShape(ee),ce=ee.length,xe=t.util.getArrayFromDType(ie.dtype,se);for(let De=0;De<Ve;++De)for(let Ke=0;Ke<ot;++Ke){const Ze=Ke*R-St.top;for(let Ge=0;Ge<bt;++Ge){const nt=Ge*v-St.left;for(let Je=0;Je<at;++Je){let yt=Number.MIN_SAFE_INTEGER;for(let gt=0;gt<x;++gt){const kt=Ze+gt*N;if(kt>=0&&kt<st)for(let Tt=0;Tt<M;++Tt){const Rt=nt+Tt*H;if(Rt>=0&&Rt<tt){const Yt=t.util.locToIndex([De,kt,Rt,Je],ye,t.util.computeStrides(ie.shape)),Ht=t.util.locToIndex([gt,Tt,Je],Re,t.util.computeStrides(F.shape)),nn=be[Yt]+Ue[Ht];nn>yt&&(yt=nn)}}}xe[t.util.locToIndex([De,Ke,Ge,Je],ce,t.util.computeStrides(ee))]=yt}}}return{dataId:$e.write(t.util.toTypedArray(xe,ie.dtype),ee,ie.dtype),shape:ee,dtype:ie.dtype}}},ha={kernelName:t.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:ve,backend:Oe,attrs:j})=>{const{x:ie,filter:F,dy:ne}=ve,{strides:ge,pad:Ee,dilations:$e}=j,be=Oe,ye=t.util.toNestedArray(ie.shape,be.data.get(ie.dataId).values),Ue=t.util.toNestedArray(F.shape,be.data.get(F.dataId).values),{batchSize:Re,inHeight:Ve,inWidth:st,inChannels:tt,outHeight:at,outWidth:ot,padInfo:bt,strideHeight:St,strideWidth:R,filterHeight:v,filterWidth:x,dilationHeight:M,dilationWidth:N,outShape:H}=t.backend_util.computeDilation2DInfo(ie.shape,F.shape,ge,Ee,"NHWC",$e);t.util.assert(ne.rank===H.length,()=>`Error in ${t.Dilation2DBackpropFilter}, dy must have the same rank as output ${H.length}, but got ${ne.rank}`);const ee=t.util.toNestedArray(H,be.data.get(ne.dataId).values),se=t.util.makeZerosNestedTypedArray(F.shape,F.dtype);for(let ce=0;ce<Re;++ce)for(let xe=0;xe<at;++xe){const De=xe*St-bt.top;for(let Ke=0;Ke<ot;++Ke){const Ze=Ke*R-bt.left;for(let Ge=0;Ge<tt;++Ge){let nt=Number.MIN_SAFE_INTEGER,Je=0,yt=0;for(let gt=0;gt<v;++gt){const kt=De+gt*M;if(kt>=0&&kt<Ve)for(let Tt=0;Tt<x;++Tt){const Rt=Ze+Tt*N;if(Rt>=0&&Rt<st){const Yt=ye[ce][kt][Rt][Ge]+Ue[gt][Tt][Ge];Yt>nt&&(nt=Yt,Je=gt,yt=Tt)}}}se[Je][yt][Ge]+=ee[ce][xe][Ke][Ge]}}}return{dataId:be.write(t.util.toTypedArray(se,ie.dtype),F.shape,F.dtype),shape:F.shape,dtype:F.dtype}}},Zr={kernelName:t.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:ve,backend:Oe,attrs:j})=>{const{x:ie,filter:F,dy:ne}=ve,{strides:ge,pad:Ee,dilations:$e}=j,be=Oe,ye=t.util.toNestedArray(ie.shape,be.data.get(ie.dataId).values),Ue=t.util.toNestedArray(F.shape,be.data.get(F.dataId).values),{batchSize:Re,inHeight:Ve,inWidth:st,inChannels:tt,outHeight:at,outWidth:ot,padInfo:bt,strideHeight:St,strideWidth:R,filterHeight:v,filterWidth:x,dilationHeight:M,dilationWidth:N,outShape:H}=t.backend_util.computeDilation2DInfo(ie.shape,F.shape,ge,Ee,"NHWC",$e);t.util.assert(ne.rank===H.length,()=>`Error in ${t.Dilation2DBackpropInput}, dy must have the same rank as output ${H.length}, but got ${ne.rank}`);const ee=t.util.toNestedArray(H,be.data.get(ne.dataId).values),se=t.util.makeZerosNestedTypedArray(ie.shape,ie.dtype);for(let ce=0;ce<Re;++ce)for(let xe=0;xe<at;++xe){const De=xe*St-bt.top;for(let Ke=0;Ke<ot;++Ke){const Ze=Ke*R-bt.left;for(let Ge=0;Ge<tt;++Ge){let nt=Number.MIN_SAFE_INTEGER,Je=De<0?0:De,yt=Ze<0?0:Ze;for(let gt=0;gt<v;++gt){const kt=De+gt*M;if(kt>=0&&kt<Ve)for(let Tt=0;Tt<x;++Tt){const Rt=Ze+Tt*N;if(Rt>=0&&Rt<st){const Yt=ye[ce][kt][Rt][Ge]+Ue[gt][Tt][Ge];Yt>nt&&(nt=Yt,Je=kt,yt=Rt)}}}se[ce][Je][yt][Ge]+=ee[ce][xe][Ke][Ge]}}}return{dataId:be.write(t.util.toTypedArray(se,ie.dtype),ie.shape,ie.dtype),shape:ie.shape,dtype:ie.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Vr=e(29),Ca=e(89);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ta(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,keepDims:ge}=ie;let Ee;Object(m.a)(F,"sum"),Ee=F.dtype==="bool"?Object(Zn.a)({inputs:{x:F},backend:j,attrs:{dtype:"int32"}}):Object(E.a)({inputs:{x:F},backend:j});const $e=Ee.shape.length,be=t.util.parseAxisParam(ne,Ee.shape),ye=t.backend_util.getAxesPermutation(be,$e);let Ue=be,Re=Ee;ye!=null&&(Re=Object(Gt.a)({inputs:{x:Ee},backend:j,attrs:{perm:ye}}),Ue=t.backend_util.getInnerMostAxes(Ue.length,$e)),t.backend_util.assertAxesAreInnerMostDims("sum",Ue,Re.shape.length);const[Ve,st]=t.backend_util.computeOutAndReduceShapes(Re.shape,Ue),tt=t.backend_util.upcastType(Re.dtype,"int32");let at=Object(Ca.a)(j,Ve,tt);const ot=t.util.sizeFromShape(st),bt=j.data.get(at.dataId).values,St=j.data.get(Re.dataId).values;for(let R=0;R<bt.length;++R){const v=R*ot;let x=0;for(let M=0;M<ot;++M)x+=St[v+M];bt[R]=x}if(ge){const R=at;at=Se({inputs:{x:at},backend:j,attrs:{shape:t.backend_util.expandShapeToKeepDim(at.shape,be)}}),j.disposeIntermediateTensorInfo(R)}return j.disposeIntermediateTensorInfo(Ee),ye!=null&&j.disposeIntermediateTensorInfo(Re),at}const Pa={kernelName:t.Sum,backendName:"cpu",kernelFunc:Ta};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const is={kernelName:t.Einsum,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{equation:F}=ie,ne=Oe,{allDims:ge,summedDims:Ee,idDims:$e}=t.backend_util.decodeEinsumEquation(F,ne.length);t.backend_util.checkEinsumDimSizes(ge.length,$e,ne);const{path:be,steps:ye}=t.backend_util.getEinsumComputePath(Ee,$e),Ue=ye.length;let Re=null,Ve=ge.length;const st=[];for(let tt=0;tt<Ue;++tt){for(const at of ye[tt]){const{permutationIndices:ot,expandDims:bt}=t.backend_util.getEinsumPermutation(Ve,$e[at]);let St;t.backend_util.isIdentityPermutation(ot)?St=ne[at]:(St=Object(Gt.a)({inputs:{x:ne[at]},backend:j,attrs:{perm:ot}}),st.push(St));const R=St.shape.slice();for(let v=0;v<bt.length;++v)R.splice(bt[v],0,1);t.util.arraysEqual(St.shape,R)||(St=Se({inputs:{x:St},backend:j,attrs:{shape:R}}),st.push(St)),Re===null?Re=St:(Re=Object(Vr.a)({inputs:{a:St,b:Re},backend:j}),st.push(Re))}tt<Ue-1&&(be[tt]>=0&&(Re=Ta({inputs:{x:Re},backend:j,attrs:{axis:be[tt]-(ge.length-Ve),keepDims:!1}}),st.push(Re)),Ve--)}for(const tt of st)tt!==Re&&j.disposeIntermediateTensorInfo(tt);return Re}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ms={kernelName:t.EluGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{dy:ie,y:F}=Oe;Object(m.a)([ie,F],"eluGrad");const ne=new Float32Array(t.util.sizeFromShape(F.shape)),ge=j.data.get(F.dataId).values,Ee=j.data.get(ie.dataId).values;for(let $e=0;$e<ge.length;++$e){const be=ge[$e];ne[$e]=be>=1?Ee[$e]:Ee[$e]*(be+1)}return j.makeTensorInfo(F.shape,"float32",ne)}};var Va=e(44);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ba=t.backend_util.ERF_P,wa=t.backend_util.ERF_A1,Ga=t.backend_util.ERF_A2,Xr=t.backend_util.ERF_A3,ka=t.backend_util.ERF_A4,_a=t.backend_util.ERF_A5,os=Object(A.a)(t.Erf,ve=>{const Oe=Math.sign(ve),j=Math.abs(ve),ie=1/(1+Ba*j);return Oe*(1-((((_a*ie+ka)*ie+Xr)*ie+Ga)*ie+wa)*ie*Math.exp(-j*j))}),Za={kernelName:t.Erf,backendName:"cpu",kernelFunc:os};var La=e(45);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{input:F}=Oe,{dim:ne}=ie,ge=F.shape.length,Ee=F.shape.slice();let $e=ne;return ne<0&&(t.util.assert(-(ge+1)<=ne,()=>`Axis must be in the interval [${-(ge+1)}, ${ge}]`),$e=ge+ne+1),Ee.splice($e,0,1),Se({inputs:{x:F},backend:j,attrs:{shape:Ee}})}const sa={kernelName:t.ExpandDims,backendName:"cpu",kernelFunc:wr};var Ia=e(59);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ba=Object(B.a)((ve,Oe)=>ve/Oe),ca=Object(J.a)(t.RealDiv,ba),Ja={kernelName:t.RealDiv,backendName:"cpu",kernelFunc:ca};var Fe=e(36);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dt(ve,Oe,j){const ie=ve.shape,F=ie[0],ne=ie[1],ge=j.data.get(ve.dataId),Ee=ge.complexTensorInfos.real,$e=ge.complexTensorInfos.imag,be=[F,ne],ye=t.util.sizeFromShape(be),Ue=t.util.getTypedArrayFromDType("float32",ye),Re=t.util.getTypedArrayFromDType("float32",ye);for(let at=0;at<F;at++){const ot=Object(Mn.a)({inputs:{x:Ee},backend:j,attrs:{begin:[at,0],size:[1,ne]}}),bt=Object(Mn.a)({inputs:{x:$e},backend:j,attrs:{begin:[at,0],size:[1,ne]}}),St=Object(Ln.a)({inputs:{real:ot,imag:bt},backend:j}),{real:R,imag:v}=Et(St,Oe,j),x=t.backend_util.mergeRealAndImagArrays(R,v);for(let M=0;M<ne;M++){const N=t.backend_util.getComplexWithIndex(x,M);Ue[at*ne+M]=N.real,Re[at*ne+M]=N.imag}j.disposeIntermediateTensorInfo(ot),j.disposeIntermediateTensorInfo(bt),j.disposeIntermediateTensorInfo(St)}const Ve=j.makeTensorInfo(be,"float32",Ue),st=j.makeTensorInfo(be,"float32",Re),tt=Object(Ln.a)({inputs:{real:Ve,imag:st},backend:j});return j.disposeIntermediateTensorInfo(Ve),j.disposeIntermediateTensorInfo(st),tt}function Et(ve,Oe,j){const ie=t.util.sizeFromShape(ve.shape),F=j.data.get(ve.dataId),ne=j.data.get(F.complexTensorInfos.real.dataId).values,ge=j.data.get(F.complexTensorInfos.imag.dataId).values;if(((Ee=ie)&Ee-1)==0){const $e=Vt(ne,ge,ie,Oe,j),be=[ve.shape[0],ve.shape[1]];if(Oe){const ye=j.makeTensorInfo(be,"float32",$e.real),Ue=j.makeTensorInfo(be,"float32",$e.imag),Re=j.makeTensorInfo([],"float32",t.util.createScalarValue(ie,"float32")),Ve=Object(E.a)({inputs:{x:Re},backend:j}),st=Ja.kernelFunc({inputs:{a:ye,b:Re},backend:j}),tt=Ja.kernelFunc({inputs:{a:Ue,b:Ve},backend:j}),at=j.data.get(st.dataId).values,ot=j.data.get(tt.dataId).values;return j.disposeIntermediateTensorInfo(ye),j.disposeIntermediateTensorInfo(Ue),j.disposeIntermediateTensorInfo(Re),j.disposeIntermediateTensorInfo(Ve),j.disposeIntermediateTensorInfo(st),j.disposeIntermediateTensorInfo(tt),{real:at,imag:ot}}return $e}{const $e=function(be,ye,Ue){const Re=new Float32Array(2*ye);for(let Ve=0;Ve<ye;Ve++){let st=0,tt=0;for(let at=0;at<ye;at++){const ot=t.backend_util.exponent(Ve*at,ye,Ue),bt=t.backend_util.getComplexWithIndex(be,at);st+=bt.real*ot.real-bt.imag*ot.imag,tt+=bt.real*ot.imag+bt.imag*ot.real}Ue&&(st/=ye,tt/=ye),t.backend_util.assignToTypedArray(Re,st,tt,Ve)}return Re}(t.backend_util.mergeRealAndImagArrays(ne,ge),ie,Oe);return t.backend_util.splitRealAndImagArrays($e)}var Ee}function Vt(ve,Oe,j,ie,F){if(j===1)return{real:ve,imag:Oe};const ne=t.backend_util.mergeRealAndImagArrays(ve,Oe),ge=j/2,Ee=t.backend_util.complexWithEvenIndex(ne),$e=Ee.real,be=Ee.imag,ye=[$e.length],Ue=F.makeTensorInfo(ye,"float32",$e),Re=F.makeTensorInfo(ye,"float32",be),Ve=Object(Ln.a)({inputs:{real:Ue,imag:Re},backend:F}),st=t.backend_util.complexWithOddIndex(ne),tt=st.real,at=st.imag,ot=[tt.length],bt=F.makeTensorInfo(ot,"float32",tt),St=F.makeTensorInfo(ot,"float32",at),R=Object(Ln.a)({inputs:{real:bt,imag:St},backend:F}),v=Vt($e,be,ge,ie,F),x=v.real,M=v.imag,N=[x.length],H=F.makeTensorInfo(N,"float32",x),ee=F.makeTensorInfo(N,"float32",M),se=Object(Ln.a)({inputs:{real:H,imag:ee},backend:F}),ce=Vt(tt,at,ge,ie,F),xe=ce.real,De=ce.imag,Ke=[xe.length],Ze=F.makeTensorInfo(Ke,"float32",xe),Ge=F.makeTensorInfo(Ke,"float32",De),nt=Object(Ln.a)({inputs:{real:Ze,imag:Ge},backend:F}),Je=t.backend_util.exponents(j,ie),yt=[Je.real.length],gt=F.makeTensorInfo(yt,"float32",Je.real),kt=F.makeTensorInfo(yt,"float32",Je.imag),Tt=Object(Ln.a)({inputs:{real:gt,imag:kt},backend:F}),Rt=Object(Vr.a)({inputs:{a:Tt,b:nt},backend:F}),Yt=Object(Q.a)({inputs:{a:se,b:Rt},backend:F}),Ht=Object(Fe.a)({inputs:{a:se,b:Rt},backend:F}),nn=Object(gr.a)({inputs:{input:Yt},backend:F}),gn=Object(gr.a)({inputs:{input:Ht},backend:F}),ln=Qn({inputs:{input:Yt},backend:F}),Bn=Qn({inputs:{input:Ht},backend:F}),wn=At({inputs:[nn,gn],backend:F,attrs:{axis:0}}),$n=At({inputs:[ln,Bn],backend:F,attrs:{axis:0}}),Wn=F.data.get(wn.dataId).values,Hn=F.data.get($n.dataId).values;return F.disposeIntermediateTensorInfo(Ue),F.disposeIntermediateTensorInfo(Re),F.disposeIntermediateTensorInfo(Ve),F.disposeIntermediateTensorInfo(bt),F.disposeIntermediateTensorInfo(St),F.disposeIntermediateTensorInfo(R),F.disposeIntermediateTensorInfo(H),F.disposeIntermediateTensorInfo(ee),F.disposeIntermediateTensorInfo(se),F.disposeIntermediateTensorInfo(Ze),F.disposeIntermediateTensorInfo(Ge),F.disposeIntermediateTensorInfo(nt),F.disposeIntermediateTensorInfo(gt),F.disposeIntermediateTensorInfo(kt),F.disposeIntermediateTensorInfo(Tt),F.disposeIntermediateTensorInfo(Rt),F.disposeIntermediateTensorInfo(Yt),F.disposeIntermediateTensorInfo(Ht),F.disposeIntermediateTensorInfo(nn),F.disposeIntermediateTensorInfo(ln),F.disposeIntermediateTensorInfo(gn),F.disposeIntermediateTensorInfo(Bn),F.disposeIntermediateTensorInfo(wn),F.disposeIntermediateTensorInfo($n),{real:Wn,imag:Hn}}const an={kernelName:t.FFT,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{input:ie}=Oe,F=t.util.sizeFromShape(ie.shape),ne=ie.shape[ie.shape.length-1],ge=Se({inputs:{x:ie},backend:j,attrs:{shape:[F/ne,ne]}}),Ee=dt(ge,!1,j),$e=Se({inputs:{x:Ee},backend:j,attrs:{shape:ie.shape}});return j.disposeIntermediateTensorInfo(ge),j.disposeIntermediateTensorInfo(Ee),$e}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(ve){const{backend:Oe,attrs:j}=ve,{shape:ie,value:F,dtype:ne}=j,ge=ne||t.util.inferDtype(F),Ee=t.util.getArrayFromDType(ge,t.util.sizeFromShape(ie));return function($e,be,ye){$e.fill(be)}(Ee,F),Oe.makeTensorInfo(ie,ge,Ee)}const _n={kernelName:t.Fill,backendName:"cpu",kernelFunc:Zt},Gn={kernelName:t.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:ve,attrs:Oe,backend:j})=>{const{image:ie}=ve,F=j,ne=t.util.getTypedArrayFromDType(ie.dtype,t.util.sizeFromShape(ie.shape)),[ge,Ee,$e,be]=ie.shape,ye=F.data.get(ie.dataId).values;for(let Ue=0;Ue<ge;Ue++){const Re=Ue*$e*Ee*be;for(let Ve=0;Ve<Ee;Ve++){const st=Ve*($e*be);for(let tt=0;tt<$e;tt++){const at=tt*be;for(let ot=0;ot<be;ot++){const bt=Math.round($e-tt-1),St=Re+st+at+ot;let R=ye[St];bt>=0&&bt<$e&&(R=ye[Re+st+bt*be+ot]),ne[St]=R}}}}return{dataId:F.write(ne,ie.shape,ie.dtype),shape:ie.shape,dtype:ie.dtype}}};var ar=e(60);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr=Object(B.a)((ve,Oe)=>Math.floor(ve/Oe)),Ir=Object(J.a)(t.FloorDiv,Rr,null,"int32"),xa={kernelName:t.FloorDiv,backendName:"cpu",kernelFunc:Ir},Er={kernelName:t.FusedConv2D,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,filter:ne,bias:ge,preluActivationWeights:Ee}=Oe,{strides:$e,pad:be,dataFormat:ye,dilations:Ue,dimRoundingMode:Re,activation:Ve,leakyreluAlpha:st}=ie;let tt=ae({inputs:{x:F,filter:ne},backend:j,attrs:{strides:$e,pad:be,dataFormat:ye,dilations:Ue,dimRoundingMode:Re}});if(ge){const at=tt;if(ye==="NCHW"&&ge.shape.length===1&&ge.shape[0]!==1){const ot=Se({inputs:{x:ge},backend:j,attrs:{shape:[ge.shape[0],1,1]}});tt=Object(Q.a)({inputs:{a:tt,b:ot},backend:j}),j.disposeIntermediateTensorInfo(ot)}else tt=Object(Q.a)({inputs:{a:tt,b:ge},backend:j});j.disposeIntermediateTensorInfo(at)}if(Ve){const at=tt;if(ye==="NCHW"&&Ve==="prelu"&&Ee.shape.length===1&&Ee.shape[0]!==1){const ot=Se({inputs:{x:Ee},backend:j,attrs:{shape:[Ee.shape[0],1,1]}});tt=he(j,tt,Ve,ot,st),j.disposeIntermediateTensorInfo(ot)}else tt=he(j,tt,Ve,Ee,st);j.disposeIntermediateTensorInfo(at)}return tt}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yr={kernelName:t.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,filter:ne,bias:ge,preluActivationWeights:Ee}=Oe,{strides:$e,pad:be,dataFormat:ye,dilations:Ue,dimRoundingMode:Re,activation:Ve,leakyreluAlpha:st}=ie;let tt=ma({inputs:{x:F,filter:ne},backend:j,attrs:{strides:$e,pad:be,dataFormat:ye,dilations:Ue,dimRoundingMode:Re}});if(ge){const at=tt;tt=Object(Q.a)({inputs:{a:tt,b:ge},backend:j}),j.disposeIntermediateTensorInfo(at)}if(Ve){const at=tt;tt=he(j,tt,Ve,Ee,st),j.disposeIntermediateTensorInfo(at)}return tt}};var ja=e(61);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oa={kernelName:t.GatherNd,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{params:ie,indices:F}=Oe,ne=t.util.sizeFromShape(ie.shape),ge=F.shape,Ee=ge[ge.length-1],[$e,be,ye,Ue]=t.backend_util.prepareAndValidate(ie,F);if(be===0)return j.makeTensorInfo($e,ie.dtype,[]);const Re=j.data.get(F.dataId).values,Ve=j.bufferSync(ie),st=Object(ja.a)(Re,Ve,ie.dtype,be,Ee,ye,Ue,ie.shape,ne);return j.makeTensorInfo($e,ie.dtype,st.values)}};var $a=e(62);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xs={kernelName:t.GatherV2,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,indices:ne}=Oe,{axis:ge,batchDims:Ee}=ie;Object(m.a)([F,ne],"gatherV2");const $e=t.util.parseAxisParam(ge,F.shape)[0],be=j.data.get(ne.dataId).values,ye=F.shape[$e];for(let R=0;R<be.length;++R){const v=be[R];t.util.assert(v<=ye-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${ye-1}]`)}let Ue=Ee;Ee==null&&(Ue=0);const Re=t.util.sizeFromShape(ne.shape),Ve=t.backend_util.segment_util.collectGatherOpShapeInfo(F,ne,$e,Ue),st=Se({inputs:{x:F},backend:j,attrs:{shape:[Ve.batchSize,Ve.outerSize,Ve.dimSize,Ve.sliceSize]}}),tt=Se({inputs:{x:ne},backend:j,attrs:{shape:[Ve.batchSize,Re/Ve.batchSize]}}),at=[Ve.batchSize,Ve.outerSize,Re/Ve.batchSize,Ve.sliceSize],ot=j.bufferSync(tt),bt=j.bufferSync(st),St=Object($a.a)(bt,ot,at);return j.disposeIntermediateTensorInfo(st),j.disposeIntermediateTensorInfo(tt),j.makeTensorInfo(Ve.outputShape,St.dtype,St.values)}};var $s=e(63),bs=e(64);const di={kernelName:t.IFFT,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{input:ie}=Oe,F=t.util.sizeFromShape(ie.shape),ne=ie.shape[ie.shape.length-1],ge=Se({inputs:{x:ie},backend:j,attrs:{shape:[F/ne,ne]}}),Ee=dt(ge,!0,j),$e=Se({inputs:{x:Ee},backend:j,attrs:{shape:ie.shape}});return j.disposeIntermediateTensorInfo(ge),j.disposeIntermediateTensorInfo(Ee),$e}},Ha=Object(A.a)(t.IsFinite,ve=>Number.isFinite(ve)?1:0,"bool"),qa={kernelName:t.IsFinite,backendName:"cpu",kernelFunc:Ha},Ea=Object(A.a)(t.IsInf,ve=>Math.abs(ve)===1/0?1:0,"bool"),ta={kernelName:t.IsInf,backendName:"cpu",kernelFunc:Ea},Ys=Object(A.a)(t.IsNan,ve=>Number.isNaN(ve)?1:0,"bool"),ia={kernelName:t.IsNan,backendName:"cpu",kernelFunc:Ys};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Aa=e(65),es=e(66),gs=e(67);const hi={kernelName:t.LinSpace,backendName:"cpu",kernelFunc:function(ve){const{backend:Oe,attrs:j}=ve,{start:ie,stop:F,num:ne}=j,ge=Object(gs.a)(ie,F,ne);return Oe.makeTensorInfo([ge.length],"float32",ge)}};var xs=e(68);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const us=Object(A.a)(t.Log1p,ve=>Math.log1p(ve)),pi={kernelName:t.Log1p,backendName:"cpu",kernelFunc:us},pr=Object(B.a)((ve,Oe)=>ve&&Oe),Jr=Object(J.a)(t.LogicalAnd,pr,null,"bool"),za={kernelName:t.LogicalAnd,backendName:"cpu",kernelFunc:Jr},Es=Object(A.a)(t.LogicalNot,ve=>ve?0:1,"bool"),Qs={kernelName:t.LogicalNot,backendName:"cpu",kernelFunc:Es},ts=Object(B.a)((ve,Oe)=>ve||Oe),As=Object(J.a)(t.LogicalOr,ts,null,"bool"),Ns={kernelName:t.LogicalOr,backendName:"cpu",kernelFunc:As},vs={kernelName:t.LRN,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{depthRadius:ne,bias:ge,alpha:Ee,beta:$e}=ie;Object(m.a)(F,"LRN");const be=F.shape[3],ye=be-1,Ue=j.data.get(F.dataId).values,Re=t.util.sizeFromShape(F.shape),Ve=new Float32Array(Re);function st(tt){const at=tt%be;let ot=tt-at+Math.max(0,at-ne);const bt=tt-at+Math.min(at+ne,ye);let St=0;for(;ot<=bt;ot++){const R=Ue[ot];St+=R*R}return St}for(let tt=0;tt<Re;tt++){const at=st(tt),ot=Ue[tt]*Math.pow(ge+Ee*at,-$e);Ve[tt]=ot}return j.makeTensorInfo(F.shape,F.dtype,Ve)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yn={kernelName:t.LRNGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,y:ne,dy:ge}=Oe,{depthRadius:Ee,bias:$e,alpha:be,beta:ye}=ie;Object(m.a)(ge,"LRNGrad");const Ue=t.util.sizeFromShape(ge.shape),Re=ge.shape[3],Ve=j.data.get(ge.dataId).values,st=j.data.get(F.dataId).values,tt=j.data.get(ne.dataId).values,at=new Float32Array(Ue),ot=Ue;for(let bt=0;bt<ot;bt++){const St=bt%Re,R=bt-St+Math.max(0,St-Ee),v=bt-St+Math.min(Re,St+Ee+1);let x=0;for(let M=R;M<v;M++)x+=Math.pow(st[M],2);x=be*x+$e;for(let M=R;M<v;M++){let N=-2*be*ye*st[M]*tt[bt]/x;bt===M&&(N+=Math.pow(x,-ye)),N*=Ve[bt],at[M]+=N}}return j.makeTensorInfo(ge.shape,F.dtype,at)}};var In=e(69),Fr=e(46);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{reductionIndices:ne,keepDims:ge}=ie,Ee=j;let $e=F.shape;const be=$e.length,ye=t.util.parseAxisParam(ne,$e);let Ue=ye;const Re=t.backend_util.getAxesPermutation(Ue,be);let Ve=Ee.data.get(F.dataId).values;if(Re!=null){const R=new Array(be);for(let v=0;v<R.length;v++)R[v]=$e[Re[v]];Ve=Object(Fr.a)(Ve,$e,F.dtype,Re,R),Ue=t.backend_util.getInnerMostAxes(Ue.length,be),$e=R}Object(m.a)(F,"max"),t.backend_util.assertAxesAreInnerMostDims("max",Ue,be);const[st,tt]=t.backend_util.computeOutAndReduceShapes($e,Ue),at=t.util.sizeFromShape(tt),ot=Object(In.a)(Ve,at,st,F.dtype),bt=Ee.write(ot,st,F.dtype);let St=st;return ge&&(St=t.backend_util.expandShapeToKeepDim(st,ye)),{dataId:bt,shape:St,dtype:F.dtype}}const Sa={kernelName:t.Max,backendName:"cpu",kernelFunc:Sn};var na=e(70);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pa={kernelName:t.MaxPool,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe;Object(m.a)(F,"maxPool");const{filterSize:ne,strides:ge,pad:Ee,dimRoundingMode:$e}=ie;t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(ge,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${ge} and dilations '1'`);const be=t.backend_util.computePool2DInfo(F.shape,ne,ge,1,Ee,$e);let ye;if(be.filterWidth===1&&be.filterHeight===1&&t.util.arraysEqual(be.inShape,be.outShape))ye=Object(E.a)({inputs:{x:F},backend:j});else{const Ue=j.data.get(F.dataId).values,Re=t.util.computeStrides(F.shape),Ve=mt(Ue,F.shape,F.dtype,Re,be,"max");ye=j.makeTensorInfo(be.outShape,F.dtype,Ve.values)}return ye}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zs={kernelName:t.MaxPool3D,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{filterSize:ne,strides:ge,pad:Ee,dimRoundingMode:$e,dataFormat:be}=ie;Object(m.a)(F,"maxPool3d");const ye=t.backend_util.computePool3DInfo(F.shape,ne,ge,1,Ee,$e,be),Ue=Nt(j.data.get(F.dataId).values,F.shape,F.dtype,t.util.computeStrides(F.shape),ye,"max");return j.makeTensorInfo(Ue.shape,"float32",Ue.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ys={kernelName:t.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,input:ne}=Oe,{filterSize:ge,strides:Ee,pad:$e,dimRoundingMode:be}=ie;Object(m.a)([F,ne],"maxPool3DGrad");const ye=t.backend_util.computePool3DInfo(ne.shape,ge,Ee,1,$e,be),Ue=function(ee,se){const ce=Object(t.buffer)(se.outShape,"int32"),xe=se.strideDepth,De=se.strideHeight,Ke=se.strideWidth,Ze=se.dilationDepth,Ge=se.dilationHeight,nt=se.dilationWidth,Je=se.effectiveFilterDepth,yt=se.effectiveFilterHeight,gt=se.effectiveFilterWidth,kt=se.padInfo.front,Tt=se.padInfo.top,Rt=se.padInfo.left;for(let Yt=0;Yt<se.batchSize;++Yt)for(let Ht=0;Ht<se.inChannels;++Ht)for(let nn=0;nn<se.outDepth;++nn){const gn=nn*xe-kt;let ln=gn;for(;ln<0;)ln+=Ze;const Bn=Math.min(se.inDepth,Je+gn);for(let wn=0;wn<se.outHeight;++wn){const $n=wn*De-Tt;let Wn=$n;for(;Wn<0;)Wn+=Ge;const Hn=Math.min(se.inHeight,yt+$n);for(let Dn=0;Dn<se.outWidth;++Dn){const er=Dn*Ke-Rt;let yr=er;for(;yr<0;)yr+=nt;const la=Math.min(se.inWidth,gt+er);let Or=Number.NEGATIVE_INFINITY,Gr=-1;for(let jr=ln;jr<Bn;jr+=Ze){const Na=jr-gn;for(let ga=Wn;ga<Hn;ga+=Ge){const Ra=ga-$n;for(let Qa=yr;Qa<la;Qa+=nt){const Ss=Qa-er,Cs=ee.get(Yt,jr,ga,Qa,Ht);Cs>=Or&&(Or=Cs,Gr=Na*yt*gt+Ra*yt+Ss)}}}ce.set(Gr,Yt,nn,wn,Dn,Ht)}}}return ce}(j.bufferSync(ne),ye),Re=ye.strideDepth,Ve=ye.strideHeight,st=ye.strideWidth,tt=ye.dilationDepth,at=ye.dilationHeight,ot=ye.dilationWidth,bt=ye.effectiveFilterDepth,St=ye.effectiveFilterHeight,R=ye.effectiveFilterWidth,v=bt-1-ye.padInfo.front,x=R-1-ye.padInfo.left,M=St-1-ye.padInfo.top,N=Object(t.buffer)(ne.shape,"float32"),H=j.bufferSync(F);for(let ee=0;ee<ye.batchSize;++ee)for(let se=0;se<ye.inChannels;++se)for(let ce=0;ce<ye.inDepth;++ce)for(let xe=0;xe<ye.inHeight;++xe)for(let De=0;De<ye.inWidth;++De){const Ke=ce-v,Ze=xe-M,Ge=De-x;let nt=0;for(let Je=0;Je<bt;Je+=tt){const yt=(Ke+Je)/Re;if(!(yt<0||yt>=ye.outDepth||Math.floor(yt)!==yt))for(let gt=0;gt<St;gt+=at){const kt=(Ze+gt)/Ve;if(!(kt<0||kt>=ye.outHeight||Math.floor(kt)!==kt))for(let Tt=0;Tt<R;Tt+=ot){const Rt=(Ge+Tt)/st;if(Rt<0||Rt>=ye.outWidth||Math.floor(Rt)!==Rt)continue;const Yt=bt*St*R-1-Ue.get(ee,yt,kt,Rt,se)===Je*St*R+gt*R+Tt?1:0;Yt!==0&&(nt+=H.get(ee,yt,kt,Rt,se)*Yt)}}}N.set(nt,ee,ce,xe,De,se)}return j.makeTensorInfo(N.shape,N.dtype,N.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cs={kernelName:t.MaxPoolGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{dy:F,input:ne,output:ge}=Oe,Ee=ne;Object(m.a)([ne,ge],"maxPoolGrad");const{filterSize:$e,strides:be,pad:ye,dimRoundingMode:Ue}=ie,Re=t.backend_util.computePool2DInfo(Ee.shape,$e,be,1,ye,Ue),Ve=j.data.get(Ee.dataId).values,st=Object(t.buffer)(Re.outShape,Ee.dtype,Mt(Ve,Ee.shape,Ee.dtype,Re).values),tt=Re.strideHeight,at=Re.strideWidth,ot=Re.dilationHeight,bt=Re.dilationWidth,St=Re.effectiveFilterHeight,R=Re.effectiveFilterWidth,v=R-1-Re.padInfo.left,x=St-1-Re.padInfo.top,M=Object(t.buffer)(Ee.shape,"float32"),N=j.data.get(F.dataId).values,H=Object(t.buffer)(F.shape,"float32",N);for(let ee=0;ee<Re.batchSize;++ee)for(let se=0;se<Re.inChannels;++se)for(let ce=0;ce<Re.inHeight;++ce)for(let xe=0;xe<Re.inWidth;++xe){const De=ce-x,Ke=xe-v;let Ze=0;for(let Ge=0;Ge<St;Ge+=ot){const nt=(De+Ge)/tt;if(!(nt<0||nt>=Re.outHeight||Math.floor(nt)!==nt))for(let Je=0;Je<R;Je+=bt){const yt=(Ke+Je)/at;if(yt<0||yt>=Re.outWidth||Math.floor(yt)!==yt)continue;const gt=St*R-1-st.get(ee,nt,yt,se)===Ge*R+Je?1:0;gt!==0&&(Ze+=H.get(ee,nt,yt,se)*gt)}}M.set(Ze,ee,ce,xe,se)}return j.makeTensorInfo(M.shape,M.dtype,M.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xi={kernelName:t.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:ve,attrs:Oe,backend:j})=>{const{x:ie}=ve,{filterSize:F,strides:ne,pad:ge,includeBatchInIndex:Ee}=Oe,$e=j;Object(m.a)(ie,"MaxPoolWithArgmax");const be=$e.data.get(ie.dataId).values,ye=t.backend_util.computePool2DInfo(ie.shape,F,ne,[1,1],ge),[Ue,Re]=function(tt,at,ot,bt,St){const R=mt(tt,0,ot,t.util.computeStrides(at),St,"max"),v=Mt(tt,at,ot,St,!0,bt);return[R.values,v.values]}(be,ie.shape,ie.dtype,Ee,ye),Ve=$e.write(Ue,ye.outShape,ie.dtype),st=$e.write(Re,ye.outShape,ie.dtype);return[{dataId:Ve,shape:ye.outShape,dtype:ie.dtype},{dataId:st,shape:ye.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ra={kernelName:t.Mean,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,keepDims:ge}=ie,Ee=t.util.parseAxisParam(ne,F.shape),$e=t.backend_util.computeOutAndReduceShapes(F.shape,Ee)[1],be=t.util.sizeFromShape($e),ye=[],Ue=j.makeTensorInfo([],"float32",new Float32Array([be]));ye.push(Ue);const Re=Object(Zn.a)({inputs:{x:F},backend:j,attrs:{dtype:"float32"}});ye.push(Re);const Ve=ca({inputs:{a:Re,b:Ue},backend:j});ye.push(Ve);const st=Ta({inputs:{x:Ve},backend:j,attrs:{axis:ne,keepDims:ge}});return ye.forEach(tt=>j.disposeIntermediateTensorInfo(tt)),st}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ua={kernelName:t.Min,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{axis:ne,keepDims:ge}=ie;Object(m.a)(F,"min");const Ee=t.util.parseAxisParam(ne,F.shape);let $e=Ee;const be=t.backend_util.getAxesPermutation($e,F.shape.length);let ye=F;be!=null&&(ye=Object(Gt.a)({inputs:{x:F},backend:j,attrs:{perm:be}}),$e=t.backend_util.getInnerMostAxes($e.length,F.shape.length)),t.backend_util.assertAxesAreInnerMostDims("min",$e,ye.shape.length);const[Ue,Re]=t.backend_util.computeOutAndReduceShapes(ye.shape,$e),Ve=t.util.sizeFromShape(Re),st=t.util.makeZerosTypedArray(t.util.sizeFromShape(Ue),ye.dtype),tt=j.data.get(ye.dataId).values;for(let ot=0;ot<st.length;++ot){const bt=ot*Ve;let St=tt[bt];for(let R=0;R<Ve;++R){const v=tt[bt+R];(Number.isNaN(v)||v<St)&&(St=v)}st[ot]=St}be!=null&&j.disposeIntermediateTensorInfo(ye);const at=j.makeTensorInfo(Ue,ye.dtype,st);if(ge){const ot=Se({inputs:{x:at},backend:j,attrs:{shape:t.backend_util.expandShapeToKeepDim(Ue,Ee)}});return j.disposeIntermediateTensorInfo(at),ot}return at}};var ls=e(71);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tr={kernelName:t.MirrorPad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{paddings:ne,mode:ge}=ie;Object(m.a)(F,"mirrorPad");const Ee=ne.map((bt,St)=>bt[0]+F.shape[St]+bt[1]),$e=ne.map(bt=>bt[0]),be=ne.map((bt,St)=>bt[0]+F.shape[St]),ye=ge==="reflect"?0:1,Ue=j.data.get(F.dataId).values,Re=F.shape.length,Ve=t.util.computeStrides(F.shape),st=t.util.sizeFromShape(Ee),tt=Ee.length,at=t.util.computeStrides(Ee),ot=t.util.getTypedArrayFromDType(F.dtype,st);for(let bt=0;bt<st;bt++){let St=t.util.indexToLoc(bt,tt,at);for(let v=0;v<tt;v++)St[v]<$e[v]?St[v]=2*$e[v]-St[v]-ye:St[v]>=be[v]&&(St[v]=2*(be[v]-1)-St[v]+ye);St=St.map((v,x)=>v-$e[x]);const R=t.util.locToIndex(St,Re,Ve);ot[bt]=Ue[R]}return{dataId:j.write(ot,Ee,F.dtype),shape:Ee,dtype:F.dtype}}},Ka=Object(B.a)((ve,Oe)=>{const j=ve%Oe;return ve<0&&Oe<0||ve>=0&&Oe>=0?j:(j+Oe)%Oe}),Rs=Object(J.a)(t.Mod,Ka),Js={kernelName:t.Mod,backendName:"cpu",kernelFunc:Rs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ws=e(49);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{logits:F}=Oe,{dim:ne}=ie,ge=F.shape.length;let Ee=ne;if(Ee===-1&&(Ee=ge-1),Ee!==ge-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${ge} and dim was ${Ee}`);const $e=t.util.parseAxisParam([Ee],F.shape),be=Sn({inputs:{x:F},backend:j,attrs:{reductionIndices:$e,keepDims:!1}}),ye=t.backend_util.expandShapeToKeepDim(be.shape,$e),Ue=Se({inputs:{x:be},backend:j,attrs:{shape:ye}}),Re=Object(Fe.a)({inputs:{a:F,b:Ue},backend:j}),Ve=Object(La.a)({inputs:{x:Re},backend:j}),st=Ta({inputs:{x:Ve},backend:j,attrs:{axis:$e,keepDims:!1}}),tt=Se({inputs:{x:st},backend:j,attrs:{shape:ye}}),at=ca({inputs:{a:Ve,b:tt},backend:j});return j.disposeIntermediateTensorInfo(be),j.disposeIntermediateTensorInfo(Ue),j.disposeIntermediateTensorInfo(Re),j.disposeIntermediateTensorInfo(Ve),j.disposeIntermediateTensorInfo(st),j.disposeIntermediateTensorInfo(tt),at}const ur={kernelName:t.Softmax,backendName:"cpu",kernelFunc:ks};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fs={kernelName:t.Multinomial,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{logits:F}=Oe,{numSamples:ne,seed:ge,normalized:Ee}=ie;Object(m.a)(F,"multinomial");const $e=Ee?F:ks({inputs:{logits:F},backend:j,attrs:{dim:-1}}),be=$e.shape[0],ye=$e.shape[1],Ue=j.data.get($e.dataId).values,Re=[be,ne],Ve=t.util.makeZerosTypedArray(t.util.sizeFromShape(Re),"int32");for(let st=0;st<be;++st){const tt=st*ye,at=new Float32Array(ye-1);at[0]=Ue[tt];for(let St=1;St<at.length;++St)at[St]=at[St-1]+Ue[tt+St];const ot=ws.alea(ge.toString()),bt=st*ne;for(let St=0;St<ne;++St){const R=ot();Ve[bt+St]=at.length;for(let v=0;v<at.length;v++)if(R<at[v]){Ve[bt+St]=v;break}}}return Ee||j.disposeIntermediateTensorInfo($e),j.makeTensorInfo(Re,"int32",Ve)}};var va=e(72);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ei=t.kernel_impls.nonMaxSuppressionV3Impl,Ms={kernelName:t.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{boxes:F,scores:ne}=Oe,{maxOutputSize:ge,iouThreshold:Ee,scoreThreshold:$e}=ie;Object(m.a)(F,"NonMaxSuppression");const be=j.data.get(F.dataId).values,ye=j.data.get(ne.dataId).values,{selectedIndices:Ue}=ei(be,ye,ge,Ee,$e);return j.makeTensorInfo([Ue.length],"int32",new Int32Array(Ue))}},Ds=t.kernel_impls.nonMaxSuppressionV4Impl;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti={kernelName:t.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{boxes:F,scores:ne}=Oe,{maxOutputSize:ge,iouThreshold:Ee,scoreThreshold:$e,padToMaxOutputSize:be}=ie;Object(m.a)(F,"NonMaxSuppressionPadded");const ye=j.data.get(F.dataId).values,Ue=j.data.get(ne.dataId).values,{selectedIndices:Re,validOutputs:Ve}=Ds(ye,Ue,ge,Ee,$e,be);return[j.makeTensorInfo([Re.length],"int32",new Int32Array(Re)),j.makeTensorInfo([],"int32",new Int32Array([Ve]))]}},Ps=t.kernel_impls.nonMaxSuppressionV5Impl;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ns={kernelName:t.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{boxes:F,scores:ne}=Oe,{maxOutputSize:ge,iouThreshold:Ee,scoreThreshold:$e,softNmsSigma:be}=ie;Object(m.a)(F,"NonMaxSuppressionWithScore");const ye=j.data.get(F.dataId).values,Ue=j.data.get(ne.dataId).values,Re=ge,Ve=Ee,st=$e,tt=be,{selectedIndices:at,selectedScores:ot}=Ps(ye,Ue,Re,Ve,st,tt);return[j.makeTensorInfo([at.length],"int32",new Int32Array(at)),j.makeTensorInfo([ot.length],"float32",new Float32Array(ot))]}};var Bs=e(73);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ai={kernelName:t.OneHot,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{indices:F}=Oe,{dtype:ne,depth:ge,onValue:Ee,offValue:$e}=ie;Object(m.a)(F,"oneHot");const be=t.util.sizeFromShape(F.shape),ye=new Float32Array(be*ge);ye.fill($e);const Ue=j.data.get(F.dataId).values;for(let Re=0;Re<be;++Re)Ue[Re]>=0&&Ue[Re]<ge&&(ye[Re*ge+Ue[Re]]=Ee);return j.makeTensorInfo([...F.shape,ge],ne,ye)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ls(ve){const{inputs:Oe,backend:j}=ve,{x:ie}=Oe;if(ie.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(ie.dtype==="complex64"){const F=Object(gr.a)({inputs:{input:ie},backend:j}),ne=Ls({inputs:{x:F},backend:j}),ge=Qn({inputs:{input:ie},backend:j}),Ee=Ls({inputs:{x:ge},backend:j}),$e=Object(Ln.a)({inputs:{real:ne,imag:Ee},backend:j});return j.disposeIntermediateTensorInfo(F),j.disposeIntermediateTensorInfo(ne),j.disposeIntermediateTensorInfo(ge),j.disposeIntermediateTensorInfo(Ee),$e}return Zt({backend:j,attrs:{shape:ie.shape,value:0,dtype:ie.dtype}})}const rs={kernelName:t.ZerosLike,backendName:"cpu",kernelFunc:Ls};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ni={kernelName:t.OnesLike,backendName:"cpu",kernelFunc:function ve(Oe){const{inputs:j,backend:ie}=Oe,{x:F}=j;if(F.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(F.dtype==="complex64"){const ne=Object(gr.a)({inputs:{input:F},backend:ie}),ge=ve({inputs:{x:ne},backend:ie}),Ee=Qn({inputs:{input:F},backend:ie}),$e=Ls({inputs:{x:Ee},backend:ie}),be=Object(Ln.a)({inputs:{real:ge,imag:$e},backend:ie});return ie.disposeIntermediateTensorInfo(ne),ie.disposeIntermediateTensorInfo(ge),ie.disposeIntermediateTensorInfo(Ee),ie.disposeIntermediateTensorInfo($e),be}return Zt({backend:ie,attrs:{shape:F.shape,value:1,dtype:F.dtype}})}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function js(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{axis:F}=ie;if(Oe.length===1)return wr({inputs:{input:Oe[0]},backend:j,attrs:{dim:F}});const ne=Oe[0].shape,ge=Oe[0].dtype;Oe.forEach(be=>{t.util.assertShapesMatch(ne,be.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(ge===be.dtype,()=>"All tensors passed to stack must have matching dtypes")});const Ee=[],$e=At({inputs:Oe.map(be=>{const ye=wr({inputs:{input:be},backend:j,attrs:{dim:F}});return Ee.push(ye),ye}),backend:j,attrs:{axis:F}});return Ee.forEach(be=>j.disposeIntermediateTensorInfo(be)),$e}const Ni={kernelName:t.Pack,backendName:"cpu",kernelFunc:js};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _s={kernelName:t.PadV2,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{paddings:ne,constantValue:ge}=ie;Object(m.a)(F,"pad");const Ee=ne.map((ot,bt)=>ot[0]+F.shape[bt]+ot[1]),$e=ne.map(ot=>ot[0]),be=j.data.get(F.dataId).values,ye=t.util.sizeFromShape(F.shape),Ue=F.shape.length,Re=t.util.computeStrides(F.shape),Ve=t.util.sizeFromShape(Ee),st=Ee.length,tt=t.util.computeStrides(Ee),at=t.util.getTypedArrayFromDType(F.dtype,Ve);ge!==0&&at.fill(ge);for(let ot=0;ot<ye;ot++){const bt=t.util.indexToLoc(ot,Ue,Re).map((St,R)=>St+$e[R]);at[t.util.locToIndex(bt,st,tt)]=be[ot]}return{dataId:j.write(at,Ee,F.dtype),shape:Ee,dtype:F.dtype}}},zs=Object(B.a)((ve,Oe)=>Math.pow(ve,Oe)),ri=Object(J.a)(t.Pow,zs),vi={kernelName:t.Pow,backendName:"cpu",kernelFunc:ri};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ri=e(74),Fi=e(75);const yi={kernelName:t.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{shape:F,values:ne,defaultValue:ge,rowPartitionTensors:Ee}=Oe,{rowPartitionTypes:$e}=ie,be=j.data.get(F.dataId).values,ye=j.data.get(ne.dataId).values,Ue=j.data.get(ge.dataId).values,Re=Ee.map(at=>j.data.get(at.dataId).values),Ve=Ee.map(at=>at.shape),[st,tt]=Object(Fi.a)(be,F.shape,ye,ne.shape,ne.dtype,Ue,ge.shape,Re,Ve,$e);return j.makeTensorInfo(st,ne.dtype,tt)}};var Ne=e(76);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ue={kernelName:t.Range,backendName:"cpu",kernelFunc:function(ve){const{backend:Oe,attrs:j}=ve,{start:ie,stop:F,dtype:ne,step:ge}=j,Ee=Object(Ne.a)(ie,F,ge,ne);return Oe.makeTensorInfo([Ee.length],ne,Ee)}},Be=Object(A.a)(t.Reciprocal,ve=>1/ve),Xe={kernelName:t.Reciprocal,backendName:"cpu",kernelFunc:Be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Te={kernelName:t.ResizeBilinear,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{images:F}=Oe,{alignCorners:ne,halfPixelCenters:ge,size:Ee}=ie;Object(m.a)(F,"resizeBilinear");const $e=t.util.computeStrides(F.shape),[be,ye]=Ee,[Ue,Re,Ve,st]=F.shape,tt=j.data.get(F.dataId).values,at=new Float32Array(t.util.sizeFromShape([Ue,be,ye,st])),ot=[ne&&be>1?Re-1:Re,ne&&ye>1?Ve-1:Ve],bt=[ne&&be>1?be-1:be,ne&&ye>1?ye-1:ye];let St=0;const R=ot[0]/bt[0],v=ot[1]/bt[1];for(let x=0;x<Ue;x++)for(let M=0;M<be;M++){let N;N=ge?R*(M+.5)-.5:R*M;const H=Math.max(0,Math.floor(N)),ee=N-H,se=Math.min(Re-1,Math.ceil(N)),ce=x*$e[0]+H*$e[1],xe=x*$e[0]+se*$e[1];for(let De=0;De<ye;De++){let Ke;Ke=ge?v*(De+.5)-.5:v*De;const Ze=Math.max(0,Math.floor(Ke)),Ge=Ke-Ze,nt=Math.min(Ve-1,Math.ceil(Ke)),Je=ce+Ze*$e[2],yt=xe+Ze*$e[2],gt=ce+nt*$e[2],kt=xe+nt*$e[2];for(let Tt=0;Tt<st;Tt++){const Rt=tt[Je+Tt],Yt=tt[yt+Tt],Ht=Rt+(tt[gt+Tt]-Rt)*Ge,nn=Ht+(Yt+(tt[kt+Tt]-Yt)*Ge-Ht)*ee;at[St++]=nn}}}return j.makeTensorInfo([Ue,be,ye,st],"float32",at)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ye={kernelName:t.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{images:F,dy:ne}=Oe,{alignCorners:ge}=ie;Object(m.a)([ne,F],"resizeBilinearGrad");const Ee=t.util.computeStrides(F.shape),[$e,be,ye,Ue]=F.shape,[,Re,Ve]=ne.shape,st=new Float32Array($e*be*ye*Ue),tt=[ge&&Re>1?be-1:be,ge&&Ve>1?ye-1:ye],at=[ge&&Re>1?Re-1:Re,ge&&Ve>1?Ve-1:Ve],ot=tt[0]/at[0],bt=tt[1]/at[1],St=j.data.get(ne.dataId).values;let R=0;for(let v=0;v<$e;v++){const x=v*Ee[0];for(let M=0;M<Re;M++){const N=M*ot,H=Math.floor(N),ee=Math.min(Math.ceil(N),be-1),se=x+H*Ee[1],ce=x+ee*Ee[1],xe=N-H,De=1-xe;for(let Ke=0;Ke<Ve;Ke++){const Ze=Ke*bt,Ge=Math.floor(Ze),nt=Math.min(Math.ceil(Ze),ye-1),Je=Ze-Ge,yt=1-Je,gt=se+Ge*Ee[2],kt=se+nt*Ee[2],Tt=ce+Ge*Ee[2],Rt=ce+nt*Ee[2],Yt=De*yt,Ht=De*Je,nn=xe*yt,gn=xe*Je;for(let ln=0;ln<Ue;ln++){const Bn=St[R++];st[gt+ln]+=Bn*Yt,st[kt+ln]+=Bn*Ht,st[Tt+ln]+=Bn*nn,st[Rt+ln]+=Bn*gn}}}}return j.makeTensorInfo([$e,ye,be,Ue],"float32",st)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const it={kernelName:t.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{images:F}=Oe,{alignCorners:ne,halfPixelCenters:ge,size:Ee}=ie;Object(m.a)(F,"resizeNearestNeighbor");const $e=t.util.computeStrides(F.shape),[be,ye]=Ee,[Ue,Re,Ve,st]=F.shape,tt=j.data.get(F.dataId).values,at=new Float32Array(Ue*be*ye*st),ot=[ne&&be>1?Re-1:Re,ne&&ye>1?Ve-1:Ve],bt=[ne&&be>1?be-1:be,ne&&ye>1?ye-1:ye],St=ot[0]/bt[0],R=ot[1]/bt[1];let v=0;for(let x=0;x<Ue;x++){const M=x*$e[0];for(let N=0;N<be;N++){const H=ge?St*(N+.5):St*N;let ee=Math.min(Re-1,ne?Math.round(H):Math.floor(H));ge&&(ee=Math.max(0,ee));const se=M+ee*$e[1];for(let ce=0;ce<ye;ce++){const xe=ge?R*(ce+.5):R*ce;let De=Math.min(Ve-1,ne?Math.round(xe):Math.floor(xe));ge&&(De=Math.max(0,De));const Ke=se+De*$e[2];for(let Ze=0;Ze<st;Ze++){const Ge=tt[Ke+Ze];at[v++]=Ge}}}}return j.makeTensorInfo([Ue,be,ye,st],F.dtype,at)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt={kernelName:t.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{images:F,dy:ne}=Oe,{alignCorners:ge}=ie;Object(m.a)([ne,F],"resizeNearestNeighborGrad");const Ee=t.util.computeStrides(F.shape),$e=t.util.computeStrides(ne.shape),[be,ye,Ue,Re]=F.shape,[,Ve,st]=ne.shape,tt=new Float32Array(be*ye*Ue*Re),at=j.data.get(ne.dataId).values,ot=[ge&&Ve>1?ye-1:ye,ge&&st>1?Ue-1:Ue],bt=[ge&&Ve>1?Ve-1:Ve,ge&&st>1?st-1:st],St=ot[0]/bt[0],R=ot[1]/bt[1],v=1/St,x=1/R,M=2*Math.ceil(v)+2,N=2*Math.ceil(x)+2;for(let H=0;H<be;H++){const ee=H*Ee[0];for(let se=0;se<ye;se++){const ce=ee+se*Ee[1],xe=Math.floor(se*v),De=Math.floor(xe-M/2);for(let Ke=0;Ke<Ue;Ke++){const Ze=ce+Ke*Ee[2],Ge=Math.floor(Ke*x),nt=Math.floor(Ge-N/2);for(let Je=0;Je<Re;Je++){let yt=0;for(let gt=0;gt<M;gt++){const kt=gt+De;if(kt<0||kt>=Ve)continue;const Tt=ee+kt*$e[1],Rt=kt*St;if(se===Math.min(ye-1,ge?Math.round(Rt):Math.floor(Rt)))for(let Yt=0;Yt<N;Yt++){const Ht=Yt+nt;if(Ht<0||Ht>=st)continue;const nn=Tt+Ht*$e[2],gn=Ht*R;Ke===Math.min(Ue-1,ge?Math.round(gn):Math.floor(gn))&&(yt+=at[nn+Je])}}tt[Ze+Je]=yt}}}}return j.makeTensorInfo(F.shape,F.dtype,tt)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ut={kernelName:t.Reverse,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{dims:ne}=ie;Object(m.a)(F,"reverse");const ge=F.shape.length,Ee=t.util.parseAxisParam(ne,F.shape);if(ge===0)return Object(E.a)({inputs:{x:F},backend:j});const $e=new t.TensorBuffer(F.shape,F.dtype),be=j.bufferSync(F);for(let ye=0;ye<$e.size;ye++){const Ue=$e.indexToLoc(ye),Re=Ue.slice();Ee.forEach(Ve=>Re[Ve]=F.shape[Ve]-1-Re[Ve]),$e.set(be.get(...Re),...Ue)}return j.makeTensorInfo($e.shape,$e.dtype,$e.values)}},ft={kernelName:t.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:ve,attrs:Oe,backend:j})=>{const{image:ie}=ve,{radians:F,fillValue:ne,center:ge}=Oe,Ee=j,$e=t.util.getTypedArrayFromDType(ie.dtype,t.util.sizeFromShape(ie.shape)),[be,ye,Ue,Re]=ie.shape,[Ve,st]=t.backend_util.getImageCenter(ge,ye,Ue),tt=Math.sin(F),at=Math.cos(F),ot=Ee.data.get(ie.dataId).values;for(let bt=0;bt<be;bt++){const St=bt*Ue*ye*Re;for(let R=0;R<ye;R++){const v=R*(Ue*Re);for(let x=0;x<Ue;x++){const M=x*Re;for(let N=0;N<Re;N++){const H=[be,R,x,N],ee=H[2],se=H[1];let ce=(ee-Ve)*at-(se-st)*tt,xe=(ee-Ve)*tt+(se-st)*at;ce=Math.round(ce+Ve),xe=Math.round(xe+st);let De=ne;typeof ne!="number"&&(De=N===3?255:ne[N]),ce>=0&&ce<Ue&&xe>=0&&xe<ye&&(De=ot[St+xe*(Ue*Re)+ce*Re+N]),$e[St+v+M+N]=De}}}}return{dataId:Ee.write($e,ie.shape,ie.dtype),shape:ie.shape,dtype:ie.dtype}}},pt=Object(A.a)(t.Round,ve=>{const Oe=Math.floor(ve);return ve-Oe<.5?Math.floor(ve):ve-Oe>.5?Math.ceil(ve):Oe%2==0?Oe:Oe+1}),zt={kernelName:t.Round,backendName:"cpu",kernelFunc:pt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Dt=e(77),We=e(33);const _t={kernelName:t.ScatterNd,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{indices:F,updates:ne}=Oe,{shape:ge}=ie,{sliceRank:Ee,numUpdates:$e,sliceSize:be,strides:ye,outputSize:Ue}=t.backend_util.calculateShapes(ne,F,ge),Re=j.bufferSync(F),Ve=j.bufferSync(ne),st=Object(We.a)(Re,Ve,ge,Ue,be,$e,Ee,ye,0,!0);return j.makeTensorInfo(ge,st.dtype,st.values)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jt(ve,Oe){let j=0,ie=ve.length,F=0;for(;j<ie;)F=Math.floor((j+ie)/2),ve[F]<Oe?j=F+1:ie=F;return ie}function Xt(ve,Oe){let j=0,ie=ve.length,F=0;for(;j<ie;)F=Math.floor((j+ie)/2),ve[F]<=Oe?j=F+1:ie=F;return ie}const on={kernelName:t.SearchSorted,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{sortedSequence:F,values:ne}=Oe,{side:ge}=ie,Ee=function($e,be,ye,Ue,Re,Ve){const st=t.util.getArrayFromDType("int32",ye*Re);for(let tt=0;tt<ye;++tt){const at=$e.slice(tt*Ue,(tt+1)*Ue),ot=tt*Re;for(let bt=0;bt<Re;++bt)st[ot+bt]=Ve==="left"?jt(at,be[bt+ot]):Xt(at,be[bt+ot])}return st}(j.data.get(F.dataId).values,j.data.get(ne.dataId).values,F.shape[0],F.shape[1],ne.shape[1],ge);return j.makeTensorInfo(ne.shape,"int32",Ee)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pt={kernelName:t.Select,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{condition:ie,t:F,e:ne}=Oe;Object(m.a)([ie,F,ne],"select");const ge=ie.shape.length,Ee=j.data.get(ie.dataId).values,$e=j.data.get(F.dataId).values,be=j.data.get(ne.dataId).values,ye=Object(t.upcastType)(F.dtype,ne.dtype),Ue=t.util.makeZerosTypedArray(t.util.sizeFromShape(F.shape),ye);let Re=0;const Ve=ge===0||ge>1||F.shape.length===1?1:t.util.sizeFromShape(F.shape.slice(1));for(let st=0;st<Ee.length;st++)for(let tt=0;tt<Ve;tt++)Ee[st]===1?Ue[Re++]=$e[st]:Ue[Re++]=be[st];return j.makeTensorInfo(F.shape,ye,Ue)}},hn=t.backend_util.SELU_SCALEALPHA,Fn=t.backend_util.SELU_SCALE,nr=Object(A.a)(t.Selu,ve=>ve>=0?Fn*ve:hn*(Math.exp(ve)-1)),dr={kernelName:t.Selu,backendName:"cpu",kernelFunc:nr},hr=Object(A.a)(t.Sign,ve=>ve<0?-1:ve>0?1:0),cr={kernelName:t.Sign,backendName:"cpu",kernelFunc:hr},Mr=Object(A.a)(t.Sin,ve=>Math.sin(ve)),Sr={kernelName:t.Sin,backendName:"cpu",kernelFunc:Mr},Dr=Object(A.a)(t.Sinh,ve=>Math.sinh(ve)),Ar={kernelName:t.Sinh,backendName:"cpu",kernelFunc:Dr},aa=Math.log(11920928955078125e-23)+2,ya=Object(A.a)(t.Softplus,ve=>{const Oe=ve>-aa,j=ve<aa,ie=Math.exp(ve);let F;return F=j?ie:Oe?ve:Math.log(1+ie),F}),Xa={kernelName:t.Softplus,backendName:"cpu",kernelFunc:ya};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const as={kernelName:t.SpaceToBatchND,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{blockShape:ne,paddings:ge}=ie;Object(m.a)([F],"spaceToBatchND");const Ee=t.util.sizeFromShape(ne),$e=[[0,0]];$e.push(...ge);for(let bt=1+ne.length;bt<F.shape.length;++bt)$e.push([0,0]);const be=_s.kernelFunc({inputs:{x:F},backend:j,attrs:{paddings:$e,constantValue:0}}),ye=t.backend_util.getReshaped(be.shape,ne,Ee,!1),Ue=t.backend_util.getPermuted(ye.length,ne.length,!1),Re=t.backend_util.getReshapedPermuted(be.shape,ne,Ee,!1),Ve=Se({inputs:{x:be},backend:j,attrs:{shape:ye}}),st={x:Ve},tt={perm:Ue},at=Object(Gt.a)({inputs:st,backend:j,attrs:tt}),ot=Se({inputs:{x:at},backend:j,attrs:{shape:Re}});return j.disposeIntermediateTensorInfo(be),j.disposeIntermediateTensorInfo(Ve),j.disposeIntermediateTensorInfo(at),ot}};var Us=e(78);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Is={kernelName:t.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{indices:ie,values:F,denseShape:ne,defaultValue:ge}=Oe;if(ne.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${ne.shape}`);if(ie.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${ie.shape}`);if(F.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${F.shape}`);if(ge.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${ge.shape}`);const Ee=j.data.get(ie.dataId).values,$e=j.data.get(F.dataId).values,be=j.data.get(ne.dataId).values,ye=j.data.get(ge.dataId).values[0],[Ue,Re,Ve,st,tt]=Object(Us.a)(Ee,ie.shape,ie.dtype,$e,F.dtype,be,ye);return[j.makeTensorInfo(Re,ie.dtype,Ue),j.makeTensorInfo([Re[0]],F.dtype,Ve),j.makeTensorInfo([st.length],"bool",new Uint8Array(st.map(at=>Number(at)))),j.makeTensorInfo([tt.length],ie.dtype,new Int32Array(tt))]}};var Ya=e(79);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ds={kernelName:t.SparseReshape,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{inputIndices:ie,inputShape:F,newShape:ne}=Oe;if(ie.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${ie.shape}`);if(F.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${F.shape}`);if(ne.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${ne.shape}`);const ge=Array.from(j.data.get(F.dataId).values),Ee=j.data.get(ie.dataId).values,$e=Array.from(j.data.get(ne.dataId).values),[be,ye,Ue]=Object(Ya.a)(Ee,ie.shape,ie.dtype,ge,$e);return[j.makeTensorInfo(ye,ie.dtype,be),j.makeTensorInfo([Ue.length],ne.dtype,new Int32Array(Ue))]}};var hs=e(48);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ws={kernelName:t.SparseSegmentMean,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{data:ie,indices:F,segmentIds:ne}=Oe;if(ie.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(F.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${F.shape}`);if(ne.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${ne.shape}`);if(F.shape[0]!==ne.shape[0])throw new Error("segmentIds and indices should have same size.");const ge=j.data.get(ie.dataId).values,Ee=j.data.get(F.dataId).values,$e=j.data.get(ne.dataId).values,[be,ye]=Object(hs.a)(ge,ie.shape,ie.dtype,Ee,$e,!0);return j.makeTensorInfo(ye,ie.dtype,be)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fa={kernelName:t.SparseSegmentSum,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j}=ve,{data:ie,indices:F,segmentIds:ne}=Oe;if(ie.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(F.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${F.shape}`);if(ne.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${ne.shape}`);if(F.shape[0]!==ne.shape[0])throw new Error("segmentIds and indices should have same size.");const ge=j.data.get(ie.dataId).values,Ee=j.data.get(F.dataId).values,$e=j.data.get(ne.dataId).values,[be,ye]=Object(hs.a)(ge,ie.shape,ie.dtype,Ee,$e);return j.makeTensorInfo(ye,ie.dtype,be)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vs={kernelName:t.SparseToDense,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{sparseIndices:F,sparseValues:ne,defaultValue:ge}=Oe,{outputShape:Ee}=ie,{sliceRank:$e,numUpdates:be,sliceSize:ye,strides:Ue,outputSize:Re}=t.backend_util.calculateShapes(ne,F,Ee),Ve=!1,st=j.bufferSync(F);let tt;switch(ne.dtype){case"bool":{const at=j.bufferSync(ne),ot=Boolean(j.data.get(ge.dataId).values[0]);tt=Object(We.a)(st,at,Ee,Re,ye,be,$e,Ue,ot,Ve);break}case"float32":{const at=j.bufferSync(ne),ot=j.data.get(ge.dataId).values[0];tt=Object(We.a)(st,at,Ee,Re,ye,be,$e,Ue,ot,Ve);break}case"int32":{const at=j.bufferSync(ne),ot=j.data.get(ge.dataId).values[0];tt=Object(We.a)(st,at,Ee,Re,ye,be,$e,Ue,ot,Ve);break}case"string":{const at=j.bufferSync(ne),ot=t.util.decodeString(j.data.get(ge.dataId).values[0]);tt=Object(We.a)(st,at,Ee,Re,ye,be,$e,Ue,ot,Ve);break}default:throw new Error(`Unsupported type ${ne.dtype}`)}return j.makeTensorInfo(Ee,tt.dtype,tt.values)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wi={kernelName:t.SplitV,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{numOrSizeSplits:ne,axis:ge}=ie,Ee=t.util.parseAxisParam(ge,F.shape)[0],$e=t.backend_util.prepareSplitSize(F,ne,Ee),be=new Array(F.shape.length).fill(0),ye=F.shape.slice();return $e.map(Ue=>{const Re=[...ye];Re[Ee]=Ue;const Ve=Object(Mn.a)({inputs:{x:F},backend:j,attrs:{begin:be,size:Re}});return be[Ee]+=Ue,Ve})}};var Gs=e(80);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ki={kernelName:t.Square,backendName:"cpu",kernelFunc:({inputs:ve,backend:Oe})=>{const{x:j}=ve,ie=Oe;Object(m.a)(j,"square");const F=ie.data.get(j.dataId).values,ne=new Float32Array(F.length);for(let ge=0;ge<F.length;++ge){const Ee=F[ge];ne[ge]=Ee*Ee}return{dataId:ie.write(ne,j.shape,j.dtype),shape:j.shape,dtype:j.dtype}}};var no=e(81);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wi=Object(A.a)(t.Step,(ve,Oe)=>{const j=Oe;return isNaN(ve)?NaN:ve>0?1:j.alpha}),ro={kernelName:t.Step,backendName:"cpu",kernelFunc:Wi};var Vi=e(82);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mi={kernelName:t.StridedSlice,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{begin:ne,end:ge,strides:Ee,beginMask:$e,endMask:be,ellipsisMask:ye,newAxisMask:Ue,shrinkAxisMask:Re}=ie;Object(m.a)(F,"stridedSlice");const{finalShapeSparse:Ve,finalShape:st,isIdentity:tt,sliceDim0:at,isSimpleSlice:ot,begin:bt,end:St,strides:R}=t.slice_util.sliceInfo(F.shape,ne,ge,Ee,$e,be,ye,Ue,Re);let v;if(tt)v=Se({inputs:{x:F},backend:j,attrs:{shape:st}});else if(at||ot){t.util.assert(F.shape.length>=1,()=>`Input must have rank at least 1, got: ${F.shape.length}`);const x=t.slice_util.computeOutShape(bt,St,R),M=Object(Mn.a)({inputs:{x:F},backend:j,attrs:{begin:bt,size:x}});v=Se({inputs:{x:M},backend:j,attrs:{shape:st}}),j.disposeIntermediateTensorInfo(M)}else{const x=j.bufferSync(F),M=Object(Vi.a)(Ve,x,R,bt);v=j.makeTensorInfo(st,M.dtype,M.values)}return v}};var _i=e(83);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gi={kernelName:t.StringNGrams,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{separator:F,nGramWidths:ne,leftPad:ge,rightPad:Ee,padWidth:$e,preserveShortSequences:be}=ie,{data:ye,dataSplits:Ue}=Oe,Re=j.data.get(ye.dataId).values,Ve=j.data.get(Ue.dataId).values,[st,tt]=Object(_i.a)(Re,Ve,F,ne,ge,Ee,$e,be);return[j.makeTensorInfo([st.length],"string",st),j.makeTensorInfo(Ue.shape,"int32",tt)]}};var Di=e(84);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai={kernelName:t.StringSplit,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{skipEmpty:F}=ie,{input:ne,delimiter:ge}=Oe;if(ne.dtype!=="string")throw new Error("Input must be of datatype string");if(ne.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${ne.shape}`);if(ge.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${ge.shape}`);const Ee=j.data.get(ne.dataId).values,$e=j.data.get(ge.dataId).values[0],[be,ye,Ue]=Object(Di.a)(Ee,$e,F),Re=ye.length;return[j.makeTensorInfo([Re,2],"int32",be),j.makeTensorInfo([Re],"string",ye),j.makeTensorInfo([2],"int32",new Int32Array(Ue))]}};var ao=e(85);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const so={kernelName:t.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{numBuckets:F}=ie,{input:ne}=Oe;if(ne.dtype!=="string")throw new Error("Input must be of datatype string");if(F<=0)throw new Error("Number of buckets must be at least 1");const ge=j.data.get(ne.dataId).values,Ee=Object(ao.a)(ge,F);return j.makeTensorInfo(ne.shape,"int32",Ee)}},io=Object(A.a)(t.Tan,ve=>Math.tan(ve)),Hi={kernelName:t.Tan,backendName:"cpu",kernelFunc:io},Ii=Object(A.a)(t.Tanh,ve=>Math.tanh(ve)),Pi={kernelName:t.Tanh,backendName:"cpu",kernelFunc:Ii};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qi=e(86);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oo={kernelName:t.Tile,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{reps:ne}=ie;Object(m.a)(F,"tile");const ge=Object(qi.a)(j.bufferSync(F),ne);return j.makeTensorInfo(ge.shape,ge.dtype,ge.values)}};var fi=e(87);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uo={kernelName:t.TopK,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F}=Oe,{k:ne,sorted:ge}=ie;Object(m.a)(F,"topk");const Ee=j.data.get(F.dataId).values,[$e,be]=Object(fi.a)(Ee,F.shape,F.dtype,ne,ge);return[j.makeTensorInfo($e.shape,$e.dtype,$e.values),j.makeTensorInfo(be.shape,be.dtype,be.values)]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const co={kernelName:t.Transform,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,attrs:j,backend:ie}=ve,{image:F,transforms:ne}=Oe,{interpolation:ge,fillMode:Ee,fillValue:$e,outputShape:be}=j,[ye,Ue,Re,Ve]=F.shape,[st,tt]=be!=null?be:[Ue,Re],at=[ye,st,tt,Ve],ot=t.util.computeStrides(F.shape),bt=ot[0],St=ot[1],R=ot[2],v=t.util.computeStrides(at),x=v[0],M=v[1],N=v[2],H=t.util.getTypedArrayFromDType(F.dtype,t.util.sizeFromShape(at));H.fill($e);const ee=ie.data.get(F.dataId).values,se=ie.data.get(ne.dataId).values;for(let ce=0;ce<ye;++ce){const xe=ne.shape[0]===1?se:se.subarray(8*ce,8*ce+8);for(let De=0;De<st;++De)for(let Ke=0;Ke<tt;++Ke)for(let Ze=0;Ze<Ve;++Ze){let Ge;const nt=xe[6]*Ke+xe[7]*De+1;if(nt===0)continue;const Je=(xe[0]*Ke+xe[1]*De+xe[2])/nt,yt=(xe[3]*Ke+xe[4]*De+xe[5])/nt,gt=Ki(Je,Re,Ee),kt=Ki(yt,Ue,Ee);switch(ge){case"nearest":Ge=si(ee,Ue,Re,bt,St,R,ce,kt,gt,Ze,$e);break;case"bilinear":Ge=Si(ee,Ue,Re,bt,St,R,ce,kt,gt,Ze,$e);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${ge}`)}H[ce*x+De*M+Ke*N+Ze]=Ge}return ie.makeTensorInfo(at,F.dtype,H)}return{dataId:ie.write(H,at,F.dtype),shape:F.shape,dtype:F.dtype}}};function Ki(ve,Oe,j){switch(j){case"reflect":return function(ie,F){let ne=ie;if(ne<0)if(F<=1)ne=0;else{const ge=2*F;ne<ge&&(ne=ge*Math.trunc(-ne/ge)+ne),ne=ne<-F?ne+ge:-ne-1}else if(ne>F-1)if(F<=1)ne=0;else{const ge=2*F;ne-=ge*Math.trunc(ne/ge),ne>=F&&(ne=ge-ne-1)}return t.util.clamp(0,ne,F-1)}(ve,Oe);case"wrap":return function(ie,F){let ne=ie;if(ne<0)if(F<=1)ne=0;else{const ge=F-1;ne+=F*(Math.trunc(-ne/ge)+1)}else if(ne>F-1)if(F<=1)ne=0;else{const ge=F-1;ne-=F*Math.trunc(ne/ge)}return t.util.clamp(0,ne,F-1)}(ve,Oe);case"nearest":return function(ie,F){return t.util.clamp(0,ie,F-1)}(ve,Oe);default:return function(ie,F){return ie}(ve)}}function mi(ve,Oe,j,ie,F,ne,ge,Ee,$e,be,ye){return 0<=Ee&&Ee<Oe&&0<=$e&&$e<j?ve[ge*ie+Ee*F+$e*ne+be]:ye}function si(ve,Oe,j,ie,F,ne,ge,Ee,$e,be,ye){return mi(ve,Oe,j,ie,F,ne,ge,Math.round(Ee),Math.round($e),be,ye)}function Si(ve,Oe,j,ie,F,ne,ge,Ee,$e,be,ye){const Ue=Math.floor(Ee),Re=Math.floor($e),Ve=Ue+1,st=Re+1;return(Ve-Ee)*((st-$e)*mi(ve,Oe,j,ie,F,ne,ge,Ue,Re,be,ye)+($e-Re)*mi(ve,Oe,j,ie,F,ne,ge,Ue,st,be,ye))+(Ee-Ue)*((st-$e)*mi(ve,Oe,j,ie,F,ne,ge,Ve,Re,be,ye)+($e-Re)*mi(ve,Oe,j,ie,F,ne,ge,Ve,st,be,ye))}var Br=e(88);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bi={kernelName:t.Unique,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,attrs:j,backend:ie}=ve,{axis:F}=j,{x:ne}=Oe;Object(m.a)(ne,"unique");const ge=ie.data.get(ne.dataId).values,{outputValues:Ee,outputShape:$e,indices:be}=Object(Br.a)(ge,F,ne.shape,ne.dtype);return[ie.makeTensorInfo($e,ne.dtype,Ee),ie.makeTensorInfo([be.length],"int32",be)]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bi={kernelName:t.Unpack,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{value:F}=Oe;let{axis:ne}=ie;ne<0&&(ne+=F.shape.length);const ge=F.shape.length,Ee=F.shape[ne],$e=new Array(ge-1);let be=0;for(let Ve=0;Ve<ge;Ve++)Ve!==ne&&($e[be++]=F.shape[Ve]);const ye=new Array(ge).fill(0),Ue=F.shape.slice();Ue[ne]=1;const Re=new Array(Ee);for(let Ve=0;Ve<Re.length;Ve++){ye[ne]=Ve;const st=Object(Mn.a)({inputs:{x:F},backend:j,attrs:{begin:ye,size:Ue}});Re[Ve]=Se({inputs:{x:st},backend:j,attrs:{shape:$e}}),j.disposeIntermediateTensorInfo(st)}return Re}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xi={kernelName:t.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(ve){const{inputs:Oe,backend:j,attrs:ie}=ve,{x:F,segmentIds:ne}=Oe,{numSegments:ge}=ie;Object(m.a)(F,"unsortedSegmentSum");const Ee=[],$e=[],be=F.shape.length-ne.shape.length;let ye=ne;for(let Re=0;Re<be;++Re){const Ve=wr({inputs:{input:ye},backend:j,attrs:{dim:Re+1}});ye=Ve,$e.push(Ve)}for(let Re=0;Re<ge;++Re){const Ve=t.util.createScalarValue(Re,"int32"),st=j.makeTensorInfo([],"int32",Ve),tt=Object(Va.a)({inputs:{a:st,b:ye},backend:j}),at=Object(Zn.a)({inputs:{x:tt},backend:j,attrs:{dtype:"float32"}}),ot=Object(Vr.a)({inputs:{a:at,b:F},backend:j}),bt=Ta({inputs:{x:ot},backend:j,attrs:{axis:0,keepDims:!1}});Ee.push(bt),$e.push(st),$e.push(tt),$e.push(at),$e.push(ot),$e.push(bt)}const Ue=js({inputs:Ee,backend:j,attrs:{axis:0}});return $e.forEach(Re=>j.disposeIntermediateTensorInfo(Re)),Ue}},ps=[me,et.a,It,$t,Q.b,Ct,Wt,lt,Qt,Ft,Nn,zn,K,wt,Ae,un,Rn,oe,le,He,qe,zr,_r,ir,Zn.b,$r.a,mn,Ln.b,or,q,Qe,ht,Bt,Kt,Ut,tn,xn,Xn,xr,Lr,Wr,vr,ua,Cr,Da,kr,Pr,qr,ha,Zr,is,y,ms,Va.b,Za,La.b,sa,Ia.a,an,_n,Gn,ar.a,xa,Er,Yr,Oa,Xs,$s.a,bs.a,E.b,di,br,qa,ta,ia,l,Aa.a,es.a,hi,xs.a,pi,za,Qs,Ns,vs,Yn,Sa,na.a,pa,Zs,ys,cs,xi,ra,Ua,ls.a,Tr,Js,Fs,Vr.b,va.a,Ms,ti,ns,Bs.a,Ai,ni,Ni,_s,vi,L,Ri.a,yi,ue,gr.b,Ja,Xe,W,ke,Z,Te,Ye,it,xt,ut,ft,zt,Dt.a,_t,on,Pt,dr,Ie.b,cr,Sr,Ar,Mn.b,ur,Xa,as,Is,ds,Ws,fa,Vs,wi,Gs.a,ki,no.a,ro,Mi,Gi,ai,so,Fe.b,Pa,Hi,Pi,oo,uo,co,Gt.b,Bi,bi,Xi,rs];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */for(const ve of ps)Object(t.registerKernel)(ve);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},function(I,n){I.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`},,,function(I,n,e){I.exports=e(104)},function(I,n,e){e.r(n),function(t){var m=e(91),h=e(37),b=e(53),A=e(39),D=e(11);typeof navigator=="undefined"&&(t.navigator={}),navigator.ml==null&&(navigator.ml=new m.a),t.ML==null&&(t.ML=m.a),t.MLContext==null&&(t.MLContext=h.a),t.MLGraphBuilder==null&&(t.MLGraphBuilder=A.d),t.MLGraph==null&&(t.MLGraph=b.a),t.MLOperand==null&&(t.MLOperand=D.c)}.call(this,e(40))},function(I,n,e){(function(t){/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */var m=e(106),h=e(107),b=e(108);function A(){return y.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function D(K,J){if(A()<J)throw new RangeError("Invalid typed array length");return y.TYPED_ARRAY_SUPPORT?(K=new Uint8Array(J)).__proto__=y.prototype:(K===null&&(K=new y(J)),K.length=J),K}function y(K,J,we){if(!(y.TYPED_ARRAY_SUPPORT||this instanceof y))return new y(K,J,we);if(typeof K=="number"){if(typeof J=="string")throw new Error("If encoding is specified then the first argument must be a string");return l(this,K)}return E(this,K,J,we)}function E(K,J,we,vt){if(typeof J=="number")throw new TypeError('"value" argument must not be a number');return typeof ArrayBuffer!="undefined"&&J instanceof ArrayBuffer?function(wt,Ot,Ae,mt){if(Ot.byteLength,Ae<0||Ot.byteLength<Ae)throw new RangeError("'offset' is out of bounds");if(Ot.byteLength<Ae+(mt||0))throw new RangeError("'length' is out of bounds");return Ot=Ae===void 0&&mt===void 0?new Uint8Array(Ot):mt===void 0?new Uint8Array(Ot,Ae):new Uint8Array(Ot,Ae,mt),y.TYPED_ARRAY_SUPPORT?(wt=Ot).__proto__=y.prototype:wt=B(wt,Ot),wt}(K,J,we,vt):typeof J=="string"?function(wt,Ot,Ae){if(typeof Ae=="string"&&Ae!==""||(Ae="utf8"),!y.isEncoding(Ae))throw new TypeError('"encoding" must be a valid string encoding');var mt=0|V(Ot,Ae),Mt=(wt=D(wt,mt)).write(Ot,Ae);return Mt!==mt&&(wt=wt.slice(0,Mt)),wt}(K,J,we):function(wt,Ot){if(y.isBuffer(Ot)){var Ae=0|O(Ot.length);return(wt=D(wt,Ae)).length===0||Ot.copy(wt,0,0,Ae),wt}if(Ot){if(typeof ArrayBuffer!="undefined"&&Ot.buffer instanceof ArrayBuffer||"length"in Ot)return typeof Ot.length!="number"||(mt=Ot.length)!=mt?D(wt,0):B(wt,Ot);if(Ot.type==="Buffer"&&b(Ot.data))return B(wt,Ot.data)}var mt;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(K,J)}function S(K){if(typeof K!="number")throw new TypeError('"size" argument must be a number');if(K<0)throw new RangeError('"size" argument must not be negative')}function l(K,J){if(S(J),K=D(K,J<0?0:0|O(J)),!y.TYPED_ARRAY_SUPPORT)for(var we=0;we<J;++we)K[we]=0;return K}function B(K,J){var we=J.length<0?0:0|O(J.length);K=D(K,we);for(var vt=0;vt<we;vt+=1)K[vt]=255&J[vt];return K}function O(K){if(K>=A())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+A().toString(16)+" bytes");return 0|K}function V(K,J){if(y.isBuffer(K))return K.length;if(typeof ArrayBuffer!="undefined"&&typeof ArrayBuffer.isView=="function"&&(ArrayBuffer.isView(K)||K instanceof ArrayBuffer))return K.byteLength;typeof K!="string"&&(K=""+K);var we=K.length;if(we===0)return 0;for(var vt=!1;;)switch(J){case"ascii":case"latin1":case"binary":return we;case"utf8":case"utf-8":case void 0:return Kn(K).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*we;case"hex":return we>>>1;case"base64":return zn(K).length;default:if(vt)return Kn(K).length;J=(""+J).toLowerCase(),vt=!0}}function L(K,J,we){var vt=!1;if((J===void 0||J<0)&&(J=0),J>this.length||((we===void 0||we>this.length)&&(we=this.length),we<=0)||(we>>>=0)<=(J>>>=0))return"";for(K||(K="utf8");;)switch(K){case"hex":return It(this,J,we);case"utf8":case"utf-8":return He(this,J,we);case"ascii":return et(this,J,we);case"latin1":case"binary":return rt(this,J,we);case"base64":return G(this,J,we);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return X(this,J,we);default:if(vt)throw new TypeError("Unknown encoding: "+K);K=(K+"").toLowerCase(),vt=!0}}function g(K,J,we){var vt=K[J];K[J]=K[we],K[we]=vt}function W(K,J,we,vt,wt){if(K.length===0)return-1;if(typeof we=="string"?(vt=we,we=0):we>2147483647?we=2147483647:we<-2147483648&&(we=-2147483648),we=+we,isNaN(we)&&(we=wt?0:K.length-1),we<0&&(we=K.length+we),we>=K.length){if(wt)return-1;we=K.length-1}else if(we<0){if(!wt)return-1;we=0}if(typeof J=="string"&&(J=y.from(J,vt)),y.isBuffer(J))return J.length===0?-1:de(K,J,we,vt,wt);if(typeof J=="number")return J&=255,y.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf=="function"?wt?Uint8Array.prototype.indexOf.call(K,J,we):Uint8Array.prototype.lastIndexOf.call(K,J,we):de(K,[J],we,vt,wt);throw new TypeError("val must be string, number or Buffer")}function de(K,J,we,vt,wt){var Ot,Ae=1,mt=K.length,Mt=J.length;if(vt!==void 0&&((vt=String(vt).toLowerCase())==="ucs2"||vt==="ucs-2"||vt==="utf16le"||vt==="utf-16le")){if(K.length<2||J.length<2)return-1;Ae=2,mt/=2,Mt/=2,we/=2}function Nt(le,qe){return Ae===1?le[qe]:le.readUInt16BE(qe*Ae)}if(wt){var un=-1;for(Ot=we;Ot<mt;Ot++)if(Nt(K,Ot)===Nt(J,un===-1?0:Ot-un)){if(un===-1&&(un=Ot),Ot-un+1===Mt)return un*Ae}else un!==-1&&(Ot-=Ot-un),un=-1}else for(we+Mt>mt&&(we=mt-Mt),Ot=we;Ot>=0;Ot--){for(var Rn=!0,oe=0;oe<Mt;oe++)if(Nt(K,Ot+oe)!==Nt(J,oe)){Rn=!1;break}if(Rn)return Ot}return-1}function ke(K,J,we,vt){we=Number(we)||0;var wt=K.length-we;vt?(vt=Number(vt))>wt&&(vt=wt):vt=wt;var Ot=J.length;if(Ot%2!=0)throw new TypeError("Invalid hex string");vt>Ot/2&&(vt=Ot/2);for(var Ae=0;Ae<vt;++Ae){var mt=parseInt(J.substr(2*Ae,2),16);if(isNaN(mt))return Ae;K[we+Ae]=mt}return Ae}function Ie(K,J,we,vt){return sr(Kn(J,K.length-we),K,we,vt)}function he(K,J,we,vt){return sr(function(wt){for(var Ot=[],Ae=0;Ae<wt.length;++Ae)Ot.push(255&wt.charCodeAt(Ae));return Ot}(J),K,we,vt)}function Q(K,J,we,vt){return he(K,J,we,vt)}function Se(K,J,we,vt){return sr(zn(J),K,we,vt)}function Z(K,J,we,vt){return sr(function(wt,Ot){for(var Ae,mt,Mt,Nt=[],un=0;un<wt.length&&!((Ot-=2)<0);++un)mt=(Ae=wt.charCodeAt(un))>>8,Mt=Ae%256,Nt.push(Mt),Nt.push(mt);return Nt}(J,K.length-we),K,we,vt)}function G(K,J,we){return J===0&&we===K.length?m.fromByteArray(K):m.fromByteArray(K.slice(J,we))}function He(K,J,we){we=Math.min(K.length,we);for(var vt=[],wt=J;wt<we;){var Ot,Ae,mt,Mt,Nt=K[wt],un=null,Rn=Nt>239?4:Nt>223?3:Nt>191?2:1;if(wt+Rn<=we)switch(Rn){case 1:Nt<128&&(un=Nt);break;case 2:(192&(Ot=K[wt+1]))==128&&(Mt=(31&Nt)<<6|63&Ot)>127&&(un=Mt);break;case 3:Ot=K[wt+1],Ae=K[wt+2],(192&Ot)==128&&(192&Ae)==128&&(Mt=(15&Nt)<<12|(63&Ot)<<6|63&Ae)>2047&&(Mt<55296||Mt>57343)&&(un=Mt);break;case 4:Ot=K[wt+1],Ae=K[wt+2],mt=K[wt+3],(192&Ot)==128&&(192&Ae)==128&&(192&mt)==128&&(Mt=(15&Nt)<<18|(63&Ot)<<12|(63&Ae)<<6|63&mt)>65535&&Mt<1114112&&(un=Mt)}un===null?(un=65533,Rn=1):un>65535&&(un-=65536,vt.push(un>>>10&1023|55296),un=56320|1023&un),vt.push(un),wt+=Rn}return function(oe){var le=oe.length;if(le<=me)return String.fromCharCode.apply(String,oe);for(var qe="",Mn=0;Mn<le;)qe+=String.fromCharCode.apply(String,oe.slice(Mn,Mn+=me));return qe}(vt)}n.Buffer=y,n.SlowBuffer=function(K){return+K!=K&&(K=0),y.alloc(+K)},n.INSPECT_MAX_BYTES=50,y.TYPED_ARRAY_SUPPORT=t.TYPED_ARRAY_SUPPORT!==void 0?t.TYPED_ARRAY_SUPPORT:function(){try{var K=new Uint8Array(1);return K.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},K.foo()===42&&typeof K.subarray=="function"&&K.subarray(1,1).byteLength===0}catch{return!1}}(),n.kMaxLength=A(),y.poolSize=8192,y._augment=function(K){return K.__proto__=y.prototype,K},y.from=function(K,J,we){return E(null,K,J,we)},y.TYPED_ARRAY_SUPPORT&&(y.prototype.__proto__=Uint8Array.prototype,y.__proto__=Uint8Array,typeof Symbol!="undefined"&&Symbol.species&&y[Symbol.species]===y&&Object.defineProperty(y,Symbol.species,{value:null,configurable:!0})),y.alloc=function(K,J,we){return function(vt,wt,Ot,Ae){return S(wt),wt<=0?D(vt,wt):Ot!==void 0?typeof Ae=="string"?D(vt,wt).fill(Ot,Ae):D(vt,wt).fill(Ot):D(vt,wt)}(null,K,J,we)},y.allocUnsafe=function(K){return l(null,K)},y.allocUnsafeSlow=function(K){return l(null,K)},y.isBuffer=function(K){return!(K==null||!K._isBuffer)},y.compare=function(K,J){if(!y.isBuffer(K)||!y.isBuffer(J))throw new TypeError("Arguments must be Buffers");if(K===J)return 0;for(var we=K.length,vt=J.length,wt=0,Ot=Math.min(we,vt);wt<Ot;++wt)if(K[wt]!==J[wt]){we=K[wt],vt=J[wt];break}return we<vt?-1:vt<we?1:0},y.isEncoding=function(K){switch(String(K).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},y.concat=function(K,J){if(!b(K))throw new TypeError('"list" argument must be an Array of Buffers');if(K.length===0)return y.alloc(0);var we;if(J===void 0)for(J=0,we=0;we<K.length;++we)J+=K[we].length;var vt=y.allocUnsafe(J),wt=0;for(we=0;we<K.length;++we){var Ot=K[we];if(!y.isBuffer(Ot))throw new TypeError('"list" argument must be an Array of Buffers');Ot.copy(vt,wt),wt+=Ot.length}return vt},y.byteLength=V,y.prototype._isBuffer=!0,y.prototype.swap16=function(){var K=this.length;if(K%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var J=0;J<K;J+=2)g(this,J,J+1);return this},y.prototype.swap32=function(){var K=this.length;if(K%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var J=0;J<K;J+=4)g(this,J,J+3),g(this,J+1,J+2);return this},y.prototype.swap64=function(){var K=this.length;if(K%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var J=0;J<K;J+=8)g(this,J,J+7),g(this,J+1,J+6),g(this,J+2,J+5),g(this,J+3,J+4);return this},y.prototype.toString=function(){var K=0|this.length;return K===0?"":arguments.length===0?He(this,0,K):L.apply(this,arguments)},y.prototype.equals=function(K){if(!y.isBuffer(K))throw new TypeError("Argument must be a Buffer");return this===K||y.compare(this,K)===0},y.prototype.inspect=function(){var K="",J=n.INSPECT_MAX_BYTES;return this.length>0&&(K=this.toString("hex",0,J).match(/.{2}/g).join(" "),this.length>J&&(K+=" ... ")),"<Buffer "+K+">"},y.prototype.compare=function(K,J,we,vt,wt){if(!y.isBuffer(K))throw new TypeError("Argument must be a Buffer");if(J===void 0&&(J=0),we===void 0&&(we=K?K.length:0),vt===void 0&&(vt=0),wt===void 0&&(wt=this.length),J<0||we>K.length||vt<0||wt>this.length)throw new RangeError("out of range index");if(vt>=wt&&J>=we)return 0;if(vt>=wt)return-1;if(J>=we)return 1;if(this===K)return 0;for(var Ot=(wt>>>=0)-(vt>>>=0),Ae=(we>>>=0)-(J>>>=0),mt=Math.min(Ot,Ae),Mt=this.slice(vt,wt),Nt=K.slice(J,we),un=0;un<mt;++un)if(Mt[un]!==Nt[un]){Ot=Mt[un],Ae=Nt[un];break}return Ot<Ae?-1:Ae<Ot?1:0},y.prototype.includes=function(K,J,we){return this.indexOf(K,J,we)!==-1},y.prototype.indexOf=function(K,J,we){return W(this,K,J,we,!0)},y.prototype.lastIndexOf=function(K,J,we){return W(this,K,J,we,!1)},y.prototype.write=function(K,J,we,vt){if(J===void 0)vt="utf8",we=this.length,J=0;else if(we===void 0&&typeof J=="string")vt=J,we=this.length,J=0;else{if(!isFinite(J))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");J|=0,isFinite(we)?(we|=0,vt===void 0&&(vt="utf8")):(vt=we,we=void 0)}var wt=this.length-J;if((we===void 0||we>wt)&&(we=wt),K.length>0&&(we<0||J<0)||J>this.length)throw new RangeError("Attempt to write outside buffer bounds");vt||(vt="utf8");for(var Ot=!1;;)switch(vt){case"hex":return ke(this,K,J,we);case"utf8":case"utf-8":return Ie(this,K,J,we);case"ascii":return he(this,K,J,we);case"latin1":case"binary":return Q(this,K,J,we);case"base64":return Se(this,K,J,we);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Z(this,K,J,we);default:if(Ot)throw new TypeError("Unknown encoding: "+vt);vt=(""+vt).toLowerCase(),Ot=!0}},y.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var me=4096;function et(K,J,we){var vt="";we=Math.min(K.length,we);for(var wt=J;wt<we;++wt)vt+=String.fromCharCode(127&K[wt]);return vt}function rt(K,J,we){var vt="";we=Math.min(K.length,we);for(var wt=J;wt<we;++wt)vt+=String.fromCharCode(K[wt]);return vt}function It(K,J,we){var vt=K.length;(!J||J<0)&&(J=0),(!we||we<0||we>vt)&&(we=vt);for(var wt="",Ot=J;Ot<we;++Ot)wt+=Nn(K[Ot]);return wt}function X(K,J,we){for(var vt=K.slice(J,we),wt="",Ot=0;Ot<vt.length;Ot+=2)wt+=String.fromCharCode(vt[Ot]+256*vt[Ot+1]);return wt}function $t(K,J,we){if(K%1!=0||K<0)throw new RangeError("offset is not uint");if(K+J>we)throw new RangeError("Trying to access beyond buffer length")}function Ct(K,J,we,vt,wt,Ot){if(!y.isBuffer(K))throw new TypeError('"buffer" argument must be a Buffer instance');if(J>wt||J<Ot)throw new RangeError('"value" argument is out of bounds');if(we+vt>K.length)throw new RangeError("Index out of range")}function Gt(K,J,we,vt){J<0&&(J=65535+J+1);for(var wt=0,Ot=Math.min(K.length-we,2);wt<Ot;++wt)K[we+wt]=(J&255<<8*(vt?wt:1-wt))>>>8*(vt?wt:1-wt)}function Wt(K,J,we,vt){J<0&&(J=4294967295+J+1);for(var wt=0,Ot=Math.min(K.length-we,4);wt<Ot;++wt)K[we+wt]=J>>>8*(vt?wt:3-wt)&255}function lt(K,J,we,vt,wt,Ot){if(we+vt>K.length)throw new RangeError("Index out of range");if(we<0)throw new RangeError("Index out of range")}function Qt(K,J,we,vt,wt){return wt||lt(K,0,we,4),h.write(K,J,we,vt,23,4),we+4}function Ft(K,J,we,vt,wt){return wt||lt(K,0,we,8),h.write(K,J,we,vt,52,8),we+8}y.prototype.slice=function(K,J){var we,vt=this.length;if((K=~~K)<0?(K+=vt)<0&&(K=0):K>vt&&(K=vt),(J=J===void 0?vt:~~J)<0?(J+=vt)<0&&(J=0):J>vt&&(J=vt),J<K&&(J=K),y.TYPED_ARRAY_SUPPORT)(we=this.subarray(K,J)).__proto__=y.prototype;else{var wt=J-K;we=new y(wt,void 0);for(var Ot=0;Ot<wt;++Ot)we[Ot]=this[Ot+K]}return we},y.prototype.readUIntLE=function(K,J,we){K|=0,J|=0,we||$t(K,J,this.length);for(var vt=this[K],wt=1,Ot=0;++Ot<J&&(wt*=256);)vt+=this[K+Ot]*wt;return vt},y.prototype.readUIntBE=function(K,J,we){K|=0,J|=0,we||$t(K,J,this.length);for(var vt=this[K+--J],wt=1;J>0&&(wt*=256);)vt+=this[K+--J]*wt;return vt},y.prototype.readUInt8=function(K,J){return J||$t(K,1,this.length),this[K]},y.prototype.readUInt16LE=function(K,J){return J||$t(K,2,this.length),this[K]|this[K+1]<<8},y.prototype.readUInt16BE=function(K,J){return J||$t(K,2,this.length),this[K]<<8|this[K+1]},y.prototype.readUInt32LE=function(K,J){return J||$t(K,4,this.length),(this[K]|this[K+1]<<8|this[K+2]<<16)+16777216*this[K+3]},y.prototype.readUInt32BE=function(K,J){return J||$t(K,4,this.length),16777216*this[K]+(this[K+1]<<16|this[K+2]<<8|this[K+3])},y.prototype.readIntLE=function(K,J,we){K|=0,J|=0,we||$t(K,J,this.length);for(var vt=this[K],wt=1,Ot=0;++Ot<J&&(wt*=256);)vt+=this[K+Ot]*wt;return vt>=(wt*=128)&&(vt-=Math.pow(2,8*J)),vt},y.prototype.readIntBE=function(K,J,we){K|=0,J|=0,we||$t(K,J,this.length);for(var vt=J,wt=1,Ot=this[K+--vt];vt>0&&(wt*=256);)Ot+=this[K+--vt]*wt;return Ot>=(wt*=128)&&(Ot-=Math.pow(2,8*J)),Ot},y.prototype.readInt8=function(K,J){return J||$t(K,1,this.length),128&this[K]?-1*(255-this[K]+1):this[K]},y.prototype.readInt16LE=function(K,J){J||$t(K,2,this.length);var we=this[K]|this[K+1]<<8;return 32768&we?4294901760|we:we},y.prototype.readInt16BE=function(K,J){J||$t(K,2,this.length);var we=this[K+1]|this[K]<<8;return 32768&we?4294901760|we:we},y.prototype.readInt32LE=function(K,J){return J||$t(K,4,this.length),this[K]|this[K+1]<<8|this[K+2]<<16|this[K+3]<<24},y.prototype.readInt32BE=function(K,J){return J||$t(K,4,this.length),this[K]<<24|this[K+1]<<16|this[K+2]<<8|this[K+3]},y.prototype.readFloatLE=function(K,J){return J||$t(K,4,this.length),h.read(this,K,!0,23,4)},y.prototype.readFloatBE=function(K,J){return J||$t(K,4,this.length),h.read(this,K,!1,23,4)},y.prototype.readDoubleLE=function(K,J){return J||$t(K,8,this.length),h.read(this,K,!0,52,8)},y.prototype.readDoubleBE=function(K,J){return J||$t(K,8,this.length),h.read(this,K,!1,52,8)},y.prototype.writeUIntLE=function(K,J,we,vt){K=+K,J|=0,we|=0,vt||Ct(this,K,J,we,Math.pow(2,8*we)-1,0);var wt=1,Ot=0;for(this[J]=255&K;++Ot<we&&(wt*=256);)this[J+Ot]=K/wt&255;return J+we},y.prototype.writeUIntBE=function(K,J,we,vt){K=+K,J|=0,we|=0,vt||Ct(this,K,J,we,Math.pow(2,8*we)-1,0);var wt=we-1,Ot=1;for(this[J+wt]=255&K;--wt>=0&&(Ot*=256);)this[J+wt]=K/Ot&255;return J+we},y.prototype.writeUInt8=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,1,255,0),y.TYPED_ARRAY_SUPPORT||(K=Math.floor(K)),this[J]=255&K,J+1},y.prototype.writeUInt16LE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,2,65535,0),y.TYPED_ARRAY_SUPPORT?(this[J]=255&K,this[J+1]=K>>>8):Gt(this,K,J,!0),J+2},y.prototype.writeUInt16BE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,2,65535,0),y.TYPED_ARRAY_SUPPORT?(this[J]=K>>>8,this[J+1]=255&K):Gt(this,K,J,!1),J+2},y.prototype.writeUInt32LE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,4,4294967295,0),y.TYPED_ARRAY_SUPPORT?(this[J+3]=K>>>24,this[J+2]=K>>>16,this[J+1]=K>>>8,this[J]=255&K):Wt(this,K,J,!0),J+4},y.prototype.writeUInt32BE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,4,4294967295,0),y.TYPED_ARRAY_SUPPORT?(this[J]=K>>>24,this[J+1]=K>>>16,this[J+2]=K>>>8,this[J+3]=255&K):Wt(this,K,J,!1),J+4},y.prototype.writeIntLE=function(K,J,we,vt){if(K=+K,J|=0,!vt){var wt=Math.pow(2,8*we-1);Ct(this,K,J,we,wt-1,-wt)}var Ot=0,Ae=1,mt=0;for(this[J]=255&K;++Ot<we&&(Ae*=256);)K<0&&mt===0&&this[J+Ot-1]!==0&&(mt=1),this[J+Ot]=(K/Ae>>0)-mt&255;return J+we},y.prototype.writeIntBE=function(K,J,we,vt){if(K=+K,J|=0,!vt){var wt=Math.pow(2,8*we-1);Ct(this,K,J,we,wt-1,-wt)}var Ot=we-1,Ae=1,mt=0;for(this[J+Ot]=255&K;--Ot>=0&&(Ae*=256);)K<0&&mt===0&&this[J+Ot+1]!==0&&(mt=1),this[J+Ot]=(K/Ae>>0)-mt&255;return J+we},y.prototype.writeInt8=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,1,127,-128),y.TYPED_ARRAY_SUPPORT||(K=Math.floor(K)),K<0&&(K=255+K+1),this[J]=255&K,J+1},y.prototype.writeInt16LE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,2,32767,-32768),y.TYPED_ARRAY_SUPPORT?(this[J]=255&K,this[J+1]=K>>>8):Gt(this,K,J,!0),J+2},y.prototype.writeInt16BE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,2,32767,-32768),y.TYPED_ARRAY_SUPPORT?(this[J]=K>>>8,this[J+1]=255&K):Gt(this,K,J,!1),J+2},y.prototype.writeInt32LE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,4,2147483647,-2147483648),y.TYPED_ARRAY_SUPPORT?(this[J]=255&K,this[J+1]=K>>>8,this[J+2]=K>>>16,this[J+3]=K>>>24):Wt(this,K,J,!0),J+4},y.prototype.writeInt32BE=function(K,J,we){return K=+K,J|=0,we||Ct(this,K,J,4,2147483647,-2147483648),K<0&&(K=4294967295+K+1),y.TYPED_ARRAY_SUPPORT?(this[J]=K>>>24,this[J+1]=K>>>16,this[J+2]=K>>>8,this[J+3]=255&K):Wt(this,K,J,!1),J+4},y.prototype.writeFloatLE=function(K,J,we){return Qt(this,K,J,!0,we)},y.prototype.writeFloatBE=function(K,J,we){return Qt(this,K,J,!1,we)},y.prototype.writeDoubleLE=function(K,J,we){return Ft(this,K,J,!0,we)},y.prototype.writeDoubleBE=function(K,J,we){return Ft(this,K,J,!1,we)},y.prototype.copy=function(K,J,we,vt){if(we||(we=0),vt||vt===0||(vt=this.length),J>=K.length&&(J=K.length),J||(J=0),vt>0&&vt<we&&(vt=we),vt===we||K.length===0||this.length===0)return 0;if(J<0)throw new RangeError("targetStart out of bounds");if(we<0||we>=this.length)throw new RangeError("sourceStart out of bounds");if(vt<0)throw new RangeError("sourceEnd out of bounds");vt>this.length&&(vt=this.length),K.length-J<vt-we&&(vt=K.length-J+we);var wt,Ot=vt-we;if(this===K&&we<J&&J<vt)for(wt=Ot-1;wt>=0;--wt)K[wt+J]=this[wt+we];else if(Ot<1e3||!y.TYPED_ARRAY_SUPPORT)for(wt=0;wt<Ot;++wt)K[wt+J]=this[wt+we];else Uint8Array.prototype.set.call(K,this.subarray(we,we+Ot),J);return Ot},y.prototype.fill=function(K,J,we,vt){if(typeof K=="string"){if(typeof J=="string"?(vt=J,J=0,we=this.length):typeof we=="string"&&(vt=we,we=this.length),K.length===1){var wt=K.charCodeAt(0);wt<256&&(K=wt)}if(vt!==void 0&&typeof vt!="string")throw new TypeError("encoding must be a string");if(typeof vt=="string"&&!y.isEncoding(vt))throw new TypeError("Unknown encoding: "+vt)}else typeof K=="number"&&(K&=255);if(J<0||this.length<J||this.length<we)throw new RangeError("Out of range index");if(we<=J)return this;var Ot;if(J>>>=0,we=we===void 0?this.length:we>>>0,K||(K=0),typeof K=="number")for(Ot=J;Ot<we;++Ot)this[Ot]=K;else{var Ae=y.isBuffer(K)?K:Kn(new y(K,vt).toString()),mt=Ae.length;for(Ot=0;Ot<we-J;++Ot)this[Ot+J]=Ae[Ot%mt]}return this};var yn=/[^+\/0-9A-Za-z-_]/g;function Nn(K){return K<16?"0"+K.toString(16):K.toString(16)}function Kn(K,J){var we;J=J||1/0;for(var vt=K.length,wt=null,Ot=[],Ae=0;Ae<vt;++Ae){if((we=K.charCodeAt(Ae))>55295&&we<57344){if(!wt){if(we>56319){(J-=3)>-1&&Ot.push(239,191,189);continue}if(Ae+1===vt){(J-=3)>-1&&Ot.push(239,191,189);continue}wt=we;continue}if(we<56320){(J-=3)>-1&&Ot.push(239,191,189),wt=we;continue}we=65536+(wt-55296<<10|we-56320)}else wt&&(J-=3)>-1&&Ot.push(239,191,189);if(wt=null,we<128){if((J-=1)<0)break;Ot.push(we)}else if(we<2048){if((J-=2)<0)break;Ot.push(we>>6|192,63&we|128)}else if(we<65536){if((J-=3)<0)break;Ot.push(we>>12|224,we>>6&63|128,63&we|128)}else{if(!(we<1114112))throw new Error("Invalid code point");if((J-=4)<0)break;Ot.push(we>>18|240,we>>12&63|128,we>>6&63|128,63&we|128)}}return Ot}function zn(K){return m.toByteArray(function(J){if((J=function(we){return we.trim?we.trim():we.replace(/^\s+|\s+$/g,"")}(J).replace(yn,"")).length<2)return"";for(;J.length%4!=0;)J+="=";return J}(K))}function sr(K,J,we,vt){for(var wt=0;wt<vt&&!(wt+we>=J.length||wt>=K.length);++wt)J[wt+we]=K[wt];return wt}}).call(this,e(40))},function(I,n,e){n.byteLength=function(S){var l=y(S),B=l[0],O=l[1];return 3*(B+O)/4-O},n.toByteArray=function(S){var l,B,O=y(S),V=O[0],L=O[1],g=new h(function(ke,Ie,he){return 3*(Ie+he)/4-he}(0,V,L)),W=0,de=L>0?V-4:V;for(B=0;B<de;B+=4)l=m[S.charCodeAt(B)]<<18|m[S.charCodeAt(B+1)]<<12|m[S.charCodeAt(B+2)]<<6|m[S.charCodeAt(B+3)],g[W++]=l>>16&255,g[W++]=l>>8&255,g[W++]=255&l;return L===2&&(l=m[S.charCodeAt(B)]<<2|m[S.charCodeAt(B+1)]>>4,g[W++]=255&l),L===1&&(l=m[S.charCodeAt(B)]<<10|m[S.charCodeAt(B+1)]<<4|m[S.charCodeAt(B+2)]>>2,g[W++]=l>>8&255,g[W++]=255&l),g},n.fromByteArray=function(S){for(var l,B=S.length,O=B%3,V=[],L=16383,g=0,W=B-O;g<W;g+=L)V.push(E(S,g,g+L>W?W:g+L));return O===1?(l=S[B-1],V.push(t[l>>2]+t[l<<4&63]+"==")):O===2&&(l=(S[B-2]<<8)+S[B-1],V.push(t[l>>10]+t[l>>4&63]+t[l<<2&63]+"=")),V.join("")};for(var t=[],m=[],h=typeof Uint8Array!="undefined"?Uint8Array:Array,b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",A=0,D=b.length;A<D;++A)t[A]=b[A],m[b.charCodeAt(A)]=A;function y(S){var l=S.length;if(l%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var B=S.indexOf("=");return B===-1&&(B=l),[B,B===l?0:4-B%4]}function E(S,l,B){for(var O,V,L=[],g=l;g<B;g+=3)O=(S[g]<<16&16711680)+(S[g+1]<<8&65280)+(255&S[g+2]),L.push(t[(V=O)>>18&63]+t[V>>12&63]+t[V>>6&63]+t[63&V]);return L.join("")}m["-".charCodeAt(0)]=62,m["_".charCodeAt(0)]=63},function(I,n){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */n.read=function(e,t,m,h,b){var A,D,y=8*b-h-1,E=(1<<y)-1,S=E>>1,l=-7,B=m?b-1:0,O=m?-1:1,V=e[t+B];for(B+=O,A=V&(1<<-l)-1,V>>=-l,l+=y;l>0;A=256*A+e[t+B],B+=O,l-=8);for(D=A&(1<<-l)-1,A>>=-l,l+=h;l>0;D=256*D+e[t+B],B+=O,l-=8);if(A===0)A=1-S;else{if(A===E)return D?NaN:1/0*(V?-1:1);D+=Math.pow(2,h),A-=S}return(V?-1:1)*D*Math.pow(2,A-h)},n.write=function(e,t,m,h,b,A){var D,y,E,S=8*A-b-1,l=(1<<S)-1,B=l>>1,O=b===23?Math.pow(2,-24)-Math.pow(2,-77):0,V=h?0:A-1,L=h?1:-1,g=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(y=isNaN(t)?1:0,D=l):(D=Math.floor(Math.log(t)/Math.LN2),t*(E=Math.pow(2,-D))<1&&(D--,E*=2),(t+=D+B>=1?O/E:O*Math.pow(2,1-B))*E>=2&&(D++,E/=2),D+B>=l?(y=0,D=l):D+B>=1?(y=(t*E-1)*Math.pow(2,b),D+=B):(y=t*Math.pow(2,B-1)*Math.pow(2,b),D=0));b>=8;e[m+V]=255&y,V+=L,y/=256,b-=8);for(D=D<<b|y,S+=b;S>0;e[m+V]=255&D,V+=L,D/=256,S-=8);e[m+V-L]|=128*g}},function(I,n){var e={}.toString;I.exports=Array.isArray||function(t){return e.call(t)=="[object Array]"}},function(I,n,e){(function(t){var m=e(9);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h=()=>e(110);let b;class A{constructor(){this.util=e(111),this.textEncoder=new this.util.TextEncoder}fetch(y,E){return Object(m.c)().global.fetch!=null?Object(m.c)().global.fetch(y,E):(b==null&&(b=h()),b(y,E))}now(){const y=t.hrtime();return 1e3*y[0]+y[1]/1e6}encode(y,E){if(E!=="utf-8"&&E!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${E}`);return this.textEncoder.encode(y)}decode(y,E){return y.length===0?"":new this.util.TextDecoder(E).decode(y)}}Object(m.c)().get("IS_NODE")&&!Object(m.c)().get("IS_BROWSER")&&Object(m.c)().setPlatform("node",new A)}).call(this,e(41))},function(I,n){},function(I,n){},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l,B=this,O=(l=4022871197,function(V){V=String(V);for(var L=0;L<V.length;L++){var g=.02519603282416938*(l+=V.charCodeAt(L));g-=l=g>>>0,l=(g*=l)>>>0,l+=4294967296*(g-=l)}return 23283064365386963e-26*(l>>>0)});B.next=function(){var V=2091639*B.s0+23283064365386963e-26*B.c;return B.s0=B.s1,B.s1=B.s2,B.s2=V-(B.c=0|V)},B.c=1,B.s0=O(" "),B.s1=O(" "),B.s2=O(" "),B.s0-=O(S),B.s0<0&&(B.s0+=1),B.s1-=O(S),B.s1<0&&(B.s1+=1),B.s2-=O(S),B.s2<0&&(B.s2+=1),O=null}function y(S,l){return l.c=S.c,l.s0=S.s0,l.s1=S.s1,l.s2=S.s2,l}function E(S,l){var B=new D(S),O=l&&l.state,V=B.next;return V.int32=function(){return 4294967296*B.next()|0},V.double=function(){return V()+11102230246251565e-32*(2097152*V()|0)},V.quick=V,O&&(typeof O=="object"&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.alea=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l=this,B="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var V=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^V^V>>>8},S===(0|S)?l.x=S:B+=S;for(var O=0;O<B.length+64;O++)l.x^=0|B.charCodeAt(O),l.next()}function y(S,l){return l.x=S.x,l.y=S.y,l.z=S.z,l.w=S.w,l}function E(S,l){var B=new D(S),O=l&&l.state,V=function(){return(B.next()>>>0)/4294967296};return V.double=function(){do var L=((B.next()>>>11)+(B.next()>>>0)/4294967296)/2097152;while(L===0);return L},V.int32=B.next,V.quick=V,O&&(typeof O=="object"&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.xor128=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l=this,B="";l.next=function(){var V=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^V^V<<1)|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,S===(0|S)?l.x=S:B+=S;for(var O=0;O<B.length+64;O++)l.x^=0|B.charCodeAt(O),O==B.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function y(S,l){return l.x=S.x,l.y=S.y,l.z=S.z,l.w=S.w,l.v=S.v,l.d=S.d,l}function E(S,l){var B=new D(S),O=l&&l.state,V=function(){return(B.next()>>>0)/4294967296};return V.double=function(){do var L=((B.next()>>>11)+(B.next()>>>0)/4294967296)/2097152;while(L===0);return L},V.int32=B.next,V.quick=V,O&&(typeof O=="object"&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.xorwow=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l=this;l.next=function(){var B,O,V=l.x,L=l.i;return B=V[L],O=(B^=B>>>7)^B<<24,O^=(B=V[L+1&7])^B>>>10,O^=(B=V[L+3&7])^B>>>3,O^=(B=V[L+4&7])^B<<7,B=V[L+7&7],O^=(B^=B<<13)^B<<9,V[L]=O,l.i=L+1&7,O},function(B,O){var V,L=[];if(O===(0|O))L[0]=O;else for(O=""+O,V=0;V<O.length;++V)L[7&V]=L[7&V]<<15^O.charCodeAt(V)+L[V+1&7]<<13;for(;L.length<8;)L.push(0);for(V=0;V<8&&L[V]===0;++V);for(V==8?L[7]=-1:L[V],B.x=L,B.i=0,V=256;V>0;--V)B.next()}(l,S)}function y(S,l){return l.x=S.x.slice(),l.i=S.i,l}function E(S,l){S==null&&(S=+new Date);var B=new D(S),O=l&&l.state,V=function(){return(B.next()>>>0)/4294967296};return V.double=function(){do var L=((B.next()>>>11)+(B.next()>>>0)/4294967296)/2097152;while(L===0);return L},V.int32=B.next,V.quick=V,O&&(O.x&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.xorshift7=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l=this;l.next=function(){var B,O,V=l.w,L=l.X,g=l.i;return l.w=V=V+1640531527|0,O=L[g+34&127],B=L[g=g+1&127],O^=O<<13,B^=B<<17,O^=O>>>15,B^=B>>>12,O=L[g]=O^B,l.i=g,O+(V^V>>>16)|0},function(B,O){var V,L,g,W,de,ke=[],Ie=128;for(O===(0|O)?(L=O,O=null):(O+="\0",L=0,Ie=Math.max(Ie,O.length)),g=0,W=-32;W<Ie;++W)O&&(L^=O.charCodeAt((W+32)%O.length)),W===0&&(de=L),L^=L<<10,L^=L>>>15,L^=L<<4,L^=L>>>13,W>=0&&(de=de+1640531527|0,g=(V=ke[127&W]^=L+de)==0?g+1:0);for(g>=128&&(ke[127&(O&&O.length||0)]=-1),g=127,W=512;W>0;--W)L=ke[g+34&127],V=ke[g=g+1&127],L^=L<<13,V^=V<<17,L^=L>>>15,V^=V>>>12,ke[g]=L^V;B.w=de,B.X=ke,B.i=g}(l,S)}function y(S,l){return l.i=S.i,l.w=S.w,l.X=S.X.slice(),l}function E(S,l){S==null&&(S=+new Date);var B=new D(S),O=l&&l.state,V=function(){return(B.next()>>>0)/4294967296};return V.double=function(){do var L=((B.next()>>>11)+(B.next()>>>0)/4294967296)/2097152;while(L===0);return L},V.int32=B.next,V.quick=V,O&&(O.X&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.xor4096=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){(function(t){var m;(function(h,b,A){function D(S){var l=this,B="";l.next=function(){var V=l.b,L=l.c,g=l.d,W=l.a;return V=V<<25^V>>>7^L,L=L-g|0,g=g<<24^g>>>8^W,W=W-V|0,l.b=V=V<<20^V>>>12^L,l.c=L=L-g|0,l.d=g<<16^L>>>16^W,l.a=W-V|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,S===Math.floor(S)?(l.a=S/4294967296|0,l.b=0|S):B+=S;for(var O=0;O<B.length+20;O++)l.b^=0|B.charCodeAt(O),l.next()}function y(S,l){return l.a=S.a,l.b=S.b,l.c=S.c,l.d=S.d,l}function E(S,l){var B=new D(S),O=l&&l.state,V=function(){return(B.next()>>>0)/4294967296};return V.double=function(){do var L=((B.next()>>>11)+(B.next()>>>0)/4294967296)/2097152;while(L===0);return L},V.int32=B.next,V.quick=V,O&&(typeof O=="object"&&y(O,B),V.state=function(){return y(B,{})}),V}b&&b.exports?b.exports=E:e(27)&&e(43)?(m=function(){return E}.call(n,e,n,b))===void 0||(b.exports=m):this.tychei=E})(0,t,e(27))}).call(this,e(42)(I))},function(I,n,e){var t;(function(m,h,b){var A,D=256,y=b.pow(D,6),E=b.pow(2,52),S=2*E,l=255;function B(de,ke,Ie){var he=[],Q=g(L((ke=ke==1?{entropy:!0}:ke||{}).entropy?[de,W(h)]:de==null?function(){try{var G;return A&&(G=A.randomBytes)?G=G(D):(G=new Uint8Array(D),(m.crypto||m.msCrypto).getRandomValues(G)),W(G)}catch{var He=m.navigator,me=He&&He.plugins;return[+new Date,m,me,m.screen,W(h)]}}():de,3),he),Se=new O(he),Z=function(){for(var G=Se.g(6),He=y,me=0;G<E;)G=(G+me)*D,He*=D,me=Se.g(1);for(;G>=S;)G/=2,He/=2,me>>>=1;return(G+me)/He};return Z.int32=function(){return 0|Se.g(4)},Z.quick=function(){return Se.g(4)/4294967296},Z.double=Z,g(W(Se.S),h),(ke.pass||Ie||function(G,He,me,et){return et&&(et.S&&V(et,Se),G.state=function(){return V(Se,{})}),me?(b.random=G,He):G})(Z,Q,"global"in ke?ke.global:this==b,ke.state)}function O(de){var ke,Ie=de.length,he=this,Q=0,Se=he.i=he.j=0,Z=he.S=[];for(Ie||(de=[Ie++]);Q<D;)Z[Q]=Q++;for(Q=0;Q<D;Q++)Z[Q]=Z[Se=l&Se+de[Q%Ie]+(ke=Z[Q])],Z[Se]=ke;(he.g=function(G){for(var He,me=0,et=he.i,rt=he.j,It=he.S;G--;)He=It[et=l&et+1],me=me*D+It[l&(It[et]=It[rt=l&rt+He])+(It[rt]=He)];return he.i=et,he.j=rt,me})(D)}function V(de,ke){return ke.i=de.i,ke.j=de.j,ke.S=de.S.slice(),ke}function L(de,ke){var Ie,he=[],Q=typeof de;if(ke&&Q=="object")for(Ie in de)try{he.push(L(de[Ie],ke-1))}catch{}return he.length?he:Q=="string"?de:de+"\0"}function g(de,ke){for(var Ie,he=de+"",Q=0;Q<he.length;)ke[l&Q]=l&(Ie^=19*ke[l&Q])+he.charCodeAt(Q++);return W(ke)}function W(de){return String.fromCharCode.apply(0,de)}if(g(b.random(),h),I.exports){I.exports=B;try{A=e(119)}catch{}}else(t=function(){return B}.call(n,e,n,I))===void 0||(I.exports=t)})(typeof self!="undefined"?self:this,[],Math)},function(I,n){},function(I,n,e){(function(t){var m=typeof t!="undefined"&&t||typeof self!="undefined"&&self||window,h=Function.prototype.apply;function b(A,D){this._id=A,this._clearFn=D}n.setTimeout=function(){return new b(h.call(setTimeout,m,arguments),clearTimeout)},n.setInterval=function(){return new b(h.call(setInterval,m,arguments),clearInterval)},n.clearTimeout=n.clearInterval=function(A){A&&A.close()},b.prototype.unref=b.prototype.ref=function(){},b.prototype.close=function(){this._clearFn.call(m,this._id)},n.enroll=function(A,D){clearTimeout(A._idleTimeoutId),A._idleTimeout=D},n.unenroll=function(A){clearTimeout(A._idleTimeoutId),A._idleTimeout=-1},n._unrefActive=n.active=function(A){clearTimeout(A._idleTimeoutId);var D=A._idleTimeout;D>=0&&(A._idleTimeoutId=setTimeout(function(){A._onTimeout&&A._onTimeout()},D))},e(121),n.setImmediate=typeof self!="undefined"&&self.setImmediate||typeof t!="undefined"&&t.setImmediate||this&&this.setImmediate,n.clearImmediate=typeof self!="undefined"&&self.clearImmediate||typeof t!="undefined"&&t.clearImmediate||this&&this.clearImmediate}).call(this,e(40))},function(I,n,e){(function(t,m){(function(h,b){if(!h.setImmediate){var A,D,y,E,S,l=1,B={},O=!1,V=h.document,L=Object.getPrototypeOf&&Object.getPrototypeOf(h);L=L&&L.setTimeout?L:h,{}.toString.call(h.process)==="[object process]"?A=function(de){m.nextTick(function(){W(de)})}:function(){if(h.postMessage&&!h.importScripts){var de=!0,ke=h.onmessage;return h.onmessage=function(){de=!1},h.postMessage("","*"),h.onmessage=ke,de}}()?(E="setImmediate$"+Math.random()+"$",S=function(de){de.source===h&&typeof de.data=="string"&&de.data.indexOf(E)===0&&W(+de.data.slice(E.length))},h.addEventListener?h.addEventListener("message",S,!1):h.attachEvent("onmessage",S),A=function(de){h.postMessage(E+de,"*")}):h.MessageChannel?((y=new MessageChannel).port1.onmessage=function(de){W(de.data)},A=function(de){y.port2.postMessage(de)}):V&&"onreadystatechange"in V.createElement("script")?(D=V.documentElement,A=function(de){var ke=V.createElement("script");ke.onreadystatechange=function(){W(de),ke.onreadystatechange=null,D.removeChild(ke),ke=null},D.appendChild(ke)}):A=function(de){setTimeout(W,0,de)},L.setImmediate=function(de){typeof de!="function"&&(de=new Function(""+de));for(var ke=new Array(arguments.length-1),Ie=0;Ie<ke.length;Ie++)ke[Ie]=arguments[Ie+1];var he={callback:de,args:ke};return B[l]=he,A(l),l++},L.clearImmediate=g}function g(de){delete B[de]}function W(de){if(O)setTimeout(W,0,de);else{var ke=B[de];if(ke){O=!0;try{(function(Ie){var he=Ie.callback,Q=Ie.args;switch(Q.length){case 0:he();break;case 1:he(Q[0]);break;case 2:he(Q[0],Q[1]);break;case 3:he(Q[0],Q[1],Q[2]);break;default:he.apply(void 0,Q)}})(ke)}finally{g(de),O=!1}}}}})(typeof self=="undefined"?typeof t=="undefined"?this:t:self)}).call(this,e(40),e(41))},function(I,n){},function(I,n){},function(I,n){}]);class Pd{constructor(n,e,t,m,h=0,b=[]){this.xmin=n,this.ymin=e,this.xmax=t,this.ymax=m,this.confidence=h,this.classes=b,this.label=-1,this.score=-1}getLabel(){if(this.label===-1){let n=0,e=0;for(let t=0;t<this.classes.length;++t)this.classes[t]>n&&(n=this.classes[t],e=t);this.label=e}return this.label}getScore(){return this.score===-1&&(this.score=this.classes[this.getLabel()]),this.score}}function Bd(I,n,e){const{numClasses:t=20,numBoxes:m=5,gridHeight:h=13,gridWidth:b=13,objThreshold:A=.5,nmsThreshold:D=.3}=I,y=4+1+t;for(let g=0;g<h*b*m;++g)n[y*g+4]=$l(n[y*g+4]);const E=[],S=[];for(let g=0;g<h*b*m;++g){let W=n.slice((t+5)*g+5,(t+5)*(g+1));W=Ud(W);let de=!1;for(let ke=0;ke<t;++ke){const Ie=n[y*g+4]*W[ke];W[ke]=0,Ie>A&&(W[ke]=Ie,de=!0)}E.push(W),de&&S.push(g)}const l=[];S.forEach(g=>{const W=E[g],de=g%m,ke=(g-de)/m%b,Ie=((g-de)/m-ke)/b%h;let he=n[y*g+0],Q=n[y*g+1],Se=n[y*g+2],Z=n[y*g+3];he=(ke+$l(he))/b,Q=(Ie+$l(Q))/h,Se=e[2*de+0]*Math.exp(Se)/b,Z=e[2*de+1]*Math.exp(Z)/h;const G=n[y*g+4],He=new Pd(he-Se/2,Q-Z/2,he+Se/2,Q+Z/2,G,W);l.push(He)});const B=[];let O=[];for(let g=0;g<t;++g){for(let W=0;W<l.length;++W)B[W]=[l[W],W];O=B.sort((W,de)=>de[0].classes[g]-W[0].classes[g]);for(let W=0;W<O.length;++W)if(O[W][0].classes[g]!==0)for(let de=W+1;de<O.length;++de)zd(O[W][0],O[de][0])>=D&&(l[O[de][1]].classes[g]=0)}const V=[];l.forEach(g=>{g.getScore()>A&&V.push(g)});const L=[];for(let g=0;g<V.length;++g){if(Math.max(...V[g].classes)===0)continue;const W=V[g].getLabel(),de=V[g].score,ke=(V[g].xmax+V[g].xmin)/2,Ie=(V[g].ymax+V[g].ymin)/2,he=V[g].xmax-V[g].xmin,Q=V[g].ymax-V[g].ymin;L.push([W,ke,Ie,he,Q,de])}return L}function Ld(I,n){const e=[];for(let t=0;t<I.length;++t){const m=I[t][0],h=I[t][1],b=I[t][2],A=I[t][3],D=I[t][4],y=I[t][5],[E,S,l,B]=Wd(h,b,A,D,n);e.push([m,E,S,l,B,y])}return e}function jd(I,n,e,t){const m=n.getContext("2d"),h=I.naturalWidth||I.width,b=I.naturalHeight||I.height;n.width=h/b*n.height,m.drawImage(I,0,0,n.width,n.height);const A=["#ff0000","#ffc107","#00b067","#704e99","#ff3860","#009bea"];e.forEach(D=>{const y=t[D[0]],E=D[1]*n.width,S=D[2]*n.width,l=D[3]*n.height,B=D[4]*n.height,O=D[5];m.strokeStyle=A[D[0]%A.length],m.fillStyle=A[D[0]%A.length],m.lineWidth=3,m.strokeRect(E,l,S-E,B-l),m.font="20px Arial";const V=`${y}: ${O.toFixed(2)}`,L=m.measureText(V).width;E>=2&&l>=parseInt(m.font,10)?(m.fillRect(E-2,l-parseInt(m.font,10),L+4,parseInt(m.font,10)),m.fillStyle="white",m.textAlign="start",m.fillText(V,E,l-3)):(m.fillRect(E+2,l,L+4,parseInt(m.font,10)),m.fillStyle="white",m.textAlign="start",m.fillText(V,E+2,l+15))})}function zd(I,n){const e=ql([I.xmin,I.xmax],[n.xmin,n.xmax]),t=ql([I.ymin,I.ymax],[n.ymin,n.ymax]),m=e*t,h=I.xmax-I.xmin,b=I.ymax-I.ymin,A=n.xmax-n.xmin,D=n.ymax-n.ymin,y=h*b+A*D-m;return m/y}function ql(I,n){const[e,t]=I,[m,h]=n;return m<e?h<e?0:Math.min(t,h)-e:t<m?0:Math.min(t,h)-m}function $l(I){return 1/(1+Math.exp(-I))}function Ud(I){const n=Math.max(...I);let e=0;for(let t=0;t<I.length;++t)e=Math.exp(I[t]-n)+e;for(let t=0;t<I.length;++t)I[t]=Math.exp(I[t]-n)/e;return I}function Wd(I,n,e,t,m){let h=I-e/2*m[0],b=I+e/2*m[1],A=n-t/2*m[2],D=n+t/2*m[3];return h<0&&(h=0),A<0&&(A=0),b>1&&(b=1),D>1&&(D=1),[h,b,A,D]}class Vd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t=!0,m=void 0){let h=this.weightsUrl,b="_mul_1.npy",A=`_sub__${e[3]}.npy`;e[0].includes("depthwise")?(h+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${e[1]}_depthwise_BatchNorm_batchnorm`,b=`_mul__${e[2]}.npy`):e[0].includes("pointwise")?e[0].includes("_")?h+=`FeatureExtractor_MobilenetV1_Conv2d_13_
${e[0]}_Conv2d_${e[1]}_BatchNorm_batchnorm`:h+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${e[1]}_pointwise_BatchNorm_batchnorm`:e[0].includes("Class")?(h+=`/BoxPredictor_${e[1]}_ClassPredictor`,b="_Conv2D.npy",A=`_biases_read__${e[3]}.npy`):e[0].includes("BoxEncoding")?(h+=`/BoxPredictor_${e[1]}_BoxEncodingPredictor`,b="_Conv2D.npy",A=`_biases_read__${e[3]}.npy`):h+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_${e[1]}_BatchNorm_batchnorm`;const D=h+b,y=await Tn(this.builder,D),E=h.replace("nchw","nhwc")+A,S=await Tn(this.builder,E);return m!==void 0?(m.inputLayout="nhwc",m.filterLayout="ohwi",m.autoPad="same-upper"):m={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"},e[0].includes("depthwise")&&(m.filterLayout="ihwo"),m.bias=S,t&&(m.activation=this.builder.clamp({minValue:0,maxValue:6})),this.builder.conv2d(n,y,m)}async load(n){const e=[2,2],t=await this.buildConv(n,["","0","","165__cf__168"],!0,{strides:e}),m=await this.buildConv(t,["depthwise","1","161__cf__164","162__cf__165"],!0,{groups:32}),h=await this.buildConv(m,["pointwise","1","","159__cf__162"]),b=await this.buildConv(h,["depthwise","2","155__cf__158","156__cf__159"],!0,{strides:e,groups:64}),A=await this.buildConv(b,["pointwise","2","","153__cf__156"]),D=await this.buildConv(A,["depthwise","3","149__cf__152","150__cf__153"],!0,{groups:128}),y=await this.buildConv(D,["pointwise","3","","147__cf__150"]),E=await this.buildConv(y,["depthwise","4","143__cf__146","144__cf__147"],!0,{strides:e,groups:128}),S=await this.buildConv(E,["pointwise","4","","141__cf__144"]),l=await this.buildConv(S,["depthwise","5","137__cf__140","138__cf__141"],!0,{groups:256}),B=await this.buildConv(l,["pointwise","5","","135__cf__138"]),O=await this.buildConv(B,["depthwise","6","131__cf__134","132__cf__135"],!0,{strides:e,groups:256}),V=await this.buildConv(O,["pointwise","6","","129__cf__132"]),L=await this.buildConv(V,["depthwise","7","125__cf__128","126__cf__129"],!0,{groups:512}),g=await this.buildConv(L,["pointwise","7","","123__cf__126"]),W=await this.buildConv(g,["depthwise","8","119__cf__122","120__cf__123"],!0,{groups:512}),de=await this.buildConv(W,["pointwise","8","","117__cf__120"]),ke=await this.buildConv(de,["depthwise","9","113__cf__116","114__cf__117"],!0,{groups:512}),Ie=await this.buildConv(ke,["pointwise","9","","111__cf__114"]),he=await this.buildConv(Ie,["depthwise","10","107__cf__110","108__cf__111"],!0,{groups:512}),Q=await this.buildConv(he,["pointwise","10","","105__cf__108"]),Se=await this.buildConv(Q,["depthwise","11","101__cf__104","102__cf__105"],!0,{groups:512}),Z=await this.buildConv(Se,["pointwise","11","","99__cf__102"]),G=await this.buildConv(Z,["depthwise","12","95__cf__98","96__cf__99"],!0,{strides:e,groups:512}),He=await this.buildConv(G,["pointwise","12","","93__cf__96"]),me=await this.buildConv(He,["depthwise","13","89__cf__92","90__cf__93"],!0,{groups:1024}),et=await this.buildConv(me,["pointwise","13","","87__cf__90"]),rt=await this.buildConv(et,["pointwise_1","2_1x1_256","","84__cf__87"]),It=await this.buildConv(rt,["pointwise_2","2_3x3_s2_512","","81__cf__84"],!0,{strides:e}),X=await this.buildConv(It,["pointwise_1","3_1x1_128","","78__cf__81"]),$t=await this.buildConv(X,["pointwise_2","3_3x3_s2_256","","75__cf__78"],!0,{strides:e}),Ct=await this.buildConv($t,["pointwise_1","4_1x1_128","","72__cf__75"]),Gt=await this.buildConv(Ct,["pointwise_2","4_3x3_s2_256","","69__cf__72"],!0,{strides:e}),Wt=await this.buildConv(Gt,["pointwise_1","5_1x1_64","","66__cf__69"]),lt=await this.buildConv(Wt,["pointwise_2","5_3x3_s2_128","","63__cf__66"],!0,{strides:e}),Qt=await this.buildConv(Z,["BoxEncoding","0","","177__cf__180"],!1),Ft=this.builder.reshape(Qt,[1,1083,1,4]),yn=await this.buildConv(et,["BoxEncoding","1","","175__cf__178"],!1),Nn=this.builder.reshape(yn,[1,600,1,4]),Kn=await this.buildConv(It,["BoxEncoding","2","","173__cf__176"],!1),zn=this.builder.reshape(Kn,[1,150,1,4]),sr=await this.buildConv($t,["BoxEncoding","3","","171__cf__174"],!1),K=this.builder.reshape(sr,[1,54,1,4]),J=await this.buildConv(Gt,["BoxEncoding","4","","169__cf__172"],!1),we=this.builder.reshape(J,[1,24,1,4]),vt=await this.buildConv(lt,["BoxEncoding","5","","167__cf__170"],!1),wt=this.builder.reshape(vt,[1,6,1,4]),Ot=this.builder.concat([Ft,Nn,zn,K],1),Ae=this.builder.concat([Ot,we,wt],1),mt=await this.buildConv(Z,["Class","0","","51__cf__54"],!1),Mt=this.builder.reshape(mt,[1,1083,91]),Nt=await this.buildConv(et,["Class","1","","49__cf__52"],!1),un=this.builder.reshape(Nt,[1,600,91]),Rn=await this.buildConv(It,["Class","2","","47__cf__50"],!1),oe=this.builder.reshape(Rn,[1,150,91]),le=await this.buildConv($t,["Class","3","","45__cf__48"],!1),qe=this.builder.reshape(le,[1,54,91]),Mn=await this.buildConv(Gt,["Class","4","","43__cf__46"],!1),zr=this.builder.reshape(Mn,[1,24,91]),Ur=await this.buildConv(lt,["Class","5","","41__cf__44"],!1),_r=this.builder.reshape(Ur,[1,6,91]),ir=this.builder.concat([Mt,un,oe,qe],1),Zn=this.builder.concat([ir,zr,_r],1);return{boxes:Ae,scores:Zn}}}class Gd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t=!0,m=void 0){let h=this.weightsUrl,b="_mul_1.npy",A=`_sub__${e[3]}.npy`;e[0].includes("depthwise")?(h+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${e[1]}_depthwise_BatchNorm_batchnorm`,b=`_mul__${e[2]}.npy`):e[0].includes("pointwise")?e[0].includes("_")?h+=`FeatureExtractor_MobilenetV1_Conv2d_13_
${e[0]}_Conv2d_${e[1]}_BatchNorm_batchnorm`:h+=`FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${e[1]}_pointwise_BatchNorm_batchnorm`:e[0].includes("Class")?(h+=`/BoxPredictor_${e[1]}_ClassPredictor`,b="_Conv2D.npy",A=`_biases_read__${e[3]}.npy`):e[0].includes("BoxEncoding")?(h+=`/BoxPredictor_${e[1]}_BoxEncodingPredictor`,b="_Conv2D.npy",A=`_biases_read__${e[3]}.npy`):h+=`/FeatureExtractor_MobilenetV1_MobilenetV1_Conv2d_
${e[1]}_BatchNorm_batchnorm`;const D=h+b,y=await Tn(this.builder,D),E=h+A,S=await Tn(this.builder,E);return m!==void 0?(m.inputLayout="nhwc",m.filterLayout="ohwi",m.autoPad="same-upper"):m={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"},e[0].includes("depthwise")&&(m.filterLayout="ihwo"),m.bias=S,t&&(m.activation=this.builder.clamp({minValue:0,maxValue:6})),this.builder.conv2d(n,y,m)}async load(n){const e=[2,2],t=await this.buildConv(n,["","0","","165__cf__168"],!0,{strides:e}),m=await this.buildConv(t,["depthwise","1","161__cf__164","162__cf__165"],!0,{groups:32}),h=await this.buildConv(m,["pointwise","1","","159__cf__162"]),b=await this.buildConv(h,["depthwise","2","155__cf__158","156__cf__159"],!0,{strides:e,groups:64}),A=await this.buildConv(b,["pointwise","2","","153__cf__156"]),D=await this.buildConv(A,["depthwise","3","149__cf__152","150__cf__153"],!0,{groups:128}),y=await this.buildConv(D,["pointwise","3","","147__cf__150"]),E=await this.buildConv(y,["depthwise","4","143__cf__146","144__cf__147"],!0,{strides:e,groups:128}),S=await this.buildConv(E,["pointwise","4","","141__cf__144"]),l=await this.buildConv(S,["depthwise","5","137__cf__140","138__cf__141"],!0,{groups:256}),B=await this.buildConv(l,["pointwise","5","","135__cf__138"]),O=await this.buildConv(B,["depthwise","6","131__cf__134","132__cf__135"],!0,{strides:e,groups:256}),V=await this.buildConv(O,["pointwise","6","","129__cf__132"]),L=await this.buildConv(V,["depthwise","7","125__cf__128","126__cf__129"],!0,{groups:512}),g=await this.buildConv(L,["pointwise","7","","123__cf__126"]),W=await this.buildConv(g,["depthwise","8","119__cf__122","120__cf__123"],!0,{groups:512}),de=await this.buildConv(W,["pointwise","8","","117__cf__120"]),ke=await this.buildConv(de,["depthwise","9","113__cf__116","114__cf__117"],!0,{groups:512}),Ie=await this.buildConv(ke,["pointwise","9","","111__cf__114"]),he=await this.buildConv(Ie,["depthwise","10","107__cf__110","108__cf__111"],!0,{groups:512}),Q=await this.buildConv(he,["pointwise","10","","105__cf__108"]),Se=await this.buildConv(Q,["depthwise","11","101__cf__104","102__cf__105"],!0,{groups:512}),Z=await this.buildConv(Se,["pointwise","11","","99__cf__102"]),G=await this.buildConv(Z,["depthwise","12","95__cf__98","96__cf__99"],!0,{strides:e,groups:512}),He=await this.buildConv(G,["pointwise","12","","93__cf__96"]),me=await this.buildConv(He,["depthwise","13","89__cf__92","90__cf__93"],!0,{groups:1024}),et=await this.buildConv(me,["pointwise","13","","87__cf__90"]),rt=await this.buildConv(et,["pointwise_1","2_1x1_256","","84__cf__87"]),It=await this.buildConv(rt,["pointwise_2","2_3x3_s2_512","","81__cf__84"],!0,{strides:e}),X=await this.buildConv(It,["pointwise_1","3_1x1_128","","78__cf__81"]),$t=await this.buildConv(X,["pointwise_2","3_3x3_s2_256","","75__cf__78"],!0,{strides:e}),Ct=await this.buildConv($t,["pointwise_1","4_1x1_128","","72__cf__75"]),Gt=await this.buildConv(Ct,["pointwise_2","4_3x3_s2_256","","69__cf__72"],!0,{strides:e}),Wt=await this.buildConv(Gt,["pointwise_1","5_1x1_64","","66__cf__69"]),lt=await this.buildConv(Wt,["pointwise_2","5_3x3_s2_128","","63__cf__66"],!0,{strides:e}),Qt=await this.buildConv(Z,["BoxEncoding","0","","177__cf__180"],!1),Ft=this.builder.reshape(Qt,[1,1083,1,4]),yn=await this.buildConv(et,["BoxEncoding","1","","175__cf__178"],!1),Nn=this.builder.reshape(yn,[1,600,1,4]),Kn=await this.buildConv(It,["BoxEncoding","2","","173__cf__176"],!1),zn=this.builder.reshape(Kn,[1,150,1,4]),sr=await this.buildConv($t,["BoxEncoding","3","","171__cf__174"],!1),K=this.builder.reshape(sr,[1,54,1,4]),J=await this.buildConv(Gt,["BoxEncoding","4","","169__cf__172"],!1),we=this.builder.reshape(J,[1,24,1,4]),vt=await this.buildConv(lt,["BoxEncoding","5","","167__cf__170"],!1),wt=this.builder.reshape(vt,[1,6,1,4]),Ot=this.builder.concat([Ft,Nn,zn,K],1),Ae=this.builder.concat([Ot,we,wt],1),mt=await this.buildConv(Z,["Class","0","","51__cf__54"],!1),Mt=this.builder.reshape(mt,[1,1083,91]),Nt=await this.buildConv(et,["Class","1","","49__cf__52"],!1),un=this.builder.reshape(Nt,[1,600,91]),Rn=await this.buildConv(It,["Class","2","","47__cf__50"],!1),oe=this.builder.reshape(Rn,[1,150,91]),le=await this.buildConv($t,["Class","3","","45__cf__48"],!1),qe=this.builder.reshape(le,[1,54,91]),Mn=await this.buildConv(Gt,["Class","4","","43__cf__46"],!1),zr=this.builder.reshape(Mn,[1,24,91]),Ur=await this.buildConv(lt,["Class","5","","41__cf__44"],!1),_r=this.builder.reshape(Ur,[1,6,91]),ir=this.builder.concat([Mt,un,oe,qe],1),Zn=this.builder.concat([ir,zr,_r],1);return{boxes:Ae,scores:Zn}}}class Hd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t=!0,m={}){const h=this.weightsUrl+"conv_"+e,b=h+"_weight.npy",A=await Tn(this.builder,b),D=h+"_bias.npy";return m.bias=await Tn(this.builder,D),t?m.activation=this.builder.clamp({minValue:0,maxValue:6}):m.activation=void 0,this.builder.conv2d(n,A,m)}async buildGemm_(n,e){const t=this.weightsUrl+"gemm_"+e,m=t+"_weight.npy",h=await Tn(this.builder,m),b=t+"_bias.npy",D={c:await Tn(this.builder,b),bTranspose:!0};return this.builder.gemm(n,h,D)}async buildLinearBottleneck_(n,e,t,m,h=!0){const b=await this.buildConv(n,e[0]),A={padding:[1,1,1,1],groups:t,strides:[m,m]},D=await this.buildConv(b,e[1],!0,A),y=await this.buildConv(D,e[2],!1);return h?this.builder.add(n,y):y}async load(n){const e=await this.buildConv(n,"0",!0,{padding:[1,1,1,1],strides:[2,2]}),t=await this.buildConv(e,"2",!0,{padding:[1,1,1,1],groups:32}),m=await this.buildConv(t,"4",!1),h=await this.buildLinearBottleneck_(m,["5","7","9"],96,2,!1),b=await this.buildLinearBottleneck_(h,["10","12","14"],144,1),A=await this.buildLinearBottleneck_(b,["16","18","20"],144,2,!1),D=await this.buildLinearBottleneck_(A,["21","23","25"],192,1),y=await this.buildLinearBottleneck_(D,["27","29","31"],192,1),E=await this.buildLinearBottleneck_(y,["33","35","37"],192,2,!1),S=await this.buildLinearBottleneck_(E,["38","40","42"],384,1),l=await this.buildLinearBottleneck_(S,["44","46","48"],384,1),B=await this.buildLinearBottleneck_(l,["50","52","54"],384,1),O=await this.buildLinearBottleneck_(B,["56","58","60"],384,1,!1),V=await this.buildLinearBottleneck_(O,["61","63","65"],576,1),L=await this.buildLinearBottleneck_(V,["67","69","71"],576,1),g=await this.buildLinearBottleneck_(L,["73","75","77"],576,2,!1),W=await this.buildLinearBottleneck_(g,["78","80","82"],960,1),de=await this.buildLinearBottleneck_(W,["84","86","88"],960,1),ke=await this.buildLinearBottleneck_(de,["90","92","94"],960,1,!1),Ie=await this.buildConv(ke,"95",!0),he=this.builder.averagePool2d(Ie),Q=this.builder.reshape(he,[1,null]),Se=await this.buildGemm_(Q,"104");return this.builder.softmax(Se)}}class qd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t,m,h){const b=this.weightsUrl+"Const_"+e+".npy",A=await Tn(this.builder,b),D=this.weightsUrl+"MobilenetV2_"+t+"_bias.npy",y=await Tn(this.builder,D);return h.inputLayout="nhwc",h.bias=y,m?h.activation=this.builder.clamp({minValue:0,maxValue:6}):h.activation=void 0,this.builder.conv2d(n,A,h)}async buildLinearBottleneck(n,e,t,m,h=!0){const b="same-upper",A="expanded_conv_"+t;m.autoPad=b,m.filterLayout="ihwo";const D={autoPad:b,filterLayout:"ohwi"},y=await this.buildConv(n,e[0],`${A}_expand_Conv2D`,!0,D),E=await this.buildConv(y,e[1],`${A}_depthwise_depthwise`,!0,m),S=await this.buildConv(E,e[2],`${A}_project_Conv2D`,!1,D);return h?this.builder.add(n,S):S}async load(n){const e=[2,2],t="same-upper",m="ohwi",h=await this.buildConv(n,"90","Conv_Conv2D",!0,{strides:e,autoPad:t,filterLayout:m}),b=await this.buildConv(h,"238","expanded_conv_depthwise_depthwise",!0,{autoPad:t,groups:32,filterLayout:"ihwo"}),A=await this.buildConv(b,"167","expanded_conv_project_Conv2D",!1,{autoPad:t,filterLayout:m}),D=await this.buildLinearBottleneck(A,["165","99","73"],"1",{strides:e,groups:96},!1),y=await this.buildLinearBottleneck(D,["3","119","115"],"2",{groups:144}),E=await this.buildLinearBottleneck(y,["255","216","157"],"3",{strides:e,groups:144},!1),S=await this.buildLinearBottleneck(E,["227","221","193"],"4",{groups:192}),l=await this.buildLinearBottleneck(S,["243","102","215"],"5",{groups:192}),B=await this.buildLinearBottleneck(l,["226","163","229"],"6",{strides:e,groups:192},!1),O=await this.buildLinearBottleneck(B,["104","254","143"],"7",{groups:384}),V=await this.buildLinearBottleneck(O,["25","142","202"],"8",{groups:384}),L=await this.buildLinearBottleneck(V,["225","129","98"],"9",{groups:384}),g=await this.buildLinearBottleneck(L,["169","2","246"],"10",{groups:384},!1),W=await this.buildLinearBottleneck(g,["162","87","106"],"11",{groups:576}),de=await this.buildLinearBottleneck(W,["52","22","40"],"12",{groups:576}),ke=await this.buildLinearBottleneck(de,["114","65","242"],"13",{strides:e,groups:576},!1),Ie=await this.buildLinearBottleneck(ke,["203","250","92"],"14",{groups:960}),he=await this.buildLinearBottleneck(Ie,["133","130","258"],"15",{groups:960}),Q=await this.buildLinearBottleneck(he,["60","248","100"],"16",{groups:960},!1),Se=await this.buildConv(Q,"71","Conv_1_Conv2D",!0,{autoPad:t,filterLayout:m}),Z=this.builder.averagePool2d(Se,{windowDimensions:[7,7],layout:"nhwc"}),G=await this.buildConv(Z,"222","Logits_Conv2d_1c_1x1_Conv2D",!1,{autoPad:t,filterLayout:m}),He=this.builder.reshape(G,[1,null]);return this.builder.softmax(He)}}class Kd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t,m=void 0){let h="";t!==""?h=this.weightsUrl+"resnetv24_stage"+t+"_conv"+e:h=this.weightsUrl+"resnetv24_conv"+e;const b=h+"_weight.npy",A=await Tn(this.builder,b);return this.builder.conv2d(n,A,m)}async buildBatchNorm(n,e,t,m=!0){let h="";t!==""?h=this.weightsUrl+"resnetv24_stage"+t+"_batchnorm"+e:h=this.weightsUrl+"resnetv24_batchnorm"+e;const b=h+"_gamma.npy",A=h+"_beta.npy",D=h+"_running_mean.npy",y=h+"_running_var.npy",E=await Tn(this.builder,b),S=await Tn(this.builder,A),l=await Tn(this.builder,D),B=await Tn(this.builder,y),O={scale:E,bias:S};return m&&(O.activation=this.builder.relu()),this.builder.batchNormalization(n,l,B,O)}async buildGemm(n,e){const t=this.weightsUrl+"resnetv24_dense"+e,m=t+"_weight.npy",h=await Tn(this.builder,m),b=t+"_bias.npy",A=await Tn(this.builder,b),D={c:this.builder.reshape(A,[1,null]),bTranspose:!0};return this.builder.gemm(n,h,D)}async buildBottlenectV2(n,e,t,m=!1,h=1){let b=n,A=[1,1];m&&(A=[h,h]);const D=await this.buildBatchNorm(n,t[0],e),y=await this.buildConv(D,t[1],e),E=await this.buildBatchNorm(y,parseInt(t[0])+1,e),S=await this.buildConv(E,t[2],e,{padding:[1,1,1,1],strides:A}),l=await this.buildBatchNorm(S,parseInt(t[0])+2,e),B=await this.buildConv(l,t[3],e);return m&&(b=await this.buildConv(D,parseInt(t[0])+3,e,{strides:A})),this.builder.add(B,b)}async load(n){const e=await this.buildBatchNorm(n,"0","",!1),t=await this.buildConv(e,"0","",{padding:[3,3,3,3],strides:[2,2]}),m=await this.buildBatchNorm(t,"1",""),h=await this.builder.maxPool2d(m,{windowDimensions:[3,3],padding:[1,1,1,1],strides:[2,2]}),b=await this.buildBottlenectV2(h,"1",["0","0","1","2"],!0),A=await this.buildBottlenectV2(b,"1",["3","4","5","6"]),D=await this.buildBottlenectV2(A,"1",["6","7","8","9"]),y=await this.buildBottlenectV2(D,"2",["0","0","1","2"],!0,2),E=await this.buildBottlenectV2(y,"2",["3","4","5","6"]),S=await this.buildBottlenectV2(E,"2",["6","7","8","9"]),l=await this.buildBottlenectV2(S,"2",["9","10","11","12"]),B=await this.buildBottlenectV2(l,"3",["0","0","1","2"],!0,2),O=await this.buildBottlenectV2(B,"3",["3","4","5","6"]),V=await this.buildBottlenectV2(O,"3",["6","7","8","9"]),L=await this.buildBottlenectV2(V,"3",["9","10","11","12"]),g=await this.buildBottlenectV2(L,"3",["12","13","14","15"]),W=await this.buildBottlenectV2(g,"3",["15","16","17","18"]),de=await this.buildBottlenectV2(W,"4",["0","0","1","2"],!0,2),ke=await this.buildBottlenectV2(de,"4",["3","4","5","6"]),Ie=await this.buildBottlenectV2(ke,"4",["6","7","8","9"]),he=await this.buildBatchNorm(Ie,"2",""),Q=await this.builder.averagePool2d(he),Se=this.builder.reshape(Q,[1,null]),Z=await this.buildGemm(Se,"0");return this.builder.softmax(Z)}}const wo="same-upper",pu=[2,2],fu="nhwc";class Xd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t={},m=!0){let h=this.weightsUrl+"resnet_v2_50_";e[0]!==""&&e[1]!==""&&(h+=`block${e[0]}_unit_${e[1]}_bottleneck_v2_`),e[2]==="shortcut"?h+="shortcut":e[2]==="logits"?h+=e[2]:h+="conv"+e[2];const b=h+"_weights.npy",A=await Tn(this.builder,b),D=h+"_Conv2D_bias.npy",y=await Tn(this.builder,D);return t.inputLayout=fu,t.filterLayout="ohwi",t.bias=y,m&&(t.activation=this.builder.relu()),this.builder.conv2d(n,A,t)}async buildFusedBatchNorm(n,e){let t=this.weightsUrl+"resnet_v2_50_";e[0]==="postnorm"?t+="postnorm":t+=`block${e[0]}_unit_${e[1]}_bottleneck_v2_preact`;const m=t+"_FusedBatchNorm_mul_0_param.npy",h=await Tn(this.builder,m),b=t+"_FusedBatchNorm_add_param.npy",A=await Tn(this.builder,b);return this.builder.relu(this.builder.add(this.builder.mul(n,h),A))}async buildBottleneckV2(n,e,t=!1,m=!0){let h=n;const b=await this.buildFusedBatchNorm(n,e),A=await this.buildConv(b,e.concat(["1"]),{autoPad:wo});let D;t&&(h=await this.buildConv(b,e.concat(["shortcut"]),{autoPad:wo},!1)),!t&&m?(h=this.builder.maxPool2d(n,{windowDimensions:[2,2],strides:pu,layout:fu,autoPad:wo}),D=await this.buildConv(A,e.concat(["2"]),{strides:pu,padding:[1,1,1,1]})):D=await this.buildConv(A,e.concat(["2"]),{autoPad:wo});const y=await this.buildConv(D,e.concat(["3"]),{autoPad:wo},!1);return this.builder.add(y,h)}async load(n){const e=await this.buildConv(n,["","","1"],{strides:pu,padding:[3,3,3,3]},!1),t=this.builder.maxPool2d(e,{windowDimensions:[3,3],strides:pu,layout:fu,autoPad:wo}),m=await this.buildBottleneckV2(t,["1","1"],!0),h=await this.buildBottleneckV2(m,["1","2"],!1,!1),b=await this.buildBottleneckV2(h,["1","3"]),A=await this.buildBottleneckV2(b,["2","1"],!0),D=await this.buildBottleneckV2(A,["2","2"],!1,!1),y=await this.buildBottleneckV2(D,["2","3"],!1,!1),E=await this.buildBottleneckV2(y,["2","4"]),S=await this.buildBottleneckV2(E,["3","1"],!0),l=async(he,Q)=>{if(Q>5)return he;{const Se=await this.buildBottleneckV2(he,["3",Q.toString()],!1,!1);return Q++,l(Se,Q)}},B=await l(S,2),O=await this.buildBottleneckV2(B,["3","6"]),V=await this.buildBottleneckV2(O,["4","1"],!0),L=await this.buildBottleneckV2(V,["4","2"],!1,!1),g=await this.buildBottleneckV2(L,["4","3"],!1,!1),W=await this.buildFusedBatchNorm(g,["postnorm"]),de=this.builder.averagePool2d(W,{layout:fu}),ke=await this.buildConv(de,["","","logits"],{autoPad:wo},!1),Ie=this.builder.reshape(ke,[1,null]);return this.builder.softmax(Ie)}}class Yd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t={}){const m=this.weightsUrl+"squeezenet0_"+e,h=m+"_weight.npy",b=await Tn(this.builder,h),A=m+"_bias.npy",D=await Tn(this.builder,A);return t.bias=D,t.activation=this.builder.relu(),this.builder.conv2d(n,b,t)}async buildFire(n,e,t,m){const h=await this.buildConv(n,e),b=await this.buildConv(h,t),A=await this.buildConv(h,m,{padding:[1,1,1,1]});return this.builder.concat([b,A],1)}async load(n){const e=await this.buildConv(n,"conv0",{strides:[2,2]}),t=this.builder.maxPool2d(e,{windowDimensions:[3,3],strides:[2,2]}),m=await this.buildFire(t,"conv1","conv2","conv3"),h=await this.buildFire(m,"conv4","conv5","conv6"),b=this.builder.maxPool2d(h,{windowDimensions:[3,3],strides:[2,2]}),A=await this.buildFire(b,"conv7","conv8","conv9"),D=await this.buildFire(A,"conv10","conv11","conv12"),y=this.builder.maxPool2d(D,{windowDimensions:[3,3],strides:[2,2]}),E=await this.buildFire(y,"conv13","conv14","conv15"),S=await this.buildFire(E,"conv16","conv17","conv18"),l=await this.buildFire(S,"conv19","conv20","conv21"),B=await this.buildFire(l,"conv22","conv23","conv24"),O=await this.buildConv(B,"conv25"),V=this.builder.averagePool2d(O,{windowDimensions:[13,13],strides:[13,13]}),L=this.builder.reshape(V,[1,null]);return this.builder.softmax(L)}}class Qd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t={}){const m=this.weightsUrl+e,h=m+"_kernel.npy",b=await Tn(this.builder,h),A=m+"_Conv2D_bias.npy",D=await Tn(this.builder,A);return t.inputLayout="nhwc",t.filterLayout="ohwi",t.bias=D,t.activation=this.builder.relu(),this.builder.conv2d(n,b,t)}async buildFire(n,e){const t=await this.buildConv(n,e+"_squeeze"),m=await this.buildConv(t,e+"_e1x1"),h=await this.buildConv(t,e+"_e3x3",{padding:[1,1,1,1]});return this.builder.concat([m,h],3)}async load(n){const e=[2,2],t="nhwc",m=await this.buildConv(n,"conv1",{strides:e,autoPad:"same-upper"}),h=this.builder.maxPool2d(m,{windowDimensions:[3,3],strides:e,layout:t}),b=await this.buildFire(h,"fire2"),A=await this.buildFire(b,"fire3"),D=await this.buildFire(A,"fire4"),y=this.builder.maxPool2d(D,{windowDimensions:[3,3],strides:e,layout:t}),E=await this.buildFire(y,"fire5"),S=await this.buildFire(E,"fire6"),l=await this.buildFire(S,"fire7"),B=await this.buildFire(l,"fire8"),O=this.builder.maxPool2d(B,{windowDimensions:[3,3],strides:e,layout:t}),V=await this.buildFire(O,"fire9"),L=await this.buildConv(V,"conv10"),g=this.builder.averagePool2d(L,{windowDimensions:[13,13],layout:t}),W=this.builder.reshape(g,[1,null]);return this.builder.softmax(W)}}class Zd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t=!1){const m=this.weightsUrl+"convolution"+e,h=m+"_W.npy",b=await Tn(this.builder,h),A={autoPad:"same-upper"};if(t){const D=m+"_B.npy";A.bias=await Tn(this.builder,D)}return this.builder.conv2d(n,b,A)}async buildBatchNorm(n,e){const t=this.weightsUrl+"BatchNormalization",m=`${t}_scale${e}.npy`,h=`${t}_B${e}.npy`,b=`${t}_mean${e}.npy`,A=`${t}_variance${e}.npy`,D=await Tn(this.builder,m),y=await Tn(this.builder,h),E=await Tn(this.builder,b),S=await Tn(this.builder,A);return this.builder.batchNormalization(n,E,S,{scale:D,bias:y,activation:this.builder.leakyRelu({alpha:.10000000149011612})})}async buildConvolutional(n,e){const t=await this.buildConv(n,e);return await this.buildBatchNorm(t,e)}async load(n){const e=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([.003921568859368563])),t=this.builder.constant({type:"float32",dimensions:[3,1,1]},new Float32Array([0,0,0])),m={windowDimensions:[2,2],strides:[2,2],autoPad:"same-upper"},h=this.builder.mul(n,e),b=this.builder.add(h,t),A=await this.buildConvolutional(b,""),D=this.builder.maxPool2d(A,m),y=await this.buildConvolutional(D,"1"),E=this.builder.maxPool2d(y,m),S=await this.buildConvolutional(E,"2"),l=this.builder.maxPool2d(S,m),B=await this.buildConvolutional(l,"3"),O=this.builder.maxPool2d(B,m),V=await this.buildConvolutional(O,"4"),L=this.builder.maxPool2d(V,m),g=await this.buildConvolutional(L,"5"),W=this.builder.maxPool2d(g,{windowDimensions:[2,2],autoPad:"same-upper"}),de=await this.buildConvolutional(W,"6"),ke=await this.buildConvolutional(de,"7");return await this.buildConv(ke,"8",!0)}}class Jd{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t=!0){const m=this.weightsUrl+"conv2d_"+e,h=m+"_kernel.npy",b=await Tn(this.builder,h),A=m+"_Conv2D_bias.npy",D=await Tn(this.builder,A),y={inputLayout:"nhwc",filterLayout:"ohwi",autoPad:"same-upper"};y.bias=D;let E=this.builder.conv2d(n,b,y);return t&&(E=this.builder.leakyRelu(E,{alpha:.10000000149011612})),E}async load(n){const e={windowDimensions:[2,2],strides:[2,2],autoPad:"same-upper",layout:"nhwc"},t=await this.buildConv(n,"1"),m=this.builder.maxPool2d(t,e),h=await this.buildConv(m,"2"),b=this.builder.maxPool2d(h,e),A=await this.buildConv(b,"3"),D=this.builder.maxPool2d(A,e),y=await this.buildConv(D,"4"),E=this.builder.maxPool2d(y,e),S=await this.buildConv(E,"5"),l=this.builder.maxPool2d(S,e),B=await this.buildConv(l,"6"),O=this.builder.maxPool2d(B,{windowDimensions:[2,2],autoPad:"same-upper",layout:"nhwc"}),V=await this.buildConv(O,"7"),L=await this.buildConv(V,"8");return await this.buildConv(L,"9",!1)}}class eh{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t="relu6",m={}){const h=this.weightsUrl.replace("nchw","nhwc")+e[0],b=`${this.weightsUrl}const_fold_opt__${e[2]}.npy`;let A=h+"_bn_offset.npy";e[0].includes("depthwise")?(A=`${h}_bn_offset.npy`,e[1]!==""&&(A=`${h}_${e[1]}.npy`)):e[0]==="logits_semantic"&&(A=h+"_biases.npy");const D=await Tn(this.builder,b),y=await Tn(this.builder,A);return m.bias=y,t==="relu6"?m.activation=this.builder.clamp({minValue:0,maxValue:6}):t==="relu"?m.activation=this.builder.relu():m.activation=void 0,this.builder.conv2d(n,D,m)}async buildLinearBottleneck(n,e,t,m=!0){const h="MobilenetV2_expanded_conv_"+e[0];let b="depthwise_bn_offset";Number.parseInt(e[0])>6&&(b="BatchNorm_FusedBatchNorm");const A=await this.buildConv(n,[`${h}_expand_Conv2D`,b,e[1]]),D=await this.buildConv(A,[`${h}_depthwise`,b,e[2]],"relu6",t),y=await this.buildConv(D,[`${h}_project_Conv2D`,b,e[3]],"none");return m?this.builder.add(n,y):y}async load(n){const e=[2,2],t=await this.buildConv(n,["MobilenetV2_Conv_Conv2D","","551"],"relu6",{strides:e,padding:[1,1,1,1]}),m=await this.buildConv(t,["MobilenetV2_expanded_conv_depthwise_depthwise","","543"],"relu6",{padding:[1,1,1,1],groups:32}),h=await this.buildConv(m,["MobilenetV2_expanded_conv_project_Conv2D","","511"],"none"),b=await this.buildLinearBottleneck(h,["1","537","494","534"],{strides:e,padding:[1,1,1,1],groups:96},!1),A=await this.buildLinearBottleneck(b,["2","447","555","523"],{padding:[1,1,1,1],groups:144}),D=await this.buildLinearBottleneck(A,["3","520","562","542"],{strides:e,padding:[1,1,1,1],groups:144},!1),y=await this.buildLinearBottleneck(D,["4","503","505","489"],{padding:[1,1,1,1],groups:192}),E=await this.buildLinearBottleneck(y,["5","446","530","522"],{padding:[1,1,1,1],groups:192}),S=await this.buildLinearBottleneck(E,["6","491","561","538"],{padding:[1,1,1,1],groups:192},!1),l=await this.buildLinearBottleneck(S,["7","487","560","478"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),B=await this.buildLinearBottleneck(l,["8","467","536","455"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),O=await this.buildLinearBottleneck(B,["9","474","524","558"],{padding:[2,2,2,2],groups:384,dilations:[2,2]}),V=await this.buildLinearBottleneck(O,["10","465","556","462"],{padding:[2,2,2,2],groups:384,dilations:[2,2]},!1),L=await this.buildLinearBottleneck(V,["11","453","532","450"],{padding:[2,2,2,2],groups:576,dilations:[2,2]}),g=await this.buildLinearBottleneck(L,["12","441","554","517"],{padding:[2,2,2,2],groups:576,dilations:[2,2]}),W=await this.buildLinearBottleneck(g,["13","544","509","479"],{padding:[2,2,2,2],groups:576,dilations:[2,2]},!1),de=await this.buildLinearBottleneck(W,["14","482","552","512"],{padding:[4,4,4,4],groups:960,dilations:[4,4]}),ke=await this.buildLinearBottleneck(de,["15","475","495","563"],{padding:[4,4,4,4],groups:960,dilations:[4,4]}),Ie=await this.buildLinearBottleneck(ke,["16","500","459","539"],{padding:[4,4,4,4],groups:960,dilations:[4,4]},!1),he=await this.buildConv(Ie,["aspp0_Conv2D","","553"],"relu"),Q=this.builder.averagePool2d(Ie,{windowDimensions:[65,65],layout:"nchw"}),Se=await this.buildConv(Q,["image_pooling_Conv2D","","546"],"relu"),Z=this.builder.resample2d(Se,{sizes:[65,65],mode:"linear"}),G=this.builder.concat([Z,he],1),He=await this.buildConv(G,["concat_projection_Conv2D","","502"],"relu"),me=await this.buildConv(He,["logits_semantic","","541"],"none"),et=this.builder.resample2d(me,{sizes:[65,65],mode:"linear"});return this.builder.resample2d(et,{sizes:[513,513],mode:"linear"})}}class th{constructor(n,e){this.weightsUrl=n,this.builder=e}async buildConv(n,e,t="",m=!0,h={}){const b=this.weightsUrl+e;let A=b+".npy",D=b+"_bn_offset.npy";e.includes("depthwise")?(A=b+"_depthwise.npy",D=`${b}_${t}.npy`):e==="logits_semantic"&&(A=b+"_Conv2D.npy",D=b+"_biases.npy");const y=await Tn(this.builder,A),E=await Tn(this.builder,D);return h.inputLayout="nhwc",h.autoPad="same-upper",e.includes("depthwise")?h.filterLayout="ihwo":h.filterLayout="ohwi",h.bias=E,m?h.activation=this.builder.clamp({minValue:0,maxValue:6}):h.activation=void 0,this.builder.conv2d(n,y,h)}async buildLinearBottleneck(n,e,t,m=!0){const h="MobilenetV2_expanded_conv_"+e;let b="depthwise_bn_offset";Number.parseInt(e)>6&&(b="BatchNorm_FusedBatchNorm");const A=await this.buildConv(n,`${h}_expand_Conv2D`),D=await this.buildConv(A,`${h}_depthwise`,b,!0,t),y=await this.buildConv(D,`${h}_project_Conv2D`,"",!1);return m?this.builder.add(n,y):y}async load(n){const e=[2,2],t=await this.buildConv(n,"MobilenetV2_Conv_Conv2D","",!0,{strides:e}),m=await this.buildConv(t,"MobilenetV2_expanded_conv_depthwise","depthwise_bn_offset",!0,{groups:32}),h=await this.buildConv(m,"MobilenetV2_expanded_conv_project_Conv2D","",!1),b=await this.buildLinearBottleneck(h,"1",{strides:e,groups:96},!1),A=await this.buildLinearBottleneck(b,"2",{groups:144}),D=await this.buildLinearBottleneck(A,"3",{strides:e,groups:144},!1),y=await this.buildLinearBottleneck(D,"4",{groups:192}),E=await this.buildLinearBottleneck(y,"5",{groups:192}),S=await this.buildLinearBottleneck(E,"6",{groups:192},!1),l=await this.buildLinearBottleneck(S,"7",{dilations:[2,2],groups:384}),B=await this.buildLinearBottleneck(l,"8",{dilations:[2,2],groups:384}),O=await this.buildLinearBottleneck(B,"9",{dilations:[2,2],groups:384}),V=await this.buildLinearBottleneck(O,"10",{dilations:[2,2],groups:384},!1),L=await this.buildLinearBottleneck(V,"11",{dilations:[2,2],groups:576}),g=await this.buildLinearBottleneck(L,"12",{dilations:[2,2],groups:576}),W=await this.buildLinearBottleneck(g,"13",{dilations:[2,2],groups:576},!1),de=await this.buildLinearBottleneck(W,"14",{dilations:[4,4],groups:960}),ke=await this.buildLinearBottleneck(de,"15",{dilations:[4,4],groups:960}),Ie=await this.buildLinearBottleneck(ke,"16",{dilations:[4,4],groups:960},!1),he=await this.buildConv(Ie,"aspp0_Conv2D"),Q=this.builder.averagePool2d(Ie,{windowDimensions:[65,65],strides:[65,65],layout:"nhwc"}),Se=await this.buildConv(Q,"image_pooling_Conv2D"),Z=this.builder.resample2d(Se,{sizes:[65,65],mode:"linear",axes:[1,2]}),G=this.builder.concat([Z,he],3),He=await this.buildConv(G,"concat_projection_Conv2D"),me=await this.buildConv(He,"logits_semantic","",!1),et=this.builder.resample2d(me,{sizes:[65,65],mode:"linear",axes:[1,2]});return this.builder.resample2d(et,{sizes:[513,513],mode:"linear",axes:[1,2]})}}class nh{constructor(n,e,t){this.weightsUrl=n,this.builder=e,this.modelId=t}buildInstanceNormalization(n,e,t){if("instanceNormalization"in this.builder)return this.builder.instanceNormalization(n,{scale:this.builder.squeeze(e),bias:this.builder.squeeze(t)});{const m=this.builder.sub(n,this.builder.reduceMean(n,{axes:[2,3],keepDimensions:!0})),h=this.builder.reduceMean(this.builder.mul(m,m),{axes:[2,3],keepDimensions:!0}),b=this.builder.pow(this.builder.add(h,this.constAdd),this.constPow),A=this.builder.mul(e,this.builder.div(m,b));return this.builder.add(A,t)}}async load(n){const e=this.weightsUrl+this.modelId+"/",t=await Tn(this.builder,e+"Variable_read__0__cf__0_0.npy"),m=await Tn(this.builder,e+"Variable_1_read__1__cf__1_0.npy"),h=await Tn(this.builder,e+"Variable_2_read__12__cf__12_0.npy"),b=await Tn(this.builder,e+"Variable_3_read__23__cf__23_0.npy"),A=await Tn(this.builder,e+"Variable_4_read__34__cf__34_0.npy"),D=await Tn(this.builder,e+"Variable_5_read__43__cf__43_0.npy"),y=await Tn(this.builder,e+"Variable_6_read__44__cf__44_0.npy"),E=await Tn(this.builder,e+"Variable_7_read__45__cf__45_0.npy"),S=await Tn(this.builder,e+"Variable_8_read__46__cf__46_0.npy"),l=await Tn(this.builder,e+"Variable_9_read__47__cf__47_0.npy"),B=await Tn(this.builder,e+"Variable_10_read__2__cf__2_0.npy"),O=await Tn(this.builder,e+"Variable_11_read__3__cf__3_0.npy"),V=await Tn(this.builder,e+"Variable_12_read__4__cf__4_0.npy"),L=await Tn(this.builder,e+"Variable_13_read__5__cf__5_0.npy"),g=await Tn(this.builder,e+"Variable_14_read__6__cf__6_0.npy"),W=await Tn(this.builder,e+"Variable_15_read__7__cf__7_0.npy"),de=await Tn(this.builder,e+"Variable_16_read__8__cf__8_0.npy"),ke=await Tn(this.builder,e+"Variable_17_read__9__cf__9_0.npy"),Ie=await Tn(this.builder,e+"Variable_18_read__10__cf__10_0.npy"),he=await Tn(this.builder,e+"Variable_19_read__11__cf__11_0.npy"),Q=await Tn(this.builder,e+"Variable_20_read__13__cf__13_0.npy"),Se=await Tn(this.builder,e+"Variable_21_read__14__cf__14_0.npy"),Z=await Tn(this.builder,e+"Variable_22_read__15__cf__15_0.npy"),G=await Tn(this.builder,e+"Variable_23_read__16__cf__16_0.npy"),He=await Tn(this.builder,e+"Variable_24_read__17__cf__17_0.npy"),me=await Tn(this.builder,e+"Variable_25_read__18__cf__18_0.npy"),et=await Tn(this.builder,e+"Variable_26_read__19__cf__19_0.npy"),rt=await Tn(this.builder,e+"Variable_27_read__20__cf__20_0.npy"),It=await Tn(this.builder,e+"Variable_28_read__21__cf__21_0.npy"),X=await Tn(this.builder,e+"Variable_29_read__22__cf__22_0.npy"),$t=await Tn(this.builder,e+"Variable_30_read__24__cf__24_0.npy"),Ct=await Tn(this.builder,e+"Variable_31_read__25__cf__25_0.npy"),Gt=await Tn(this.builder,e+"Variable_32_read__26__cf__26_0.npy"),Wt=await Tn(this.builder,e+"Variable_33_read__27__cf__27_0.npy"),lt=await Tn(this.builder,e+"Variable_34_read__28__cf__28_0.npy"),Qt=await Tn(this.builder,e+"Variable_35_read__29__cf__29_0.npy"),Ft=await Tn(this.builder,e+"Variable_36_read__30__cf__30_0.npy"),yn=await Tn(this.builder,e+"Variable_37_read__31__cf__31_0.npy"),Nn=await Tn(this.builder,e+"Variable_38_read__32__cf__32_0.npy"),Kn=await Tn(this.builder,e+"Variable_39_read__33__cf__33_0.npy"),zn=await Tn(this.builder,e+"Variable_40_read__35__cf__35_0.npy"),sr=await Tn(this.builder,e+"Variable_41_read__36__cf__36_0.npy"),K=await Tn(this.builder,e+"Variable_42_read__37__cf__37_0.npy"),J=await Tn(this.builder,e+"Variable_43_read__38__cf__38_0.npy"),we=await Tn(this.builder,e+"Variable_44_read__39__cf__39_0.npy"),vt=await Tn(this.builder,e+"Variable_45_read__40__cf__40_0.npy"),wt=await Tn(this.builder,e+"Variable_46_read__41__cf__41_0.npy"),Ot=await Tn(this.builder,e+"Variable_47_read__42__cf__42_0.npy"),Ae=[0,0,1,1],mt=[0,0,4,4];this.constAdd=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([9999999717180685e-25])),this.constPow=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([.5]));const Mt=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([150])),Nt=this.builder.constant({type:"float32",dimensions:[1]},new Float32Array([127.5])),un=this.builder.conv2d(this.builder.pad(n,mt,mt,{mode:"reflection"}),t),Rn=this.buildInstanceNormalization(un,h,m),oe=this.builder.relu(Rn),le=this.builder.conv2d(this.builder.pad(oe,Ae,Ae,{mode:"reflection"}),b,{strides:[2,2]}),qe=this.buildInstanceNormalization(le,D,A),Mn=this.builder.relu(qe),zr=this.builder.conv2d(this.builder.pad(Mn,Ae,Ae,{mode:"reflection"}),y,{strides:[2,2]}),Ur=this.buildInstanceNormalization(zr,S,E),_r=this.builder.relu(Ur),ir=this.builder.conv2d(this.builder.pad(_r,Ae,Ae,{mode:"reflection"}),l),Zn=this.buildInstanceNormalization(ir,O,B),$r=this.builder.relu(Zn),en=this.builder.conv2d(this.builder.pad($r,Ae,Ae,{mode:"reflection"}),V),mn=this.buildInstanceNormalization(en,g,L),Ln=this.builder.add(_r,mn),or=this.builder.conv2d(this.builder.pad(Ln,Ae,Ae,{mode:"reflection"}),W),lr=this.buildInstanceNormalization(or,ke,de),Qn=this.builder.relu(lr),br=this.builder.conv2d(this.builder.pad(Qn,Ae,Ae,{mode:"reflection"}),Ie),gr=this.buildInstanceNormalization(br,Q,he),At=this.builder.add(Ln,gr),q=this.builder.conv2d(this.builder.pad(At,Ae,Ae,{mode:"reflection"}),Se),ae=this.buildInstanceNormalization(q,G,Z),Qe=this.builder.relu(ae),ht=this.builder.conv2d(this.builder.pad(Qe,Ae,Ae,{mode:"reflection"}),He),Bt=this.buildInstanceNormalization(ht,et,me),Kt=this.builder.add(At,Bt),Ut=this.builder.conv2d(this.builder.pad(Kt,Ae,Ae,{mode:"reflection"}),rt),tn=this.buildInstanceNormalization(Ut,X,It),bn=this.builder.relu(tn),xn=this.builder.conv2d(this.builder.pad(bn,Ae,Ae,{mode:"reflection"}),$t),rn=this.buildInstanceNormalization(xn,Gt,Ct),Xn=this.builder.add(Kt,rn),xr=this.builder.conv2d(this.builder.pad(Xn,Ae,Ae,{mode:"reflection"}),Wt),Lr=this.buildInstanceNormalization(xr,Qt,lt),Wr=this.builder.relu(Lr),vr=this.builder.conv2d(this.builder.pad(Wr,Ae,Ae,{mode:"reflection"}),Ft),ua=this.buildInstanceNormalization(vr,Nn,yn),ma=this.builder.add(Xn,ua),Cr=this.builder.convTranspose2d(ma,Kn,{strides:[2,2],outputSizes:[270,270]}),Da=this.buildInstanceNormalization(Cr,sr,zn),kr=this.builder.relu(Da),Pr=this.builder.convTranspose2d(kr,K,{strides:[2,2],outputSizes:[540,540]}),qr=this.buildInstanceNormalization(Pr,we,J),ha=this.builder.relu(qr),Zr=this.builder.conv2d(this.builder.pad(ha,mt,mt,{mode:"reflection"}),vt),Vr=this.buildInstanceNormalization(Zr,Ot,wt);return this.builder.add(this.builder.mul(this.builder.tanh(Vr),Mt),Nt)}}class rh{constructor(n,e,t){this.context=n,this.builder=e,this.modelName=t}async compile(n){const e=performance.now();let t;this.modelName.startsWith("ssdMobilenetV1")?t=n:t={output:n};const m=await this.builder.build(t),h=performance.now();return{compiled:m,time:vu(e,h)}}async execute(n,e,t){const m=performance.now(),h={input:e},b={output:t},A=await this.context.compute(n,h,b),D=performance.now();return{executed:A,time:vu(m,D)}}async load(n,e){const t=performance.now(),m=`https://web102.in-p.de/webnn/models/${this.modelName}/weights/`;let h;switch(this.modelName){case"mobilenetv2_nchw":{h=new Hd(m,this.builder);break}case"mobilenetv2_nhwc":{h=new qd(m,this.builder);break}case"squeezenet_nchw":{h=new Yd(m,this.builder);break}case"squeezenet_nhwc":{h=new Qd(m,this.builder);break}case"resnet50v2_nchw":{h=new Kd(m,this.builder);break}case"resnet50v2_nhwc":{h=new Xd(m,this.builder);break}case"ssdMobilenetV1_nchw":{h=new Vd(m,this.builder);break}case"ssdMobilenetV1_nhwc":{h=new Gd(m,this.builder);break}case"tinyYoloV2_nchw":{h=new Zd(m,this.builder);break}case"tinyYoloV2_nhwc":{h=new Jd(m,this.builder);break}case"fastStyleTransfer_nchw":{h=new nh(m,this.builder,e);break}case"deeplabV3_nchw":{h=new eh(m,this.builder);break}case"deeplabV3_nhwc":{h=new th(m,this.builder);break}default:throw Error(`Model "${this.modelName}" not valid!`)}const b=await h.load(n),A=performance.now();return{graph:b,time:vu(t,A)}}}let Fa={};Fa.Array=class{constructor(I){if(I){const n=new Fa.Reader(I),e=[147,78,85,77,80,89];if(!n.bytes(6).every((b,A)=>b==e[A]))throw new Fa.Error("Invalid signature.");const t=n.byte(),m=n.byte();if(t!==1&&m!==0)throw new Fa.Error("Invalid version '"+[t,m].join(".")+"'.");const h=JSON.parse(n.string().trim().replace(/'/g,'"').replace("False","false").replace("(","[").replace(/,*\),*/g,"]"));if(h.fortran_order)throw new Fa.Error("Fortran order is not supported.'");if(!h.descr||h.descr.length<2)throw new Fa.Error("Missing property 'descr'.");if(!h.shape)throw new Fa.Error("Missing property 'shape'.");switch(this._shape=h.shape,this._byteOrder=h.descr[0],this._byteOrder){case"|":{this._dataType=h.descr.substring(1),this._data=n.bytes(n.size-n.position);break}case">":case"<":{if(h.descr.length!==3)throw new Fa.Error("Unsupported data type '"+h.descr+"'.");this._dataType=h.descr.substring(1);const b=parseInt(h.descr[2],10)*this._shape.reduce((A,D)=>A*D,1);this._data=n.bytes(b);break}default:throw new Fa.Error("Unsupported data type '"+h.descr+"'.")}}}get data(){return this._data}set data(I){this._data=I}get dataType(){return this._dataType}set dataType(I){this._dataType=I}get shape(){return this._shape}set shape(I){this._shape=I}get byteOrder(){return this._byteOrder}set byteOrder(I){this._byteOrder=I}toBuffer(){const I=new Fa.Writer;I.bytes([147,78,85,77,80,89]),I.byte(1),I.byte(0);const n={itemSize:1,position:0,dataType:this._dataType,byteOrder:this._byteOrder||"<",shape:this._shape,descr:""};if(n.byteOrder!=="<"&&n.byteOrder!==">")throw new Fa.Error("Unknown byte order '"+this._byteOrder+"'.");if(n.dataType.length!==2||n.dataType[0]!=="f"&&n.dataType[0]!=="i"&&n.dataType[0]!=="u")throw new Fa.Error("Unsupported data type '"+this._dataType+"'.");n.itemSize=parseInt(n.dataType[1],10);let e="";switch(this._shape.length){case 0:throw new Fa.Error("Invalid shape.");case 1:e="("+this._shape[0].toString()+",)";break;default:e="("+this._shape.map(b=>b.toString()).join(", ")+")";break}const t=["'descr': '"+n.byteOrder+n.dataType+"'","'fortran_order': False","'shape': "+e];let m="{ "+t.join(", ")+" }";m+=" ".repeat(16-(m.length+2+8+1&15))+`
`,I.string(m);const h=n.itemSize*this._shape.reduce((b,A)=>b*A);return n.data=new Uint8Array(h),n.view=new DataView(n.data.buffer,n.data.byteOffset,h),Fa.Array._encodeDimension(n,this._data,0),I.bytes(n.data),I.toBuffer()}static _encodeDimension(I,n,e){const t=I.shape[e],m=I.byteOrder==="<";if(e==I.shape.length-1)for(let h=0;h<t;h++){switch(I.dataType){case"f2":I.view.setFloat16(I.position,n[h],m);break;case"f4":I.view.setFloat32(I.position,n[h],m);break;case"f8":I.view.setFloat64(I.position,n[h],m);break;case"i1":I.view.setInt8(I.position,n[h],m);break;case"i2":I.view.setInt16(I.position,n[h],m);break;case"i4":I.view.setInt32(I.position,n[h],m);break;case"i8":I.view.setInt64(I.position,n[h],m);break;case"u1":I.view.setUint8(I.position,n[h],m);break;case"u2":I.view.setUint16(I.position,n[h],m);break;case"u4":I.view.setUint32(I.position,n[h],m);break;case"u8":I.view.setUint64(I.position,n[h],m);break}I.position+=I.itemSize}else for(let h=0;h<t;h++)Fa.Array._encodeDimension(I,n[h],e+1)}};Fa.Reader=class{constructor(I){this._buffer=I,this._position=0}get position(){return this._position}get size(){return this._buffer.length}byte(){return this._buffer[this._position++]}bytes(I){const n=this._buffer.slice(this._position,this._position+I);return this._position+=I,n}uint16(){return this.byte()|this.byte()<<8}string(){const I=this.uint16();let n="";for(let e=0;e<I;e++)n+=String.fromCharCode(this.byte());return n}};Fa.Writer=class{constructor(){this._length=0,this._head=null,this._tail=null}byte(I){this.bytes([I])}uint16(I){this.bytes([I&255,I>>8&255])}bytes(I){const n=new Uint8Array(I.length);for(let e=0;e<I.length;e++)n[e]=I[e];this._write(n)}string(I){this.uint16(I.length);const n=new Uint8Array(I.length);for(let e=0;e<I.length;e++)n[e]=I.charCodeAt(e);this._write(n)}_write(I){const n={buffer:I,next:null};this._tail?this._tail.next=n:this._head=n,this._tail=n,this._length+=n.buffer.length}toBuffer(){const I=new Uint8Array(this._length);let n=0,e=this._head;for(;e!=null;)I.set(e.buffer,n),n+=e.buffer.length,e=e.next;return I}};Fa.Error=class extends Error{constructor(I){super(I);this.name="NumPy Error"}};function ad(I,n){return function(){return I.apply(n,arguments)}}const{toString:ah}=Object.prototype,{getPrototypeOf:Bl}=Object,wu=(I=>n=>{const e=ah.call(n);return I[e]||(I[e]=e.slice(8,-1).toLowerCase())})(Object.create(null)),Ei=I=>(I=I.toLowerCase(),n=>wu(n)===I),ku=I=>n=>typeof n===I,{isArray:$o}=Array,Uo=ku("undefined");function sh(I){return I!==null&&!Uo(I)&&I.constructor!==null&&!Uo(I.constructor)&&li(I.constructor.isBuffer)&&I.constructor.isBuffer(I)}const sd=Ei("ArrayBuffer");function ih(I){let n;return typeof ArrayBuffer!="undefined"&&ArrayBuffer.isView?n=ArrayBuffer.isView(I):n=I&&I.buffer&&sd(I.buffer),n}const oh=ku("string"),li=ku("function"),id=ku("number"),_u=I=>I!==null&&typeof I=="object",uh=I=>I===!0||I===!1,mu=I=>{if(wu(I)!=="object")return!1;const n=Bl(I);return(n===null||n===Object.prototype||Object.getPrototypeOf(n)===null)&&!(Symbol.toStringTag in I)&&!(Symbol.iterator in I)},ch=Ei("Date"),lh=Ei("File"),dh=Ei("Blob"),hh=Ei("FileList"),ph=I=>_u(I)&&li(I.pipe),fh=I=>{let n;return I&&(typeof FormData=="function"&&I instanceof FormData||li(I.append)&&((n=wu(I))==="formdata"||n==="object"&&li(I.toString)&&I.toString()==="[object FormData]"))},mh=Ei("URLSearchParams"),bh=I=>I.trim?I.trim():I.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function Wo(I,n,{allOwnKeys:e=!1}={}){if(I===null||typeof I=="undefined")return;let t,m;if(typeof I!="object"&&(I=[I]),$o(I))for(t=0,m=I.length;t<m;t++)n.call(null,I[t],t,I);else{const h=e?Object.getOwnPropertyNames(I):Object.keys(I),b=h.length;let A;for(t=0;t<b;t++)A=h[t],n.call(null,I[A],A,I)}}function od(I,n){n=n.toLowerCase();const e=Object.keys(I);let t=e.length,m;for(;t-- >0;)if(m=e[t],n===m.toLowerCase())return m;return null}const ud=(()=>typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:global)(),cd=I=>!Uo(I)&&I!==ud;function Fl(){const{caseless:I}=cd(this)&&this||{},n={},e=(t,m)=>{const h=I&&od(n,m)||m;mu(n[h])&&mu(t)?n[h]=Fl(n[h],t):mu(t)?n[h]=Fl({},t):$o(t)?n[h]=t.slice():n[h]=t};for(let t=0,m=arguments.length;t<m;t++)arguments[t]&&Wo(arguments[t],e);return n}const gh=(I,n,e,{allOwnKeys:t}={})=>(Wo(n,(m,h)=>{e&&li(m)?I[h]=ad(m,e):I[h]=m},{allOwnKeys:t}),I),xh=I=>(I.charCodeAt(0)===65279&&(I=I.slice(1)),I),vh=(I,n,e,t)=>{I.prototype=Object.create(n.prototype,t),I.prototype.constructor=I,Object.defineProperty(I,"super",{value:n.prototype}),e&&Object.assign(I.prototype,e)},yh=(I,n,e,t)=>{let m,h,b;const A={};if(n=n||{},I==null)return n;do{for(m=Object.getOwnPropertyNames(I),h=m.length;h-- >0;)b=m[h],(!t||t(b,I,n))&&!A[b]&&(n[b]=I[b],A[b]=!0);I=e!==!1&&Bl(I)}while(I&&(!e||e(I,n))&&I!==Object.prototype);return n},wh=(I,n,e)=>{I=String(I),(e===void 0||e>I.length)&&(e=I.length),e-=n.length;const t=I.indexOf(n,e);return t!==-1&&t===e},kh=I=>{if(!I)return null;if($o(I))return I;let n=I.length;if(!id(n))return null;const e=new Array(n);for(;n-- >0;)e[n]=I[n];return e},_h=(I=>n=>I&&n instanceof I)(typeof Uint8Array!="undefined"&&Bl(Uint8Array)),Ih=(I,n)=>{const t=(I&&I[Symbol.iterator]).call(I);let m;for(;(m=t.next())&&!m.done;){const h=m.value;n.call(I,h[0],h[1])}},Sh=(I,n)=>{let e;const t=[];for(;(e=I.exec(n))!==null;)t.push(e);return t},Ch=Ei("HTMLFormElement"),Th=I=>I.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(e,t,m){return t.toUpperCase()+m}),Kl=(({hasOwnProperty:I})=>(n,e)=>I.call(n,e))(Object.prototype),Oh=Ei("RegExp"),ld=(I,n)=>{const e=Object.getOwnPropertyDescriptors(I),t={};Wo(e,(m,h)=>{n(m,h,I)!==!1&&(t[h]=m)}),Object.defineProperties(I,t)},$h=I=>{ld(I,(n,e)=>{if(li(I)&&["arguments","caller","callee"].indexOf(e)!==-1)return!1;const t=I[e];if(!!li(t)){if(n.enumerable=!1,"writable"in n){n.writable=!1;return}n.set||(n.set=()=>{throw Error("Can not rewrite read-only method '"+e+"'")})}})},Eh=(I,n)=>{const e={},t=m=>{m.forEach(h=>{e[h]=!0})};return $o(I)?t(I):t(String(I).split(n)),e},Ah=()=>{},Nh=(I,n)=>(I=+I,Number.isFinite(I)?I:n),El="abcdefghijklmnopqrstuvwxyz",Xl="0123456789",dd={DIGIT:Xl,ALPHA:El,ALPHA_DIGIT:El+El.toUpperCase()+Xl},Rh=(I=16,n=dd.ALPHA_DIGIT)=>{let e="";const{length:t}=n;for(;I--;)e+=n[Math.random()*t|0];return e};function Fh(I){return!!(I&&li(I.append)&&I[Symbol.toStringTag]==="FormData"&&I[Symbol.iterator])}const Mh=I=>{const n=new Array(10),e=(t,m)=>{if(_u(t)){if(n.indexOf(t)>=0)return;if(!("toJSON"in t)){n[m]=t;const h=$o(t)?[]:{};return Wo(t,(b,A)=>{const D=e(b,m+1);!Uo(D)&&(h[A]=D)}),n[m]=void 0,h}}return t};return e(I,0)},Dh=Ei("AsyncFunction"),Ph=I=>I&&(_u(I)||li(I))&&li(I.then)&&li(I.catch);var cn={isArray:$o,isArrayBuffer:sd,isBuffer:sh,isFormData:fh,isArrayBufferView:ih,isString:oh,isNumber:id,isBoolean:uh,isObject:_u,isPlainObject:mu,isUndefined:Uo,isDate:ch,isFile:lh,isBlob:dh,isRegExp:Oh,isFunction:li,isStream:ph,isURLSearchParams:mh,isTypedArray:_h,isFileList:hh,forEach:Wo,merge:Fl,extend:gh,trim:bh,stripBOM:xh,inherits:vh,toFlatObject:yh,kindOf:wu,kindOfTest:Ei,endsWith:wh,toArray:kh,forEachEntry:Ih,matchAll:Sh,isHTMLForm:Ch,hasOwnProperty:Kl,hasOwnProp:Kl,reduceDescriptors:ld,freezeMethods:$h,toObjectSet:Eh,toCamelCase:Th,noop:Ah,toFiniteNumber:Nh,findKey:od,global:ud,isContextDefined:cd,ALPHABET:dd,generateString:Rh,isSpecCompliantForm:Fh,toJSONObject:Mh,isAsyncFn:Dh,isThenable:Ph};function Hr(I,n,e,t,m){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=I,this.name="AxiosError",n&&(this.code=n),e&&(this.config=e),t&&(this.request=t),m&&(this.response=m)}cn.inherits(Hr,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:cn.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const hd=Hr.prototype,pd={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(I=>{pd[I]={value:I}});Object.defineProperties(Hr,pd);Object.defineProperty(hd,"isAxiosError",{value:!0});Hr.from=(I,n,e,t,m,h)=>{const b=Object.create(hd);return cn.toFlatObject(I,b,function(D){return D!==Error.prototype},A=>A!=="isAxiosError"),Hr.call(b,I.message,n,e,t,m),b.cause=I,b.name=I.name,h&&Object.assign(b,h),b};var Bh=null;function Ml(I){return cn.isPlainObject(I)||cn.isArray(I)}function fd(I){return cn.endsWith(I,"[]")?I.slice(0,-2):I}function Yl(I,n,e){return I?I.concat(n).map(function(m,h){return m=fd(m),!e&&h?"["+m+"]":m}).join(e?".":""):n}function Lh(I){return cn.isArray(I)&&!I.some(Ml)}const jh=cn.toFlatObject(cn,{},null,function(n){return/^is[A-Z]/.test(n)});function Iu(I,n,e){if(!cn.isObject(I))throw new TypeError("target must be an object");n=n||new FormData,e=cn.toFlatObject(e,{metaTokens:!0,dots:!1,indexes:!1},!1,function(V,L){return!cn.isUndefined(L[V])});const t=e.metaTokens,m=e.visitor||E,h=e.dots,b=e.indexes,D=(e.Blob||typeof Blob!="undefined"&&Blob)&&cn.isSpecCompliantForm(n);if(!cn.isFunction(m))throw new TypeError("visitor must be a function");function y(O){if(O===null)return"";if(cn.isDate(O))return O.toISOString();if(!D&&cn.isBlob(O))throw new Hr("Blob is not supported. Use a Buffer instead.");return cn.isArrayBuffer(O)||cn.isTypedArray(O)?D&&typeof Blob=="function"?new Blob([O]):Buffer.from(O):O}function E(O,V,L){let g=O;if(O&&!L&&typeof O=="object"){if(cn.endsWith(V,"{}"))V=t?V:V.slice(0,-2),O=JSON.stringify(O);else if(cn.isArray(O)&&Lh(O)||(cn.isFileList(O)||cn.endsWith(V,"[]"))&&(g=cn.toArray(O)))return V=fd(V),g.forEach(function(de,ke){!(cn.isUndefined(de)||de===null)&&n.append(b===!0?Yl([V],ke,h):b===null?V:V+"[]",y(de))}),!1}return Ml(O)?!0:(n.append(Yl(L,V,h),y(O)),!1)}const S=[],l=Object.assign(jh,{defaultVisitor:E,convertValue:y,isVisitable:Ml});function B(O,V){if(!cn.isUndefined(O)){if(S.indexOf(O)!==-1)throw Error("Circular reference detected in "+V.join("."));S.push(O),cn.forEach(O,function(g,W){(!(cn.isUndefined(g)||g===null)&&m.call(n,g,cn.isString(W)?W.trim():W,V,l))===!0&&B(g,V?V.concat(W):[W])}),S.pop()}}if(!cn.isObject(I))throw new TypeError("data must be an object");return B(I),n}function Ql(I){const n={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(I).replace(/[!'()~]|%20|%00/g,function(t){return n[t]})}function Ll(I,n){this._pairs=[],I&&Iu(I,this,n)}const md=Ll.prototype;md.append=function(n,e){this._pairs.push([n,e])};md.toString=function(n){const e=n?function(t){return n.call(this,t,Ql)}:Ql;return this._pairs.map(function(m){return e(m[0])+"="+e(m[1])},"").join("&")};function zh(I){return encodeURIComponent(I).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function bd(I,n,e){if(!n)return I;const t=e&&e.encode||zh,m=e&&e.serialize;let h;if(m?h=m(n,e):h=cn.isURLSearchParams(n)?n.toString():new Ll(n,e).toString(t),h){const b=I.indexOf("#");b!==-1&&(I=I.slice(0,b)),I+=(I.indexOf("?")===-1?"?":"&")+h}return I}class Uh{constructor(){this.handlers=[]}use(n,e,t){return this.handlers.push({fulfilled:n,rejected:e,synchronous:t?t.synchronous:!1,runWhen:t?t.runWhen:null}),this.handlers.length-1}eject(n){this.handlers[n]&&(this.handlers[n]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(n){cn.forEach(this.handlers,function(t){t!==null&&n(t)})}}var Zl=Uh,gd={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Wh=typeof URLSearchParams!="undefined"?URLSearchParams:Ll,Vh=typeof FormData!="undefined"?FormData:null,Gh=typeof Blob!="undefined"?Blob:null;const Hh=(()=>{let I;return typeof navigator!="undefined"&&((I=navigator.product)==="ReactNative"||I==="NativeScript"||I==="NS")?!1:typeof window!="undefined"&&typeof document!="undefined"})(),qh=(()=>typeof WorkerGlobalScope!="undefined"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function")();var $i={isBrowser:!0,classes:{URLSearchParams:Wh,FormData:Vh,Blob:Gh},isStandardBrowserEnv:Hh,isStandardBrowserWebWorkerEnv:qh,protocols:["http","https","file","blob","url","data"]};function Kh(I,n){return Iu(I,new $i.classes.URLSearchParams,Object.assign({visitor:function(e,t,m,h){return $i.isNode&&cn.isBuffer(e)?(this.append(t,e.toString("base64")),!1):h.defaultVisitor.apply(this,arguments)}},n))}function Xh(I){return cn.matchAll(/\w+|\[(\w*)]/g,I).map(n=>n[0]==="[]"?"":n[1]||n[0])}function Yh(I){const n={},e=Object.keys(I);let t;const m=e.length;let h;for(t=0;t<m;t++)h=e[t],n[h]=I[h];return n}function xd(I){function n(e,t,m,h){let b=e[h++];const A=Number.isFinite(+b),D=h>=e.length;return b=!b&&cn.isArray(m)?m.length:b,D?(cn.hasOwnProp(m,b)?m[b]=[m[b],t]:m[b]=t,!A):((!m[b]||!cn.isObject(m[b]))&&(m[b]=[]),n(e,t,m[b],h)&&cn.isArray(m[b])&&(m[b]=Yh(m[b])),!A)}if(cn.isFormData(I)&&cn.isFunction(I.entries)){const e={};return cn.forEachEntry(I,(t,m)=>{n(Xh(t),m,e,0)}),e}return null}const Qh={"Content-Type":void 0};function Zh(I,n,e){if(cn.isString(I))try{return(n||JSON.parse)(I),cn.trim(I)}catch(t){if(t.name!=="SyntaxError")throw t}return(e||JSON.stringify)(I)}const Su={transitional:gd,adapter:["xhr","http"],transformRequest:[function(n,e){const t=e.getContentType()||"",m=t.indexOf("application/json")>-1,h=cn.isObject(n);if(h&&cn.isHTMLForm(n)&&(n=new FormData(n)),cn.isFormData(n))return m&&m?JSON.stringify(xd(n)):n;if(cn.isArrayBuffer(n)||cn.isBuffer(n)||cn.isStream(n)||cn.isFile(n)||cn.isBlob(n))return n;if(cn.isArrayBufferView(n))return n.buffer;if(cn.isURLSearchParams(n))return e.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),n.toString();let A;if(h){if(t.indexOf("application/x-www-form-urlencoded")>-1)return Kh(n,this.formSerializer).toString();if((A=cn.isFileList(n))||t.indexOf("multipart/form-data")>-1){const D=this.env&&this.env.FormData;return Iu(A?{"files[]":n}:n,D&&new D,this.formSerializer)}}return h||m?(e.setContentType("application/json",!1),Zh(n)):n}],transformResponse:[function(n){const e=this.transitional||Su.transitional,t=e&&e.forcedJSONParsing,m=this.responseType==="json";if(n&&cn.isString(n)&&(t&&!this.responseType||m)){const b=!(e&&e.silentJSONParsing)&&m;try{return JSON.parse(n)}catch(A){if(b)throw A.name==="SyntaxError"?Hr.from(A,Hr.ERR_BAD_RESPONSE,this,null,this.response):A}}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:$i.classes.FormData,Blob:$i.classes.Blob},validateStatus:function(n){return n>=200&&n<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};cn.forEach(["delete","get","head"],function(n){Su.headers[n]={}});cn.forEach(["post","put","patch"],function(n){Su.headers[n]=cn.merge(Qh)});var jl=Su;const Jh=cn.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]);var ep=I=>{const n={};let e,t,m;return I&&I.split(`
`).forEach(function(b){m=b.indexOf(":"),e=b.substring(0,m).trim().toLowerCase(),t=b.substring(m+1).trim(),!(!e||n[e]&&Jh[e])&&(e==="set-cookie"?n[e]?n[e].push(t):n[e]=[t]:n[e]=n[e]?n[e]+", "+t:t)}),n};const Jl=Symbol("internals");function zo(I){return I&&String(I).trim().toLowerCase()}function bu(I){return I===!1||I==null?I:cn.isArray(I)?I.map(bu):String(I)}function tp(I){const n=Object.create(null),e=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let t;for(;t=e.exec(I);)n[t[1]]=t[2];return n}const np=I=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(I.trim());function Al(I,n,e,t,m){if(cn.isFunction(t))return t.call(this,n,e);if(m&&(n=e),!!cn.isString(n)){if(cn.isString(t))return n.indexOf(t)!==-1;if(cn.isRegExp(t))return t.test(n)}}function rp(I){return I.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(n,e,t)=>e.toUpperCase()+t)}function ap(I,n){const e=cn.toCamelCase(" "+n);["get","set","has"].forEach(t=>{Object.defineProperty(I,t+e,{value:function(m,h,b){return this[t].call(this,n,m,h,b)},configurable:!0})})}class Cu{constructor(n){n&&this.set(n)}set(n,e,t){const m=this;function h(A,D,y){const E=zo(D);if(!E)throw new Error("header name must be a non-empty string");const S=cn.findKey(m,E);(!S||m[S]===void 0||y===!0||y===void 0&&m[S]!==!1)&&(m[S||D]=bu(A))}const b=(A,D)=>cn.forEach(A,(y,E)=>h(y,E,D));return cn.isPlainObject(n)||n instanceof this.constructor?b(n,e):cn.isString(n)&&(n=n.trim())&&!np(n)?b(ep(n),e):n!=null&&h(e,n,t),this}get(n,e){if(n=zo(n),n){const t=cn.findKey(this,n);if(t){const m=this[t];if(!e)return m;if(e===!0)return tp(m);if(cn.isFunction(e))return e.call(this,m,t);if(cn.isRegExp(e))return e.exec(m);throw new TypeError("parser must be boolean|regexp|function")}}}has(n,e){if(n=zo(n),n){const t=cn.findKey(this,n);return!!(t&&this[t]!==void 0&&(!e||Al(this,this[t],t,e)))}return!1}delete(n,e){const t=this;let m=!1;function h(b){if(b=zo(b),b){const A=cn.findKey(t,b);A&&(!e||Al(t,t[A],A,e))&&(delete t[A],m=!0)}}return cn.isArray(n)?n.forEach(h):h(n),m}clear(n){const e=Object.keys(this);let t=e.length,m=!1;for(;t--;){const h=e[t];(!n||Al(this,this[h],h,n,!0))&&(delete this[h],m=!0)}return m}normalize(n){const e=this,t={};return cn.forEach(this,(m,h)=>{const b=cn.findKey(t,h);if(b){e[b]=bu(m),delete e[h];return}const A=n?rp(h):String(h).trim();A!==h&&delete e[h],e[A]=bu(m),t[A]=!0}),this}concat(...n){return this.constructor.concat(this,...n)}toJSON(n){const e=Object.create(null);return cn.forEach(this,(t,m)=>{t!=null&&t!==!1&&(e[m]=n&&cn.isArray(t)?t.join(", "):t)}),e}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([n,e])=>n+": "+e).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(n){return n instanceof this?n:new this(n)}static concat(n,...e){const t=new this(n);return e.forEach(m=>t.set(m)),t}static accessor(n){const t=(this[Jl]=this[Jl]={accessors:{}}).accessors,m=this.prototype;function h(b){const A=zo(b);t[A]||(ap(m,b),t[A]=!0)}return cn.isArray(n)?n.forEach(h):h(n),this}}Cu.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);cn.freezeMethods(Cu.prototype);cn.freezeMethods(Cu);var Ui=Cu;function Nl(I,n){const e=this||jl,t=n||e,m=Ui.from(t.headers);let h=t.data;return cn.forEach(I,function(A){h=A.call(e,h,m.normalize(),n?n.status:void 0)}),m.normalize(),h}function vd(I){return!!(I&&I.__CANCEL__)}function Vo(I,n,e){Hr.call(this,I==null?"canceled":I,Hr.ERR_CANCELED,n,e),this.name="CanceledError"}cn.inherits(Vo,Hr,{__CANCEL__:!0});function sp(I,n,e){const t=e.config.validateStatus;!e.status||!t||t(e.status)?I(e):n(new Hr("Request failed with status code "+e.status,[Hr.ERR_BAD_REQUEST,Hr.ERR_BAD_RESPONSE][Math.floor(e.status/100)-4],e.config,e.request,e))}var ip=$i.isStandardBrowserEnv?function(){return{write:function(e,t,m,h,b,A){const D=[];D.push(e+"="+encodeURIComponent(t)),cn.isNumber(m)&&D.push("expires="+new Date(m).toGMTString()),cn.isString(h)&&D.push("path="+h),cn.isString(b)&&D.push("domain="+b),A===!0&&D.push("secure"),document.cookie=D.join("; ")},read:function(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}();function op(I){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(I)}function up(I,n){return n?I.replace(/\/+$/,"")+"/"+n.replace(/^\/+/,""):I}function yd(I,n){return I&&!op(n)?up(I,n):n}var cp=$i.isStandardBrowserEnv?function(){const n=/(msie|trident)/i.test(navigator.userAgent),e=document.createElement("a");let t;function m(h){let b=h;return n&&(e.setAttribute("href",b),b=e.href),e.setAttribute("href",b),{href:e.href,protocol:e.protocol?e.protocol.replace(/:$/,""):"",host:e.host,search:e.search?e.search.replace(/^\?/,""):"",hash:e.hash?e.hash.replace(/^#/,""):"",hostname:e.hostname,port:e.port,pathname:e.pathname.charAt(0)==="/"?e.pathname:"/"+e.pathname}}return t=m(window.location.href),function(b){const A=cn.isString(b)?m(b):b;return A.protocol===t.protocol&&A.host===t.host}}():function(){return function(){return!0}}();function lp(I){const n=/^([-+\w]{1,25})(:?\/\/|:)/.exec(I);return n&&n[1]||""}function dp(I,n){I=I||10;const e=new Array(I),t=new Array(I);let m=0,h=0,b;return n=n!==void 0?n:1e3,function(D){const y=Date.now(),E=t[h];b||(b=y),e[m]=D,t[m]=y;let S=h,l=0;for(;S!==m;)l+=e[S++],S=S%I;if(m=(m+1)%I,m===h&&(h=(h+1)%I),y-b<n)return;const B=E&&y-E;return B?Math.round(l*1e3/B):void 0}}function ed(I,n){let e=0;const t=dp(50,250);return m=>{const h=m.loaded,b=m.lengthComputable?m.total:void 0,A=h-e,D=t(A),y=h<=b;e=h;const E={loaded:h,total:b,progress:b?h/b:void 0,bytes:A,rate:D||void 0,estimated:D&&b&&y?(b-h)/D:void 0,event:m};E[n?"download":"upload"]=!0,I(E)}}const hp=typeof XMLHttpRequest!="undefined";var pp=hp&&function(I){return new Promise(function(e,t){let m=I.data;const h=Ui.from(I.headers).normalize(),b=I.responseType;let A;function D(){I.cancelToken&&I.cancelToken.unsubscribe(A),I.signal&&I.signal.removeEventListener("abort",A)}cn.isFormData(m)&&($i.isStandardBrowserEnv||$i.isStandardBrowserWebWorkerEnv?h.setContentType(!1):h.setContentType("multipart/form-data;",!1));let y=new XMLHttpRequest;if(I.auth){const B=I.auth.username||"",O=I.auth.password?unescape(encodeURIComponent(I.auth.password)):"";h.set("Authorization","Basic "+btoa(B+":"+O))}const E=yd(I.baseURL,I.url);y.open(I.method.toUpperCase(),bd(E,I.params,I.paramsSerializer),!0),y.timeout=I.timeout;function S(){if(!y)return;const B=Ui.from("getAllResponseHeaders"in y&&y.getAllResponseHeaders()),V={data:!b||b==="text"||b==="json"?y.responseText:y.response,status:y.status,statusText:y.statusText,headers:B,config:I,request:y};sp(function(g){e(g),D()},function(g){t(g),D()},V),y=null}if("onloadend"in y?y.onloadend=S:y.onreadystatechange=function(){!y||y.readyState!==4||y.status===0&&!(y.responseURL&&y.responseURL.indexOf("file:")===0)||setTimeout(S)},y.onabort=function(){!y||(t(new Hr("Request aborted",Hr.ECONNABORTED,I,y)),y=null)},y.onerror=function(){t(new Hr("Network Error",Hr.ERR_NETWORK,I,y)),y=null},y.ontimeout=function(){let O=I.timeout?"timeout of "+I.timeout+"ms exceeded":"timeout exceeded";const V=I.transitional||gd;I.timeoutErrorMessage&&(O=I.timeoutErrorMessage),t(new Hr(O,V.clarifyTimeoutError?Hr.ETIMEDOUT:Hr.ECONNABORTED,I,y)),y=null},$i.isStandardBrowserEnv){const B=(I.withCredentials||cp(E))&&I.xsrfCookieName&&ip.read(I.xsrfCookieName);B&&h.set(I.xsrfHeaderName,B)}m===void 0&&h.setContentType(null),"setRequestHeader"in y&&cn.forEach(h.toJSON(),function(O,V){y.setRequestHeader(V,O)}),cn.isUndefined(I.withCredentials)||(y.withCredentials=!!I.withCredentials),b&&b!=="json"&&(y.responseType=I.responseType),typeof I.onDownloadProgress=="function"&&y.addEventListener("progress",ed(I.onDownloadProgress,!0)),typeof I.onUploadProgress=="function"&&y.upload&&y.upload.addEventListener("progress",ed(I.onUploadProgress)),(I.cancelToken||I.signal)&&(A=B=>{!y||(t(!B||B.type?new Vo(null,I,y):B),y.abort(),y=null)},I.cancelToken&&I.cancelToken.subscribe(A),I.signal&&(I.signal.aborted?A():I.signal.addEventListener("abort",A)));const l=lp(E);if(l&&$i.protocols.indexOf(l)===-1){t(new Hr("Unsupported protocol "+l+":",Hr.ERR_BAD_REQUEST,I));return}y.send(m||null)})};const gu={http:Bh,xhr:pp};cn.forEach(gu,(I,n)=>{if(I){try{Object.defineProperty(I,"name",{value:n})}catch{}Object.defineProperty(I,"adapterName",{value:n})}});var fp={getAdapter:I=>{I=cn.isArray(I)?I:[I];const{length:n}=I;let e,t;for(let m=0;m<n&&(e=I[m],!(t=cn.isString(e)?gu[e.toLowerCase()]:e));m++);if(!t)throw t===!1?new Hr(`Adapter ${e} is not supported by the environment`,"ERR_NOT_SUPPORT"):new Error(cn.hasOwnProp(gu,e)?`Adapter '${e}' is not available in the build`:`Unknown adapter '${e}'`);if(!cn.isFunction(t))throw new TypeError("adapter is not a function");return t},adapters:gu};function Rl(I){if(I.cancelToken&&I.cancelToken.throwIfRequested(),I.signal&&I.signal.aborted)throw new Vo(null,I)}function td(I){return Rl(I),I.headers=Ui.from(I.headers),I.data=Nl.call(I,I.transformRequest),["post","put","patch"].indexOf(I.method)!==-1&&I.headers.setContentType("application/x-www-form-urlencoded",!1),fp.getAdapter(I.adapter||jl.adapter)(I).then(function(t){return Rl(I),t.data=Nl.call(I,I.transformResponse,t),t.headers=Ui.from(t.headers),t},function(t){return vd(t)||(Rl(I),t&&t.response&&(t.response.data=Nl.call(I,I.transformResponse,t.response),t.response.headers=Ui.from(t.response.headers))),Promise.reject(t)})}const nd=I=>I instanceof Ui?I.toJSON():I;function Oo(I,n){n=n||{};const e={};function t(y,E,S){return cn.isPlainObject(y)&&cn.isPlainObject(E)?cn.merge.call({caseless:S},y,E):cn.isPlainObject(E)?cn.merge({},E):cn.isArray(E)?E.slice():E}function m(y,E,S){if(cn.isUndefined(E)){if(!cn.isUndefined(y))return t(void 0,y,S)}else return t(y,E,S)}function h(y,E){if(!cn.isUndefined(E))return t(void 0,E)}function b(y,E){if(cn.isUndefined(E)){if(!cn.isUndefined(y))return t(void 0,y)}else return t(void 0,E)}function A(y,E,S){if(S in n)return t(y,E);if(S in I)return t(void 0,y)}const D={url:h,method:h,data:h,baseURL:b,transformRequest:b,transformResponse:b,paramsSerializer:b,timeout:b,timeoutMessage:b,withCredentials:b,adapter:b,responseType:b,xsrfCookieName:b,xsrfHeaderName:b,onUploadProgress:b,onDownloadProgress:b,decompress:b,maxContentLength:b,maxBodyLength:b,beforeRedirect:b,transport:b,httpAgent:b,httpsAgent:b,cancelToken:b,socketPath:b,responseEncoding:b,validateStatus:A,headers:(y,E)=>m(nd(y),nd(E),!0)};return cn.forEach(Object.keys(Object.assign({},I,n)),function(E){const S=D[E]||m,l=S(I[E],n[E],E);cn.isUndefined(l)&&S!==A||(e[E]=l)}),e}const wd="1.4.0",zl={};["object","boolean","number","function","string","symbol"].forEach((I,n)=>{zl[I]=function(t){return typeof t===I||"a"+(n<1?"n ":" ")+I}});const rd={};zl.transitional=function(n,e,t){function m(h,b){return"[Axios v"+wd+"] Transitional option '"+h+"'"+b+(t?". "+t:"")}return(h,b,A)=>{if(n===!1)throw new Hr(m(b," has been removed"+(e?" in "+e:"")),Hr.ERR_DEPRECATED);return e&&!rd[b]&&(rd[b]=!0,console.warn(m(b," has been deprecated since v"+e+" and will be removed in the near future"))),n?n(h,b,A):!0}};function mp(I,n,e){if(typeof I!="object")throw new Hr("options must be an object",Hr.ERR_BAD_OPTION_VALUE);const t=Object.keys(I);let m=t.length;for(;m-- >0;){const h=t[m],b=n[h];if(b){const A=I[h],D=A===void 0||b(A,h,I);if(D!==!0)throw new Hr("option "+h+" must be "+D,Hr.ERR_BAD_OPTION_VALUE);continue}if(e!==!0)throw new Hr("Unknown option "+h,Hr.ERR_BAD_OPTION)}}var Dl={assertOptions:mp,validators:zl};const to=Dl.validators;class yu{constructor(n){this.defaults=n,this.interceptors={request:new Zl,response:new Zl}}request(n,e){typeof n=="string"?(e=e||{},e.url=n):e=n||{},e=Oo(this.defaults,e);const{transitional:t,paramsSerializer:m,headers:h}=e;t!==void 0&&Dl.assertOptions(t,{silentJSONParsing:to.transitional(to.boolean),forcedJSONParsing:to.transitional(to.boolean),clarifyTimeoutError:to.transitional(to.boolean)},!1),m!=null&&(cn.isFunction(m)?e.paramsSerializer={serialize:m}:Dl.assertOptions(m,{encode:to.function,serialize:to.function},!0)),e.method=(e.method||this.defaults.method||"get").toLowerCase();let b;b=h&&cn.merge(h.common,h[e.method]),b&&cn.forEach(["delete","get","head","post","put","patch","common"],O=>{delete h[O]}),e.headers=Ui.concat(b,h);const A=[];let D=!0;this.interceptors.request.forEach(function(V){typeof V.runWhen=="function"&&V.runWhen(e)===!1||(D=D&&V.synchronous,A.unshift(V.fulfilled,V.rejected))});const y=[];this.interceptors.response.forEach(function(V){y.push(V.fulfilled,V.rejected)});let E,S=0,l;if(!D){const O=[td.bind(this),void 0];for(O.unshift.apply(O,A),O.push.apply(O,y),l=O.length,E=Promise.resolve(e);S<l;)E=E.then(O[S++],O[S++]);return E}l=A.length;let B=e;for(S=0;S<l;){const O=A[S++],V=A[S++];try{B=O(B)}catch(L){V.call(this,L);break}}try{E=td.call(this,B)}catch(O){return Promise.reject(O)}for(S=0,l=y.length;S<l;)E=E.then(y[S++],y[S++]);return E}getUri(n){n=Oo(this.defaults,n);const e=yd(n.baseURL,n.url);return bd(e,n.params,n.paramsSerializer)}}cn.forEach(["delete","get","head","options"],function(n){yu.prototype[n]=function(e,t){return this.request(Oo(t||{},{method:n,url:e,data:(t||{}).data}))}});cn.forEach(["post","put","patch"],function(n){function e(t){return function(h,b,A){return this.request(Oo(A||{},{method:n,headers:t?{"Content-Type":"multipart/form-data"}:{},url:h,data:b}))}}yu.prototype[n]=e(),yu.prototype[n+"Form"]=e(!0)});var xu=yu;class Ul{constructor(n){if(typeof n!="function")throw new TypeError("executor must be a function.");let e;this.promise=new Promise(function(h){e=h});const t=this;this.promise.then(m=>{if(!t._listeners)return;let h=t._listeners.length;for(;h-- >0;)t._listeners[h](m);t._listeners=null}),this.promise.then=m=>{let h;const b=new Promise(A=>{t.subscribe(A),h=A}).then(m);return b.cancel=function(){t.unsubscribe(h)},b},n(function(h,b,A){t.reason||(t.reason=new Vo(h,b,A),e(t.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(n){if(this.reason){n(this.reason);return}this._listeners?this._listeners.push(n):this._listeners=[n]}unsubscribe(n){if(!this._listeners)return;const e=this._listeners.indexOf(n);e!==-1&&this._listeners.splice(e,1)}static source(){let n;return{token:new Ul(function(m){n=m}),cancel:n}}}var bp=Ul;function gp(I){return function(e){return I.apply(null,e)}}function xp(I){return cn.isObject(I)&&I.isAxiosError===!0}const Pl={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Pl).forEach(([I,n])=>{Pl[n]=I});var vp=Pl;function kd(I){const n=new xu(I),e=ad(xu.prototype.request,n);return cn.extend(e,xu.prototype,n,{allOwnKeys:!0}),cn.extend(e,n,null,{allOwnKeys:!0}),e.create=function(m){return kd(Oo(I,m))},e}const Ma=kd(jl);Ma.Axios=xu;Ma.CanceledError=Vo;Ma.CancelToken=bp;Ma.isCancel=vd;Ma.VERSION=wd;Ma.toFormData=Iu;Ma.AxiosError=Hr;Ma.Cancel=Ma.CanceledError;Ma.all=function(n){return Promise.all(n)};Ma.spread=gp;Ma.isAxiosError=xp;Ma.mergeConfig=Oo;Ma.AxiosHeaders=Ui;Ma.formToJSON=I=>xd(cn.isHTMLForm(I)?new FormData(I):I);Ma.HttpStatusCode=vp;Ma.default=Ma;var yp=Ma;async function wp(I,n){return(await yp.get(I,n)).data}class _d{constructor(n){this.gl_=n,this.fbo_={},this.tex_={}}setTexture(n,e){this.tex_[n]=e}getTexture(n){return this.tex_[n]}setup2dQuad(){const n=new Float32Array([-1,-1,1,-1,1,1,1,1,-1,1,-1,-1]),e=this.gl_.createBuffer();this.gl_.bindBuffer(this.gl_.ARRAY_BUFFER,e),this.gl_.bufferData(this.gl_.ARRAY_BUFFER,n,this.gl_.STATIC_DRAW),this.gl_.enableVertexAttribArray(0),this.gl_.vertexAttribPointer(0,2,this.gl_.FLOAT,!1,0,0)}createAndBindTexture(n){const e=n.name,t=n.filter||this.gl_.LINEAR,m=n.target||this.gl_.TEXTURE_2D,h=n.level||0,b=n.width||1,A=n.height||1,D=n.border||0,y=n.format||this.gl_.RGBA,E=n.internalformat||y,S=n.type||this.gl_.UNSIGNED_BYTE,l=n.format||null,B=this.gl_.createTexture();return this.gl_.bindTexture(this.gl_.TEXTURE_2D,B),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_WRAP_S,this.gl_.CLAMP_TO_EDGE),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_WRAP_T,this.gl_.CLAMP_TO_EDGE),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_MIN_FILTER,t),this.gl_.texParameteri(this.gl_.TEXTURE_2D,this.gl_.TEXTURE_MAG_FILTER,t),this.gl_.texImage2D(m,h,E,b,A,D,y,S,l),this.tex_[e]=B,B}createTextures(n){for(const e of n)this.createAndBindTexture(e)}bindInputTextures(n){for(let e=0;e<n.length;e++)this.gl_.activeTexture(this.gl_.TEXTURE0+e),this.gl_.bindTexture(this.gl_.TEXTURE_2D,this.tex_[n[e]])}bindFramebuffer(n){n===null?this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,null):this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,this.fbo_[n])}bindTexture(n){this.gl_.bindTexture(this.gl_.TEXTURE_2D,this.tex_[n])}createTexInFrameBuffer(n,e){const t=this.gl_.createFramebuffer();this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,t),this.fbo_[n]=t;const m=[];for(let b=0;b<e.length;b++){const A=e[b],D=(A.attach||b)+this.gl_.COLOR_ATTACHMENT0;m.push(D);const y=this.createAndBindTexture(A);this.gl_.framebufferTexture2D(this.gl_.FRAMEBUFFER,D,this.gl_.TEXTURE_2D,y,0)}m.length>1&&this.gl_.drawBuffers(m),this.gl_.checkFramebufferStatus(this.gl_.FRAMEBUFFER)!==this.gl_.FRAMEBUFFER_COMPLETE&&console.warn("FBO is not complete"),this.gl_.bindFramebuffer(this.gl_.FRAMEBUFFER,null)}setViewport(n,e){this.gl_.viewport(0,0,n,e)}render(){this.gl_.drawArrays(this.gl_.TRIANGLES,0,6)}delete(){this.fbo_={},this.tex_={}}}class ci{constructor(n,e,t){this.gl_=n,this.loc_=[];const m=this.createShader_(this.gl_.VERTEX_SHADER,e),h=this.createShader_(this.gl_.FRAGMENT_SHADER,t);this.prog_=this.createProgram_(m,h);const b=/uniform\s+[^\s]+\s+([_a-zA-Z][_a-zA-Z0-9]*)[=[\s]?[^;]*;/g,A=e+t;for(let D;D=b.exec(A);){const y=D[1];this.loc_[y]=this.gl_.getUniformLocation(this.prog_,y)}}use(){this.gl_.useProgram(this.prog_)}set1i(n,e){this.gl_.uniform1i(this.loc_[n],e)}set4f(n,e,t,m,h){this.gl_.uniform4f(this.loc_[n],e,t,m,h)}set2f(n,e,t){this.gl_.uniform2f(this.loc_[n],e,t)}set1f(n,e){this.gl_.uniform1f(this.loc_[n],e)}set1fv(n,e){this.gl_.uniform1fv(this.loc_[n],e)}createShader_(n,e){const t=this.gl_.createShader(n);if(this.gl_.shaderSource(t,e),this.gl_.compileShader(t),!this.gl_.getShaderParameter(t,this.gl_.COMPILE_STATUS)){const m=this.gl_.getShaderInfoLog(t);throw this.gl_.deleteShader(t),new Error(m)}return t}createProgram_(n,e){const t=this.gl_.createProgram();if(this.gl_.attachShader(t,n),this.gl_.attachShader(t,e),this.gl_.linkProgram(t),!this.gl_.getProgramParameter(t,this.gl_.LINK_STATUS)){const m=this.gl_.getProgramInfoLog(t);throw this.gl_.deleteProgram(t),new Error(m)}return t}}class kp{constructor(n){if(this.gl=n,this.utils=new _d(n),!this.gl.getExtension("EXT_color_buffer_float"))throw new Error("not support EXT_color_buffer_float");if(!this.gl.getExtension("OES_texture_float_linear"))throw new Error("not support OES_texture_float_linear");this.shaders={},this.width=513,this.height=513,this.subsample=4,this.radius=16,this.epsilon=1e-6,this.radius<4?(this.subRadius=this.radius,this.subWidth=this.width,this.subHeight=this.height):(this.subRadius=this.radius/this.subsample,this.subWidth=this.width/this.subsample,this.subHeight=this.height/this.subsample)}setup(n,e,t,m){this.radius=n,this.epsilon=e,this.width=t,this.height=m,this.radius<4?(this.subRadius=this.radius,this.subWidth=this.width,this.subHeight=this.height):(this.subRadius=this.radius/this.subsample,this.subWidth=this.width/this.subsample,this.subHeight=this.height/this.subsample),this.utils.setup2dQuad(),this.setupHadamard4Shader_(),this.setupBoxFilterShader_(),this.setupHadamard2Shader_(),this.setupCovarShader_(),this.setupFinalShader_()}setupHadamard4Shader_(){const n=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        }`,e=`#version 300 es
        precision highp float;

        out vec4 result;

        uniform sampler2D u_p;
        uniform sampler2D u_I;

        in vec2 v_texcoord;

        void main() {
          float I = texture(u_I, v_texcoord).x;
          float p = texture(u_p, v_texcoord).a;
          float Ip = I * p;
          float II = I * I;
          result = vec4(I, p, Ip, II);
        }`;this.shaders.hadamard4=new ci(this.gl,n,e),this.utils.createAndBindTexture({name:"p",filter:this.gl.NEAREST}),this.utils.createAndBindTexture({name:"I",filter:this.gl.LINEAR}),this.utils.createTexInFrameBuffer("fbo1",[{name:"result1",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.shaders.hadamard4.use(),this.shaders.hadamard4.set1i("u_p",0),this.shaders.hadamard4.set1i("u_I",1)}setupBoxFilterShader_(){const n=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,e=`#version 300 es
        precision highp float;
        out vec4 out_color;
        in vec2 v_texcoord;

        uniform sampler2D bg;
        uniform bool first_pass;
        uniform int radius;

        void main() {
          vec2 tex_offset = 1.0 / vec2(textureSize(bg, 0));
          vec4 result = texture(bg, v_texcoord);
          if (first_pass) {
            for (int i = 1; i <= radius; ++i) {
              result += texture(bg, v_texcoord + vec2(tex_offset.x * float(i), 0.0));
              result += texture(bg, v_texcoord - vec2(tex_offset.x * float(i), 0.0));
            }
          } else {
            for (int i = 1; i <= radius; ++i) {
              result += texture(bg, v_texcoord + vec2(0.0, tex_offset.y * float(i)));
              result += texture(bg, v_texcoord - vec2(0.0, tex_offset.y * float(i)));
            }
          }
          out_color = result / (2.0 * float(radius) + 1.0);
        }`;this.shaders.boxFilter=new ci(this.gl,n,e),this.utils.createTexInFrameBuffer("pingpong",[{name:"pingpongTemp",width:this.subWidth,height:this.subHeight,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.utils.createTexInFrameBuffer("fbo2",[{name:"result2",width:this.subWidth,height:this.subHeight,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}]),this.utils.createTexInFrameBuffer("fbo5",[{name:"result5",width:this.width,height:this.height,filter:this.gl.LINEAR,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupHadamard2Shader_(){const n=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,e=`#version 300 es
        precision highp float;

        in vec2 v_texcoord;
        out vec4 result;

        uniform sampler2D result2;

        void main() {
          vec4 prev = texture(result2, v_texcoord);
          float mean_I = prev.x;
          float mean_p = prev.y;
          result.xy = vec2(mean_I * mean_p, mean_I * mean_I);
        }`;this.shaders.hadamard2=new ci(this.gl,n,e),this.utils.createTexInFrameBuffer("fbo3",[{name:"result3",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupCovarShader_(){const n=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
        }`,e=`#version 300 es
        precision highp float;

        in vec2 v_texcoord;
        out vec4 result;

        uniform sampler2D result2;
        uniform sampler2D result3;
        uniform float epsilon;

        void main() {
          vec4 r2 = texture(result2, v_texcoord);
          float meanI = r2.x;
          float meanp = r2.y;
          float meanIp = r2.z;
          float meanII = r2.a;
          vec4 r3 = texture(result3, v_texcoord);
          float meanI_meanp = r3.x;
          float meanI_meanI = r3.y;

          // this is the covariance of (I, p) in each local patch
          float covIp = meanIp - meanI_meanp;
          float varI = meanII - meanI_meanI;
          float a = covIp / (varI + epsilon);
          float b = meanp - a * meanI;
          result.xy = vec2(a, b);
        }`;this.shaders.covar=new ci(this.gl,n,e),this.shaders.covar.use(),this.shaders.covar.set1i("result2",0),this.shaders.covar.set1i("result3",1),this.utils.createTexInFrameBuffer("fbo4",[{name:"result4",width:this.subWidth,height:this.subHeight,filter:this.gl.NEAREST,type:this.gl.FLOAT,internalformat:this.gl.RGBA32F}])}setupFinalShader_(){const n=`#version 300 es
        in vec4 a_pos;
        out vec2 v_texcoord;
        out vec2 v_flipcord;

        void main() {
          gl_Position = a_pos;
          v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
          v_flipcord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        }`,e=`#version 300 es
        precision highp float;

        out vec4 result;

        uniform sampler2D result5;
        uniform sampler2D u_I;

        in vec2 v_flipcord;
        in vec2 v_texcoord;

        void main() {
          vec4 r5 = texture(result5, v_texcoord);
          vec4 I = texture(u_I, v_flipcord);
          float mean_a = r5.x;
          float mean_b = r5.y;

          // q = mean_a .* I + mean_b;
          float intensity = mean_a * I.z + mean_b;
          result = vec4(intensity, intensity, intensity, intensity);
        }`;this.shaders.final=new ci(this.gl,n,e),this.shaders.final.use(),this.shaders.final.set1i("result5",0),this.shaders.final.set1i("u_I",1),this.utils.createTexInFrameBuffer("fbo6",[{name:"result6",width:this.width,height:this.height,filter:this.gl.LINEAR}])}apply(n,e,t,m){return this.utils.bindTexture("p"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,t,m,0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,e),this.utils.bindTexture("I"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.LUMINANCE,this.gl.LUMINANCE,this.gl.UNSIGNED_BYTE,n),this.shaders.hadamard4.use(),this.utils.bindFramebuffer("fbo1"),this.utils.bindInputTextures(["p","I"]),this.utils.setViewport(this.subWidth,this.subHeight),this.utils.render(),this.shaders.boxFilter.use(),this.shaders.boxFilter.set1i("first_pass",1),this.shaders.boxFilter.set1i("radius",this.subRadius),this.utils.bindFramebuffer("pingpong"),this.utils.bindInputTextures(["result1"]),this.utils.render(),this.shaders.boxFilter.set1i("first_pass",0),this.utils.bindFramebuffer("fbo2"),this.utils.bindInputTextures(["pingpongTemp"]),this.utils.render(),this.shaders.hadamard2.use(),this.utils.bindFramebuffer("fbo3"),this.utils.bindInputTextures(["result2"]),this.utils.render(),this.shaders.covar.use(),this.shaders.covar.set1f("epsilon",this.epsilon),this.utils.bindFramebuffer("fbo4"),this.utils.bindInputTextures(["result2","result3"]),this.utils.render(),this.shaders.boxFilter.use(),this.shaders.boxFilter.set1i("first_pass",1),this.shaders.boxFilter.set1i("radius",this.subRadius),this.utils.bindFramebuffer("pingpong"),this.utils.bindInputTextures(["result4"]),this.utils.render(),this.shaders.boxFilter.set1i("first_pass",0),this.utils.bindFramebuffer("fbo5"),this.utils.bindInputTextures(["pingpongTemp"]),this.utils.setViewport(this.width,this.height),this.utils.render(),this.shaders.final.use(),this.utils.bindFramebuffer("fbo6"),this.utils.bindInputTextures(["result5","I"]),this.utils.render(),this.utils.getTexture("result6")}}class _p{constructor(n){if(this.gl=n.getContext("webgl2"),this.gl===null)throw new Error("Unable to initialize WebGL.");this.guidedFilter=new kp(this.gl),this.utils=new _d(this.gl),this.shaders={},this.segMap_=null,this.predictions_=null,this.fixedSize_=513,this.clippedSize_=[this.fixedSize_,this.fixedSize_],this.imageSource_=null,this.effect_="label",this.zoom_=1,this.bgColor_=[57,135,189],this.colorMapAlpha_=.7,this.blurRadius_=30,this.backgroundImageSource_=null;const e=this.generateGaussianKernel1D_(this.blurRadius_*2+1);this.halfKernel_=e.slice(this.blurRadius_),this.guidedFilterRadius_=0,this.colorPalette_=new Uint8Array([45,52,54,85,239,196,129,236,236,116,185,255,162,155,254,223,230,233,0,184,148,0,206,201,9,132,227,39,60,117,108,92,231,178,190,195,255,234,167,250,177,160,255,118,117,253,121,168,99,110,114,253,203,110,225,112,85,214,48,49,232,67,147])}setup(){switch(this.guidedFilter.setup(this.guidedFilterRadius_,1e-6,this.clippedSize_[0]*this.zoom_,this.clippedSize_[1]*this.zoom_),this.utils.setup2dQuad(),this.effect_){case"label":this.setupColorizeShader_();break;case"blur":this.setupExtractShader_(),this.setupBlurShader_(),this.setupBlendShader_();break;case"image":this.setupExtractShader_(),this.setupImageShader_(),this.setupBlendShader_();break;case"fill":this.setupExtractShader_(),this.setupFillShader_(),this.setupBlendShader_();break;default:console.warn("Unknown effect")}}setupColorizeShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = v_texcoord;
      }`,e=`#version 300 es
      precision highp float;
      out vec4 out_color;

      uniform sampler2D u_image;
      uniform sampler2D upredictions_;
      uniform sampler2D u_palette;
      uniform int u_length;
      uniform float u_alpha;

      in vec2 v_maskcord;
      in vec2 v_texcoord;

      void main() {
        float label_index = texture(upredictions_, v_maskcord).a * 255.0;
        vec4 label_color = texture(u_palette, vec2((label_index + 0.5) / float(u_length), 0.5));
        vec4 im_color = texture(u_image, v_texcoord);
        out_color = mix(im_color, label_color, u_alpha);
      }`;this.shaders.colorize=new ci(this.gl,n,e),this.shaders.colorize.use(),this.shaders.colorize.set1i("u_image",0),this.shaders.colorize.set1i("upredictions_",1),this.shaders.colorize.set1i("u_palette",2),this.shaders.colorize.set1i("u_length",this.colorPalette_.length/3),typeof this.utils.getTexture("image")=="undefined"&&this.utils.createAndBindTexture({name:"image",filter:this.gl.LINEAR}),this.utils.createAndBindTexture({name:"predictions",filter:this.gl.NEAREST}),this.utils.createAndBindTexture({name:"palette",filter:this.gl.NEAREST}),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGB,this.colorPalette_.length/3,1,0,this.gl.RGB,this.gl.UNSIGNED_BYTE,this.colorPalette_)}setupExtractShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = v_texcoord;
      }`,e=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;
      out vec2 v_maskcord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
        v_maskcord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,t=`#version 300 es
      precision highp float;
      layout(location = 0) out vec4 fg_color;
      layout(location = 1) out vec4 bg_color;

      uniform sampler2D u_mask;
      uniform sampler2D u_image;

      in vec2 v_maskcord;
      in vec2 v_texcoord;

      void main() {
        float fg_alpha = texture(u_mask, v_maskcord).a;
        float bg_alpha = 1.0 - fg_alpha;

        vec4 pixel = texture(u_image, v_texcoord);
        fg_color = vec4(pixel.xyz * fg_alpha, fg_alpha);
        bg_color = vec4(pixel.xyz * bg_alpha, bg_alpha);
      }`;this.guidedFilterRadius_===0?this.shaders.extract=new ci(this.gl,n,t):this.shaders.extract=new ci(this.gl,e,t),typeof this.utils.getTexture("image")=="undefined"&&this.utils.createAndBindTexture({name:"image",filter:this.gl.LINEAR}),this.utils.createAndBindTexture({name:"predictions",filter:this.gl.NEAREST}),this.utils.createTexInFrameBuffer("extract",[{name:"fg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_},{name:"bg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.shaders.extract.use(),this.shaders.extract.set1i("u_image",0),this.shaders.extract.set1i("u_mask",1)}setupBlurShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,e=`#version 300 es
      precision highp float;
      out vec4 out_color;
      in vec2 v_texcoord;

      uniform sampler2D bg;
      uniform bool first_pass;
      uniform float kernel[${this.blurRadius_+1}];

      // https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/7.bloom/7.blur.fs

      void main() {
        vec2 tex_offset = 1.0 / vec2(textureSize(bg, 0)); // gets size of single texel
        vec4 bg_color = texture(bg, v_texcoord);
        vec4 result = bg_color * kernel[0];
        if (first_pass) {
          for (int i = 1; i < ${this.blurRadius_+1}; ++i) {
            result += texture(bg, v_texcoord + vec2(tex_offset.x * float(i), 0.0)) * kernel[i];
            result += texture(bg, v_texcoord - vec2(tex_offset.x * float(i), 0.0)) * kernel[i];
          }
        } else {
          for (int i = 1; i < ${this.blurRadius_+1}; ++i) {
            result += texture(bg, v_texcoord + vec2(0.0, tex_offset.y * float(i))) * kernel[i];
            result += texture(bg, v_texcoord - vec2(0.0, tex_offset.y * float(i))) * kernel[i];
          }
        }
        out_color = result;
      }`;this.shaders.blur=new ci(this.gl,n,e),this.shaders.blur.use(),this.shaders.blur.set1fv("kernel",this.halfKernel_),this.utils.createTexInFrameBuffer("blurFirstPassResult",[{name:"blurFirstPassResult",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}])}setupFillShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
      }`,e=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;
      uniform vec4 fill_color;

      void main() {
        // solid color background
        out_color = fill_color;
      }`;this.shaders.fill=new ci(this.gl,n,e),this.shaders.fill.use();const t=this.bgColor_.map(m=>m/255);this.shaders.fill.set4f("fill_color",...t,1),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}])}setupImageShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, -0.5) + 0.5;
      }`,e=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;
      uniform int has_bg;
      uniform vec2 canvas_size;

      uniform sampler2D bg_image;

      void main() {
        if (has_bg != 0) {
          // stretch the background image to fit the viewport
          vec2 image_size = vec2(textureSize(bg_image, 0));
          float image_ratio = image_size.x / image_size.y;
          float canvas_ratio = canvas_size.x / canvas_size.y;
          vec2 bgcoord = (v_texcoord / image_size) * canvas_size;
          if (image_ratio > canvas_ratio) {
            bgcoord *= image_size.y / canvas_size.y;
          } else {
            bgcoord *= image_size.x / canvas_size.x;
          }
          out_color = texture(bg_image, bgcoord);
        } else {
          // checkerboard background
          vec2 offset = floor(v_texcoord * canvas_size / 5.0);
          if (mod(offset.x, 2.0) == 0.0) {
            if (mod(offset.y, 2.0) == 0.0) {
              out_color = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
              out_color = vec4(0.8, 0.8, 0.8, 1.0);
            }
          } else {
            if (mod(offset.y, 2.0) != 0.0) {
              out_color = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
              out_color = vec4(0.8, 0.8, 0.8, 1.0);
            }
          }
        }
      }`;this.shaders.image=new ci(this.gl,n,e),this.utils.createAndBindTexture({name:"bgImage"}),this.utils.createTexInFrameBuffer("styledBg",[{name:"styledBg",width:this.clippedSize_[0]*this.zoom_,height:this.clippedSize_[1]*this.zoom_}]),this.shaders.image.use(),this.shaders.image.set2f("canvas_size",this.clippedSize_[0],this.clippedSize_[1]),this.backgroundImageSource_?(this.shaders.image.set1i("has_bg",1),this.utils.bindTexture("bgImage"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,this.backgroundImageSource_)):this.shaders.image.set1i("has_bg",0)}setupBlendShader_(){const n=`#version 300 es
      in vec4 a_pos;
      out vec2 v_texcoord;

      void main() {
        gl_Position = a_pos;
        v_texcoord = a_pos.xy * vec2(0.5, 0.5) + 0.5;
      }`,e=`#version 300 es
      precision highp float;

      in vec2 v_texcoord;
      out vec4 out_color;

      uniform sampler2D fg;
      uniform sampler2D bg;
      uniform sampler2D orig;

      void main() {
        vec4 fg_color = texture(fg, v_texcoord);
        vec4 bg_color = texture(bg, v_texcoord);
        vec4 orig_color = texture(orig, vec2(v_texcoord.x, (1.0-v_texcoord.y)));
        bg_color = bg_color + (1.0 - bg_color.a) * orig_color;
        out_color = fg_color + (1.0 - fg_color.a) * bg_color;
      }`;this.shaders.blend=new ci(this.gl,n,e),this.shaders.blend.use(),this.shaders.blend.set1i("fg",0),this.shaders.blend.set1i("bg",1),this.shaders.blend.set1i("orig",2)}async uploadNewTexture(n,e){(this.clippedSize_[0]!==e[0]||this.clippedSize_[1]!==e[1])&&(this.clippedSize_=e,this.zoom_=this.fixedSize_/this.clippedSize_[0],this.setup()),this.imageSource_=n,this.utils.bindTexture("image"),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,n)}async drawOutputs(n){if(!!n){if(this.gl.canvas.width=this.clippedSize_[0]*this.zoom_,this.gl.canvas.height=this.clippedSize_[1]*this.zoom_,this.utils.setViewport(this.gl.drawingBufferWidth,this.gl.drawingBufferHeight),this.effect_==="label")return this.segMap_=n,this.predictions_=this.maskSegMap_(n),this.utils.bindTexture("predictions"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,this.clippedSize_[0],this.clippedSize_[1],0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,this.predictions_),this.drawColorLabel_();if(this.segMap_=n,this.predictions_=this.maskSegMapPerson_(n),this.guidedFilterRadius_===0)this.utils.bindTexture("predictions"),this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT,1),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.ALPHA,this.clippedSize_[0],this.clippedSize_[1],0,this.gl.ALPHA,this.gl.UNSIGNED_BYTE,this.predictions_);else{const e=this.guidedFilter.apply(this.imageSource_,this.predictions_,this.clippedSize_[0],this.clippedSize_[1]);this.utils.setTexture("predictions",e)}return this.drawPerson_()}}drawColorLabel_(){const n=this.shaders.colorize;n.use(),n.set1f("u_alpha",this.colorMapAlpha_),this.utils.bindFramebuffer(null),this.utils.bindInputTextures(["image","predictions","palette"]),this.utils.render();const e=new Set(this.predictions_),t={};for(const m of e){const h=this.segMap_.labels[m],b=this.colorPalette_.slice(m*3,(m+1)*3);h&&(t[m]=[h,b])}return t}drawPerson_(){let n;switch(this.shaders.extract.use(),this.utils.bindFramebuffer("extract"),this.utils.bindInputTextures(["image","predictions"]),this.utils.render(),this.effect_){case"blur":n=this.shaders.blur,n.use(),n.set1i("first_pass",1),this.utils.bindFramebuffer("blurFirstPassResult"),this.utils.bindInputTextures(["bg"]),this.utils.render(),n.set1i("first_pass",0),this.utils.bindFramebuffer("styledBg"),this.utils.bindInputTextures(["blurFirstPassResult"]),this.utils.render();break;case"image":n=this.shaders.image,n.use(),this.utils.bindFramebuffer("styledBg"),this.utils.bindInputTextures(["bgImage"]),this.utils.render();break;case"fill":n=this.shaders.fill,n.use(),this.utils.bindFramebuffer("styledBg"),this.utils.render()}this.shaders.blend.use(),this.utils.bindFramebuffer(null),this.utils.bindInputTextures(["fg","styledBg","image"]),this.utils.render()}maskSegMap_(n){const e=this.clippedSize_[1],t=this.clippedSize_[0],m=n.outputShape[1],h=n.data,b=new Uint8Array(e*t);let A=0;for(let D=0;D<e;D++)for(let y=0;y<t;y++)b[A++]=h[D*m+y];return b}maskSegMapPerson_(n){const t=this.clippedSize_[1],m=this.clippedSize_[0],h=n.outputShape[1],b=n.data,A=new Uint8Array(t*m);let D=0;for(let y=0;y<t;y++)for(let E=0;E<m;E++)A[D++]=b[y*h+E]===15?255:0;return A}generateGaussianKernel1D_(n,e=30){const t=(A,D)=>1/(Math.sqrt(2*Math.PI)*D)*Math.exp(-A*A/(2*D*D)),m=[],h=(n-1)/2;for(let A=-h;A<=h;A++)m.push(t(A,e));const b=m.reduce((A,D)=>A+D);return m.map(A=>A/b)}}async function Id(I={}){var n;return await navigator.ml.createContext(Ol(Tl({powerPreference:"low-power"},I),{deviceType:(n=I.device)!=null?n:"cpu"}))}async function Tp(I,n){const t=await Id(),m=new MLGraphBuilder(t),h=To(I),b={type:"float32",dimensions:I},D=I.map((O,V)=>m.input(`input_${V}`,b)).reduce((O,V,L,g)=>{const W=Math.floor(L/2);return O[W]||(O[W]=[]),O[W].push(V),O},[]).filter(O=>!!O[0]&&!!O[1]).map(O=>m.add(O[0],O[1])),y=m.div(D[0],D[1]),E=await m.build({output:y}),S=[...E.inputs_.keys()].reduce((O,V,L)=>Ol(Tl({},O),{[V]:new Float32Array(h).fill(n[L])}),{}),l=new Float32Array(h);return(await t.compute(E,S,{output:l})).outputs.output}function Op(I,n,e){const t=performance.now();let m=[1,3,e.height,e.width];const h=new Float32Array(m.slice(1).reduce((ke,Ie)=>ke*Ie));let[b,A,D]=m.slice(1);e.layout==="nhwc"&&(m=[1,e.height,e.width,3],[A,D,b]=m.slice(1));const y=e.mean||[0,0,0,0],E=e.std||[1,1,1,1],S=e.normalize||!1,l=e.channelScheme||"RGB",B=e.scaled||!1,O=e.layout,V=4,L=n;I.width=I.videoWidth||I.naturalWidth,I.height=I.videoHeight||I.naturalHeight,L.width=D,L.height=A;const g=L.getContext("2d");if(B){const ke=Math.max(Math.max(I.width/D,I.height/A),1),Ie=Math.floor(I.width/ke),he=Math.floor(I.height/ke);g.drawImage(I,0,0,Ie,he)}else g.drawImage(I,0,0,D,A);let W=g.getImageData(0,0,D,A).data;S&&(W=new Float32Array(W).map(ke=>ke/255));for(let ke=0;ke<b;++ke)for(let Ie=0;Ie<A;++Ie)for(let he=0;he<D;++he){let Q;l==="BGR"?Q=W[Ie*D*V+he*V+(b-ke-1)]:Q=W[Ie*D*V+he*V+ke],O==="nchw"?h[ke*D*A+Ie*D+he]=(Q-y[ke])/E[ke]:h[Ie*D*b+he*b+ke]=(Q-y[ke])/E[ke]}const de=performance.now();return{tensor:h,dimensions:m,inputTime:vu(t,de)}}async function $p(I,n,e,t,m,h,b){const A=await Id({device:b}),D=new MLGraphBuilder(A),y=D.input("input",{type:"float32",dimensions:e});let E;I==="objectDetection"&&t.startsWith("ssdMobilenetV1")?E={boxes:new Float32Array(To([1,1917,1,4])),scores:new Float32Array(To([1,1917,91]))}:E=new Float32Array(To(m));const S=new rh(A,D,t),{graph:l,time:B}=await S.load(y,h),{compiled:O,time:V}=await S.compile(l),{executed:L,time:g}=await S.execute(O,n,E);return{result:L.outputs.output,buildTime:B,compileTime:V,executionTime:g}}async function Ep(I,n,e,t,m,h,b,A=3){if(I==="imageClassification")return Array.from(e).map((S,l)=>[S,l]).sort((S,l)=>S[0]-l[0]).reverse().slice(0,A).map(([S,l])=>({label:t[l],value:(S*100).toFixed(2)}));if(I==="objectDetection"){const[D,y]=n.split("_");if(D==="tinyYoloV2"){y==="nchw"&&(e=Gl(()=>{const l=Hl(e,m,"float32");return Md(l,[0,2,3,1]).dataSync()}));const E=Bd({numClasses:20},e,h.anchors),S=Ld(E,h.margin);return S.length===0?!1:(jd(b.input,b.output,S,t),S.map(l=>({label:t[l[0]],value:Math.round(l.pop()*100).toFixed(2)})))}else console.log(I,D,y,e)}else if(I==="semanticSegmentation"){const[D,y]=Gl(()=>{const Ie=Hl(e,m,"float32"),he=h.layout==="nchw"?1:3,Q=Dd(Ie,he);return[Q.dataSync(),Q.shape]}),E=b.input,S=h.dimensions[2],l=E.naturalWidth|E.width,B=E.naturalHeight|E.height,O=Math.max(Math.max(l,B)/S,1),V=Math.floor(l/O),L=Math.floor(B/O),g={data:D,outputShape:y,labels:t},W=new _p(b.segCanvas);W.setup(),await W.uploadNewTexture(E,[V,L]);const de=await W.drawOutputs(g),ke=[];for(const Ie in de){const[he,Q]=de[Ie];ke.push({label:he,value:Q.join(", ")})}return console.log(de),ke}else console.log(I,e);return[{label:"TEST",value:0}]}async function Tn(I,n){const e=new Map([["f2",{type:"float16",array:Uint16Array}],["f4",{type:"float32",array:Float32Array}],["f8",{type:"float64",array:Float64Array}],["i1",{type:"int8",array:Int8Array}],["i2",{type:"int16",array:Int16Array}],["i4",{type:"int32",array:Int32Array}],["i8",{type:"int64",array:BigInt64Array}],["u1",{type:"uint8",array:Uint8Array}],["u2",{type:"uint16",array:Uint16Array}],["u4",{type:"uint32",array:Uint32Array}],["u8",{type:"uint64",array:BigUint64Array}]]),t=await wp(n,{responseType:"arraybuffer"}),m=new Fa.Array(new Uint8Array(t));if(!e.has(m.dataType))throw new Error(`Data type ${m.dataType} is not supported.`);const h=m.shape,b=e.get(m.dataType).type,A=e.get(m.dataType).array,D=new A(To(h)),y=new DataView(m.data.buffer),E=m.byteOrder==="<";for(let S=0;S<To(h);++S)D[S]=y["get"+b[0].toUpperCase()+b.substr(1)](S*A.BYTES_PER_ELEMENT,E);return I.constant({type:b,dimensions:h},D)}function To(I){return I.reduce((n,e)=>n*e)}function vu(I,n){return n-I}export{wp as G,vu as a,Tp as b,$p as c,Op as g,Ep as m};
